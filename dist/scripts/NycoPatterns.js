var NycoPatterns = (function () {
  'use strict';

  /**
   * The Utility class
   * @class
   */

  var Utility = function Utility() {
    return this;
  };
  /**
   * Boolean for debug mode
   * @return {boolean} wether or not the front-end is in debug mode.
   */


  Utility.debug = function () {
    return Utility.getUrlParameter(Utility.PARAMS.DEBUG) === '1';
  };
  /**
   * Returns the value of a given key in a URL query string. If no URL query
   * string is provided, the current URL location is used.
   * @param  {string}  name        - Key name.
   * @param  {?string} queryString - Optional query string to check.
   * @return {?string} Query parameter value.
   */


  Utility.getUrlParameter = function (name, queryString) {
    var query = queryString || window.location.search;
    var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
    var results = regex.exec(query);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
  };
  /**
   * For translating strings, there is a global LOCALIZED_STRINGS array that
   * is defined on the HTML template level so that those strings are exposed to
   * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
   * `slug` key whose value is some constant, and a `label` value which is the
   * translated equivalent. This function takes a slug name and returns the
   * label.
   * @param  {string} slug
   * @return {string} localized value
   */


  Utility.localize = function (slug) {
    var text = slug || '';
    var strings = window.LOCALIZED_STRINGS || [];
    var match = strings.filter(function (s) {
      return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
    });
    return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
  };
  /**
   * Application parameters
   * @type {Object}
   */


  Utility.PARAMS = {
    DEBUG: 'debug'
  };
  /**
   * Selectors for the Utility module
   * @type {Object}
   */

  Utility.SELECTORS = {
    parseMarkdown: '[data-js="markdown"]'
  };

  /**
   * The Icon module
   * @class
   */

  var Icons = function Icons(path) {
    path = path ? path : Icons.path;
    fetch(path).then(function (response) {
      if (response.ok) {
        return response.text();
      } else // eslint-disable-next-line no-console
        if (Utility.debug()) {
          console.dir(response);
        }
    })["catch"](function (error) {
      // eslint-disable-next-line no-console
      if (Utility.debug()) {
        console.dir(error);
      }
    }).then(function (data) {
      var sprite = document.createElement('div');
      sprite.innerHTML = data;
      sprite.setAttribute('aria-hidden', true);
      sprite.setAttribute('style', 'display: none;');
      document.body.appendChild(sprite);
    });
    return this;
  };
  /** @type {String} The path of the icon file */


  Icons.path = 'icons.svg';

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */

  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max;
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function () {
      return value;
    };
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeNow = Date.now;
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = shortOut(baseSetToString);

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */

  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */

  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }

    var type = typeof index;

    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
      return eq(object[index], value);
    }

    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */

  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */

  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */

  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports$1 && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  /* Node.js helper references. */

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
    return value === proto;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * This method is like `_.assignIn` except that it accepts `customizer`
   * which is invoked to produce the assigned values. If `customizer` returns
   * `undefined`, assignment is handled by the method instead. The `customizer`
   * is invoked with five arguments: (objValue, srcValue, key, object, source).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extendWith
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @see _.assignWith
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   return _.isUndefined(objValue) ? srcValue : objValue;
   * }
   *
   * var defaults = _.partialRight(_.assignInWith, customizer);
   *
   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */

  var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */

  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /** `Object#toString` result references. */

  var objectTag$1 = '[object Object]';
  /** Used for built-in method references. */

  var funcProto$2 = Function.prototype,
      objectProto$8 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$2 = funcProto$2.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString$2.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  /** `Object#toString` result references. */

  var domExcTag = '[object DOMException]',
      errorTag$1 = '[object Error]';
  /**
   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
   * `SyntaxError`, `TypeError`, or `URIError` object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
   * @example
   *
   * _.isError(new Error);
   * // => true
   *
   * _.isError(Error);
   * // => false
   */

  function isError(value) {
    if (!isObjectLike(value)) {
      return false;
    }

    var tag = baseGetTag(value);
    return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
  }

  /**
   * Attempts to invoke `func`, returning either the result or the caught error
   * object. Any additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Function} func The function to attempt.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {*} Returns the `func` result or error object.
   * @example
   *
   * // Avoid throwing errors for invalid selectors.
   * var elements = _.attempt(function(selector) {
   *   return document.querySelectorAll(selector);
   * }, '>_>');
   *
   * if (_.isError(elements)) {
   *   elements = [];
   * }
   */

  var attempt = baseRest(function (func, args) {
    try {
      return apply(func, undefined, args);
    } catch (e) {
      return isError(e) ? e : new Error(e);
    }
  });

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }

  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /**
   * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
   * of source objects to the destination object for all destination properties
   * that resolve to `undefined`.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to assign.
   * @param {Object} object The parent object of `objValue`.
   * @returns {*} Returns the value to assign.
   */

  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
      return srcValue;
    }

    return objValue;
  }

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };
  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /** Used to match template delimiters. */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  /** Used to map characters to HTML entities. */

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */

  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /** Used to match HTML entities and HTML characters. */

  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */

  function escape(string) {
    string = toString(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
  }

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g;

  /** Used to match template delimiters. */
  var reEvaluate = /<%([\s\S]+?)%>/g;

  /**
   * By default, the template delimiters used by lodash are like those in
   * embedded Ruby (ERB) as well as ES2015 template strings. Change the
   * following template settings to use alternative delimiters.
   *
   * @static
   * @memberOf _
   * @type {Object}
   */

  var templateSettings = {
    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'escape': reEscape,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'evaluate': reEvaluate,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'interpolate': reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type {string}
     */
    'variable': '',

    /**
     * Used to import variables into the compiled template.
     *
     * @memberOf _.templateSettings
     * @type {Object}
     */
    'imports': {
      /**
       * A reference to the `lodash` function.
       *
       * @memberOf _.templateSettings.imports
       * @type {Function}
       */
      '_': {
        'escape': escape
      }
    }
  };

  /** Used to match empty string literals in compiled template source. */

  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */

  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to ensure capturing order of template delimiters. */

  var reNoMatch = /($^)/;
  /** Used to match unescaped characters in compiled string literals. */

  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  /**
   * Creates a compiled template function that can interpolate data properties
   * in "interpolate" delimiters, HTML-escape interpolated data properties in
   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
   * properties may be accessed as free variables in the template. If a setting
   * object is given, it takes precedence over `_.templateSettings` values.
   *
   * **Note:** In the development build `_.template` utilizes
   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
   * for easier debugging.
   *
   * For more information on precompiling templates see
   * [lodash's custom builds documentation](https://lodash.com/custom-builds).
   *
   * For more information on Chrome extension sandboxes see
   * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The template string.
   * @param {Object} [options={}] The options object.
   * @param {RegExp} [options.escape=_.templateSettings.escape]
   *  The HTML "escape" delimiter.
   * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
   *  The "evaluate" delimiter.
   * @param {Object} [options.imports=_.templateSettings.imports]
   *  An object to import into the template as free variables.
   * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
   *  The "interpolate" delimiter.
   * @param {string} [options.sourceURL='templateSources[n]']
   *  The sourceURL of the compiled template.
   * @param {string} [options.variable='obj']
   *  The data object variable name.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Function} Returns the compiled template function.
   * @example
   *
   * // Use the "interpolate" delimiter to create a compiled template.
   * var compiled = _.template('hello <%= user %>!');
   * compiled({ 'user': 'fred' });
   * // => 'hello fred!'
   *
   * // Use the HTML "escape" delimiter to escape data property values.
   * var compiled = _.template('<b><%- value %></b>');
   * compiled({ 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
   * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the internal `print` function in "evaluate" delimiters.
   * var compiled = _.template('<% print("hello " + user); %>!');
   * compiled({ 'user': 'barney' });
   * // => 'hello barney!'
   *
   * // Use the ES template literal delimiter as an "interpolate" delimiter.
   * // Disable support by replacing the "interpolate" delimiter.
   * var compiled = _.template('hello ${ user }!');
   * compiled({ 'user': 'pebbles' });
   * // => 'hello pebbles!'
   *
   * // Use backslashes to treat delimiters as plain text.
   * var compiled = _.template('<%= "\\<%- value %\\>" %>');
   * compiled({ 'value': 'ignored' });
   * // => '<%- value %>'
   *
   * // Use the `imports` option to import `jQuery` as `jq`.
   * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
   * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the `sourceURL` option to specify a custom sourceURL for the template.
   * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
   *
   * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
   * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   * //   var __t, __p = '';
   * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
   * //   return __p;
   * // }
   *
   * // Use custom template delimiters.
   * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
   * var compiled = _.template('hello {{ user }}!');
   * compiled({ 'user': 'mustache' });
   * // => 'hello mustache!'
   *
   * // Use the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and stack traces.
   * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */

  function template(string, options, guard) {
    // Based on John Resig's `tmpl` implementation
    // (http://ejohn.org/blog/javascript-micro-templating/)
    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
    var settings = templateSettings.imports._.templateSettings || templateSettings;

    if (guard && isIterateeCall(string, options, guard)) {
      options = undefined;
    }

    string = toString(string);
    options = assignInWith({}, options, settings, customDefaultsAssignIn);
    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
        importsKeys = keys(imports),
        importsValues = baseValues(imports, importsKeys);
    var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '"; // Compile the regexp to match each delimiter.

    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.

    var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

      source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }

      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }

      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }

      index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
      // order to produce the correct `offset` value.

      return match;
    });
    source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
    // code to add the data object to the top of the scope chain.

    var variable = options.variable;

    if (!variable) {
      source = 'with (obj) {\n' + source + '\n}\n';
    } // Cleanup code by stripping empty strings.


    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

    source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
    var result = attempt(function () {
      return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
    }); // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.

    result.source = source;

    if (isError(result)) {
      throw result;
    }

    return result;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */

  var baseEach = createBaseEach(baseForOwn);

  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */

  function castFunction(value) {
    return typeof value == 'function' ? value : identity;
  }

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /* Built-in method references that are verified to be native. */

  var Map = getNative(root, 'Map');

  /* Built-in method references that are verified to be native. */

  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */

  var objectProto$c = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignMergeValue(object, key, value) {
    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  /** Detect free variable `exports`. */

  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  /** Built-in value references. */

  var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */

  var Uint8Array = root.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  /** Built-in value references. */

  var objectCreate = Object.create;
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */

  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */

  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }

    var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray(srcValue),
          isBuff = !isArr && isBuffer(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;

      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;

        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }

    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }

    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */

  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }

    baseFor(source, function (srcValue, key) {
      if (isObject(srcValue)) {
        stack || (stack = new Stack());
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }

        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */

  var merge = createAssigner(function (object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /** `Object#toString` result references. */

  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$2 = '[object Error]',
      mapTag$1 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$1:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$1:
        var convert = mapToArray;

      case setTag$1:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /* Built-in method references that are verified to be native. */

  var DataView = getNative(root, 'DataView');

  /* Built-in method references that are verified to be native. */

  var Promise$1 = getNative(root, 'Promise');

  /* Built-in method references that are verified to be native. */

  var Set$1 = getNative(root, 'Set');

  /* Built-in method references that are verified to be native. */

  var WeakMap = getNative(root, 'WeakMap');

  /** `Object#toString` result references. */

  var mapTag$2 = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$2 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$2 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set$1),
      weakMapCtorString = toSource(WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
    getTag = function (value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;

          case mapCtorString:
            return mapTag$2;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$2;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var getTag$1 = getTag;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$3 = '[object Object]';
  /** Used for built-in method references. */

  var objectProto$f = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag$1 : getTag$1(object),
        othTag = othIsArr ? arrayTag$1 : getTag$1(other);
    objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
    var objIsObj = objTag == objectTag$3,
        othIsObj = othTag == objectTag$3,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;
  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */

  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */

  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }

    return result;
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatches(source) {
    var matchData = getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function () {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }

    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;
  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */

  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */

  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity;
    }

    if (typeof value == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }

    return property(value);
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */

  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function (value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);

    while (length--) {
      array[length] = array[length].value;
    }

    return array;
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */

  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);
      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }

      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }

    return 0;
  }

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */

  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);

      if (result) {
        if (index >= ordersLength) {
          return result;
        }

        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


    return object.index - other.index;
  }

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */

  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
    var result = baseMap(collection, function (value, key, collection) {
      var criteria = arrayMap(iteratees, function (iteratee) {
        return iteratee(value);
      });
      return {
        'criteria': criteria,
        'index': ++index,
        'value': value
      };
    });
    return baseSortBy(result, function (object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  /**
   * This method is like `_.sortBy` except that it allows specifying the sort
   * orders of the iteratees to sort by. If `orders` is unspecified, all values
   * are sorted in ascending order. Otherwise, specify an order of "desc" for
   * descending or "asc" for ascending sort order of corresponding values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @param {string[]} [orders] The sort orders of `iteratees`.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 34 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 36 }
   * ];
   *
   * // Sort by `user` in ascending order and by `age` in descending order.
   * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   */

  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }

    if (!isArray(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }

    orders = guard ? undefined : orders;

    if (!isArray(orders)) {
      orders = orders == null ? [] : [orders];
    }

    return baseOrderBy(collection, iteratees, orders);
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {// No operation performed.
  }

  /** Used as references for various `Number` constants. */

  var INFINITY$2 = 1 / 0;
  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */

  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
    return new Set$1(values);
  };

  /**
   *
   */

  var Feed = function Feed(config) {
    this["default"] = Feed["default"];
    this._settings = merge({}, Feed["default"], config);
    this.init();
  };
  /**
   * Initializes the module
   */


  Feed.prototype.init = function init() {
    var this$1 = this;
    var data = [];
    var feed = this._settings.feed;
    var config = {
      rssToJson: Feed.rssToJson,
      rssUrl: Array.isArray(feed) ? feed : [feed]
    }; // Go through each feed

    forEach(config.rssUrl, function (url, index) {
      // Make the request
      this$1._request(config, url).then(function (response) {
        // Process the data
        data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

        if (data.length === config.rssUrl.length) {
          this$1._merge(data, this$1._settings);

          var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

          var el = document.querySelector(this$1._settings.selector);

          if (el) {
            el.innerHTML = compiled;
          }
        }
      });
    });

    return this;
  };
  /**
   * Create an XHR request for the feed data
   * @param{object} config The request data
   * @param{string} url  The request url
   * @return {Promise}     Resolves when the response is ready, rejects when
   *                       the operation times out or there is an error.
   */


  Feed.prototype._request = function _request(config, url) {
    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();

      xhr.onreadystatechange = function (event) {
        var _xhr = event.target;

        if (_xhr.readyState === 4) {
          if (_xhr.status >= 200 && _xhr.status < 400) {
            resolve(_xhr.response);
          } else {
            reject(new Error(_xhr.status));
          }
        }
      };

      xhr.ontimeout = function () {
        reject(new Error('The Feed request timed out'));
      };

      xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
      xhr.send();
      xhr = null;
    });
  };
  /**
   * Pass data to the appropriate processing function based on type
   * @param{object} data   The requested feed data to pass
   * @param{object} settings The application settings
   * @return {object}        The processed data
   */


  Feed.prototype._process = function _process(data, settings) {
    return Feed.process[settings.type](data, settings);
  };
  /**
   * Pass data to the appropriate merge function based on type
   * @param{object} data   The requested feed data to pass
   * @param{object} settings The application settings
   * @return {object}        The merged feed data
   */


  Feed.prototype._merge = function _merge(data, settings) {
    return Feed.merge[settings.type](data);
  };
  /**
   * Combine template components, pass data, and return compiled temlate
   * @param{object} data   The requested feed data to pass
   * @param{object} settings The application settings
   * @return {string}        The complied html string
   */


  Feed.prototype._render = function _render(data, settings) {
    data.settings = settings;

    if (settings.log) {
      console.dir(data);
    }

    var template$1 = values(settings.templates).join('');

    var compiled = template(template$1, {
      'imports': {
        '_each': forEach
      }
    });

    return compiled(data);
  };
  /**
   * An open RSS to JSON api, see https://rss2json.com
   * @type {String}
   */


  Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
  /**
   * The template for the widget.
   * @type {String}
   */

  Feed.templates = {
    medium: {
      opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
      header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
      posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
      closer: ['</section>']
    }
  };
  /**
   * Functions for processing the data based on the feed type.
   * @type {Object}
   */

  Feed.process = {
    medium: function medium(data, settings) {
      var length = settings.postExcerptLength;

      forEach(data.items, function (post, index) {
        var excerpt = '';
        var date = ''; // Remove figures first

        excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

        excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

        excerpt = excerpt.substr(0, length);
        excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
        post.excerpt = excerpt; // Format the date

        date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
        post.date = date;
        return post;
      });

      return data;
    }
    /**
     * Functions for merging the data feeds together, based on the feed type.
     * @type {Object}
     */

  };
  Feed.merge = {
    medium: function medium(data) {
      var merged = {};
      var items = []; // Combine the post items

      data.forEach(function (feed) {
        items = items.concat(feed.items);
      }); // Merge the data, this will override values, it probably won't be
      // particularly useful for feeds that are the same, but potentially
      // different feed types could use this and combine unique data

      data.forEach(function (feed) {
        merged = merge(merged, feed);
      }); // Get unique posts
      // items = _uniqBy(items, (item) => item.guid);

      merged.items = orderBy(items, 'pubDate', 'desc');
      return merged;
    }
    /**
     * See https://rss2json.com/docs for details on default parameters
     * @type {Object}
     */

  };
  Feed["default"] = {
    feed: '',
    selector: '#js-feed',
    type: 'medium',
    title: '',
    titleUrl: '',
    profileImg: '',
    fontSize: '',
    ratioProfile: ['50', '50'],
    postBorderColor: 'lightsteelblue',
    postImgHeight: '200px',
    postExcerptLength: 120,
    postExcerptTrail: '…',
    postCtaText: 'Read the full post',
    postDateLocal: 'en-US',
    postDateFormat: {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    },
    postDateTitle: 'Published Date',
    classes: {
      wrapper: '',
      header: '',
      url: '',
      feedItem: '',
      title: '',
      link: '',
      thumbnail: '',
      excerpt: '',
      itemFooter: '',
      cta: '',
      date: ''
    },
    templates: {
      opener: Feed.templates.medium.opener.join(''),
      header: Feed.templates.medium.header.join(''),
      posts: Feed.templates.medium.posts.join(''),
      closer: Feed.templates.medium.closer.join('')
    },
    log: false,
    unique: false
  };

  /**
   * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
   * on target elements, determined by a click event on a selected link or
   * element. This will also toggle the aria-hidden attribute for targeted
   * elements to support screen readers. Target settings and other functionality
   * can be controlled through data attributes.
   *
   * This uses the .matches() method which will require a polyfill for IE
   * https://polyfill.io/v2/docs/features/#Element_prototype_matches
   *
   * Basic Usage;
   *
   * javascript:
   *   new Toggle().init();
   *
   * Toggling Anchor links:
   *   <a data-js='toggle' href='#main-menu'>Menu</a>
   *   <div id='main-menu' aria-hidden='true'> ... </div>
   *
   * Toggling aria-control elements:
   *
   *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
   *      Menu
   *   </button>
   *   <div id='main-menu' aria-hidden='true'> ... </div>
   *
   * Create "Undo" Event (to close a dialogue);
   *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
   *   <div id='main-menu' aria-hidden='true'>
   *     <a id="close">Close</a>
   *   </div>
   * @class
   */

  var Toggle = function Toggle(s) {
    var this$1 = this;
    var body = document.querySelector('body');
    s = !s ? {} : s;
    this._settings = {
      selector: s.selector ? s.selector : Toggle.selector,
      namespace: s.namespace ? s.namespace : Toggle.namespace,
      inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
      activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
    };
    body.addEventListener('click', function (event) {
      if (!event.target.matches(this$1._settings.selector)) {
        return;
      }

      event.preventDefault();

      this$1._toggle(event);
    });
    return this;
  };
  /**
   * Logs constants to the debugger
   * @param{object} eventThe main click event
   * @return {object}      The class
   */


  Toggle.prototype._toggle = function _toggle(event) {
    var this$1 = this;
    var el = event.target;
    var target = false;
    /** Anchor Links */

    target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
    /** Toggle Controls */
    // console.dir(el.getAttribute('aria-controls'));

    target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
    /** Main Functionality */

    if (!target) {
      return this;
    }

    this.elementToggle(el, target);
    /** Undo */

    if (el.dataset[this._settings.namespace + "Undo"]) {
      var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
      undo.addEventListener('click', function (event) {
        event.preventDefault();
        this$1.elementToggle(el, target);
        undo.removeEventListener('click');
      });
    }

    return this;
  };
  /**
   * The main toggling method
   * @param{object} el   The current element to toggle active
   * @param{object} target The target element to toggle active/hidden
   * @return {object}      The class
   */


  Toggle.prototype.elementToggle = function elementToggle(el, target) {
    if (this._settings.activeClass !== '') {
      el.classList.toggle(this._settings.activeClass);
      target.classList.toggle(this._settings.activeClass);
    }

    if (this._settings.inactiveClass !== '') {
      target.classList.toggle(this._settings.inactiveClass);
    } // Check the element for defined aria roles and toggle them if they exist


    for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
      if (el.getAttribute(Toggle.elAriaRoles[i])) {
        el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
      }
    } // Check the target for defined aria roles and toggle them if they exist


    for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
      if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
        target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
      }
    }

    if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
      window.location.hash = '';
      window.location.hash = el.getAttribute('href');
    }

    return this;
  };
  /** @type {String} The main selector to add the toggling function to */


  Toggle.selector = '[data-js*="toggle"]';
  /** @type {String} The namespace for our data attribute settings */

  Toggle.namespace = 'toggle';
  /** @type {String} The hide class */

  Toggle.inactiveClass = 'hidden';
  /** @type {String} The active class */

  Toggle.activeClass = 'active';
  /** @type {Array} Aria roles to toggle true/false on the toggling element */

  Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
  /** @type {Array} Aria roles to toggle true/false on the target element */

  Toggle.targetAriaRoles = ['aria-hidden'];

  /**
   * Tracking bus for Google analytics and Webtrends.
   */

  var Track = function Track(s) {
    var this$1 = this;
    var body = document.querySelector('body');
    s = !s ? {} : s;
    this._settings = {
      selector: s.selector ? s.selector : Track.selector
    };
    body.addEventListener('click', function (event) {
      if (!event.target.matches(this$1._settings.selector)) {
        return;
      }

      var key = event.target.dataset.trackKey;
      var data = JSON.parse(event.target.dataset.trackData);
      this$1.click(key, data);
    });
    return this;
  };
  /**
   * Tracking function wrapper
   * @param{string}   keyThe key or event of the data
   * @param{collection} data The data to track
   * @return {object}        The final data object
   */


  Track.prototype.click = function click(key, data) {
    // Set the path name based on the location
    var d = data.map(function (el) {
      if (el.hasOwnProperty(Track.key)) {
        el[Track.key] = window.location.pathname + "/" + el[Track.key];
      }

      return el;
    });
    var wt = this.webtrends(key, d);
    var ga = this.gtag(key, d);
    /* eslint-disable no-console */

    if (Utility.debug()) {
      console.dir({
        'Track': [wt, ga]
      });
    }
    /* eslint-enable no-console */


    return d;
  };
  /**
   * Data bus for tracking views in Webtrends and Google Analytics
   * @param{string}   appThe name of the Single Page Application to track
   * @param{string}   keyThe key or event of the data
   * @param{collection} data The data to track
   */

  Track.prototype.view = function view(app, key, data) {
    var wt = this.webtrends(key, data);
    var ga = this.gtagView(app, key);
    /* eslint-disable no-console */

    if (Utility.debug()) {
      console.dir({
        'Track': [wt, ga]
      });
    }
    /* eslint-enable no-console */

  };
  /**
   * Push Events to Webtrends
   * @param{string}   keyThe key or event of the data
   * @param{collection} data The data to track
   */

  Track.prototype.webtrends = function webtrends(key, data) {
    var event = [{
      'WT.ti': key
    }];

    if (data[0] && data[0].hasOwnProperty(Track.key)) {
      event.push({
        'DCS.dcsuri': data[0][Track.key]
      });
    } else {
      Object.assign(event, data);
    } // Format data for Webtrends


    var wtd = {
      argsa: event.flatMap(function (e) {
        return Object.keys(e).flatMap(function (k) {
          return [k, e[k]];
        });
      })
    };
    /* eslint-disable no-undef */

    if (typeof Webtrends !== 'undefined') {
      Webtrends.multiTrack(wtd);
    }
    /* eslint-disable no-undef */


    return ['Webtrends', wtd];
  };
  /**
   * Push Click Events to Google Analytics
   * @param{string}   keyThe key or event of the data
   * @param{collection} data The data to track
   */

  Track.prototype.gtag = function gtag$1(key, data) {
    var uri = data.find(function (element) {
      return element.hasOwnProperty(Track.key);
    });
    var event = {
      'event_category': key
    };
    /* eslint-disable no-undef */

    if (typeof gtag !== 'undefined') {
      gtag(Track.key, uri[Track.key], event);
    }
    /* eslint-enable no-undef */


    return ['gtag', Track.key, uri[Track.key], event];
  };
  /**
   * Push Screen View Events to Google Analytics
   * @param{string}   appThe name of the application
   * @param{string}   keyThe key or event of the data
   */

  Track.prototype.gtagView = function gtagView(app, key) {
    var view = {
      app_name: app,
      screen_name: key
    };
    /* eslint-disable no-undef */

    if (typeof gtag !== 'undefined') {
      gtag('event', 'screen_view', view);
    }
    /* eslint-enable no-undef */


    return ['gtag', Track.key, 'screen_view', view];
  };
  /** @type {String} The main selector to add the tracking function to */


  Track.selector = '[data-js*="track"]';
  /** @type {String} The main event tracking key to map to Webtrends DCS.uri */

  Track.key = 'event';

  /*!
   * Vue.js v2.6.6
   * (c) 2014-2019 Evan You
   * Released under the MIT License.
   */

  /*  */
  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
  // explicitness and function inlining.

  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }
  /**
   * Check if value is primitive.
   */


  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
    typeof value === 'symbol' || typeof value === 'boolean';
  }
  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */


  function isObject$1(obj) {
    return obj !== null && typeof obj === 'object';
  }
  /**
   * Get the raw type string of a value, e.g., [object Object].
   */


  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }
  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */


  function isPlainObject$1(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }
  /**
   * Check if val is a valid array index.
   */


  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  function isPromise(val) {
    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
  }
  /**
   * Convert a value to a string that is actually rendered.
   */


  function toString$1(val) {
    return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
  }
  /**
   * Convert an input value to a number for persistence.
   * If the conversion fails, return original string.
   */


  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }
  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */


  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');

    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }

    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }
  /**
   * Check if a tag is a built-in tag.
   */


  var isBuiltInTag = makeMap('slot,component', true);
  /**
   * Check if an attribute is a reserved attribute.
   */

  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
  /**
   * Remove an item from an array.
   */

  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);

      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }
  /**
   * Check whether an object has the property.
   */


  var hasOwnProperty$d = Object.prototype.hasOwnProperty;

  function hasOwn(obj, key) {
    return hasOwnProperty$d.call(obj, key);
  }
  /**
   * Create a cached version of a pure function.
   */


  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }
  /**
   * Camelize a hyphen-delimited string.
   */


  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });
  /**
   * Capitalize a string.
   */

  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  /**
   * Hyphenate a camelCase string.
   */

  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });
  /**
   * Simple bind polyfill for environments that do not support it,
   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
   * since native bind is now performant enough in most browsers.
   * But removing it would mean breaking code that was able to run in
   * PhantomJS 1.x, so this must be kept for backward compatibility.
   */

  /* istanbul ignore next */

  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }

    boundFn._length = fn.length;
    return boundFn;
  }

  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }

  var bind = Function.prototype.bind ? nativeBind : polyfillBind;
  /**
   * Convert an Array-like object to a real Array.
   */

  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);

    while (i--) {
      ret[i] = list[i + start];
    }

    return ret;
  }
  /**
   * Mix properties into target object.
   */


  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }

    return to;
  }
  /**
   * Merge an Array of Objects into a single Object.
   */


  function toObject(arr) {
    var res = {};

    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }

    return res;
  }
  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */


  function noop$1(a, b, c) {}
  /**
   * Always return false.
   */


  var no = function (a, b, c) {
    return false;
  };
  /* eslint-enable no-unused-vars */

  /**
   * Return the same value.
   */


  var identity$1 = function (_) {
    return _;
  };
  /**
   * Generate a string containing static keys from compiler modules.
   */


  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }
  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */


  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }

    var isObjectA = isObject$1(a);
    var isObjectB = isObject$1(b);

    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);

        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime();
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }
  /**
   * Return the first index at which a loosely equal value can be
   * found in the array (if value is a plain object, the array must
   * contain an object of the same shape), or -1 if it is not present.
   */


  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Ensure a function is called only once.
   */


  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';
  var ASSET_TYPES = ['component', 'directive', 'filter'];
  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop$1,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity$1,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };
  /*  */

  /**
   * unicode letters used for parsing html tags, component names and property paths.
   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
   */

  var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
  /**
   * Check if a string starts with $ or _
   */

  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }
  /**
   * Define a property.
   */


  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }
  /**
   * Parse simple path.
   */


  var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }

    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }

        obj = obj[segments[i]];
      }

      return obj;
    };
  }
  /*  */
  // can we use __proto__?


  var hasProto = '__proto__' in {}; // Browser environment sniffing

  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

  var nativeWatch = {}.watch;
  var supportsPassive = false;

  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285

      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  } // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV


  var _isServer;

  var isServerRendering = function () {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }

    return _isServer;
  }; // detect devtools


  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
  /* istanbul ignore next */

  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */
  // $flow-disable-line


  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set =
    /*@__PURE__*/
    function () {
      function Set() {
        this.set = Object.create(null);
      }

      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };

      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };

      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }
  /*  */


  var warn = noop$1;
  var tip = noop$1;
  var generateComponentTrace = noop$1; // work around flow check

  var formatComponentName = noop$1;
  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;

    var classify = function (str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function (msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function (msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function (vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }

      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
      var name = options.name || options._componentTag;
      var file = options.__file;

      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat$1 = function (str, n) {
      var res = '';

      while (n) {
        if (n % 2 === 1) {
          res += str;
        }

        if (n > 1) {
          str += str;
        }

        n >>= 1;
      }

      return res;
    };

    generateComponentTrace = function (vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;

        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];

            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }

          tree.push(vm);
          vm = vm.$parent;
        }

        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }
  /*  */

  var uid = 0;
  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */

  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();

    if (!config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort(function (a, b) {
        return a.id - b.id;
      });
    }

    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }; // The current target watcher being evaluated.
  // This is globally unique because only one watcher
  // can be evaluated at a time.


  Dep.target = null;
  var targetStack = [];

  function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
  }

  function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }
  /*  */


  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = {
    child: {
      configurable: true
    }
  }; // DEPRECATED: alias for componentInstance for backwards compat.

  /* istanbul ignore next */

  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function (text) {
    if (text === void 0) text = '';
    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  } // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.


  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
  }
  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */


  var arrayProto$1 = Array.prototype;
  var arrayMethods = Object.create(arrayProto$1);
  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
  /**
   * Intercept mutating methods and emit events
   */

  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto$1[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;

      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;

        case 'splice':
          inserted = args.slice(2);
          break;
      }

      if (inserted) {
        ob.observeArray(inserted);
      } // notify change


      ob.dep.notify();
      return result;
    });
  });
  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */

  var shouldObserve = true;

  function toggleObserving(value) {
    shouldObserve = value;
  }
  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */


  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);

    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }

      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };
  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */


  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);

    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };
  /**
   * Observe a list of Array items.
   */


  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  }; // helpers

  /**
   * Augment a target Object or Array by intercepting
   * the prototype chain using __proto__
   */


  function protoAugment(target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }
  /**
   * Augment a target Object or Array by defining
   * hidden properties.
   */

  /* istanbul ignore next */


  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }
  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */


  function observe(value, asRootData) {
    if (!isObject$1(value) || value instanceof VNode) {
      return;
    }

    var ob;

    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }

    if (asRootData && ob) {
      ob.vmCount++;
    }

    return ob;
  }
  /**
   * Define a reactive property on an Object.
   */


  function defineReactive$$1(obj, key, val, customSetter, shallow) {
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);

    if (property && property.configurable === false) {
      return;
    } // cater for pre-defined getter/setters


    var getter = property && property.get;
    var setter = property && property.set;

    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;

        if (Dep.target) {
          dep.depend();

          if (childOb) {
            childOb.dep.depend();

            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }

        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */

        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */


        if (customSetter) {
          customSetter();
        } // #7981: for accessor properties without setter


        if (getter && !setter) {
          return;
        }

        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }

        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }
  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */


  function set(target, key, val) {
    if (isUndef(target) || isPrimitive(target)) {
      warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
    }

    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }

    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }

    var ob = target.__ob__;

    if (target._isVue || ob && ob.vmCount) {
      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }

    if (!ob) {
      target[key] = val;
      return val;
    }

    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val;
  }
  /**
   * Delete a property and trigger change if necessary.
   */


  function del(target, key) {
    if (isUndef(target) || isPrimitive(target)) {
      warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
    }

    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }

    var ob = target.__ob__;

    if (target._isVue || ob && ob.vmCount) {
      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }

    if (!hasOwn(target, key)) {
      return;
    }

    delete target[key];

    if (!ob) {
      return;
    }

    ob.dep.notify();
  }
  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */


  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();

      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }
  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */


  var strats = config.optionMergeStrategies;
  /**
   * Options with restrictions
   */

  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }

      return defaultStrat(parent, child);
    };
  }
  /**
   * Helper that recursively merges two data objects together.
   */

  function mergeData(to, from) {
    if (!from) {
      return to;
    }

    var key, toVal, fromVal;
    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
      key = keys[i]; // in case the object is already observed...

      if (key === '__ob__') {
        continue;
      }

      toVal = to[key];
      fromVal = from[key];

      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }

    return to;
  }
  /**
   * Data
   */


  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }

      if (!parentVal) {
        return childVal;
      } // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.


      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
        return parentVal;
      }

      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };
  /**
   * Hooks and props are merged as arrays.
   */


  function mergeHook(parentVal, childVal) {
    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
    return res ? dedupeHooks(res) : res;
  }

  function dedupeHooks(hooks) {
    var res = [];

    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }

    return res;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });
  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */

  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);

    if (childVal) {
      assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });
  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */

  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }

    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */


    if (!childVal) {
      return Object.create(parentVal || null);
    }

    {
      assertObjectType(key, childVal, vm);
    }

    if (!parentVal) {
      return childVal;
    }

    var ret = {};
    extend(ret, parentVal);

    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];

      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }

      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }

    return ret;
  };
  /**
   * Other object hashes.
   */


  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }

    if (!parentVal) {
      return childVal;
    }

    var ret = Object.create(null);
    extend(ret, parentVal);

    if (childVal) {
      extend(ret, childVal);
    }

    return ret;
  };

  strats.provide = mergeDataOrFn;
  /**
   * Default strategy.
   */

  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };
  /**
   * Validate component names
   */


  function checkComponents(options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName(name) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
      warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
    }

    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
    }
  }
  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */


  function normalizeProps(options, vm) {
    var props = options.props;

    if (!props) {
      return;
    }

    var res = {};
    var i, val, name;

    if (Array.isArray(props)) {
      i = props.length;

      while (i--) {
        val = props[i];

        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = {
            type: null
          };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject$1(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject$1(val) ? val : {
          type: val
        };
      }
    } else {
      warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
    }

    options.props = res;
  }
  /**
   * Normalize all injections into Object-based format
   */


  function normalizeInject(options, vm) {
    var inject = options.inject;

    if (!inject) {
      return;
    }

    var normalized = options.inject = {};

    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = {
          from: inject[i]
        };
      }
    } else if (isPlainObject$1(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject$1(val) ? extend({
          from: key
        }, val) : {
          from: val
        };
      }
    } else {
      warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
    }
  }
  /**
   * Normalize raw function directives into object format.
   */


  function normalizeDirectives(options) {
    var dirs = options.directives;

    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];

        if (typeof def$$1 === 'function') {
          dirs[key] = {
            bind: def$$1,
            update: def$$1
          };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject$1(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }
  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */


  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child); // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.

    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }

      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;

    for (key in parent) {
      mergeField(key);
    }

    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }

    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }

    return options;
  }
  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */


  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }

    var assets = options[type]; // check local registration variations first

    if (hasOwn(assets, id)) {
      return assets[id];
    }

    var camelizedId = camelize(id);

    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }

    var PascalCaseId = capitalize(camelizedId);

    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    } // fallback to prototype chain


    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

    if (warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }

    return res;
  }
  /*  */


  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key]; // boolean casting

    var booleanIndex = getTypeIndex(Boolean, prop.type);

    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);

        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    } // check default value


    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
      // make sure to observe it.

      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }

    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }
  /**
   * Get the default value of a prop.
   */


  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }

    var def = prop.default; // warn against non-factory defaults for Object & Array

    if (isObject$1(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    } // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger


    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    } // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context


    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }
  /**
   * Assert whether a prop is valid.
   */


  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }

    if (value == null && !prop.required) {
      return;
    }

    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];

    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }

      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }

    if (!valid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
      return;
    }

    var validator = prop.validator;

    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);

    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value;
      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject$1(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }

    return {
      valid: valid,
      expectedType: expectedType
    };
  }
  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */


  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isSameType(a, b) {
    return getType(a) === getType(b);
  }

  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }

    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }

    return -1;
  }

  function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += " with value " + expectedValue;
    }

    message += ", got " + receivedType + " "; // check if we need to specify received value

    if (isExplicable(receivedType)) {
      message += "with value " + receivedValue + ".";
    }

    return message;
  }

  function styleValue(value, type) {
    if (type === 'String') {
      return "\"" + value + "\"";
    } else if (type === 'Number') {
      return "" + Number(value);
    } else {
      return "" + value;
    }
  }

  function isExplicable(value) {
    var explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(function (elem) {
      return value.toLowerCase() === elem;
    });
  }

  function isBoolean() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    return args.some(function (elem) {
      return elem.toLowerCase() === 'boolean';
    });
  }
  /*  */


  function handleError(err, vm, info) {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  }

  function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;

    try {
      res = args ? handler.apply(context, args) : handler.call(context);

      if (res && !res._isVue && isPromise(res)) {
        res.catch(function (e) {
          return handleError(e, vm, info + " (Promise/async)");
        });
      }
    } catch (e) {
      handleError(e, vm, info);
    }

    return res;
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        // if the user intentionally throws the original error in the handler,
        // do not log it twice
        if (e !== err) {
          logError(e, null, 'config.errorHandler');
        }
      }
    }

    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */

    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
  /*  */


  var isUsingMicroTask = false;
  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;

    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  } // Here we have async deferring wrappers using microtasks.
  // In 2.5 we used (macro) tasks (in combination with microtasks).
  // However, it has subtle problems when state is changed right before repaint
  // (e.g. #6813, out-in transitions).
  // Also, using (macro) tasks in event handler would cause some weird behaviors
  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
  // So we now use microtasks everywhere, again.
  // A major drawback of this tradeoff is that there are some scenarios
  // where microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690, which have workarounds)
  // or even between bubbling of the same event (#6566).


  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:

  /* istanbul ignore next, $flow-disable-line */

  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();

    timerFunc = function () {
      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.

      if (isIOS) {
        setTimeout(noop$1);
      }
    };

    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });

    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };

    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  } else {
    // Fallback to setTimeout.
    timerFunc = function () {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick(cb, ctx) {
    var _resolve;

    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });

    if (!pending) {
      pending = true;
      timerFunc();
    } // $flow-disable-line


    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }
  /*  */


  var mark;
  var measure;
  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */

    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function (tag) {
        return perf.mark(tag);
      };

      measure = function (name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag); // perf.clearMeasures(name)
      };
    }
  }
  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;
  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function (target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };

    var warnReservedPrefix = function (target, key) {
      warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

        if (!has && !isAllowed) {
          if (key in target.$data) {
            warnReservedPrefix(target, key);
          } else {
            warnNonPresent(target, key);
          }
        }

        return has || !isAllowed;
      }
    };
    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          if (key in target.$data) {
            warnReservedPrefix(target, key);
          } else {
            warnNonPresent(target, key);
          }
        }

        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }
  /*  */

  var seenObjects = new _Set();
  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */

  function traverse(val) {
    _traverse(val, seenObjects);

    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);

    if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }

    if (val.__ob__) {
      var depId = val.__ob__.dep.id;

      if (seen.has(depId)) {
        return;
      }

      seen.add(depId);
    }

    if (isA) {
      i = val.length;

      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;

      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }
  /*  */


  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns, vm) {
    function invoker() {
      var arguments$1 = arguments;
      var fns = invoker.fns;

      if (Array.isArray(fns)) {
        var cloned = fns.slice();

        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // return handler return value for single handlers
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
      }
    }

    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
    var name, def$$1, cur, old, event;

    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);

      if (isUndef(cur)) {
        warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }

        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }

        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }

    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }
  /*  */


  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }

    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
      // and prevent memory leak

      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }
  /*  */


  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;

    if (isUndef(propOptions)) {
      return;
    }

    var res = {};
    var attrs = data.attrs;
    var props = data.props;

    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();

          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }

    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];

        if (!preserve) {
          delete hash[key];
        }

        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];

        if (!preserve) {
          delete hash[altKey];
        }

        return true;
      }
    }

    return false;
  }
  /*  */
  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:
  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.


  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }

    return children;
  } // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.


  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;

    for (i = 0; i < children.length; i++) {
      c = children[i];

      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }

      lastIndex = res.length - 1;
      last = res[lastIndex]; //  nested

      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }

          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }

          res.push(c);
        }
      }
    }

    return res;
  }
  /*  */


  function initProvide(vm) {
    var provide = vm.$options.provide;

    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);

    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i]; // #6574 in case the inject object is observed...

        if (key === '__ob__') {
          continue;
        }

        var provideKey = inject[key].from;
        var source = vm;

        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }

          source = source.$parent;
        }

        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {
            warn("Injection \"" + key + "\" not found", vm);
          }
        }
      }

      return result;
    }
  }
  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */


  function resolveSlots(children, context) {
    if (!children || !children.length) {
      return {};
    }

    var slots = {};

    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      } // named slots should only be respected if the vnode was rendered in the
      // same context.


      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name = data.slot;
        var slot = slots[name] || (slots[name] = []);

        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    } // ignore slots that contains only whitespace


    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }

    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }
  /*  */


  function normalizeScopedSlots(slots, normalSlots, prevSlots) {
    var res;

    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      // fast path 1: child component re-render only, parent did not change
      return slots._normalized;
    } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
      // fast path 2: stable scoped slots w/ no normal slots to proxy,
      // only need to normalize once
      return prevSlots;
    } else {
      res = {};

      for (var key in slots) {
        if (slots[key] && key[0] !== '$') {
          res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
        }
      }
    } // expose normal slots on scopedSlots


    for (var key$1 in normalSlots) {
      if (!(key$1 in res)) {
        res[key$1] = proxyNormalSlot(normalSlots, key$1);
      }
    } // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error


    if (slots && Object.isExtensible(slots)) {
      slots._normalized = res;
    }

    def(res, '$stable', slots ? !!slots.$stable : true);
    return res;
  }

  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
      : normalizeChildren(res);
      return res && res.length === 0 ? undefined : res;
    }; // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.


    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }

    return normalized;
  }

  function proxyNormalSlot(slots, key) {
    return function () {
      return slots[key];
    };
  }
  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */


  function renderList(val, render) {
    var ret, i, l, keys, key;

    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);

      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);

      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject$1(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();

        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);

        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }

    if (!isDef(ret)) {
      ret = [];
    }

    ret._isVList = true;
    return ret;
  }
  /*  */

  /**
   * Runtime helper for rendering <slot>
   */


  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;

    if (scopedSlotFn) {
      // scoped slot
      props = props || {};

      if (bindObject) {
        if (!isObject$1(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }

        props = extend(extend({}, bindObject), props);
      }

      nodes = scopedSlotFn(props) || fallback;
    } else {
      nodes = this.$slots[name] || fallback;
    }

    var target = props && props.slot;

    if (target) {
      return this.$createElement('template', {
        slot: target
      }, nodes);
    } else {
      return nodes;
    }
  }
  /*  */

  /**
   * Runtime helper for resolving filters
   */


  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity$1;
  }
  /*  */


  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }
  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */


  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }
  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */


  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject$1(value)) {
        warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }

        var hash;

        var loop = function (key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }

          var camelizedKey = camelize(key);

          if (!(key in hash) && !(camelizedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});

              on["update:" + camelizedKey] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop(key);
      }
    }

    return data;
  }
  /*  */

  /**
   * Runtime helper for rendering static trees.
   */


  function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.

    if (tree && !isInFor) {
      return tree;
    } // otherwise, render a fresh tree.


    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__" + index, false);
    return tree;
  }
  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */


  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }
  /*  */


  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject$1(value)) {
        warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};

        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }

    return data;
  }
  /*  */


  function resolveScopedSlots(fns, // see flow/vnode
  hasDynamicKeys, res) {
    res = res || {
      $stable: !hasDynamicKeys
    };

    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];

      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, hasDynamicKeys, res);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }

        res[slot.key] = slot.fn;
      }
    }

    return res;
  }
  /*  */


  function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];

      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== '' && key !== null) {
        // null is a speical value for explicitly removing a binding
        warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
      }
    }

    return baseObj;
  } // helper to dynamically append modifier runtime markers to event names.
  // ensure only append when value is already string, otherwise it will be cast
  // to string and cause the type check to miss.


  function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
  }
  /*  */


  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString$1;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
  }
  /*  */


  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var this$1 = this;
    var options = Ctor.options; // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check

    var contextVm;

    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent); // $flow-disable-line

      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent; // $flow-disable-line

      parent = parent._original;
    }

    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);

    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
      }

      return this$1.$slots;
    };

    Object.defineProperty(this, 'scopedSlots', {
      enumerable: true,
      get: function get() {
        return normalizeScopedSlots(data.scopedSlots, this.slots());
      }
    }); // support for compiled functional template

    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options; // pre-resolve slots for renderSlot()

      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);

        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }

        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;

    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }

      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);

      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }

      return res;
    }
  }

  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }

    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }

    return clone;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }
  /*  */

  /*  */

  /*  */

  /*  */
  // inline hooks to be invoked on component VNodes during patch


  var componentVNodeHooks = {
    init: function init(vnode, hydrating) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow

        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },
    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },
    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;

      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }

      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true
          /* direct */
          );
        }
      }
    },
    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;

      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true
          /* direct */
          );
        }
      }
    }
  };
  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base; // plain options object: turn it into a constructor

    if (isObject$1(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    } // if at this stage it's not a constructor or an async component factory,
    // reject.


    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    } // async component


    var asyncFactory;

    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {}; // resolve constructor options in case global mixins are applied after
    // component constructor creation

    resolveConstructorOptions(Ctor); // transform component v-model data into props & events

    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    } // extract props


    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    } // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners


    var listeners = data.on; // replace with listeners with .native modifier
    // so it gets processed during parent component patch.

    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot
      // work around flow
      var slot = data.slot;
      data = {};

      if (slot) {
        data.slot = slot;
      }
    } // install component management hooks onto the placeholder node


    installComponentHooks(data); // return a placeholder vnode

    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
      Ctor: Ctor,
      propsData: propsData,
      listeners: listeners,
      tag: tag,
      children: children
    }, asyncFactory);
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
  ) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    }; // check inline-template render functions

    var inlineTemplate = vnode.data.inlineTemplate;

    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }

    return new vnode.componentOptions.Ctor(options);
  }

  function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});

    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];

      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1(f1, f2) {
    var merged = function (a, b) {
      // flow complains about extra args which is why we use any
      f1(a, b);
      f2(a, b);
    };

    merged._merged = true;
    return merged;
  } // transform component v-model info (value and callback) into
  // prop and event handler respectively.


  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;

    if (isDef(existing)) {
      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }
  /*  */


  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
  // without getting yelled at by flow

  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }

    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }

    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    } // object syntax in v-bind


    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }

    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    } // warn against non-primitive key


    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      {
        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
      }
    } // support single function children as default scoped slot


    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = {
        default: children[0]
      };
      children.length = 0;
    }

    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }

    var vnode, ns;

    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }

    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }

      if (isDef(data)) {
        registerDeepBindings(data);
      }

      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;

    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }

    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];

        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
          applyNS(child, ns, force);
        }
      }
    }
  } // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes


  function registerDeepBindings(data) {
    if (isObject$1(data.style)) {
      traverse(data.style);
    }

    if (isObject$1(data.class)) {
      traverse(data.class);
    }
  }
  /*  */


  function initRender(vm) {
    vm._vnode = null; // the root of the child tree

    vm._staticTrees = null; // v-once cached trees

    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates

    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    }; // normalization is always applied for the public version, used in
    // user-written render functions.


    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    }; // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated


    var parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */

    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
      } // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.


      vm.$vnode = _parentVnode; // render self

      var vnode;

      try {
        // There's no need to maintain a stack becaues all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render"); // return error render result,
        // or previous vnode to prevent render error causing blank component

        /* istanbul ignore else */

        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      } // if the returned array contains only a single node, allow it


      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      } // return empty vnode in case the render function errored out


      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }

        vnode = createEmptyVNode();
      } // set parent


      vnode.parent = _parentVnode;
      return vnode;
    };
  }
  /*  */


  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }

    return isObject$1(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = {
      data: data,
      context: context,
      children: children,
      tag: tag
    };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    var owner = currentRenderingInstance;

    if (isDef(factory.owners)) {
      // already pending
      factory.owners.push(owner);
    } else {
      var owners = factory.owners = [owner];
      var sync = true;

      var forceRender = function (renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          owners[i].$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)

        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });
      var reject = once(function (reason) {
        warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });
      var res = factory(resolve, reject);

      if (isObject$1(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);

            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false; // return in case resolved synchronously

      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }
  /*  */


  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }
  /*  */


  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];

        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }
  /*  */

  /*  */


  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false; // init parent attached events

    var listeners = vm.$options._parentListeners;

    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn) {
    target.$on(event, fn);
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function createOnceHandler(event, fn) {
    var _target = target;
    return function onceHandler() {
      var res = fn.apply(null, arguments);

      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    };
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;

    Vue.prototype.$on = function (event, fn) {
      var vm = this;

      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup

        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }

      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;

      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }

      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var vm = this; // all

      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      } // array of events


      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }

        return vm;
      } // specific event


      var cbs = vm._events[event];

      if (!cbs) {
        return vm;
      }

      if (!fn) {
        vm._events[event] = null;
        return vm;
      } // specific handler


      var cb;
      var i = cbs.length;

      while (i--) {
        cb = cbs[i];

        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break;
        }
      }

      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();

        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];

      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";

        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }

      return vm;
    };
  }
  /*  */


  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    };
  }

  function initLifecycle(vm) {
    var options = vm.$options; // locate first non-abstract parent

    var parent = options.parent;

    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }

      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.

      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
        /* removeOnly */
        );
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }

      restoreActiveInstance(); // update __vue__ reference

      if (prevEl) {
        prevEl.__vue__ = null;
      }

      if (vm.$el) {
        vm.$el.__vue__ = vm;
      } // if parent is an HOC, update its $el as well


      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      } // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.

    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;

      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;

      if (vm._isBeingDestroyed) {
        return;
      }

      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true; // remove self from parent

      var parent = vm.$parent;

      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      } // teardown watchers


      if (vm._watcher) {
        vm._watcher.teardown();
      }

      var i = vm._watchers.length;

      while (i--) {
        vm._watchers[i].teardown();
      } // remove reference from data ob
      // frozen object may not have observer.


      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      } // call the last hook...


      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

      vm.__patch__(vm._vnode, null); // fire destroyed hook


      callHook(vm, 'destroyed'); // turn off all instance listeners.

      vm.$off(); // remove __vue__ reference

      if (vm.$el) {
        vm.$el.__vue__ = null;
      } // release circular reference (#6759)


      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;

    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }

    callHook(vm, 'beforeMount');
    var updateComponent;
    /* istanbul ignore if */

    if (config.performance && mark) {
      updateComponent = function () {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;
        mark(startTag);

        var vnode = vm._render();

        mark(endTag);
        measure("vue " + name + " render", startTag, endTag);
        mark(startTag);

        vm._update(vnode, hydrating);

        mark(endTag);
        measure("vue " + name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    } // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined


    new Watcher(vm, updateComponent, noop$1, {
      before: function before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true
    /* isRenderWatcher */
    );
    hydrating = false; // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook

    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }

    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    } // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.

    var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.

    var needsForceUpdate = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    hasDynamicScopedSlot);
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }

    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render

    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject; // update props

    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];

      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?

        props[key] = validateProp(key, propOptions, propsData, vm);
      }

      toggleObserving(true); // keep a copy of raw propsData

      vm.$options.propsData = propsData;
    } // update listeners


    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }

    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;

      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }

    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;

      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }

      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;

      if (isInInactiveTree(vm)) {
        return;
      }
    }

    if (!vm._inactive) {
      vm._inactive = true;

      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }

      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";

    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }

    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }

    popTarget();
  }
  /*  */


  var MAX_UPDATE_COUNT = 100;
  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;
  /**
   * Reset the scheduler's state.
   */

  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  } // Async edge case #6566 requires saving the timestamp when event listeners are
  // attached. However, calling performance.now() has a perf overhead especially
  // if the page has thousands of event listeners. Instead, we take a timestamp
  // every time the scheduler flushes and use that for all event listeners
  // attached during that flush.


  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.

  if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    getNow = function () {
      return performance.now();
    };
  }
  /**
   * Flush both queues and run the watchers.
   */


  function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id; // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.

    queue.sort(function (a, b) {
      return a.id - b.id;
    }); // do not cache length because more watchers might be pushed
    // as we run existing watchers

    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];

      if (watcher.before) {
        watcher.before();
      }

      id = watcher.id;
      has[id] = null;
      watcher.run(); // in dev build, check and stop circular updates.

      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;

        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    } // keep copies of post queues before resetting state


    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    resetSchedulerState(); // call component updated and activated hooks

    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue); // devtool hook

    /* istanbul ignore if */

    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;

    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;

      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }
  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */


  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true
      /* true */
      );
    }
  }
  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */


  function queueWatcher(watcher) {
    var id = watcher.id;

    if (has[id] == null) {
      has[id] = true;

      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;

        while (i > index && queue[i].id > watcher.id) {
          i--;
        }

        queue.splice(i + 1, 0, watcher);
      } // queue the flush


      if (!waiting) {
        waiting = true;

        if (!config.async) {
          flushSchedulerQueue();
          return;
        }

        nextTick(flushSchedulerQueue);
      }
    }
  }
  /*  */


  var uid$2 = 0;
  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */

  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;

    if (isRenderWatcher) {
      vm._watcher = this;
    }

    vm._watchers.push(this); // options


    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }

    this.cb = cb;
    this.id = ++uid$2; // uid for batching

    this.active = true;
    this.dirty = this.lazy; // for lazy watchers

    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString(); // parse expression for getter

    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);

      if (!this.getter) {
        this.getter = noop$1;
        warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }

    this.value = this.lazy ? undefined : this.get();
  };
  /**
   * Evaluate the getter, and re-collect dependencies.
   */


  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;

    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }

      popTarget();
      this.cleanupDeps();
    }

    return value;
  };
  /**
   * Add a dependency to this directive.
   */


  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;

    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);

      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };
  /**
   * Clean up for dependency collection.
   */


  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var i = this.deps.length;

    while (i--) {
      var dep = this.deps[i];

      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }

    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */


  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };
  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */


  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();

      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject$1(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;

        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };
  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */


  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };
  /**
   * Depend on all deps collected by this watcher.
   */


  Watcher.prototype.depend = function depend() {
    var i = this.deps.length;

    while (i--) {
      this.deps[i].depend();
    }
  };
  /**
   * Remove self from all dependencies' subscriber list.
   */


  Watcher.prototype.teardown = function teardown() {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }

      var i = this.deps.length;

      while (i--) {
        this.deps[i].removeSub(this);
      }

      this.active = false;
    }
  };
  /*  */


  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop$1,
    set: noop$1
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };

    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };

    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;

    if (opts.props) {
      initProps(vm, opts.props);
    }

    if (opts.methods) {
      initMethods(vm, opts.methods);
    }

    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true
      /* asRootData */
      );
    }

    if (opts.computed) {
      initComputed(vm, opts.computed);
    }

    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.

    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent; // root instance props should be converted

    if (!isRoot) {
      toggleObserving(false);
    }

    var loop = function (key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */

      {
        var hyphenatedKey = hyphenate(key);

        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }

        defineReactive$$1(props, key, value, function () {
          if (!isRoot && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      } // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.

      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop(key);

    toggleObserving(true);
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

    if (!isPlainObject$1(data)) {
      data = {};
      warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    } // proxy data on instance


    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;

    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("Method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }

      if (props && hasOwn(props, key)) {
        warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    } // observe data


    observe(data, true
    /* asRootData */
    );
  }

  function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();

    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = {
    lazy: true
  };

  function initComputed(vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;

      if (getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
      } // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.


      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();

    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop$1;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
      sharedPropertyDefinition.set = userDef.set || noop$1;
    }

    if (sharedPropertyDefinition.set === noop$1) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }

    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];

      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }

        if (Dep.target) {
          watcher.depend();
        }

        return watcher.value;
      }
    };
  }

  function createGetterInvoker(fn) {
    return function computedGetter() {
      return fn.call(this, this);
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;

    for (var key in methods) {
      {
        if (typeof methods[key] !== 'function') {
          warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
        }

        if (props && hasOwn(props, key)) {
          warn("Method \"" + key + "\" has already been defined as a prop.", vm);
        }

        if (key in vm && isReserved(key)) {
          warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
        }
      }
      vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];

      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject$1(handler)) {
      options = handler;
      handler = handler.handler;
    }

    if (typeof handler === 'string') {
      handler = vm[handler];
    }

    return vm.$watch(expOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};

    dataDef.get = function () {
      return this._data;
    };

    var propsDef = {};

    propsDef.get = function () {
      return this._props;
    };

    {
      dataDef.set = function () {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };

      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;

      if (isPlainObject$1(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }

      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);

      if (options.immediate) {
        try {
          cb.call(vm, watcher.value);
        } catch (error) {
          handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
        }
      }

      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }
  /*  */


  var uid$3 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this; // a uid

      vm._uid = uid$3++;
      var startTag, endTag;
      /* istanbul ignore if */

      if (config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      } // a flag to avoid this being observed


      vm._isVue = true; // merge options

      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */


      {
        initProxy(vm);
      } // expose real self

      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props

      initState(vm);
      initProvide(vm); // resolve provide after data/props

      callHook(vm, 'created');
      /* istanbul ignore if */

      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;

    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;

      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }

        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }

    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;

    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }

        modified[key] = latest[key];
      }
    }

    return modified;
  }

  function Vue(options) {
    if (!(this instanceof Vue)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }

    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);
  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      } // additional parameters


      var args = toArray(arguments, 1);
      args.unshift(this);

      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }

      installedPlugins.push(plugin);
      return this;
    };
  }
  /*  */


  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }
  /*  */


  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;
    /**
     * Class inheritance
     */

    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;

      if (name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };

      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.

      if (Sub.options.props) {
        initProps$1(Sub);
      }

      if (Sub.options.computed) {
        initComputed$1(Sub);
      } // allow further extension/mixin/plugin usage


      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use; // create asset registers, so extended classes
      // can have their private assets too.

      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      }); // enable recursive self-lookup

      if (name) {
        Sub.options.components[name] = Sub;
      } // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.


      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options); // cache constructor

      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;

    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;

    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }
  /*  */


  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          if (type === 'component') {
            validateComponentName(id);
          }

          if (type === 'component' && isPlainObject$1(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }

          if (type === 'directive' && typeof definition === 'function') {
            definition = {
              bind: definition,
              update: definition
            };
          }

          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }
  /*  */


  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */


    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;

    for (var key in cache) {
      var cachedNode = cache[key];

      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);

        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];

    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }

    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];
  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },
    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },
    destroyed: function destroyed() {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },
    mounted: function mounted() {
      var this$1 = this;
      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) {
          return matches(val, name);
        });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) {
          return !matches(val, name);
        });
      });
    },
    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;

      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;

        if ( // not included
        include && (!name || !matches(include, name)) || // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance; // make current key freshest

          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key); // prune oldest entry

          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }

      return vnode || slot && slot[0];
    }
  };
  var builtInComponents = {
    KeepAlive: KeepAlive
  };
  /*  */

  function initGlobalAPI(Vue) {
    // config
    var configDef = {};

    configDef.get = function () {
      return config;
    };

    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.

    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick; // 2.6 explicit observable API

    Vue.observable = function (obj) {
      observe(obj);
      return obj;
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    }); // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.

    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);
  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });
  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  }); // expose FunctionalRenderContext for ssr runtime helper installation

  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });
  Vue.version = '2.6.6';
  /*  */
  // these are reserved for web because they are directly compiled away
  // during template compilation

  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

  var acceptValue = makeMap('input,textarea,option,select,progress');

  var mustUseProp = function (tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
  };

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function (val) {
    return val == null || val === false;
  };
  /*  */


  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;

    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }

    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }

    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */


    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }

    if (isObject$1(value)) {
      return stringifyObject(value);
    }

    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */


    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;

    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }

        res += stringified;
      }
    }

    return res;
  }

  function stringifyObject(value) {
    var res = '';

    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }

        res += key;
      }
    }

    return res;
  }
  /*  */


  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };
  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.

  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function (tag) {
    return tag === 'pre';
  };

  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    } // basic support for MathML
    // note it doesn't support other MathML elements being component roots


    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);

  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }

    if (isReservedTag(tag)) {
      return false;
    }

    tag = tag.toLowerCase();
    /* istanbul ignore if */

    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }

    var el = document.createElement(tag);

    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');
  /*  */

  /**
   * Query an element selector if it's not an element already.
   */

  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);

      if (!selected) {
        warn('Cannot find element: ' + el);
        return document.createElement('div');
      }

      return selected;
    } else {
      return el;
    }
  }
  /*  */


  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);

    if (tagName !== 'select') {
      return elm;
    } // false or null will remove the attribute but undefined will not


    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }

    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps =
  /*#__PURE__*/
  Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });
  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;

    if (!isDef(key)) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;

    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }
  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */


  var emptyNode = new VNode('', {}, []);
  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }

    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};

    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;

      if (isDef(key)) {
        map[key] = i;
      }
    }

    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};
    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];

      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove$$1() {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }

      remove$$1.listeners = listeners;
      return remove$$1;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }

    var creatingElmInVPre = 0;

    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check

      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;

      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }

          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }
        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);
        /* istanbul ignore if */

        {
          createChildren(vnode, children, insertedVnodeQueue);

          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }

          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;

      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false
          /* hydrating */
          );
        } // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.


        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);

          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }

          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }

      vnode.elm = vnode.componentInstance.$el;

      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode); // make sure to invoke the insert hook

        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i; // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.

      var innerNode = vnode;

      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;

        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }

          insertedVnodeQueue.push(innerNode);
          break;
        }
      } // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself


      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }

        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }

      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }

      i = vnode.data.hook; // Reuse variable

      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }

        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    } // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.


    function setScope(vnode) {
      var i;

      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;

        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }

          ancestor = ancestor.parent;
        }
      } // for slot content they should also get the scopeId from the host instance.


      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;

      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }

        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }

      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];

        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;

        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        } // recursively invoke hooks on child component root node


        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }

        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }

        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions

      var canMove = !removeOnly;
      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }

          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];

            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }

          newStartVnode = newCh[++newStartIdx];
        }
      }

      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys(children) {
      var seenKeys = {};

      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;

        if (isDef(key)) {
          if (seenKeys[key]) {
            warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];

        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // clone reused vnode
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }

        return;
      } // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.


      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;

      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;

      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }

        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }

      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          {
            checkDuplicateKeys(ch);
          }

          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }

          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }

      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).

    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      } // assert node match


      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }

      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true
          /* hydrating */
          );
        }

        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }

      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }

                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;

              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }

                childNode = childNode.nextSibling;
              } // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.


              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }

                return false;
              }
            }
          }
        }

        if (isDef(data)) {
          var fullInvoke = false;

          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }

          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }

      return true;
    }

    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }

        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);

        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }

            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            } // either not server-rendered, or hydration failed.
            // create an empty node and replace it


            oldVnode = emptyNodeAt(oldVnode);
          } // replacing existing element


          var oldElm = oldVnode.elm;
          var parentElm = nodeOps.parentNode(oldElm); // create new node

          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);

            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }

              ancestor.elm = vnode.elm;

              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                } // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.


                var insert = ancestor.data.hook.insert;

                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }

              ancestor = ancestor.parent;
            }
          } // destroy old node


          if (isDef(parentElm)) {
            removeVnodes(parentElm, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }
  /*  */


  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
    var dirsWithInsert = [];
    var dirsWithPostpatch = [];
    var key, oldDir, dir;

    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];

      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);

        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, 'update', vnode, oldVnode);

        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function () {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };

      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);

    if (!dirs) {
      // $flow-disable-line
      return res;
    }

    var i, dir;

    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];

      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }

      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    } // $flow-disable-line


    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];

    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];
  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;

    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }

    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }

    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];

      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    } // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max

    /* istanbul ignore if */


    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }

    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.

      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
        var blocker = function (e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };

        el.addEventListener('input', blocker); // $flow-disable-line

        el.__ieph = true;
        /* IE placeholder patched */
      }

      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };
  /*  */

  function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode); // handle transition classes

    var transitionClass = el._transitionClasses;

    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    } // set the class


    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };
  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);

      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;
            break;
          // "

          case 0x27:
            inSingle = true;
            break;
          // '

          case 0x60:
            inTemplateString = true;
            break;
          // `

          case 0x28:
            paren++;
            break;
          // (

          case 0x29:
            paren--;
            break;
          // )

          case 0x5B:
            square++;
            break;
          // [

          case 0x5D:
            square--;
            break;
          // ]

          case 0x7B:
            curly++;
            break;
          // {

          case 0x7D:
            curly--;
            break;
          // }
        }

        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0; // find first non-whitespace prev char

          for (; j >= 0; j--) {
            p = exp.charAt(j);

            if (p !== ' ') {
              break;
            }
          }

          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');

    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
    }
  }
  /*  */

  /* eslint-disable no-unused-vars */


  function baseWarn(msg, range) {
    console.error("[Vue compiler]: " + msg);
  }
  /* eslint-enable no-unused-vars */


  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({
      name: name,
      value: value,
      dynamic: dynamic
    }, range));
    el.plain = false;
  }

  function addAttr(el, name, value, range, dynamic) {
    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
    attrs.push(rangeSetItem({
      name: name,
      value: value,
      dynamic: dynamic
    }, range));
    el.plain = false;
  } // add a raw attr (use this in preTransforms)


  function addRawAttr(el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({
      name: name,
      value: value
    }, range));
  }

  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
      name: name,
      rawName: rawName,
      value: value,
      arg: arg,
      isDynamicArg: isDynamicArg,
      modifiers: modifiers
    }, range));
    el.plain = false;
  }

  function prependModifierMarker(symbol, name, dynamic) {
    return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
  }

  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
    modifiers = modifiers || emptyObject; // warn prevent and passive modifier

    /* istanbul ignore if */

    if (warn && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
    } // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.


    if (modifiers.right) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
      } else if (name === 'click') {
        name = 'contextmenu';
        delete modifiers.right;
      }
    } else if (modifiers.middle) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
      } else if (name === 'click') {
        name = 'mouseup';
      }
    } // check capture modifier


    if (modifiers.capture) {
      delete modifiers.capture;
      name = prependModifierMarker('!', name, dynamic);
    }

    if (modifiers.once) {
      delete modifiers.once;
      name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */


    if (modifiers.passive) {
      delete modifiers.passive;
      name = prependModifierMarker('&', name, dynamic);
    }

    var events;

    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = rangeSetItem({
      value: value.trim(),
      dynamic: dynamic
    }, range);

    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */

    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getRawBindingAttr(el, name) {
    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);

      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  } // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.


  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;

    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;

      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }

    if (removeFromMap) {
      delete el.attrsMap[name];
    }

    return val;
  }

  function getAndRemoveAttrByRegex(el, name) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      var attr = list[i];

      if (name.test(attr.name)) {
        list.splice(i, 1);
        return attr;
      }
    }
  }

  function rangeSetItem(item, range) {
    if (range) {
      if (range.start != null) {
        item.start = range.start;
      }

      if (range.end != null) {
        item.end = range.end;
      }
    }

    return item;
  }
  /*  */

  /**
   * Cross-platform code generation for component v-model
   */


  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;
    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;

    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }

    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var assignment = genAssignmentCode(value, valueExpression);
    el.model = {
      value: "(" + value + ")",
      expression: JSON.stringify(value),
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }
  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */


  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);

    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }
  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */


  var len, str, chr, index$1, expressionPos, expressionEndPos;

  function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');

      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */

      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;

    while (!eof()) {
      chr = next();

      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }

      if (chr === 0x5B) {
        inBracket++;
      }

      if (chr === 0x5D) {
        inBracket--;
      }

      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;

    while (!eof()) {
      chr = next();

      if (chr === stringQuote) {
        break;
      }
    }
  }
  /*  */


  var warn$1; // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.

  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;
    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
    } // ensure runtime directive metadata


    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type

    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
      }
    }
    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
    var valueExpression = '$event.target.value';

    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }

    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);

    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);

    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }
  /*  */
  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.


  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    } // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4

    /* istanbul ignore if */


    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler$1(event, handler, capture) {
    var _target = target$1; // save current target element in closure

    return function onceHandler() {
      var res = handler.apply(null, arguments);

      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
  // implementation and does not fire microtasks in between event propagation, so
  // safe to exclude.


  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

  function add$1(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;

      handler = original._wrapper = function (e) {
        if ( // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget || // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
        e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document) {
          return original.apply(this, arguments);
        }
      };
    }

    target$1.addEventListener(name, handler, supportsPassive ? {
      capture: capture,
      passive: passive
    } : capture);
  }

  function remove$2(name, handler, capture, _target) {
    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }

    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };
  /*  */

  var svgContainer;

  function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }

    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }

    for (key in props) {
      cur = props[key]; // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)

      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }

        if (cur === oldProps[key]) {
          continue;
        } // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property


        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      } // skip the update if old and new VDOM state is the same.
      // the only exception is `value` where the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This also covers #4521 by skipping the unnecesarry `checked` update.


      if (key !== 'value' && cur === oldProps[key]) {
        continue;
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur; // avoid resetting cursor position when value is the same

        var strCur = isUndef(cur) ? '' : String(cur);

        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        // IE doesn't support innerHTML for SVG elements
        svgContainer = svgContainer || document.createElement('div');
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;

        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }

        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else {
        elm[key] = cur;
      }
    }
  } // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }

  function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true; // #6157
    // work around IE bug when accessing document.activeElement in an iframe

    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}

    return notInFocus && elm.value !== checkVal;
  }

  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime

    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }

      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }

    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };
  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  }); // merge static and dynamic style data on the same vnode

  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it

    return data.staticStyle ? extend(data.staticStyle, style) : style;
  } // normalize possible array / string values into Object


  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }

    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }

    return bindingStyle;
  }
  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */


  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;

      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;

        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;

    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }

    return res;
  }
  /*  */


  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;

  var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);

      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];
  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);

    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }

    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

    var oldStyle = oldStaticStyle || oldStyleBinding;
    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.

    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }

    for (name in newStyle) {
      cur = newStyle[name];

      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };
  /*  */

  var whitespaceRE = /\s+/;
  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */

  function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }
    /* istanbul ignore else */


    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";

      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }
  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */


  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }
    /* istanbul ignore else */


    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }

      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';

      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }

      cur = cur.trim();

      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }
  /*  */


  function resolveTransition(def$$1) {
    if (!def$$1) {
      return;
    }
    /* istanbul ignore else */


    if (typeof def$$1 === 'object') {
      var res = {};

      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }

      extend(res, def$$1);
      return res;
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });
  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation'; // Transition property/event sniffing

  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';

  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }

    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  } // binding to window is necessary to make hot reload work in IE in strict mode


  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
  /* istanbul ignore next */
  function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }

    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;

    if (!type) {
      return cb();
    }

    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;

    var end = function () {
      el.removeEventListener(event, onEnd);
      cb();
    };

    var onEnd = function (e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };

    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */

    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }

    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
  // in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
  // as a floor function) causing unexpected behaviors


  function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
  }
  /*  */


  function enter(vnode, toggleDisplay) {
    var el = vnode.elm; // call leave callback now

    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;

      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);

    if (isUndef(data)) {
      return;
    }
    /* istanbul ignore if */


    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration; // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.

    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;

    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
    var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

    if (explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);
    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }

      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }

        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }

      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];

        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }

        enterHook && enterHook(el, cb);
      });
    } // start enter transition


    beforeEnterHook && beforeEnterHook(el);

    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);

        if (!cb.cancelled) {
          addTransitionClass(el, toClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm; // call enter callback now

    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;

      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);

    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }
    /* istanbul ignore if */


    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);
    var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

    if (isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }

      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }

      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }

        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }

      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      } // record leaving element


      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }

      beforeLeave && beforeLeave(el);

      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);

          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);

            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }

      leave && leave(el, cb);

      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  } // only used in dev mode


  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }
  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */


  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }

    var invokerFns = fn.fns;

    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};
  var platformModules = [attrs, klass, events, domProps, style, transition];
  /*  */
  // the directive module should be applied last, after all
  // built-in modules have been applied.

  var modules = platformModules.concat(baseModules);
  var patch = createPatchFunction({
    nodeOps: nodeOps,
    modules: modules
  });
  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */

  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;

      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }

        el._vOptions = [].map.call(el.options, getValue$1);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;

        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.

          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */

          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },
    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.

        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */

    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;

    if (isMultiple && !Array.isArray(value)) {
      warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }

    var selected, option;

    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];

      if (isMultiple) {
        selected = looseIndexOf(value, getValue$1(option)) > -1;

        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue$1(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }

          return;
        }
      }
    }

    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue$1(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }

    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }
  /*  */
  // recursively search for possible transition defined inside the component root


  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },
    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;
      /* istanbul ignore if */

      if (!value === !oldValue) {
        return;
      }

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;

      if (transition$$1) {
        vnode.data.show = true;

        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },
    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };
  var platformDirectives = {
    model: directive,
    show: show
  };
  /*  */

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  }; // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered

  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;

    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options; // props

    for (var key in options.propsData) {
      data[key] = comp[key];
    } // events.
    // extract listeners and pass them directly to the transition methods


    var listeners = options._parentListeners;

    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }

    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var isNotTextNode = function (c) {
    return c.tag || isAsyncPlaceholder(c);
  };

  var isVShowDirective = function (d) {
    return d.name === 'show';
  };

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render: function render(h) {
      var this$1 = this;
      var children = this.$slots.default;

      if (!children) {
        return;
      } // filter out text nodes (possible whitespaces)


      children = children.filter(isNotTextNode);
      /* istanbul ignore if */

      if (!children.length) {
        return;
      } // warn multiple elements


      if (children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode; // warn invalid mode

      if (mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0]; // if this is a component root node and the component's
      // parent container node also has transition, skip.

      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      } // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive


      var child = getRealChild(rawChild);
      /* istanbul ignore if */

      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      } // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.


      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild); // mark v-show
      // so that the transition module can hand over the control to the directive

      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }

          var delayedLeave;

          var performLeave = function () {
            delayedLeave();
          };

          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }
  };
  /*  */

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);
  delete props.mode;
  var TransitionGroup = {
    props: props,
    beforeMount: function beforeMount() {
      var this$1 = this;
      var update = this._update;

      this._update = function (vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
        );

        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },
    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];

        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;
            (c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];

        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();

          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }

        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },
    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';

      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      } // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.


      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation); // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line

      this._reflow = document.body.offsetHeight;
      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (e && e.target !== el) {
              return;
            }

            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },
    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */


        if (this._hasMove) {
          return this._hasMove;
        } // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.


        var clone = el.cloneNode();

        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }

        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */


    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;

    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };
  /*  */
  // install platform specific utils

  Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents); // install platform patch function

  Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

  Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  }; // devtools global hook

  /* istanbul ignore next */


  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else {
          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
        }
      }

      if (config.productionTip !== false && typeof console !== 'undefined') {
        console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
      }
    }, 0);
  }
  /*  */


  var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

    if (!tagRE.test(text)) {
      return;
    }

    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;

    while (match = tagRE.exec(text)) {
      index = match.index; // push text token

      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      } // tag token


      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      rawTokens.push({
        '@binding': exp
      });
      lastIndex = index + match[0].length;
    }

    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }

    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    };
  }
  /*  */


  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');

    if (staticClass) {
      var res = parseText(staticClass, options.delimiters);

      if (res) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
      }
    }

    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }

    var classBinding = getBindingAttr(el, 'class', false
    /* getStatic */
    );

    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';

    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }

    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }

    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };
  /*  */

  function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');

    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);

        if (res) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false
    /* getStatic */
    );

    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';

    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }

    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }

    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };
  /*  */

  var decoder;
  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }
  };
  /*  */

  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
  // (and which close themselves)

  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
  /**
   * Not type-checking this file because it's mostly vendor code.
   */
  // Regular Expressions for parsing tags and attributes

  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};
  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
  };
  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

  var isIgnoreNewlineTag = makeMap('pre,textarea', true);

  var shouldIgnoreFirstNewline = function (tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;

    while (html) {
      last = html; // Make sure we're not in a plaintext content element like script/style

      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');

        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
              }

              advance(commentEnd + 3);
              continue;
            }
          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          } // Doctype:


          var doctypeMatch = html.match(doctype);

          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          } // End tag:


          var endTagMatch = html.match(endTag);

          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          } // Start tag:


          var startTagMatch = parseStartTag();

          if (startTagMatch) {
            handleStartTag(startTagMatch);

            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
              advance(1);
            }

            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;

        if (textEnd >= 0) {
          rest = html.slice(textEnd);

          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);

            if (next < 0) {
              break;
            }

            textEnd += next;
            rest = html.slice(textEnd);
          }

          text = html.substring(0, textEnd);
        }

        if (textEnd < 0) {
          text = html;
        }

        if (text) {
          advance(text.length);
        }

        if (options.chars && text) {
          options.chars(text, index - text.length, index);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;

          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }

          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }

          if (options.chars) {
            options.chars(text);
          }

          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);

        if (!stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
            start: index + html.length
          });
        }

        break;
      }
    } // Clean up any remaining tags


    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);

      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;

        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
          attr.start = index;
          advance(attr[0].length);
          attr.end = index;
          match.attrs.push(attr);
        }

        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }

        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;
      var l = match.attrs.length;
      var attrs = new Array(l);

      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };

        if (options.outputSourceRange) {
          attrs[i].start = args.start + args[0].match(/^\s*/).length;
          attrs[i].end = args.end;
        }
      }

      if (!unary) {
        stack.push({
          tag: tagName,
          lowerCasedTag: tagName.toLowerCase(),
          attrs: attrs,
          start: match.start,
          end: match.end
        });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;

      if (start == null) {
        start = index;
      }

      if (end == null) {
        end = index;
      } // Find the closest opened tag of the same type


      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();

        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (i > pos || !tagName && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
              start: stack[i].start
            });
          }

          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        } // Remove the open elements from the stack


        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }

        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }
  /*  */


  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  var dynamicArgRE = /^\[.*\]$/;
  var argRE = /:(.*)$/;
  var bindRE = /^:|^\.|^v-bind:/;
  var modifierRE = /\.[^.]+/g;
  var slotRE = /^v-slot(:|$)|^#/;
  var lineBreakRE = /[\r\n]/;
  var whitespaceRE$1 = /\s+/g;
  var invalidAttributeRE = /[\s"'<>\/=]/;
  var decodeHTMLCached = cached(he.decode);
  var emptySlotScopeToken = "_empty_"; // configurable state

  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;
  var maybeComponent;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      rawAttrsMap: {},
      parent: parent,
      children: []
    };
  }
  /**
   * Convert HTML string to AST.
   */


  function parse(template, options) {
    warn$2 = options.warn || baseWarn;
    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;

    maybeComponent = function (el) {
      return !!el.component || !isReservedTag(el.tag);
    };

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
    delimiters = options.delimiters;
    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg, range) {
      if (!warned) {
        warned = true;
        warn$2(msg, range);
      }
    }

    function closeElement(element) {
      trimEndingWhitespace(element);

      if (!inVPre && !element.processed) {
        element = processElement(element, options);
      } // tree management


      if (!stack.length && element !== root) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          {
            checkRootConstraints(element);
          }
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
            start: element.start
          });
        }
      }

      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else {
          if (element.slotScope) {
            // scoped slot
            // keep it in the children list so that v-else(-if) conditions can
            // find it as the prev node.
            var name = element.slotTarget || '"default"';
            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          }

          currentParent.children.push(element);
          element.parent = currentParent;
        }
      } // final children cleanup
      // filter out scoped slots


      element.children = element.children.filter(function (c) {
        return !c.slotScope;
      }); // remove trailing whitespace node again

      trimEndingWhitespace(element); // check pre state

      if (element.pre) {
        inVPre = false;
      }

      if (platformIsPreTag(element.tag)) {
        inPre = false;
      } // apply post-transforms


      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    function trimEndingWhitespace(el) {
      // remove trailing whitespace node
      if (!inPre) {
        var lastNode;

        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
          el.children.pop();
        }
      }
    }

    function checkRootConstraints(el) {
      if (el.tag === 'slot' || el.tag === 'template') {
        warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
          start: el.start
        });
      }

      if (el.attrsMap.hasOwnProperty('v-for')) {
        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      outputSourceRange: options.outputSourceRange,
      start: function start(tag, attrs, unary, start$1) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

        /* istanbul ignore if */

        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);

        if (ns) {
          element.ns = ns;
        }

        {
          if (options.outputSourceRange) {
            element.start = start$1;
            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
              cumulated[attr.name] = attr;
              return cumulated;
            }, {});
          }

          attrs.forEach(function (attr) {
            if (invalidAttributeRE.test(attr.name)) {
              warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              });
            }
          });
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
            start: element.start
          });
        } // apply pre-transforms


        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);

          if (element.pre) {
            inVPre = true;
          }
        }

        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }

        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
        }

        if (!root) {
          root = element;
          {
            checkRootConstraints(root);
          }
        }

        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },
      end: function end(tag, start, end$1) {
        var element = stack[stack.length - 1]; // pop stack

        stack.length -= 1;
        currentParent = stack[stack.length - 1];

        if (options.outputSourceRange) {
          element.end = end$1;
        }

        closeElement(element);
      },
      chars: function chars(text, start, end) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.', {
                start: start
              });
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.", {
                start: start
              });
            }
          }
          return;
        } // IE textarea placeholder bug

        /* istanbul ignore if */


        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }

        var children = currentParent.children;

        if (inPre || text.trim()) {
          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
        } else if (!children.length) {
          // remove the whitespace-only node right after an opening tag
          text = '';
        } else if (whitespaceOption) {
          if (whitespaceOption === 'condense') {
            // in condense mode, remove the whitespace node if it contains
            // line break, otherwise condense to a single space
            text = lineBreakRE.test(text) ? '' : ' ';
          } else {
            text = ' ';
          }
        } else {
          text = preserveWhitespace ? ' ' : '';
        }

        if (text) {
          if (whitespaceOption === 'condense') {
            // condense consecutive whitespaces into single space
            text = text.replace(whitespaceRE$1, ' ');
          }

          var res;
          var child;

          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            child = {
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            };
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            child = {
              type: 3,
              text: text
            };
          }

          if (child) {
            if (options.outputSourceRange) {
              child.start = start;
              child.end = end;
            }

            children.push(child);
          }
        }
      },
      comment: function comment(text, start, end) {
        // adding anyting as a sibling to the root node is forbidden
        // comments should still be allowed, but ignored
        if (currentParent) {
          var child = {
            type: 3,
            text: text,
            isComment: true
          };

          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          currentParent.children.push(child);
        }
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var list = el.attrsList;
    var len = list.length;

    if (len) {
      var attrs = el.attrs = new Array(len);

      for (var i = 0; i < len; i++) {
        attrs[i] = {
          name: list[i].name,
          value: JSON.stringify(list[i].value)
        };

        if (list[i].start != null) {
          attrs[i].start = list[i].start;
          attrs[i].end = list[i].end;
        }
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element); // determine whether this is a plain element after
    // removing structural attributes

    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);

    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }

    processAttrs(element);
    return element;
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');

    if (exp) {
      {
        if (el.tag === 'template') {
          warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
        }

        if (el.for) {
          var iterator = el.iterator2 || el.iterator1;
          var parent = el.parent;

          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
            warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
            /* tip */
            );
          }
        }
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');

    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;

    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var res = parseFor(exp);

      if (res) {
        extend(el, res);
      } else {
        warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
      }
    }
  }

  function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);

    if (!inMatch) {
      return;
    }

    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);

    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '').trim();
      res.iterator1 = iteratorMatch[1].trim();

      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }

    return res;
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');

    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }

      var elseif = getAndRemoveAttr(el, 'v-else-if');

      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);

    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
    }
  }

  function findPrevElement(children) {
    var i = children.length;

    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if (children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
        }

        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }

    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');

    if (once$$1 != null) {
      el.once = true;
    }
  } // handle content being passed to a component as slot,
  // e.g. <template slot="xxx">, <div slot-scope="xxx">


  function processSlotContent(el) {
    var slotScope;

    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */

      if (slotScope) {
        warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
      }

      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
      /* istanbul ignore if */
      if (el.attrsMap['v-for']) {
        warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
      }

      el.slotScope = slotScope;
    } // slot="xxx"


    var slotTarget = getBindingAttr(el, 'slot');

    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.

      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
      }
    } // 2.6 v-slot syntax


    {
      if (el.tag === 'template') {
        // v-slot on <template>
        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

        if (slotBinding) {
          {
            if (el.slotTarget || el.slotScope) {
              warn$2("Unexpected mixed usage of different slot syntaxes.", el);
            }

            if (el.parent && !maybeComponent(el.parent)) {
              warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
            }
          }
          var ref = getSlotName(slotBinding);
          var name = ref.name;
          var dynamic = ref.dynamic;
          el.slotTarget = name;
          el.slotTargetDynamic = dynamic;
          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
        }
      } else {
        // v-slot on component, denotes default slot
        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

        if (slotBinding$1) {
          {
            if (!maybeComponent(el)) {
              warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
            }

            if (el.slotScope || el.slotTarget) {
              warn$2("Unexpected mixed usage of different slot syntaxes.", el);
            }

            if (el.scopedSlots) {
              warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
            }
          } // add the component's children to its default slot

          var slots = el.scopedSlots || (el.scopedSlots = {});
          var ref$1 = getSlotName(slotBinding$1);
          var name$1 = ref$1.name;
          var dynamic$1 = ref$1.dynamic;
          var slotContainer = slots[name$1] = createASTElement('template', [], el);
          slotContainer.slotTarget = name$1;
          slotContainer.slotTargetDynamic = dynamic$1;
          slotContainer.children = el.children.filter(function (c) {
            if (!c.slotScope) {
              c.parent = slotContainer;
              return true;
            }
          });
          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

          el.children = []; // mark el non-plain so data gets generated

          el.plain = false;
        }
      }
    }
  }

  function getSlotName(binding) {
    var name = binding.name.replace(slotRE, '');

    if (!name) {
      if (binding.name[0] !== '#') {
        name = 'default';
      } else {
        warn$2("v-slot shorthand syntax requires a slot name.", binding);
      }
    }

    return dynamicArgRE.test(name) // dynamic [name]
    ? {
      name: name.slice(1, -1),
      dynamic: true // static name

    } : {
      name: "\"" + name + "\"",
      dynamic: false
    };
  } // handle <slot/> outlets


  function processSlotOutlet(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');

      if (el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
      }
    }
  }

  function processComponent(el) {
    var binding;

    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }

    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;

      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true; // modifiers

        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

        if (modifiers) {
          name = name.replace(modifierRE, '');
        }

        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isDynamic = dynamicArgRE.test(name);

          if (isDynamic) {
            name = name.slice(1, -1);
          }

          if (value.trim().length === 0) {
            warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
          }

          if (modifiers) {
            if (modifiers.prop && !isDynamic) {
              name = camelize(name);

              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }

            if (modifiers.camel && !isDynamic) {
              name = camelize(name);
            }

            if (modifiers.sync) {
              syncGen = genAssignmentCode(value, "$event");

              if (!isDynamic) {
                addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

                if (hyphenate(name) !== camelize(name)) {
                  addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
                }
              } else {
                // handler w/ dynamic event name
                addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
                );
              }
            }
          }

          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value, list[i], isDynamic);
          } else {
            addAttr(el, name, value, list[i], isDynamic);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          isDynamic = dynamicArgRE.test(name);

          if (isDynamic) {
            name = name.slice(1, -1);
          }

          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
        } else {
          // normal directives
          name = name.replace(dirRE, ''); // parse arg

          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          isDynamic = false;

          if (arg) {
            name = name.slice(0, -(arg.length + 1));

            if (dynamicArgRE.test(arg)) {
              arg = arg.slice(1, -1);
              isDynamic = true;
            }
          }

          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

          if (name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);

          if (res) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
          }
        }
        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation

        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true', list[i]);
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;

    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }

      parent = parent.parent;
    }

    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);

    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};

    for (var i = 0, l = attrs.length; i < l; i++) {
      if (map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
      }

      map[attrs[i].name] = attrs[i].value;
    }

    return map;
  } // for script (e.g. type="x/template") or style, do not decode content


  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;
  /* istanbul ignore next */

  function guardIESVGBug(attrs) {
    var res = [];

    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];

      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }

    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;

    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
      }

      _el = _el.parent;
    }
  }
  /*  */


  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;

      if (!map['v-model']) {
        return;
      }

      var typeBinding;

      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }

      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + map['v-bind'] + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

        var branch0 = cloneASTElement(el); // process for on the main node

        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed

        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        }); // 2. add radio else-if condition

        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        }); // 3. other

        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  var model$1 = {
    preTransformNode: preTransformNode
  };
  var modules$1 = [klass$1, style$1, model$1];
  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
    }
  }
  /*  */


  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };
  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };
  /*  */

  var isStaticKey;
  var isPlatformReservedTag;
  var genStaticKeysCached = cached(genStaticKeys$1);
  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */

  function optimize(root, options) {
    if (!root) {
      return;
    }

    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

    markStatic$1(root); // second pass: mark static roots.

    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);

    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }

      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);

        if (!child.static) {
          node.static = false;
        }
      }

      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);

          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      } // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.


      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }

      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }

      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }

    if (node.type === 3) {
      // text
      return true;
    }

    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;

      if (node.tag !== 'template') {
        return false;
      }

      if (node.for) {
        return true;
      }
    }

    return false;
  }
  /*  */


  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var fnInvokeRE = /\([^)]*?\);*$/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  }; // KeyboardEvent.key aliases

  var keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    'delete': ['Backspace', 'Delete', 'Del']
  }; // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once

  var genGuard = function (condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative) {
    var prefix = isNative ? 'nativeOn:' : 'on:';
    var staticHandlers = "";
    var dynamicHandlers = "";

    for (var name in events) {
      var handlerCode = genHandler(events[name]);

      if (events[name] && events[name].dynamic) {
        dynamicHandlers += name + "," + handlerCode + ",";
      } else {
        staticHandlers += "\"" + name + "\":" + handlerCode + ",";
      }
    }

    staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

    if (dynamicHandlers) {
      return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
    } else {
      return prefix + staticHandlers;
    }
  }

  function genHandler(handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);
    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value;
      }

      return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];

      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key]; // left/right

          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }

      if (keys.length) {
        code += genKeyFilter(keys);
      } // Make sure modifiers like prevent and stop get executed after key filtering


      if (genModifierCode) {
        code += genModifierCode;
      }

      var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return (// make sure the key filters only apply to KeyboardEvents
      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
      // key events that do not have keyCode property...
      "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
    );
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);

    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }

    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
  }
  /*  */


  function on(el, dir) {
    if (dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }

    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }
  /*  */


  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }
  /*  */


  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop$1
  };
  /*  */

  var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;

    this.maybeComponent = function (el) {
      return !!el.component || !isReservedTag(el.tag);
    };

    this.onceId = 0;
    this.staticRenderFns = [];
    this.pre = false;
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.parent) {
      el.pre = el.pre || el.parent.pre;
    }

    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;

      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data;

        if (!el.plain || el.pre && state.maybeComponent(el)) {
          data = genData$2(el, state);
        }

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      } // module transforms


      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }

      return code;
    }
  } // hoist static sub-trees out


  function genStatic(el, state) {
    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.

    var originalPreState = state.pre;

    if (el.pre) {
      state.pre = el.pre;
    }

    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    state.pre = originalPreState;
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  } // v-once


  function genOnce(el, state) {
    el.onceProcessed = true;

    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;

      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }

        parent = parent.parent;
      }

      if (!key) {
        state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
        return genElement(el, state);
      }

      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion

    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();

    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    } // v-if with v-once should generate code like (a)?_m(0):_m(1)


    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
      /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion

    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{'; // directives first.
    // directives may mutate the el's other properties before they are generated.

    var dirs = genDirectives(el, state);

    if (dirs) {
      data += dirs + ',';
    } // key


    if (el.key) {
      data += "key:" + el.key + ",";
    } // ref


    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }

    if (el.refInFor) {
      data += "refInFor:true,";
    } // pre


    if (el.pre) {
      data += "pre:true,";
    } // record original tag name for components using "is" attribute


    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    } // module data generation functions


    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    } // attributes


    if (el.attrs) {
      data += "attrs:" + genProps(el.attrs) + ",";
    } // DOM props


    if (el.props) {
      data += "domProps:" + genProps(el.props) + ",";
    } // event handlers


    if (el.events) {
      data += genHandlers(el.events, false) + ",";
    }

    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true) + ",";
    } // slot target
    // only for non-scoped slots


    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    } // scoped slots


    if (el.scopedSlots) {
      data += genScopedSlots(el, el.scopedSlots, state) + ",";
    } // component v-model


    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    } // inline-template


    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);

      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }

    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.

    if (el.dynamicAttrs) {
      data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
    } // v-bind data wrap


    if (el.wrapData) {
      data = el.wrapData(data);
    } // v-on data wrap


    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }

    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;

    if (!dirs) {
      return;
    }

    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;

    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];

      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }

      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }

    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];

    if (el.children.length !== 1 || ast.type !== 1) {
      state.warn('Inline-template components must have exactly one child element.', {
        start: el.start
      });
    }

    if (ast && ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(el, slots, state) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    var needsForceUpdate = Object.keys(slots).some(function (key) {
      var slot = slots[key];
      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
      ;
    }); // OR when it is inside another scoped slot (the reactivity is disconnected)
    // #9438

    if (!needsForceUpdate) {
      var parent = el.parent;

      while (parent) {
        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
          needsForceUpdate = true;
          break;
        }

        parent = parent.parent;
      }
    }

    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(slots[key], state);
    }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
  }

  function containsSlotChild(el) {
    if (el.type === 1) {
      if (el.tag === 'slot') {
        return true;
      }

      return el.children.some(containsSlotChild);
    }

    return false;
  }

  function genScopedSlot(el, state) {
    var isLegacySyntax = el.attrsMap['slot-scope'];

    if (el.if && !el.ifProcessed && !isLegacySyntax) {
      return genIf(el, state, genScopedSlot, "null");
    }

    if (el.for && !el.forProcessed) {
      return genFor(el, state, genScopedSlot);
    }

    var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
    var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

    var reverseProxy = slotScope ? "" : ",proxy:true";
    return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;

    if (children.length) {
      var el$1 = children[0]; // optimize single v-for

      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
        return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
      }

      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
    }
  } // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed


  function getNormalizationType(children, maybeComponent) {
    var res = 0;

    for (var i = 0; i < children.length; i++) {
      var el = children[i];

      if (el.type !== 1) {
        continue;
      }

      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }

      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }

    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    } else if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
      return {
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      };
    })) : null;
    var bind$$1 = el.attrsMap['v-bind'];

    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }

    if (attrs) {
      res += "," + attrs;
    }

    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }

    return res + ')';
  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement


  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var staticProps = "";
    var dynamicProps = "";

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var value = transformSpecialNewlines(prop.value);

      if (prop.dynamic) {
        dynamicProps += prop.name + "," + value + ",";
      } else {
        staticProps += "\"" + prop.name + "\":" + value + ",";
      }
    }

    staticProps = "{" + staticProps.slice(0, -1) + "}";

    if (dynamicProps) {
      return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
    } else {
      return staticProps;
    }
  } // #3895, #4268


  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }
  /*  */
  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed


  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

  function detectErrors(ast, warn) {
    if (ast) {
      checkNode(ast, warn);
    }
  }

  function checkNode(node, warn) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];

          if (value) {
            var range = node.rawAttrsMap[name];

            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", warn, range);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", warn, range);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", warn, range);
            }
          }
        }
      }

      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], warn);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, warn, node);
    }
  }

  function checkEvent(exp, text, warn, range) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);

    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
    }

    checkExpression(exp, text, warn, range);
  }

  function checkFor(node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
  }

  function checkIdentifier(ident, type, text, warn, range) {
    if (typeof ident === 'string') {
      try {
        new Function("var " + ident + "=_");
      } catch (e) {
        warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
      }
    }
  }

  function checkExpression(exp, text, warn, range) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

      if (keywordMatch) {
        warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
      } else {
        warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
      }
    }
  }
  /*  */


  var range = 2;

  function generateCodeFrame(source, start, end) {
    if (start === void 0) start = 0;
    if (end === void 0) end = source.length;
    var lines = source.split(/\r?\n/);
    var count = 0;
    var res = [];

    for (var i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;

      if (count >= start) {
        for (var j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length) {
            continue;
          }

          res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
          var lineLength = lines[j].length;

          if (j === i) {
            // push underline
            var pad = start - (count - lineLength) + 1;
            var length = end > count ? lineLength - pad : end - start;
            res.push("   |  " + repeat(" ", pad) + repeat("^", length));
          } else if (j > i) {
            if (end > count) {
              var length$1 = Math.min(end - count, lineLength);
              res.push("   |  " + repeat("^", length$1));
            }

            count += lineLength + 1;
          }
        }

        break;
      }
    }

    return res.join('\n');
  }

  function repeat(str, n) {
    var result = '';

    while (true) {
      // eslint-disable-line
      if (n & 1) {
        result += str;
      }

      n >>>= 1;

      if (n <= 0) {
        break;
      }

      str += str;
    }

    return result;
  }
  /*  */


  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({
        err: err,
        code: code
      });
      return noop$1;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);
    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;
      /* istanbul ignore if */

      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      } // check cache

      var key = options.delimiters ? String(options.delimiters) + template : template;

      if (cache[key]) {
        return cache[key];
      } // compile


      var compiled = compile(template, options); // check compilation errors/tips

      {
        if (compiled.errors && compiled.errors.length) {
          if (options.outputSourceRange) {
            compiled.errors.forEach(function (e) {
              warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
            });
          } else {
            warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
              return "- " + e;
            }).join('\n') + '\n', vm);
          }
        }

        if (compiled.tips && compiled.tips.length) {
          if (options.outputSourceRange) {
            compiled.tips.forEach(function (e) {
              return tip(e.msg, vm);
            });
          } else {
            compiled.tips.forEach(function (msg) {
              return tip(msg, vm);
            });
          }
        }
      } // turn code into functions

      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      }); // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use

      /* istanbul ignore if */

      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;
            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }
      return cache[key] = res;
    };
  }
  /*  */


  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];

        var warn = function (msg, range, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          if (options.outputSourceRange) {
            // $flow-disable-line
            var leadingSpaceLength = template.match(/^\s*/)[0].length;

            warn = function (msg, range, tip) {
              var data = {
                msg: msg
              };

              if (range) {
                if (range.start != null) {
                  data.start = range.start + leadingSpaceLength;
                }

                if (range.end != null) {
                  data.end = range.end + leadingSpaceLength;
                }
              }

              (tip ? tips : errors).push(data);
            };
          } // merge custom modules


          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          } // merge custom directives


          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
          } // copy other options


          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        finalOptions.warn = warn;
        var compiled = baseCompile(template.trim(), finalOptions);
        {
          detectErrors(compiled.ast, warn);
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }
  /*  */
  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.


  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);

    if (options.optimize !== false) {
      optimize(ast, options);
    }

    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });
  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;
  /*  */
  // check whether current browser encodes a char inside attribute values

  var div;

  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  } // #3663: IE encodes newlines inside attribute values while other browsers don't


  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });
  var mount = Vue.prototype.$mount;

  Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);
    /* istanbul ignore if */

    if (el === document.body || el === document.documentElement) {
      warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options; // resolve template/el and convert to render function

    if (!options.render) {
      var template = options.template;

      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */

            if (!template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }

      if (template) {
        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          outputSourceRange: "development" !== 'production',
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        /* istanbul ignore if */

        if (config.performance && mark) {
          mark('compile end');
          measure("vue " + this._name + " compile", 'compile', 'compile end');
        }
      }
    }

    return mount.call(this, el, hydrating);
  };
  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */


  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue.compile = compileToFunctions;

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script = {
    props: ['options', 'value'],
    data: function data() {
      return {
        selected: null
      };
    },
    mounted: function mounted() {
      this.selected = this.value;
    },
    watch: {
      value: function value(newValue) {
        this.selected = newValue;
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent;

  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

  function createInjector(context) {
    return function (id, style) {
      return addStyle(id, style);
    };
  }

  var HEAD = document.head || document.getElementsByTagName('head')[0];
  var styles = {};

  function addStyle(id, css) {
    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: new Set(),
      styles: []
    });

    if (!style.ids.has(id)) {
      style.ids.add(id);
      var code = css.source;

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (!style.element) {
        style.element = document.createElement('style');
        style.element.type = 'text/css';

        if (css.media) {
          style.element.setAttribute('media', css.media);
        }

        HEAD.appendChild(style.element);
      }

      if ('styleSheet' in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
      } else {
        var index = style.ids.size - 1;
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;

        if (nodes[index]) {
          style.element.removeChild(nodes[index]);
        }

        if (nodes.length) {
          style.element.insertBefore(textNode, nodes[index]);
        } else {
          style.element.appendChild(textNode);
        }
      }
    }
  }

  var browser = createInjector;

  /* script */
  var __vue_script__ = script;

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c(
        "select",
        {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.selected,
              expression: "selected"
            }
          ],
          staticClass: "select",
          on: {
            input: function(event) {
              _vm.$emit("input", event.target.value);
            },
            change: function($event) {
              var $$selectedVal = Array.prototype.filter
                .call($event.target.options, function(o) {
                  return o.selected
                })
                .map(function(o) {
                  var val = "_value" in o ? o._value : o.value;
                  return val
                });
              _vm.selected = $event.target.multiple
                ? $$selectedVal
                : $$selectedVal[0];
            }
          }
        },
        _vm._l(_vm.options, function(option) {
          return _c(
            "option",
            { key: option.value, domProps: { value: option.value } },
            [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
          )
        }),
        0
      )
    ])
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    var __vue_inject_styles__ = function (inject) {
      if (!inject) { return }
      inject("data-v-0fefdf17_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__ = undefined;
    /* module identifier */
    var __vue_module_identifier__ = undefined;
    /* functional template */
    var __vue_is_functional_template__ = false;
    /* style inject SSR */
    

    
    var SelectComponent = normalizeComponent_1(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      browser,
      undefined
    );

  var SelectData = [{
    text: 'All Boroughs',
    value: 'all'
  }, {
    text: 'Brooklyn',
    value: 'brooklyn'
  }, {
    text: 'Queens',
    value: 'queens'
  }, {
    text: 'Manhattan',
    value: 'manhattan'
  }, {
    text: 'Staten Island',
    value: 'staten island'
  }, {
    text: 'The Bronx',
    value: 'bronx'
  }];

  var Select = function Select(settings, data) {
    if (settings === void 0) settings = {};
    if (data === void 0) data = {};
    this.data = data;
    this.settings = settings;
    this.init();
  };
  /**
   * Initializes the module
   */


  Select.prototype.init = function init() {
    Vue.component('nyco-select', SelectComponent);
    new Vue({
      el: '[data-js="app"]',
      delimiters: ['v{', '}'],
      data: function data() {
        return {
          options: Select.data,
          selected: 'all'
        };
      },
      methods: {}
    });
  };
  /**
   * Logs constants to the debugger
   * @param{object} param - our constants
   */


  Select.prototype._constants = function _constants(param) {
    console.dir(param);
  };

  Select.data = SelectData;

  function dataHandler(newData, oldData) {
    if (oldData) {
      var chart = this.$data._chart;
      var newDatasetLabels = newData.datasets.map(function (dataset) {
        return dataset.label;
      });
      var oldDatasetLabels = oldData.datasets.map(function (dataset) {
        return dataset.label;
      });
      var oldLabels = JSON.stringify(oldDatasetLabels);
      var newLabels = JSON.stringify(newDatasetLabels);

      if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
        newData.datasets.forEach(function (dataset, i) {
          var oldDatasetKeys = Object.keys(oldData.datasets[i]);
          var newDatasetKeys = Object.keys(dataset);
          var deletionKeys = oldDatasetKeys.filter(function (key) {
            return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
          });
          deletionKeys.forEach(function (deletionKey) {
            delete chart.data.datasets[i][deletionKey];
          });

          for (var attribute in dataset) {
            if (dataset.hasOwnProperty(attribute)) {
              chart.data.datasets[i][attribute] = dataset[attribute];
            }
          }
        });

        if (newData.hasOwnProperty('labels')) {
          chart.data.labels = newData.labels;
          this.$emit('labels:update');
        }

        if (newData.hasOwnProperty('xLabels')) {
          chart.data.xLabels = newData.xLabels;
          this.$emit('xlabels:update');
        }

        if (newData.hasOwnProperty('yLabels')) {
          chart.data.yLabels = newData.yLabels;
          this.$emit('ylabels:update');
        }

        chart.update();
        this.$emit('chart:update');
      } else {
        if (chart) {
          chart.destroy();
          this.$emit('chart:destroy');
        }

        this.renderChart(this.chartData, this.options);
        this.$emit('chart:render');
      }
    } else {
      if (this.$data._chart) {
        this.$data._chart.destroy();

        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  }

  var reactiveData = {
    data: function data() {
      return {
        chartData: null
      };
    },
    watch: {
      'chartData': dataHandler
    }
  };
  var reactiveProp = {
    props: {
      chartData: {
        required: true
      }
    },
    watch: {
      'chartData': dataHandler
    }
  };
  var mixins = {
    reactiveData: reactiveData,
    reactiveProp: reactiveProp
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var moment = createCommonjsModule(function (module, exports) {

    (function (global, factory) {
      module.exports = factory();
    })(commonjsGlobal, function () {

      var hookCallback;

      function hooks() {
        return hookCallback.apply(null, arguments);
      } // This is done to register the method called with moment()
      // without creating circular dependencies.


      function setHookCallback(callback) {
        hookCallback = callback;
      }

      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }

      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;

          for (k in obj) {
            if (obj.hasOwnProperty(k)) {
              return false;
            }
          }

          return true;
        }
      }

      function isUndefined(input) {
        return input === void 0;
      }

      function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
      }

      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
        var res = [],
            i;

        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }

        return res;
      }

      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }

        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
        }

        return a;
      }

      function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }

      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }

        return m._pf;
      }

      var some;

      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function (fun) {
          var t = Object(this);
          var len = t.length >>> 0;

          for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }

          return false;
        };
      }

      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
          });
          var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }

          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }

        return m._isValid;
      }

      function createInvalid(flags) {
        var m = createUTC(NaN);

        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }

        return m;
      } // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.


      var momentProperties = hooks.momentProperties = [];

      function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }

        if (!isUndefined(from._i)) {
          to._i = from._i;
        }

        if (!isUndefined(from._f)) {
          to._f = from._f;
        }

        if (!isUndefined(from._l)) {
          to._l = from._l;
        }

        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }

        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }

        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }

        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }

        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }

        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];

            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }

        return to;
      }

      var updateInProgress = false; // Moment prototype object

      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);

        if (!this.isValid()) {
          this._d = new Date(NaN);
        } // Prevent infinite loop in case updateOffset creates new moment
        // objects.


        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }

      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }

      function absFloor(number) {
        if (number < 0) {
          // -0 -> 0
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }

      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }

        return value;
      } // compare two arrays, return the number of differences


      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;

        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }

        return diffs + lengthDiff;
      }

      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
          console.warn('Deprecation warning: ' + msg);
        }
      }

      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
          var arguments$1 = arguments;

          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }

          if (firstTime) {
            var args = [];
            var arg;

            for (var i = 0; i < arguments.length; i++) {
              arg = '';

              if (typeof arguments$1[i] === 'object') {
                arg += '\n[' + i + '] ';

                for (var key in arguments[0]) {
                  arg += key + ': ' + arguments$1[0][key] + ', ';
                }

                arg = arg.slice(0, -2); // Remove trailing comma and space
              } else {
                arg = arguments$1[i];
              }

              args.push(arg);
            }

            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
            firstTime = false;
          }

          return fn.apply(this, arguments);
        }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }

        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function set(config) {
        var prop, i;

        for (i in config) {
          prop = config[i];

          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this['_' + i] = prop;
          }
        }

        this._config = config; // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.

        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
      }

      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;

        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }

        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
          }
        }

        return res;
      }

      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }

      var keys;

      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function (obj) {
          var i,
              res = [];

          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }

          return res;
        };
      }

      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
      };

      function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
          return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
          return val.slice(1);
        });
        return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
        return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
        return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
      };

      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);

            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }

        return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
        var units = [];

        for (var u in unitsObj) {
          units.push({
            unit: u,
            priority: priorities[u]
          });
        }

        units.sort(function (a, b) {
          return a.priority - b.priority;
        });
        return units;
      }

      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
      var formatFunctions = {};
      var formatTokenFunctions = {}; // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }

      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;

        if (typeof callback === 'string') {
          func = function () {
            return this[callback]();
          };
        }

        if (token) {
          formatTokenFunctions[token] = func;
        }

        if (padded) {
          formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }

        if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }

      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
        }

        return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }

        return function (mom) {
          var output = '',
              i;

          for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
          }

          return output;
        };
      } // format date using native date object


      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;

        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }

        return format;
      }

      var match1 = /\d/; //       0 - 9

      var match2 = /\d\d/; //      00 - 99

      var match3 = /\d{3}/; //     000 - 999

      var match4 = /\d{4}/; //    0000 - 9999

      var match6 = /[+-]?\d{6}/; // -999999 - 999999

      var match1to2 = /\d\d?/; //       0 - 99

      var match3to4 = /\d\d\d\d?/; //     999 - 9999

      var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

      var match1to3 = /\d{1,3}/; //       0 - 999

      var match1to4 = /\d{1,4}/; //       0 - 9999

      var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

      var matchUnsigned = /\d+/; //       0 - inf

      var matchSigned = /[+-]?\d+/; //    -inf - inf

      var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months

      var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
      var regexes = {};

      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }

      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
      } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


      function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }

      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
        var i,
            func = callback;

        if (typeof token === 'string') {
          token = [token];
        }

        if (isNumber(callback)) {
          func = function (input, array) {
            array[callback] = toInt(input);
          };
        }

        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
        }
      }

      function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }

      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8; // FORMATTING

      addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
      });
      addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
      });
      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

      addUnitAlias('year', 'y'); // PRIORITIES

      addUnitPriority('year', 1); // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);
      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
      }); // HELPERS

      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      } // HOOKS


      hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      }; // MOMENTS


      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
        return isLeapYear(this.year());
      }

      function makeGetSet(unit, keepTime) {
        return function (value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }

      function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
        }
      } // MOMENTS


      function stringGet(units) {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units]();
        }

        return this;
      }

      function stringSet(units, value) {
        if (typeof units === 'object') {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units);

          for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);

          if (isFunction(this[units])) {
            return this[units](value);
          }
        }

        return this;
      }

      function mod(n, x) {
        return (n % x + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function (o) {
          // I know
          var i;

          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }

          return -1;
        };
      }

      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }

        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      } // FORMATTING


      addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
      });
      addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
      });
      addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
      }); // ALIASES

      addUnitAlias('month', 'M'); // PRIORITY

      addUnitPriority('month', 8); // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
      });
      addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      }); // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

      function localeMonths(m, format) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months['standalone'];
        }

        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

      function localeMonthsShort(m, format) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }

        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();

        if (!this._monthsParse) {
          // this is not used
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];

          for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
        }

        if (strict) {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }

      function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        } // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse


        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);

          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }

          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          } // test the regex


          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      } // MOMENTS


      function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
          // No op
          return mom;
        }

        if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

            if (!isNumber(value)) {
              return mom;
            }
          }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

        return mom;
      }

      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, 'Month');
        }
      }

      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;

      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }

          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }

          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }

      var defaultMonthsRegex = matchWord;

      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }

          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
          }

          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }

      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;

        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          shortPieces.push(this.monthsShort(mom, ''));
          longPieces.push(this.months(mom, ''));
          mixedPieces.push(this.months(mom, ''));
          mixedPieces.push(this.monthsShort(mom, ''));
        } // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.


        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }

        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date; // the date constructor remaps years 0-99 to 1900-1999

        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          date = new Date(y + 400, m, d, h, M, s, ms);

          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
      }

      function createUTCDate(y) {
        var date; // the Date.UTC function remaps years 0-99 to 1900-1999

        if (y < 100 && y >= 0) {
          var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));

          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
      } // start-of-first-week - start-of-year


      function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }

        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }

      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }

        return {
          week: resWeek,
          year: resYear
        };
      }

      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      } // FORMATTING


      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W'); // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5); // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      }); // HELPERS
      // LOCALES

      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 6th is the first week of the year.

      };

      function localeFirstDayOfWeek() {
        return this._week.dow;
      }

      function localeFirstDayOfYear() {
        return this._week.doy;
      } // MOMENTS


      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
      } // FORMATTING


      addFormatToken('d', 0, 'do', 'day');
      addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
      });
      addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
      });
      addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
      });
      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E'); // PRIORITY

      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11); // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
      });
      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
      }); // HELPERS

      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input;
        }

        if (!isNaN(input)) {
          return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);

        if (typeof input === 'number') {
          return input;
        }

        return null;
      }

      function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
          return locale.weekdaysParse(input) % 7 || 7;
        }

        return isNaN(input) ? null : input;
      } // LOCALES


      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

      function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();

        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];

          for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
        }

        if (strict) {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._shortWeekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._weekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._weekdaysParse, llc);

            if (ii !== -1) {
              return ii;
            }

            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);

          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
          }

          if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          } // test the regex


          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      } // MOMENTS


      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }

        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
        } else {
          return day;
        }
      }

      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }

        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        } // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.


        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }

      var defaultWeekdaysRegex = matchWord;

      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }

          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }

          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }

      var defaultWeekdaysShortRegex = matchWord;

      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }

          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }

          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }

      var defaultWeekdaysMinRegex = matchWord;

      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }

          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }

          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }

      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;

        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);
          minp = this.weekdaysMin(mom, '');
          shortp = this.weekdaysShort(mom, '');
          longp = this.weekdays(mom, '');
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.


        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        for (i = 0; i < 7; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      } // FORMATTING


      function hFormat() {
        return this.hours() % 12 || 12;
      }

      function kFormat() {
        return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);
      addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });

      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }

      meridiem('a', true);
      meridiem('A', false); // ALIASES

      addUnitAlias('hour', 'h'); // PRIORITY

      addUnitPriority('hour', 13); // PARSING

      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);
      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);
      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      }); // LOCALES

      function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM';
        } else {
          return isLower ? 'am' : 'AM';
        }
      } // MOMENTS
      // Setting the hour should keep the time, because the user explicitly
      // specified which hour they want. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.


      var getSetHour = makeGetSet('Hours', true);
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      }; // internal storage for locale config files

      var locales = {};
      var localeFamilies = {};
      var globalLocale;

      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
      } // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


      function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;

          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));

            if (locale) {
              return locale;
            }

            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              //the next array item is better than a shallower substring of this one
              break;
            }

            j--;
          }

          i++;
        }

        return globalLocale;
      }

      function loadLocale(name) {
        var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

        if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = commonjsRequire;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {}
        }

        return locales[name];
      } // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.


      function getSetGlobalLocale(key, values) {
        var data;

        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }

          if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
          } else {
            if (typeof console !== 'undefined' && console.warn) {
              //warn user if arguments are passed but the locale could not be set
              console.warn('Locale ' + key + ' not found. Did you forget to load it?');
            }
          }
        }

        return globalLocale._abbr;
      }

      function defineLocale(name, config) {
        if (config !== null) {
          var locale,
              parentConfig = baseConfig;
          config.abbr = name;

          if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale = loadLocale(config.parentLocale);

              if (locale != null) {
                parentConfig = locale._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }

                localeFamilies[config.parentLocale].push({
                  name: name,
                  config: config
                });
                return null;
              }
            }
          }

          locales[name] = new Locale(mergeConfigs(parentConfig, config));

          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
              defineLocale(x.name, x.config);
            });
          } // backwards compat for now: also set the locale
          // make sure we set the locale AFTER all child locales have been
          // created, so we won't end up with the child locale set.


          getSetGlobalLocale(name);
          return locales[name];
        } else {
          // useful for testing
          delete locales[name];
          return null;
        }
      }

      function updateLocale(name, config) {
        if (config != null) {
          var locale,
              tmpLocale,
              parentConfig = baseConfig; // MERGE

          tmpLocale = loadLocale(name);

          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }

          config = mergeConfigs(parentConfig, config);
          locale = new Locale(config);
          locale.parentLocale = locales[name];
          locales[name] = locale; // backwards compat for now: also set the locale

          getSetGlobalLocale(name);
        } else {
          // pass null for config to unupdate, useful for tests
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }

        return locales[name];
      } // returns locale data


      function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }

        if (!key) {
          return globalLocale;
        }

        if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);

          if (locale) {
            return locale;
          }

          key = [key];
        }

        return chooseLocale(key);
      }

      function listLocales() {
        return keys(locales);
      }

      function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }

          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }

          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }

          getParsingFlags(m).overflow = overflow;
        }

        return m;
      } // Pick the first defined of two or three arguments.


      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }

        if (b != null) {
          return b;
        }

        return c;
      }

      function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());

        if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }

        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      } // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]


      function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
          return;
        }

        currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        } //if the day of the year is set, figure out what it is


        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }

          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        } // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything


        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        } // Zero out whatever was not defaulted, including time


        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        } // Check for 24:00:00.000


        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.

        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
          config._a[HOUR] = 24;
        } // check for mismatching day of week


        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }

      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        w = config._w;

        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).

          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);

          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          var curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

          week = defaults(w.w, curWeek.week);

          if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;

            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            // local weekday -- counting starts from beginning of week
            weekday = w.e + dow;

            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            // default to beginning of week
            weekday = dow;
          }
        }

        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      } // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
      var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
      ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

      var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

      function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
          getParsingFlags(config).iso = true;

          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }

          if (dateFormat == null) {
            config._isValid = false;
            return;
          }

          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                // match[2] should be 'T' or space
                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                break;
              }
            }

            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }

          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }

          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = 'Z';
            } else {
              config._isValid = false;
              return;
            }
          }

          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }

        return result;
      }

      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);

        if (year <= 49) {
          return 2000 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }

        return year;
      }

      function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }

        return true;
      }

      var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          // the only allowed military tz is Z
          return 0;
        } else {
          var hm = parseInt(numOffset, 10);
          var m = hm % 100,
              h = (hm - m) / 100;
          return h * 60 + m;
        }
      } // date and time from ref 2822 format


      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));

        if (match) {
          var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }

          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);

          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      } // date from iso format or fallback


      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }

        configFromISO(config);

        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }

        configFromRFC2822(config);

        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        } // Final attempt, use Input Fallback


        hooks.createFromInputFallback(config);
      }

      hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      }); // constant that refers to the ISO standard

      hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


      hooks.RFC_2822 = function () {}; // date from string and format string


      function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }

        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }

        config._a = [];
        getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
          //         'regex', getParseRegexForToken(token, config));

          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));

            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }

            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          } // don't parse if it's not a known token


          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }

            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        } // add remaining unparsed input length to the string


        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        } // clear _12h flag if hour is <= 12


        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
          // nothing to do
          return hour;
        }

        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);

          if (isPm && hour < 12) {
            hour += 12;
          }

          if (!isPm && hour === 12) {
            hour = 0;
          }

          return hour;
        } else {
          // this is not supposed to happen
          return hour;
        }
      } // date from string and array of format strings


      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;

        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }

        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);

          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }

          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);

          if (!isValid(tempConfig)) {
            continue;
          } // if there is any input that was not parsed add a penalty for that format


          currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;

          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }

        extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
        if (config._d) {
          return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }

      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));

        if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined;
        }

        return res;
      }

      function prepareConfig(config) {
        var input = config._i,
            format = config._f;
        config._locale = config._locale || getLocale(config._l);

        if (input === null || format === undefined && input === '') {
          return createInvalid({
            nullInput: true
          });
        }

        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }

        if (!isValid(config)) {
          config._d = null;
        }

        return config;
      }

      function configFromInput(config) {
        var input = config._i;

        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          // from milliseconds
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
        }

        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = undefined;
        } // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423


        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);

        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      });
      var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);

        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }); // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.

      function pickBy(fn, moments) {
        var res, i;

        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }

        if (!moments.length) {
          return createLocal();
        }

        res = moments[0];

        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }

        return res;
      } // TODO: Use [].sort instead?


      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
      }

      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
      }

      var now = function () {
        return Date.now ? Date.now() : +new Date();
      };

      var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

      function isDurationValid(m) {
        for (var key in m) {
          if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }

        var unitHasDecimal = false;

        for (var i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false; // only allow non-integers for smallest unit
            }

            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }

        return true;
      }

      function isValid$1() {
        return this._isValid;
      }

      function createInvalid$1() {
        return createDuration(NaN);
      }

      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately

        this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.

        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();

        this._bubble();
      }

      function isDuration(obj) {
        return obj instanceof Duration;
      }

      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      } // FORMATTING


      function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset();
          var sign = '+';

          if (offset < 0) {
            offset = -offset;
            sign = '-';
          }

          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
      }

      offset('Z', ':');
      offset('ZZ', ''); // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      }); // HELPERS
      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']

      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
          return null;
        }

        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      } // Return a moment from input, that is local/utc/zone equivalent to model.


      function cloneWithOffset(input, model) {
        var res, diff;

        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

          res._d.setTime(res._d.valueOf() + diff);

          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }

      function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      } // HOOKS
      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.


      hooks.updateOffset = function () {}; // MOMENTS
      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.


      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;

        if (!this.isValid()) {
          return input != null ? this : NaN;
        }

        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);

            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }

          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }

          this._offset = input;
          this._isUTC = true;

          if (localAdjust != null) {
            this.add(localAdjust, 'm');
          }

          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }

          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }

      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input;
          }

          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }

      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;

          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
          }
        }

        return this;
      }

      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
          var tZone = offsetFromString(matchOffset, this._i);

          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }

        return this;
      }

      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }

        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }

      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }

        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
          var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }

        return this._isDSTShifted;
      }

      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      } // ASP.NET json date format regex


      var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day

      var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
        match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input)) {
          duration = {};

          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

          };
        } else if (!!(match = isoRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
          };
        } else if (duration == null) {
          // checks for null or undefined
          duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
        }

        return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

        return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res;
      }

      function momentsDifference(base, other) {
        var res;

        if (!(base.isValid() && other.isValid())) {
          return {
            milliseconds: 0,
            months: 0
          };
        }

        other = cloneWithOffset(other, base);

        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }

        return res;
      } // TODO: remove 'name' arg after deprecation is removed


      function createAdder(direction, name) {
        return function (val, period) {
          var dur, tmp; //invert the arguments, but complain about it

          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val;
            val = period;
            period = tmp;
          }

          val = typeof val === 'string' ? +val : val;
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
          // No op
          return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
          setMonth(mom, get(mom, 'Month') + months * isAdding);
        }

        if (days) {
          set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }

        if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }

        if (updateOffset) {
          hooks.updateOffset(mom, days || months);
        }
      }

      var add = createAdder(1, 'add');
      var subtract = createAdder(-1, 'subtract');

      function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      }

      function calendar$1(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';
        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }

      function clone() {
        return new Moment(this);
      }

      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);

        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }

        units = normalizeUnits(units) || 'millisecond';

        if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }

      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);

        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }

        units = normalizeUnits(units) || 'millisecond';

        if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }

      function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);

        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }

        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }

      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;

        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }

        units = normalizeUnits(units) || 'millisecond';

        if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }

      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
          return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
          return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);

        switch (units) {
          case 'year':
            output = monthDiff(this, that) / 12;
            break;

          case 'month':
            output = monthDiff(this, that);
            break;

          case 'quarter':
            output = monthDiff(this, that) / 3;
            break;

          case 'second':
            output = (this - that) / 1e3;
            break;
          // 1000

          case 'minute':
            output = (this - that) / 6e4;
            break;
          // 1000 * 60

          case 'hour':
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60

          case 'day':
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst

          case 'week':
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst

          default:
            output = this - that;
        }

        return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

          adjust = (b - anchor) / (anchor2 - anchor);
        } //check for negative zero, return zero if negative zero


        return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }

        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;

        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }

        if (isFunction(Date.prototype.toISOString)) {
          // native implementation is ~50x faster, use it when we can
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
          }
        }

        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }
      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */


      function inspect() {
        if (!this.isValid()) {
          return 'moment.invalid(/* ' + this._i + ' */)';
        }

        var func = 'moment';
        var zone = '';

        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
          zone = 'Z';
        }

        var prefix = '[' + func + '("]';
        var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }

        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }

      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            from: this,
            to: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }

      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      } // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.


      function locale(key) {
        var newLocaleData;

        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);

          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }

          return this;
        }
      }

      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });

      function localeData() {
        return this._locale;
      }

      var MS_PER_SECOND = 1000;
      var MS_PER_MINUTE = 60 * MS_PER_SECOND;
      var MS_PER_HOUR = 60 * MS_PER_MINUTE;
      var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }

      function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }

      function startOf(units) {
        var time;
        units = normalizeUnits(units);

        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
          case 'year':
            time = startOfDate(this.year(), 0, 1);
            break;

          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;

          case 'month':
            time = startOfDate(this.year(), this.month(), 1);
            break;

          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;

          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;

          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date());
            break;

          case 'hour':
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;

          case 'minute':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;

          case 'second':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }

        this._d.setTime(time);

        hooks.updateOffset(this, true);
        return this;
      }

      function endOf(units) {
        var time;
        units = normalizeUnits(units);

        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
          case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;

          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;

          case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;

          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;

          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;

          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;

          case 'hour':
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;

          case 'minute':
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;

          case 'second':
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }

        this._d.setTime(time);

        hooks.updateOffset(this, true);
        return this;
      }

      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
        return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
        return new Date(this.valueOf());
      }

      function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }

      function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
        return isValid(this);
      }

      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
        return getParsingFlags(this).overflow;
      }

      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      } // FORMATTING


      addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1); // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
      }); // MOMENTS

      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }

      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;

        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;

        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);

          if (week > weeksTarget) {
            week = weeksTarget;
          }

          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      } // FORMATTING


      addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

      addUnitAlias('quarter', 'Q'); // PRIORITY

      addUnitPriority('quarter', 7); // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      }); // MOMENTS

      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      } // FORMATTING


      addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

      addUnitAlias('date', 'D'); // PRIORITY

      addUnitPriority('date', 9); // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      }); // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

      addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

      addUnitPriority('dayOfYear', 4); // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
      }); // HELPERS
      // MOMENTS

      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      } // FORMATTING


      addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

      addUnitAlias('minute', 'm'); // PRIORITY

      addUnitPriority('minute', 14); // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE); // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

      addUnitAlias('second', 's'); // PRIORITY

      addUnitPriority('second', 15); // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND); // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

      addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
      }); // ALIASES

      addUnitAlias('millisecond', 'ms'); // PRIORITY

      addUnitPriority('millisecond', 16); // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);
      var token;

      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
      } // MOMENTS


      var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

      function createUnix(input) {
        return createLocal(input * 1000);
      }

      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
        return string;
      }

      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';

        if (index != null) {
          return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];

        for (i = 0; i < 12; i++) {
          out[i] = get$1(format, i, field, 'month');
        }

        return out;
      } // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)


      function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';
        } else {
          format = localeSorted;
          index = format;
          localeSorted = false;

          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
          return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];

        for (i = 0; i < 7; i++) {
          out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }

        return out;
      }

      function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
          var b = number % 10,
              output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        }
      }); // Side effect imports

      hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
      hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
      var mathAbs = Math.abs;

      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }

      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      } // supports only 2.0-style add(1, 's') or add(duration)


      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      } // supports only 2.0-style subtract(1, 's') or subtract(duration)


      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }

      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166

        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        } // The following code bubbles up values, see the tests for
        // examples of what that means.


        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24); // convert days to months

        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
      }

      function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
      }

      function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
      }

      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }

        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);

          switch (units) {
            case 'month':
              return months;

            case 'quarter':
              return months / 3;

            case 'year':
              return months / 12;
          }
        } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));

          switch (units) {
            case 'week':
              return days / 7 + milliseconds / 6048e5;

            case 'day':
              return days + milliseconds / 864e5;

            case 'hour':
              return days * 24 + milliseconds / 36e5;

            case 'minute':
              return days * 1440 + milliseconds / 6e4;

            case 'second':
              return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here

            case 'millisecond':
              return Math.floor(days * 864e5) + milliseconds;

            default:
              throw new Error('Unknown unit ' + units);
          }
        }
      } // TODO: Use this.as('ms')?


      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }

        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }

      function makeAs(alias) {
        return function () {
          return this.as(alias);
        };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds = makeAs('s');
      var asMinutes = makeAs('m');
      var asHours = makeAs('h');
      var asDays = makeAs('d');
      var asWeeks = makeAs('w');
      var asMonths = makeAs('M');
      var asQuarters = makeAs('Q');
      var asYears = makeAs('y');

      function clone$1() {
        return createDuration(this);
      }

      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
        return function () {
          return this.isValid() ? this._data[name] : NaN;
        };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds = makeGetter('seconds');
      var minutes = makeGetter('minutes');
      var hours = makeGetter('hours');
      var days = makeGetter('days');
      var months = makeGetter('months');
      var years = makeGetter('years');

      function weeks() {
        return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month
        M: 11 // months to year

      }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));
        var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      } // This function allows you to set the rounding function for relative time strings


      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
          return round;
        }

        if (typeof roundingFunction === 'function') {
          round = roundingFunction;
          return true;
        }

        return false;
      } // This function allows you to set a threshold for relative time strings


      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }

        if (limit === undefined) {
          return thresholds[threshold];
        }

        thresholds[threshold] = limit;

        if (threshold === 's') {
          thresholds.ss = limit - 1;
        }

        return true;
      }

      function humanize(withSuffix) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60; // 12 months -> 1 year

        years = absFloor(months / 12);
        months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
      }

      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
      proto$2.lang = lang; // Side effect imports
      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf'); // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
      }); // Side effect imports

      hooks.version = '2.24.0';
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

      hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',
        // <input type="date" />
        TIME: 'HH:mm',
        // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',
        // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',
        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',
        // <input type="week" />
        MONTH: 'YYYY-MM' // <input type="month" />

      };
      return hooks;
    });
  });

  var Chart$1 = createCommonjsModule(function (module, exports) {
    /*!
     * Chart.js v2.8.0
     * https://www.chartjs.org
     * (c) 2019 Chart.js Contributors
     * Released under the MIT License
     */
    (function (global, factory) {
      module.exports = factory(function () {
        try {
          return moment;
        } catch (e) {}
      }());
    })(commonjsGlobal, function (moment) {

      moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
      /* MIT license */

      var conversions = {
        rgb2hsl: rgb2hsl,
        rgb2hsv: rgb2hsv,
        rgb2hwb: rgb2hwb,
        rgb2cmyk: rgb2cmyk,
        rgb2keyword: rgb2keyword,
        rgb2xyz: rgb2xyz,
        rgb2lab: rgb2lab,
        rgb2lch: rgb2lch,
        hsl2rgb: hsl2rgb,
        hsl2hsv: hsl2hsv,
        hsl2hwb: hsl2hwb,
        hsl2cmyk: hsl2cmyk,
        hsl2keyword: hsl2keyword,
        hsv2rgb: hsv2rgb,
        hsv2hsl: hsv2hsl,
        hsv2hwb: hsv2hwb,
        hsv2cmyk: hsv2cmyk,
        hsv2keyword: hsv2keyword,
        hwb2rgb: hwb2rgb,
        hwb2hsl: hwb2hsl,
        hwb2hsv: hwb2hsv,
        hwb2cmyk: hwb2cmyk,
        hwb2keyword: hwb2keyword,
        cmyk2rgb: cmyk2rgb,
        cmyk2hsl: cmyk2hsl,
        cmyk2hsv: cmyk2hsv,
        cmyk2hwb: cmyk2hwb,
        cmyk2keyword: cmyk2keyword,
        keyword2rgb: keyword2rgb,
        keyword2hsl: keyword2hsl,
        keyword2hsv: keyword2hsv,
        keyword2hwb: keyword2hwb,
        keyword2cmyk: keyword2cmyk,
        keyword2lab: keyword2lab,
        keyword2xyz: keyword2xyz,
        xyz2rgb: xyz2rgb,
        xyz2lab: xyz2lab,
        xyz2lch: xyz2lch,
        lab2xyz: lab2xyz,
        lab2rgb: lab2rgb,
        lab2lch: lab2lch,
        lch2lab: lch2lab,
        lch2xyz: lch2xyz,
        lch2rgb: lch2rgb
      };

      function rgb2hsl(rgb) {
        var r = rgb[0] / 255,
            g = rgb[1] / 255,
            b = rgb[2] / 255,
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            delta = max - min,
            h,
            s,
            l;

        if (max == min) {
          h = 0;
        } else if (r == max) {
          h = (g - b) / delta;
        } else if (g == max) {
          h = 2 + (b - r) / delta;
        } else if (b == max) {
          h = 4 + (r - g) / delta;
        }

        h = Math.min(h * 60, 360);

        if (h < 0) {
          h += 360;
        }

        l = (min + max) / 2;

        if (max == min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }

        return [h, s * 100, l * 100];
      }

      function rgb2hsv(rgb) {
        var r = rgb[0],
            g = rgb[1],
            b = rgb[2],
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            delta = max - min,
            h,
            s,
            v;

        if (max == 0) {
          s = 0;
        } else {
          s = delta / max * 1000 / 10;
        }

        if (max == min) {
          h = 0;
        } else if (r == max) {
          h = (g - b) / delta;
        } else if (g == max) {
          h = 2 + (b - r) / delta;
        } else if (b == max) {
          h = 4 + (r - g) / delta;
        }

        h = Math.min(h * 60, 360);

        if (h < 0) {
          h += 360;
        }

        v = max / 255 * 1000 / 10;
        return [h, s, v];
      }

      function rgb2hwb(rgb) {
        var r = rgb[0],
            g = rgb[1],
            b = rgb[2],
            h = rgb2hsl(rgb)[0],
            w = 1 / 255 * Math.min(r, Math.min(g, b)),
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      }

      function rgb2cmyk(rgb) {
        var r = rgb[0] / 255,
            g = rgb[1] / 255,
            b = rgb[2] / 255,
            c,
            m,
            y,
            k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      }

      function rgb2keyword(rgb) {
        return reverseKeywords[JSON.stringify(rgb)];
      }

      function rgb2xyz(rgb) {
        var r = rgb[0] / 255,
            g = rgb[1] / 255,
            b = rgb[2] / 255; // assume sRGB

        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      }

      function rgb2lab(rgb) {
        var xyz = rgb2xyz(rgb),
            x = xyz[0],
            y = xyz[1],
            z = xyz[2],
            l,
            a,
            b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      }

      function rgb2lch(args) {
        return lab2lch(rgb2lab(args));
      }

      function hsl2rgb(hsl) {
        var h = hsl[0] / 360,
            s = hsl[1] / 100,
            l = hsl[2] / 100,
            t1,
            t2,
            t3,
            rgb,
            val;

        if (s == 0) {
          val = l * 255;
          return [val, val, val];
        }

        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }

        t1 = 2 * l - t2;
        rgb = [0, 0, 0];

        for (var i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          t3 < 0 && t3++;
          t3 > 1 && t3--;

          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }

          rgb[i] = val * 255;
        }

        return rgb;
      }

      function hsl2hsv(hsl) {
        var h = hsl[0],
            s = hsl[1] / 100,
            l = hsl[2] / 100,
            sv,
            v;

        if (l === 0) {
          // no need to do calc on black
          // also avoids divide by 0 error
          return [0, 0, 0];
        }

        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        v = (l + s) / 2;
        sv = 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      }

      function hsl2hwb(args) {
        return rgb2hwb(hsl2rgb(args));
      }

      function hsl2cmyk(args) {
        return rgb2cmyk(hsl2rgb(args));
      }

      function hsl2keyword(args) {
        return rgb2keyword(hsl2rgb(args));
      }

      function hsv2rgb(hsv) {
        var h = hsv[0] / 60,
            s = hsv[1] / 100,
            v = hsv[2] / 100,
            hi = Math.floor(h) % 6;
        var f = h - Math.floor(h),
            p = 255 * v * (1 - s),
            q = 255 * v * (1 - s * f),
            t = 255 * v * (1 - s * (1 - f)),
            v = 255 * v;

        switch (hi) {
          case 0:
            return [v, t, p];

          case 1:
            return [q, v, p];

          case 2:
            return [p, v, t];

          case 3:
            return [p, q, v];

          case 4:
            return [t, p, v];

          case 5:
            return [v, p, q];
        }
      }

      function hsv2hsl(hsv) {
        var h = hsv[0],
            s = hsv[1] / 100,
            v = hsv[2] / 100,
            sl,
            l;
        l = (2 - s) * v;
        sl = s * v;
        sl /= l <= 1 ? l : 2 - l;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      }

      function hsv2hwb(args) {
        return rgb2hwb(hsv2rgb(args));
      }

      function hsv2cmyk(args) {
        return rgb2cmyk(hsv2rgb(args));
      }

      function hsv2keyword(args) {
        return rgb2keyword(hsv2rgb(args));
      } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


      function hwb2rgb(hwb) {
        var h = hwb[0] / 360,
            wh = hwb[1] / 100,
            bl = hwb[2] / 100,
            ratio = wh + bl,
            i,
            v,
            f,
            n; // wh + bl cant be > 1

        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }

        i = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i;

        if ((i & 0x01) != 0) {
          f = 1 - f;
        }

        n = wh + f * (v - wh); // linear interpolation

        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;

          case 1:
            r = n;
            g = v;
            b = wh;
            break;

          case 2:
            r = wh;
            g = v;
            b = n;
            break;

          case 3:
            r = wh;
            g = n;
            b = v;
            break;

          case 4:
            r = n;
            g = wh;
            b = v;
            break;

          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }

        return [r * 255, g * 255, b * 255];
      }

      function hwb2hsl(args) {
        return rgb2hsl(hwb2rgb(args));
      }

      function hwb2hsv(args) {
        return rgb2hsv(hwb2rgb(args));
      }

      function hwb2cmyk(args) {
        return rgb2cmyk(hwb2rgb(args));
      }

      function hwb2keyword(args) {
        return rgb2keyword(hwb2rgb(args));
      }

      function cmyk2rgb(cmyk) {
        var c = cmyk[0] / 100,
            m = cmyk[1] / 100,
            y = cmyk[2] / 100,
            k = cmyk[3] / 100,
            r,
            g,
            b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      }

      function cmyk2hsl(args) {
        return rgb2hsl(cmyk2rgb(args));
      }

      function cmyk2hsv(args) {
        return rgb2hsv(cmyk2rgb(args));
      }

      function cmyk2hwb(args) {
        return rgb2hwb(cmyk2rgb(args));
      }

      function cmyk2keyword(args) {
        return rgb2keyword(cmyk2rgb(args));
      }

      function xyz2rgb(xyz) {
        var x = xyz[0] / 100,
            y = xyz[1] / 100,
            z = xyz[2] / 100,
            r,
            g,
            b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      }

      function xyz2lab(xyz) {
        var x = xyz[0],
            y = xyz[1],
            z = xyz[2],
            l,
            a,
            b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      }

      function xyz2lch(args) {
        return lab2lch(xyz2lab(args));
      }

      function lab2xyz(lab) {
        var l = lab[0],
            a = lab[1],
            b = lab[2],
            x,
            y,
            z,
            y2;

        if (l <= 8) {
          y = l * 100 / 903.3;
          y2 = 7.787 * (y / 100) + 16 / 116;
        } else {
          y = 100 * Math.pow((l + 16) / 116, 3);
          y2 = Math.pow(y / 100, 1 / 3);
        }

        x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
        z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
        return [x, y, z];
      }

      function lab2lch(lab) {
        var l = lab[0],
            a = lab[1],
            b = lab[2],
            hr,
            h,
            c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;

        if (h < 0) {
          h += 360;
        }

        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      }

      function lab2rgb(args) {
        return xyz2rgb(lab2xyz(args));
      }

      function lch2lab(lch) {
        var l = lch[0],
            c = lch[1],
            h = lch[2],
            a,
            b,
            hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      }

      function lch2xyz(args) {
        return lab2xyz(lch2lab(args));
      }

      function lch2rgb(args) {
        return lab2rgb(lch2lab(args));
      }

      function keyword2rgb(keyword) {
        return cssKeywords[keyword];
      }

      function keyword2hsl(args) {
        return rgb2hsl(keyword2rgb(args));
      }

      function keyword2hsv(args) {
        return rgb2hsv(keyword2rgb(args));
      }

      function keyword2hwb(args) {
        return rgb2hwb(keyword2rgb(args));
      }

      function keyword2cmyk(args) {
        return rgb2cmyk(keyword2rgb(args));
      }

      function keyword2lab(args) {
        return rgb2lab(keyword2rgb(args));
      }

      function keyword2xyz(args) {
        return rgb2xyz(keyword2rgb(args));
      }

      var cssKeywords = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
      var reverseKeywords = {};

      for (var key in cssKeywords) {
        reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
      }

      var convert = function () {
        return new Converter();
      };

      for (var func in conversions) {
        // export Raw versions
        convert[func + "Raw"] = function (func) {
          // accept array or plain args
          return function (arg) {
            if (typeof arg == "number") {
              arg = Array.prototype.slice.call(arguments);
            }

            return conversions[func](arg);
          };
        }(func);

        var pair = /(\w+)2(\w+)/.exec(func),
            from = pair[1],
            to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

        convert[from] = convert[from] || {};

        convert[from][to] = convert[func] = function (func) {
          return function (arg) {
            if (typeof arg == "number") {
              arg = Array.prototype.slice.call(arguments);
            }

            var val = conversions[func](arg);

            if (typeof val == "string" || val === undefined) {
              return val;
            } // keyword


            for (var i = 0; i < val.length; i++) {
              val[i] = Math.round(val[i]);
            }

            return val;
          };
        }(func);
      }
      /* Converter does lazy conversion and caching */


      var Converter = function () {
        this.convs = {};
      };
      /* Either get the values for a space or
        set the values for a space, depending on args */


      Converter.prototype.routeSpace = function (space, args) {
        var values = args[0];

        if (values === undefined) {
          // color.rgb()
          return this.getValues(space);
        } // color.rgb(10, 10, 10)


        if (typeof values == "number") {
          values = Array.prototype.slice.call(args);
        }

        return this.setValues(space, values);
      };
      /* Set the values for a space, invalidating cache */


      Converter.prototype.setValues = function (space, values) {
        this.space = space;
        this.convs = {};
        this.convs[space] = values;
        return this;
      };
      /* Get the values for a space. If there's already
        a conversion for the space, fetch it, otherwise
        compute it */


      Converter.prototype.getValues = function (space) {
        var vals = this.convs[space];

        if (!vals) {
          var fspace = this.space,
              from = this.convs[fspace];
          vals = convert[fspace][space](from);
          this.convs[space] = vals;
        }

        return vals;
      };

      ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
        Converter.prototype[space] = function (vals) {
          return this.routeSpace(space, arguments);
        };
      });
      var colorConvert = convert;
      var colorName = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
      /* MIT license */

      var colorString = {
        getRgba: getRgba,
        getHsla: getHsla,
        getRgb: getRgb,
        getHsl: getHsl,
        getHwb: getHwb,
        getAlpha: getAlpha,
        hexString: hexString,
        rgbString: rgbString,
        rgbaString: rgbaString,
        percentString: percentString,
        percentaString: percentaString,
        hslString: hslString,
        hslaString: hslaString,
        hwbString: hwbString,
        keyword: keyword
      };

      function getRgba(string) {
        if (!string) {
          return;
        }

        var abbr = /^#([a-fA-F0-9]{3,4})$/i,
            hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
            rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
            per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
            keyword = /(\w+)/;
        var rgb = [0, 0, 0],
            a = 1,
            match = string.match(abbr),
            hexAlpha = "";

        if (match) {
          match = match[1];
          hexAlpha = match[3];

          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = parseInt(match[i] + match[i], 16);
          }

          if (hexAlpha) {
            a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
          }
        } else if (match = string.match(hex)) {
          hexAlpha = match[2];
          match = match[1];

          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
          }

          if (hexAlpha) {
            a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
          }
        } else if (match = string.match(rgba)) {
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = parseInt(match[i + 1]);
          }

          a = parseFloat(match[4]);
        } else if (match = string.match(per)) {
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
          }

          a = parseFloat(match[4]);
        } else if (match = string.match(keyword)) {
          if (match[1] == "transparent") {
            return [0, 0, 0, 0];
          }

          rgb = colorName[match[1]];

          if (!rgb) {
            return;
          }
        }

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = scale(rgb[i], 0, 255);
        }

        if (!a && a != 0) {
          a = 1;
        } else {
          a = scale(a, 0, 1);
        }

        rgb[3] = a;
        return rgb;
      }

      function getHsla(string) {
        if (!string) {
          return;
        }

        var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
        var match = string.match(hsl);

        if (match) {
          var alpha = parseFloat(match[4]);
          var h = scale(parseInt(match[1]), 0, 360),
              s = scale(parseFloat(match[2]), 0, 100),
              l = scale(parseFloat(match[3]), 0, 100),
              a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, s, l, a];
        }
      }

      function getHwb(string) {
        if (!string) {
          return;
        }

        var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
        var match = string.match(hwb);

        if (match) {
          var alpha = parseFloat(match[4]);
          var h = scale(parseInt(match[1]), 0, 360),
              w = scale(parseFloat(match[2]), 0, 100),
              b = scale(parseFloat(match[3]), 0, 100),
              a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, w, b, a];
        }
      }

      function getRgb(string) {
        var rgba = getRgba(string);
        return rgba && rgba.slice(0, 3);
      }

      function getHsl(string) {
        var hsla = getHsla(string);
        return hsla && hsla.slice(0, 3);
      }

      function getAlpha(string) {
        var vals = getRgba(string);

        if (vals) {
          return vals[3];
        } else if (vals = getHsla(string)) {
          return vals[3];
        } else if (vals = getHwb(string)) {
          return vals[3];
        }
      } // generators


      function hexString(rgba, a) {
        var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
        return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
      }

      function rgbString(rgba, alpha) {
        if (alpha < 1 || rgba[3] && rgba[3] < 1) {
          return rgbaString(rgba, alpha);
        }

        return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
      }

      function rgbaString(rgba, alpha) {
        if (alpha === undefined) {
          alpha = rgba[3] !== undefined ? rgba[3] : 1;
        }

        return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
      }

      function percentString(rgba, alpha) {
        if (alpha < 1 || rgba[3] && rgba[3] < 1) {
          return percentaString(rgba, alpha);
        }

        var r = Math.round(rgba[0] / 255 * 100),
            g = Math.round(rgba[1] / 255 * 100),
            b = Math.round(rgba[2] / 255 * 100);
        return "rgb(" + r + "%, " + g + "%, " + b + "%)";
      }

      function percentaString(rgba, alpha) {
        var r = Math.round(rgba[0] / 255 * 100),
            g = Math.round(rgba[1] / 255 * 100),
            b = Math.round(rgba[2] / 255 * 100);
        return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
      }

      function hslString(hsla, alpha) {
        if (alpha < 1 || hsla[3] && hsla[3] < 1) {
          return hslaString(hsla, alpha);
        }

        return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
      }

      function hslaString(hsla, alpha) {
        if (alpha === undefined) {
          alpha = hsla[3] !== undefined ? hsla[3] : 1;
        }

        return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
      } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
      // (hwb have alpha optional & 1 is default value)


      function hwbString(hwb, alpha) {
        if (alpha === undefined) {
          alpha = hwb[3] !== undefined ? hwb[3] : 1;
        }

        return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
      }

      function keyword(rgb) {
        return reverseNames[rgb.slice(0, 3)];
      } // helpers


      function scale(num, min, max) {
        return Math.min(Math.max(min, num), max);
      }

      function hexDouble(num) {
        var str = num.toString(16).toUpperCase();
        return str.length < 2 ? "0" + str : str;
      } //create a list of reverse color names


      var reverseNames = {};

      for (var name in colorName) {
        reverseNames[colorName[name]] = name;
      }
      /* MIT license */


      var Color = function (obj) {
        if (obj instanceof Color) {
          return obj;
        }

        if (!(this instanceof Color)) {
          return new Color(obj);
        }

        this.valid = false;
        this.values = {
          rgb: [0, 0, 0],
          hsl: [0, 0, 0],
          hsv: [0, 0, 0],
          hwb: [0, 0, 0],
          cmyk: [0, 0, 0, 0],
          alpha: 1
        }; // parse Color() argument

        var vals;

        if (typeof obj === 'string') {
          vals = colorString.getRgba(obj);

          if (vals) {
            this.setValues('rgb', vals);
          } else if (vals = colorString.getHsla(obj)) {
            this.setValues('hsl', vals);
          } else if (vals = colorString.getHwb(obj)) {
            this.setValues('hwb', vals);
          }
        } else if (typeof obj === 'object') {
          vals = obj;

          if (vals.r !== undefined || vals.red !== undefined) {
            this.setValues('rgb', vals);
          } else if (vals.l !== undefined || vals.lightness !== undefined) {
            this.setValues('hsl', vals);
          } else if (vals.v !== undefined || vals.value !== undefined) {
            this.setValues('hsv', vals);
          } else if (vals.w !== undefined || vals.whiteness !== undefined) {
            this.setValues('hwb', vals);
          } else if (vals.c !== undefined || vals.cyan !== undefined) {
            this.setValues('cmyk', vals);
          }
        }
      };

      Color.prototype = {
        isValid: function () {
          return this.valid;
        },
        rgb: function () {
          return this.setSpace('rgb', arguments);
        },
        hsl: function () {
          return this.setSpace('hsl', arguments);
        },
        hsv: function () {
          return this.setSpace('hsv', arguments);
        },
        hwb: function () {
          return this.setSpace('hwb', arguments);
        },
        cmyk: function () {
          return this.setSpace('cmyk', arguments);
        },
        rgbArray: function () {
          return this.values.rgb;
        },
        hslArray: function () {
          return this.values.hsl;
        },
        hsvArray: function () {
          return this.values.hsv;
        },
        hwbArray: function () {
          var values = this.values;

          if (values.alpha !== 1) {
            return values.hwb.concat([values.alpha]);
          }

          return values.hwb;
        },
        cmykArray: function () {
          return this.values.cmyk;
        },
        rgbaArray: function () {
          var values = this.values;
          return values.rgb.concat([values.alpha]);
        },
        hslaArray: function () {
          var values = this.values;
          return values.hsl.concat([values.alpha]);
        },
        alpha: function (val) {
          if (val === undefined) {
            return this.values.alpha;
          }

          this.setValues('alpha', val);
          return this;
        },
        red: function (val) {
          return this.setChannel('rgb', 0, val);
        },
        green: function (val) {
          return this.setChannel('rgb', 1, val);
        },
        blue: function (val) {
          return this.setChannel('rgb', 2, val);
        },
        hue: function (val) {
          if (val) {
            val %= 360;
            val = val < 0 ? 360 + val : val;
          }

          return this.setChannel('hsl', 0, val);
        },
        saturation: function (val) {
          return this.setChannel('hsl', 1, val);
        },
        lightness: function (val) {
          return this.setChannel('hsl', 2, val);
        },
        saturationv: function (val) {
          return this.setChannel('hsv', 1, val);
        },
        whiteness: function (val) {
          return this.setChannel('hwb', 1, val);
        },
        blackness: function (val) {
          return this.setChannel('hwb', 2, val);
        },
        value: function (val) {
          return this.setChannel('hsv', 2, val);
        },
        cyan: function (val) {
          return this.setChannel('cmyk', 0, val);
        },
        magenta: function (val) {
          return this.setChannel('cmyk', 1, val);
        },
        yellow: function (val) {
          return this.setChannel('cmyk', 2, val);
        },
        black: function (val) {
          return this.setChannel('cmyk', 3, val);
        },
        hexString: function () {
          return colorString.hexString(this.values.rgb);
        },
        rgbString: function () {
          return colorString.rgbString(this.values.rgb, this.values.alpha);
        },
        rgbaString: function () {
          return colorString.rgbaString(this.values.rgb, this.values.alpha);
        },
        percentString: function () {
          return colorString.percentString(this.values.rgb, this.values.alpha);
        },
        hslString: function () {
          return colorString.hslString(this.values.hsl, this.values.alpha);
        },
        hslaString: function () {
          return colorString.hslaString(this.values.hsl, this.values.alpha);
        },
        hwbString: function () {
          return colorString.hwbString(this.values.hwb, this.values.alpha);
        },
        keyword: function () {
          return colorString.keyword(this.values.rgb, this.values.alpha);
        },
        rgbNumber: function () {
          var rgb = this.values.rgb;
          return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
        },
        luminosity: function () {
          // http://www.w3.org/TR/WCAG20/#relativeluminancedef
          var rgb = this.values.rgb;
          var lum = [];

          for (var i = 0; i < rgb.length; i++) {
            var chan = rgb[i] / 255;
            lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
          }

          return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
        },
        contrast: function (color2) {
          // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
          var lum1 = this.luminosity();
          var lum2 = color2.luminosity();

          if (lum1 > lum2) {
            return (lum1 + 0.05) / (lum2 + 0.05);
          }

          return (lum2 + 0.05) / (lum1 + 0.05);
        },
        level: function (color2) {
          var contrastRatio = this.contrast(color2);

          if (contrastRatio >= 7.1) {
            return 'AAA';
          }

          return contrastRatio >= 4.5 ? 'AA' : '';
        },
        dark: function () {
          // YIQ equation from http://24ways.org/2010/calculating-color-contrast
          var rgb = this.values.rgb;
          var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
          return yiq < 128;
        },
        light: function () {
          return !this.dark();
        },
        negate: function () {
          var rgb = [];

          for (var i = 0; i < 3; i++) {
            rgb[i] = 255 - this.values.rgb[i];
          }

          this.setValues('rgb', rgb);
          return this;
        },
        lighten: function (ratio) {
          var hsl = this.values.hsl;
          hsl[2] += hsl[2] * ratio;
          this.setValues('hsl', hsl);
          return this;
        },
        darken: function (ratio) {
          var hsl = this.values.hsl;
          hsl[2] -= hsl[2] * ratio;
          this.setValues('hsl', hsl);
          return this;
        },
        saturate: function (ratio) {
          var hsl = this.values.hsl;
          hsl[1] += hsl[1] * ratio;
          this.setValues('hsl', hsl);
          return this;
        },
        desaturate: function (ratio) {
          var hsl = this.values.hsl;
          hsl[1] -= hsl[1] * ratio;
          this.setValues('hsl', hsl);
          return this;
        },
        whiten: function (ratio) {
          var hwb = this.values.hwb;
          hwb[1] += hwb[1] * ratio;
          this.setValues('hwb', hwb);
          return this;
        },
        blacken: function (ratio) {
          var hwb = this.values.hwb;
          hwb[2] += hwb[2] * ratio;
          this.setValues('hwb', hwb);
          return this;
        },
        greyscale: function () {
          var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

          var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
          this.setValues('rgb', [val, val, val]);
          return this;
        },
        clearer: function (ratio) {
          var alpha = this.values.alpha;
          this.setValues('alpha', alpha - alpha * ratio);
          return this;
        },
        opaquer: function (ratio) {
          var alpha = this.values.alpha;
          this.setValues('alpha', alpha + alpha * ratio);
          return this;
        },
        rotate: function (degrees) {
          var hsl = this.values.hsl;
          var hue = (hsl[0] + degrees) % 360;
          hsl[0] = hue < 0 ? 360 + hue : hue;
          this.setValues('hsl', hsl);
          return this;
        },

        /**
         * Ported from sass implementation in C
         * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
         */
        mix: function (mixinColor, weight) {
          var color1 = this;
          var color2 = mixinColor;
          var p = weight === undefined ? 0.5 : weight;
          var w = 2 * p - 1;
          var a = color1.alpha() - color2.alpha();
          var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
          var w2 = 1 - w1;
          return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
        },
        toJSON: function () {
          return this.rgb();
        },
        clone: function () {
          // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
          // making the final build way to big to embed in Chart.js. So let's do it manually,
          // assuming that values to clone are 1 dimension arrays containing only numbers,
          // except 'alpha' which is a number.
          var result = new Color();
          var source = this.values;
          var target = result.values;
          var value, type;

          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              value = source[prop];
              type = {}.toString.call(value);

              if (type === '[object Array]') {
                target[prop] = value.slice(0);
              } else if (type === '[object Number]') {
                target[prop] = value;
              } else {
                console.error('unexpected color value:', value);
              }
            }
          }

          return result;
        }
      };
      Color.prototype.spaces = {
        rgb: ['red', 'green', 'blue'],
        hsl: ['hue', 'saturation', 'lightness'],
        hsv: ['hue', 'saturation', 'value'],
        hwb: ['hue', 'whiteness', 'blackness'],
        cmyk: ['cyan', 'magenta', 'yellow', 'black']
      };
      Color.prototype.maxes = {
        rgb: [255, 255, 255],
        hsl: [360, 100, 100],
        hsv: [360, 100, 100],
        hwb: [360, 100, 100],
        cmyk: [100, 100, 100, 100]
      };

      Color.prototype.getValues = function (space) {
        var values = this.values;
        var vals = {};

        for (var i = 0; i < space.length; i++) {
          vals[space.charAt(i)] = values[space][i];
        }

        if (values.alpha !== 1) {
          vals.a = values.alpha;
        } // {r: 255, g: 255, b: 255, a: 0.4}


        return vals;
      };

      Color.prototype.setValues = function (space, vals) {
        var values = this.values;
        var spaces = this.spaces;
        var maxes = this.maxes;
        var alpha = 1;
        var i;
        this.valid = true;

        if (space === 'alpha') {
          alpha = vals;
        } else if (vals.length) {
          // [10, 10, 10]
          values[space] = vals.slice(0, space.length);
          alpha = vals[space.length];
        } else if (vals[space.charAt(0)] !== undefined) {
          // {r: 10, g: 10, b: 10}
          for (i = 0; i < space.length; i++) {
            values[space][i] = vals[space.charAt(i)];
          }

          alpha = vals.a;
        } else if (vals[spaces[space][0]] !== undefined) {
          // {red: 10, green: 10, blue: 10}
          var chans = spaces[space];

          for (i = 0; i < space.length; i++) {
            values[space][i] = vals[chans[i]];
          }

          alpha = vals.alpha;
        }

        values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

        if (space === 'alpha') {
          return false;
        }

        var capped; // cap values of the space prior converting all values

        for (i = 0; i < space.length; i++) {
          capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
          values[space][i] = Math.round(capped);
        } // convert to all the other color spaces


        for (var sname in spaces) {
          if (sname !== space) {
            values[sname] = colorConvert[space][sname](values[space]);
          }
        }

        return true;
      };

      Color.prototype.setSpace = function (space, args) {
        var vals = args[0];

        if (vals === undefined) {
          // color.rgb()
          return this.getValues(space);
        } // color.rgb(10, 10, 10)


        if (typeof vals === 'number') {
          vals = Array.prototype.slice.call(args);
        }

        this.setValues(space, vals);
        return this;
      };

      Color.prototype.setChannel = function (space, index, val) {
        var svalues = this.values[space];

        if (val === undefined) {
          // color.red()
          return svalues[index];
        } else if (val === svalues[index]) {
          // color.red(color.red())
          return this;
        } // color.red(100)


        svalues[index] = val;
        this.setValues(space, svalues);
        return this;
      };

      if (typeof window !== 'undefined') {
        window.Color = Color;
      }

      var chartjsColor = Color;
      /**
       * @namespace Chart.helpers
       */

      var helpers = {
        /**
         * An empty function that can be used, for example, for optional callback.
         */
        noop: function () {},

        /**
         * Returns a unique id, sequentially generated from a global variable.
         * @returns {number}
         * @function
         */
        uid: function () {
          var id = 0;
          return function () {
            return id++;
          };
        }(),

        /**
         * Returns true if `value` is neither null nor undefined, else returns false.
         * @param {*} value - The value to test.
         * @returns {boolean}
         * @since 2.7.0
         */
        isNullOrUndef: function (value) {
          return value === null || typeof value === 'undefined';
        },

        /**
         * Returns true if `value` is an array (including typed arrays), else returns false.
         * @param {*} value - The value to test.
         * @returns {boolean}
         * @function
         */
        isArray: function (value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }

          var type = Object.prototype.toString.call(value);

          if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
            return true;
          }

          return false;
        },

        /**
         * Returns true if `value` is an object (excluding null), else returns false.
         * @param {*} value - The value to test.
         * @returns {boolean}
         * @since 2.7.0
         */
        isObject: function (value) {
          return value !== null && Object.prototype.toString.call(value) === '[object Object]';
        },

        /**
         * Returns true if `value` is a finite number, else returns false
         * @param {*} value  - The value to test.
         * @returns {boolean}
         */
        isFinite: function (value) {
          return (typeof value === 'number' || value instanceof Number) && isFinite(value);
        },

        /**
         * Returns `value` if defined, else returns `defaultValue`.
         * @param {*} value - The value to return if defined.
         * @param {*} defaultValue - The value to return if `value` is undefined.
         * @returns {*}
         */
        valueOrDefault: function (value, defaultValue) {
          return typeof value === 'undefined' ? defaultValue : value;
        },

        /**
         * Returns value at the given `index` in array if defined, else returns `defaultValue`.
         * @param {Array} value - The array to lookup for value at `index`.
         * @param {number} index - The index in `value` to lookup for value.
         * @param {*} defaultValue - The value to return if `value[index]` is undefined.
         * @returns {*}
         */
        valueAtIndexOrDefault: function (value, index, defaultValue) {
          return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
        },

        /**
         * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
         * value returned by `fn`. If `fn` is not a function, this method returns undefined.
         * @param {function} fn - The function to call.
         * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
         * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
         * @returns {*}
         */
        callback: function (fn, args, thisArg) {
          if (fn && typeof fn.call === 'function') {
            return fn.apply(thisArg, args);
          }
        },

        /**
         * Note(SB) for performance sake, this method should only be used when loopable type
         * is unknown or in none intensive code (not called often and small loopable). Else
         * it's preferable to use a regular for() loop and save extra function calls.
         * @param {object|Array} loopable - The object or array to be iterated.
         * @param {function} fn - The function to call for each item.
         * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
         * @param {boolean} [reverse] - If true, iterates backward on the loopable.
         */
        each: function (loopable, fn, thisArg, reverse) {
          var i, len, keys;

          if (helpers.isArray(loopable)) {
            len = loopable.length;

            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (helpers.isObject(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;

            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        },

        /**
         * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
         * @see https://stackoverflow.com/a/14853974
         * @param {Array} a0 - The array to compare
         * @param {Array} a1 - The array to compare
         * @returns {boolean}
         */
        arrayEquals: function (a0, a1) {
          var i, ilen, v0, v1;

          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }

          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];

            if (v0 instanceof Array && v1 instanceof Array) {
              if (!helpers.arrayEquals(v0, v1)) {
                return false;
              }
            } else if (v0 !== v1) {
              // NOTE: two different object instances will never be equal: {x:20} != {x:20}
              return false;
            }
          }

          return true;
        },

        /**
         * Returns a deep copy of `source` without keeping references on objects and arrays.
         * @param {*} source - The value to clone.
         * @returns {*}
         */
        clone: function (source) {
          if (helpers.isArray(source)) {
            return source.map(helpers.clone);
          }

          if (helpers.isObject(source)) {
            var target = {};
            var keys = Object.keys(source);
            var klen = keys.length;
            var k = 0;

            for (; k < klen; ++k) {
              target[keys[k]] = helpers.clone(source[keys[k]]);
            }

            return target;
          }

          return source;
        },

        /**
         * The default merger when Chart.helpers.merge is called without merger option.
         * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
         * @private
         */
        _merger: function (key, target, source, options) {
          var tval = target[key];
          var sval = source[key];

          if (helpers.isObject(tval) && helpers.isObject(sval)) {
            helpers.merge(tval, sval, options);
          } else {
            target[key] = helpers.clone(sval);
          }
        },

        /**
         * Merges source[key] in target[key] only if target[key] is undefined.
         * @private
         */
        _mergerIf: function (key, target, source) {
          var tval = target[key];
          var sval = source[key];

          if (helpers.isObject(tval) && helpers.isObject(sval)) {
            helpers.mergeIf(tval, sval);
          } else if (!target.hasOwnProperty(key)) {
            target[key] = helpers.clone(sval);
          }
        },

        /**
         * Recursively deep copies `source` properties into `target` with the given `options`.
         * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
         * @param {object} target - The target object in which all sources are merged into.
         * @param {object|object[]} source - Object(s) to merge into `target`.
         * @param {object} [options] - Merging options:
         * @param {function} [options.merger] - The merge method (key, target, source, options)
         * @returns {object} The `target` object.
         */
        merge: function (target, source, options) {
          var sources = helpers.isArray(source) ? source : [source];
          var ilen = sources.length;
          var merge, i, keys, klen, k;

          if (!helpers.isObject(target)) {
            return target;
          }

          options = options || {};
          merge = options.merger || helpers._merger;

          for (i = 0; i < ilen; ++i) {
            source = sources[i];

            if (!helpers.isObject(source)) {
              continue;
            }

            keys = Object.keys(source);

            for (k = 0, klen = keys.length; k < klen; ++k) {
              merge(keys[k], target, source, options);
            }
          }

          return target;
        },

        /**
         * Recursively deep copies `source` properties into `target` *only* if not defined in target.
         * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
         * @param {object} target - The target object in which all sources are merged into.
         * @param {object|object[]} source - Object(s) to merge into `target`.
         * @returns {object} The `target` object.
         */
        mergeIf: function (target, source) {
          return helpers.merge(target, source, {
            merger: helpers._mergerIf
          });
        },

        /**
         * Applies the contents of two or more objects together into the first object.
         * @param {object} target - The target object in which all objects are merged into.
         * @param {object} arg1 - Object containing additional properties to merge in target.
         * @param {object} argN - Additional objects containing properties to merge in target.
         * @returns {object} The `target` object.
         */
        extend: function (target) {
          var arguments$1 = arguments;

          var setFn = function (value, key) {
            target[key] = value;
          };

          for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
            helpers.each(arguments$1[i], setFn);
          }

          return target;
        },

        /**
         * Basic javascript inheritance based on the model created in Backbone.js
         */
        inherits: function (extensions) {
          var me = this;
          var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
            return me.apply(this, arguments);
          };

          var Surrogate = function () {
            this.constructor = ChartElement;
          };

          Surrogate.prototype = me.prototype;
          ChartElement.prototype = new Surrogate();
          ChartElement.extend = helpers.inherits;

          if (extensions) {
            helpers.extend(ChartElement.prototype, extensions);
          }

          ChartElement.__super__ = me.prototype;
          return ChartElement;
        }
      };
      var helpers_core = helpers; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use Chart.helpers.callback instead.
       * @function Chart.helpers.callCallback
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */

      helpers.callCallback = helpers.callback;
      /**
       * Provided for backward compatibility, use Array.prototype.indexOf instead.
       * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
       * @function Chart.helpers.indexOf
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers.indexOf = function (array, item, fromIndex) {
        return Array.prototype.indexOf.call(array, item, fromIndex);
      };
      /**
       * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
       * @function Chart.helpers.getValueOrDefault
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */


      helpers.getValueOrDefault = helpers.valueOrDefault;
      /**
       * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
       * @function Chart.helpers.getValueAtIndexOrDefault
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
      /**
       * Easing functions adapted from Robert Penner's easing equations.
       * @namespace Chart.helpers.easingEffects
       * @see http://www.robertpenner.com/easing/
       */

      var effects = {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return t * t;
        },
        easeOutQuad: function (t) {
          return -t * (t - 2);
        },
        easeInOutQuad: function (t) {
          if ((t /= 0.5) < 1) {
            return 0.5 * t * t;
          }

          return -0.5 * (--t * (t - 2) - 1);
        },
        easeInCubic: function (t) {
          return t * t * t;
        },
        easeOutCubic: function (t) {
          return (t = t - 1) * t * t + 1;
        },
        easeInOutCubic: function (t) {
          if ((t /= 0.5) < 1) {
            return 0.5 * t * t * t;
          }

          return 0.5 * ((t -= 2) * t * t + 2);
        },
        easeInQuart: function (t) {
          return t * t * t * t;
        },
        easeOutQuart: function (t) {
          return -((t = t - 1) * t * t * t - 1);
        },
        easeInOutQuart: function (t) {
          if ((t /= 0.5) < 1) {
            return 0.5 * t * t * t * t;
          }

          return -0.5 * ((t -= 2) * t * t * t - 2);
        },
        easeInQuint: function (t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function (t) {
          return (t = t - 1) * t * t * t * t + 1;
        },
        easeInOutQuint: function (t) {
          if ((t /= 0.5) < 1) {
            return 0.5 * t * t * t * t * t;
          }

          return 0.5 * ((t -= 2) * t * t * t * t + 2);
        },
        easeInSine: function (t) {
          return -Math.cos(t * (Math.PI / 2)) + 1;
        },
        easeOutSine: function (t) {
          return Math.sin(t * (Math.PI / 2));
        },
        easeInOutSine: function (t) {
          return -0.5 * (Math.cos(Math.PI * t) - 1);
        },
        easeInExpo: function (t) {
          return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
        },
        easeOutExpo: function (t) {
          return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
        },
        easeInOutExpo: function (t) {
          if (t === 0) {
            return 0;
          }

          if (t === 1) {
            return 1;
          }

          if ((t /= 0.5) < 1) {
            return 0.5 * Math.pow(2, 10 * (t - 1));
          }

          return 0.5 * (-Math.pow(2, -10 * --t) + 2);
        },
        easeInCirc: function (t) {
          if (t >= 1) {
            return t;
          }

          return -(Math.sqrt(1 - t * t) - 1);
        },
        easeOutCirc: function (t) {
          return Math.sqrt(1 - (t = t - 1) * t);
        },
        easeInOutCirc: function (t) {
          if ((t /= 0.5) < 1) {
            return -0.5 * (Math.sqrt(1 - t * t) - 1);
          }

          return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        easeInElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;

          if (t === 0) {
            return 0;
          }

          if (t === 1) {
            return 1;
          }

          if (!p) {
            p = 0.3;
          }

          if (a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a);
          }

          return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        },
        easeOutElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;

          if (t === 0) {
            return 0;
          }

          if (t === 1) {
            return 1;
          }

          if (!p) {
            p = 0.3;
          }

          if (a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a);
          }

          return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
        },
        easeInOutElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;

          if (t === 0) {
            return 0;
          }

          if ((t /= 0.5) === 2) {
            return 1;
          }

          if (!p) {
            p = 0.45;
          }

          if (a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a);
          }

          if (t < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
          }

          return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
        },
        easeInBack: function (t) {
          var s = 1.70158;
          return t * t * ((s + 1) * t - s);
        },
        easeOutBack: function (t) {
          var s = 1.70158;
          return (t = t - 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack: function (t) {
          var s = 1.70158;

          if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
          }

          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: function (t) {
          return 1 - effects.easeOutBounce(1 - t);
        },
        easeOutBounce: function (t) {
          if (t < 1 / 2.75) {
            return 7.5625 * t * t;
          }

          if (t < 2 / 2.75) {
            return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
          }

          if (t < 2.5 / 2.75) {
            return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
          }

          return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        },
        easeInOutBounce: function (t) {
          if (t < 0.5) {
            return effects.easeInBounce(t * 2) * 0.5;
          }

          return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
        }
      };
      var helpers_easing = {
        effects: effects
      }; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
       * @function Chart.helpers.easingEffects
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers_core.easingEffects = effects;
      var PI = Math.PI;
      var RAD_PER_DEG = PI / 180;
      var DOUBLE_PI = PI * 2;
      var HALF_PI = PI / 2;
      var QUARTER_PI = PI / 4;
      var TWO_THIRDS_PI = PI * 2 / 3;
      /**
       * @namespace Chart.helpers.canvas
       */

      var exports$1 = {
        /**
         * Clears the entire canvas associated to the given `chart`.
         * @param {Chart} chart - The chart for which to clear the canvas.
         */
        clear: function (chart) {
          chart.ctx.clearRect(0, 0, chart.width, chart.height);
        },

        /**
         * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
         * given size (width, height) and the same `radius` for all corners.
         * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
         * @param {number} x - The x axis of the coordinate for the rectangle starting point.
         * @param {number} y - The y axis of the coordinate for the rectangle starting point.
         * @param {number} width - The rectangle's width.
         * @param {number} height - The rectangle's height.
         * @param {number} radius - The rounded amount (in pixels) for the four corners.
         * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
         */
        roundedRect: function (ctx, x, y, width, height, radius) {
          if (radius) {
            var r = Math.min(radius, height / 2, width / 2);
            var left = x + r;
            var top = y + r;
            var right = x + width - r;
            var bottom = y + height - r;
            ctx.moveTo(x, top);

            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -PI, 0);
              ctx.arc(left, bottom, r, 0, PI);
            } else {
              ctx.arc(left, top, r, -PI, PI);
            }

            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, width, height);
          }
        },
        drawPoint: function (ctx, style, radius, x, y, rotation) {
          var type, xOffset, yOffset, size, cornerRadius;
          var rad = (rotation || 0) * RAD_PER_DEG;

          if (style && typeof style === 'object') {
            type = style.toString();

            if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
              ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
              return;
            }
          }

          if (isNaN(radius) || radius <= 0) {
            return;
          }

          ctx.beginPath();

          switch (style) {
            // Default includes circle
            default:
              ctx.arc(x, y, radius, 0, DOUBLE_PI);
              ctx.closePath();
              break;

            case 'triangle':
              ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;

            case 'rectRounded':
              // NOTE: the rounded rect implementation changed to use `arc` instead of
              // `quadraticCurveTo` since it generates better results when rect is
              // almost a circle. 0.516 (instead of 0.5) produces results with visually
              // closer proportion to the previous impl and it is inscribed in the
              // circle with `radius`. For more details, see the following PRs:
              // https://github.com/chartjs/Chart.js/issues/5597
              // https://github.com/chartjs/Chart.js/issues/5858
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;

            case 'rect':
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                ctx.rect(x - size, y - size, 2 * size, 2 * size);
                break;
              }

              rad += QUARTER_PI;

            /* falls through */

            case 'rectRot':
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + yOffset, y - xOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              ctx.closePath();
              break;

            case 'crossRot':
              rad += QUARTER_PI;

            /* falls through */

            case 'cross':
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;

            case 'star':
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;

            case 'line':
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;

            case 'dash':
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
              break;
          }

          ctx.fill();
          ctx.stroke();
        },

        /**
         * Returns true if the point is inside the rectangle
         * @param {object} point - The point to test
         * @param {object} area - The rectangle
         * @returns {boolean}
         * @private
         */
        _isPointInArea: function (point, area) {
          var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

          return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
        },
        clipArea: function (ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        },
        unclipArea: function (ctx) {
          ctx.restore();
        },
        lineTo: function (ctx, previous, target, flip) {
          var stepped = target.steppedLine;

          if (stepped) {
            if (stepped === 'middle') {
              var midpoint = (previous.x + target.x) / 2.0;
              ctx.lineTo(midpoint, flip ? target.y : previous.y);
              ctx.lineTo(midpoint, flip ? previous.y : target.y);
            } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
              ctx.lineTo(previous.x, target.y);
            } else {
              ctx.lineTo(target.x, previous.y);
            }

            ctx.lineTo(target.x, target.y);
            return;
          }

          if (!target.tension) {
            ctx.lineTo(target.x, target.y);
            return;
          }

          ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
        }
      };
      var helpers_canvas = exports$1; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
       * @namespace Chart.helpers.clear
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers_core.clear = exports$1.clear;
      /**
       * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
       * @namespace Chart.helpers.drawRoundedRectangle
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers_core.drawRoundedRectangle = function (ctx) {
        ctx.beginPath();
        exports$1.roundedRect.apply(exports$1, arguments);
      };

      var defaults = {
        /**
         * @private
         */
        _set: function (scope, values) {
          return helpers_core.merge(this[scope] || (this[scope] = {}), values);
        }
      };

      defaults._set('global', {
        defaultColor: 'rgba(0,0,0,0.1)',
        defaultFontColor: '#666',
        defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        defaultFontSize: 12,
        defaultFontStyle: 'normal',
        defaultLineHeight: 1.2,
        showLines: true
      });

      var core_defaults = defaults;
      var valueOrDefault = helpers_core.valueOrDefault;
      /**
       * Converts the given font object into a CSS font string.
       * @param {object} font - A font object.
       * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
       * @private
       */

      function toFontString(font) {
        if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
          return null;
        }

        return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
      }
      /**
       * @alias Chart.helpers.options
       * @namespace
       */


      var helpers_options = {
        /**
         * Converts the given line height `value` in pixels for a specific font `size`.
         * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
         * @param {number} size - The font size (in pixels) used to resolve relative `value`.
         * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
         * @since 2.7.0
         */
        toLineHeight: function (value, size) {
          var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

          if (!matches || matches[1] === 'normal') {
            return size * 1.2;
          }

          value = +matches[2];

          switch (matches[3]) {
            case 'px':
              return value;

            case '%':
              value /= 100;
              break;

            default:
              break;
          }

          return size * value;
        },

        /**
         * Converts the given value into a padding object with pre-computed width/height.
         * @param {number|object} value - If a number, set the value to all TRBL component,
         *  else, if and object, use defined properties and sets undefined ones to 0.
         * @returns {object} The padding values (top, right, bottom, left, width, height)
         * @since 2.7.0
         */
        toPadding: function (value) {
          var t, r, b, l;

          if (helpers_core.isObject(value)) {
            t = +value.top || 0;
            r = +value.right || 0;
            b = +value.bottom || 0;
            l = +value.left || 0;
          } else {
            t = r = b = l = +value || 0;
          }

          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            height: t + b,
            width: l + r
          };
        },

        /**
         * Parses font options and returns the font object.
         * @param {object} options - A object that contains font options to be parsed.
         * @return {object} The font object.
         * @todo Support font.* options and renamed to toFont().
         * @private
         */
        _parseFont: function (options) {
          var globalDefaults = core_defaults.global;
          var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
          var font = {
            family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
            lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
            size: size,
            style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
            weight: null,
            string: ''
          };
          font.string = toFontString(font);
          return font;
        },

        /**
         * Evaluates the given `inputs` sequentially and returns the first defined value.
         * @param {Array} inputs - An array of values, falling back to the last value.
         * @param {object} [context] - If defined and the current value is a function, the value
         * is called with `context` as first argument and the result becomes the new input.
         * @param {number} [index] - If defined and the current value is an array, the value
         * at `index` become the new input.
         * @since 2.7.0
         */
        resolve: function (inputs, context, index) {
          var i, ilen, value;

          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];

            if (value === undefined) {
              continue;
            }

            if (context !== undefined && typeof value === 'function') {
              value = value(context);
            }

            if (index !== undefined && helpers_core.isArray(value)) {
              value = value[index];
            }

            if (value !== undefined) {
              return value;
            }
          }
        }
      };
      var helpers$1 = helpers_core;
      var easing = helpers_easing;
      var canvas = helpers_canvas;
      var options = helpers_options;
      helpers$1.easing = easing;
      helpers$1.canvas = canvas;
      helpers$1.options = options;

      function interpolate(start, view, model, ease) {
        var keys = Object.keys(model);
        var i, ilen, key, actual, origin, target, type, c0, c1;

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          target = model[key]; // if a value is added to the model after pivot() has been called, the view
          // doesn't contain it, so let's initialize the view to the target value.

          if (!view.hasOwnProperty(key)) {
            view[key] = target;
          }

          actual = view[key];

          if (actual === target || key[0] === '_') {
            continue;
          }

          if (!start.hasOwnProperty(key)) {
            start[key] = actual;
          }

          origin = start[key];
          type = typeof target;

          if (type === typeof origin) {
            if (type === 'string') {
              c0 = chartjsColor(origin);

              if (c0.valid) {
                c1 = chartjsColor(target);

                if (c1.valid) {
                  view[key] = c1.mix(c0, ease).rgbString();
                  continue;
                }
              }
            } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
              view[key] = origin + (target - origin) * ease;
              continue;
            }
          }

          view[key] = target;
        }
      }

      var Element = function (configuration) {
        helpers$1.extend(this, configuration);
        this.initialize.apply(this, arguments);
      };

      helpers$1.extend(Element.prototype, {
        initialize: function () {
          this.hidden = false;
        },
        pivot: function () {
          var me = this;

          if (!me._view) {
            me._view = helpers$1.clone(me._model);
          }

          me._start = {};
          return me;
        },
        transition: function (ease) {
          var me = this;
          var model = me._model;
          var start = me._start;
          var view = me._view; // No animation -> No Transition

          if (!model || ease === 1) {
            me._view = model;
            me._start = null;
            return me;
          }

          if (!view) {
            view = me._view = {};
          }

          if (!start) {
            start = me._start = {};
          }

          interpolate(start, view, model, ease);
          return me;
        },
        tooltipPosition: function () {
          return {
            x: this._model.x,
            y: this._model.y
          };
        },
        hasValue: function () {
          return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
        }
      });
      Element.extend = helpers$1.inherits;
      var core_element = Element;
      var exports$2 = core_element.extend({
        chart: null,
        // the animation associated chart instance
        currentStep: 0,
        // the current animation step
        numSteps: 60,
        // default number of steps
        easing: '',
        // the easing to use for this animation
        render: null,
        // render function used by the animation service
        onAnimationProgress: null,
        // user specified callback to fire on each step of the animation
        onAnimationComplete: null // user specified callback to fire when the animation finishes

      });
      var core_animation = exports$2; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use Chart.Animation instead
       * @prop Chart.Animation#animationObject
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */

      Object.defineProperty(exports$2.prototype, 'animationObject', {
        get: function () {
          return this;
        }
      });
      /**
       * Provided for backward compatibility, use Chart.Animation#chart instead
       * @prop Chart.Animation#chartInstance
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */

      Object.defineProperty(exports$2.prototype, 'chartInstance', {
        get: function () {
          return this.chart;
        },
        set: function (value) {
          this.chart = value;
        }
      });

      core_defaults._set('global', {
        animation: {
          duration: 1000,
          easing: 'easeOutQuart',
          onProgress: helpers$1.noop,
          onComplete: helpers$1.noop
        }
      });

      var core_animations = {
        animations: [],
        request: null,

        /**
         * @param {Chart} chart - The chart to animate.
         * @param {Chart.Animation} animation - The animation that we will animate.
         * @param {number} duration - The animation duration in ms.
         * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
         */
        addAnimation: function (chart, animation, duration, lazy) {
          var animations = this.animations;
          var i, ilen;
          animation.chart = chart;
          animation.startTime = Date.now();
          animation.duration = duration;

          if (!lazy) {
            chart.animating = true;
          }

          for (i = 0, ilen = animations.length; i < ilen; ++i) {
            if (animations[i].chart === chart) {
              animations[i] = animation;
              return;
            }
          }

          animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

          if (animations.length === 1) {
            this.requestAnimationFrame();
          }
        },
        cancelAnimation: function (chart) {
          var index = helpers$1.findIndex(this.animations, function (animation) {
            return animation.chart === chart;
          });

          if (index !== -1) {
            this.animations.splice(index, 1);
            chart.animating = false;
          }
        },
        requestAnimationFrame: function () {
          var me = this;

          if (me.request === null) {
            // Skip animation frame requests until the active one is executed.
            // This can happen when processing mouse events, e.g. 'mousemove'
            // and 'mouseout' events will trigger multiple renders.
            me.request = helpers$1.requestAnimFrame.call(window, function () {
              me.request = null;
              me.startDigest();
            });
          }
        },

        /**
         * @private
         */
        startDigest: function () {
          var me = this;
          me.advance(); // Do we have more stuff to animate?

          if (me.animations.length > 0) {
            me.requestAnimationFrame();
          }
        },

        /**
         * @private
         */
        advance: function () {
          var animations = this.animations;
          var animation, chart, numSteps, nextStep;
          var i = 0; // 1 animation per chart, so we are looping charts here

          while (i < animations.length) {
            animation = animations[i];
            chart = animation.chart;
            numSteps = animation.numSteps; // Make sure that currentStep starts at 1
            // https://github.com/chartjs/Chart.js/issues/6104

            nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
            animation.currentStep = Math.min(nextStep, numSteps);
            helpers$1.callback(animation.render, [chart, animation], chart);
            helpers$1.callback(animation.onAnimationProgress, [animation], chart);

            if (animation.currentStep >= numSteps) {
              helpers$1.callback(animation.onAnimationComplete, [animation], chart);
              chart.animating = false;
              animations.splice(i, 1);
            } else {
              ++i;
            }
          }
        }
      };
      var resolve = helpers$1.options.resolve;
      var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
      /**
       * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
       * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
       * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
       */

      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);

          return;
        }

        Object.defineProperty(array, '_chartjs', {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [listener]
          }
        });
        arrayEvents.forEach(function (key) {
          var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
          var base = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value: function () {
              var args = Array.prototype.slice.call(arguments);
              var res = base.apply(this, args);
              helpers$1.each(array._chartjs.listeners, function (object) {
                if (typeof object[method] === 'function') {
                  object[method].apply(object, args);
                }
              });
              return res;
            }
          });
        });
      }
      /**
       * Removes the given array event listener and cleanup extra attached properties (such as
       * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
       */


      function unlistenArrayEvents(array, listener) {
        var stub = array._chartjs;

        if (!stub) {
          return;
        }

        var listeners = stub.listeners;
        var index = listeners.indexOf(listener);

        if (index !== -1) {
          listeners.splice(index, 1);
        }

        if (listeners.length > 0) {
          return;
        }

        arrayEvents.forEach(function (key) {
          delete array[key];
        });
        delete array._chartjs;
      } // Base class for all dataset controllers (line, bar, etc)


      var DatasetController = function (chart, datasetIndex) {
        this.initialize(chart, datasetIndex);
      };

      helpers$1.extend(DatasetController.prototype, {
        /**
         * Element type used to generate a meta dataset (e.g. Chart.element.Line).
         * @type {Chart.core.element}
         */
        datasetElementType: null,

        /**
         * Element type used to generate a meta data (e.g. Chart.element.Point).
         * @type {Chart.core.element}
         */
        dataElementType: null,
        initialize: function (chart, datasetIndex) {
          var me = this;
          me.chart = chart;
          me.index = datasetIndex;
          me.linkScales();
          me.addElements();
        },
        updateIndex: function (datasetIndex) {
          this.index = datasetIndex;
        },
        linkScales: function () {
          var me = this;
          var meta = me.getMeta();
          var dataset = me.getDataset();

          if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
            meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
          }

          if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
            meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
          }
        },
        getDataset: function () {
          return this.chart.data.datasets[this.index];
        },
        getMeta: function () {
          return this.chart.getDatasetMeta(this.index);
        },
        getScaleForId: function (scaleID) {
          return this.chart.scales[scaleID];
        },

        /**
         * @private
         */
        _getValueScaleId: function () {
          return this.getMeta().yAxisID;
        },

        /**
         * @private
         */
        _getIndexScaleId: function () {
          return this.getMeta().xAxisID;
        },

        /**
         * @private
         */
        _getValueScale: function () {
          return this.getScaleForId(this._getValueScaleId());
        },

        /**
         * @private
         */
        _getIndexScale: function () {
          return this.getScaleForId(this._getIndexScaleId());
        },
        reset: function () {
          this.update(true);
        },

        /**
         * @private
         */
        destroy: function () {
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
        },
        createMetaDataset: function () {
          var me = this;
          var type = me.datasetElementType;
          return type && new type({
            _chart: me.chart,
            _datasetIndex: me.index
          });
        },
        createMetaData: function (index) {
          var me = this;
          var type = me.dataElementType;
          return type && new type({
            _chart: me.chart,
            _datasetIndex: me.index,
            _index: index
          });
        },
        addElements: function () {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data || [];
          var metaData = meta.data;
          var i, ilen;

          for (i = 0, ilen = data.length; i < ilen; ++i) {
            metaData[i] = metaData[i] || me.createMetaData(i);
          }

          meta.dataset = meta.dataset || me.createMetaDataset();
        },
        addElementAndReset: function (index) {
          var element = this.createMetaData(index);
          this.getMeta().data.splice(index, 0, element);
          this.updateElement(element, index, true);
        },
        buildOrUpdateElements: function () {
          var me = this;
          var dataset = me.getDataset();
          var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
          // real-time charts), we need to monitor these data modifications and synchronize
          // the internal meta data accordingly.

          if (me._data !== data) {
            if (me._data) {
              // This case happens when the user replaced the data array instance.
              unlistenArrayEvents(me._data, me);
            }

            if (data && Object.isExtensible(data)) {
              listenArrayEvents(data, me);
            }

            me._data = data;
          } // Re-sync meta data in case the user replaced the data array or if we missed
          // any updates and so make sure that we handle number of datapoints changing.


          me.resyncElements();
        },
        update: helpers$1.noop,
        transition: function (easingValue) {
          var meta = this.getMeta();
          var elements = meta.data || [];
          var ilen = elements.length;
          var i = 0;

          for (; i < ilen; ++i) {
            elements[i].transition(easingValue);
          }

          if (meta.dataset) {
            meta.dataset.transition(easingValue);
          }
        },
        draw: function () {
          var meta = this.getMeta();
          var elements = meta.data || [];
          var ilen = elements.length;
          var i = 0;

          if (meta.dataset) {
            meta.dataset.draw();
          }

          for (; i < ilen; ++i) {
            elements[i].draw();
          }
        },
        removeHoverStyle: function (element) {
          helpers$1.merge(element._model, element.$previousStyle || {});
          delete element.$previousStyle;
        },
        setHoverStyle: function (element) {
          var dataset = this.chart.data.datasets[element._datasetIndex];
          var index = element._index;
          var custom = element.custom || {};
          var model = element._model;
          var getHoverColor = helpers$1.getHoverColor;
          element.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth
          };
          model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
          model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
          model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
        },

        /**
         * @private
         */
        resyncElements: function () {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data;
          var numMeta = meta.data.length;
          var numData = data.length;

          if (numData < numMeta) {
            meta.data.splice(numData, numMeta - numData);
          } else if (numData > numMeta) {
            me.insertElements(numMeta, numData - numMeta);
          }
        },

        /**
         * @private
         */
        insertElements: function (start, count) {
          for (var i = 0; i < count; ++i) {
            this.addElementAndReset(start + i);
          }
        },

        /**
         * @private
         */
        onDataPush: function () {
          var count = arguments.length;
          this.insertElements(this.getDataset().data.length - count, count);
        },

        /**
         * @private
         */
        onDataPop: function () {
          this.getMeta().data.pop();
        },

        /**
         * @private
         */
        onDataShift: function () {
          this.getMeta().data.shift();
        },

        /**
         * @private
         */
        onDataSplice: function (start, count) {
          this.getMeta().data.splice(start, count);
          this.insertElements(start, arguments.length - 2);
        },

        /**
         * @private
         */
        onDataUnshift: function () {
          this.insertElements(0, arguments.length);
        }
      });
      DatasetController.extend = helpers$1.inherits;
      var core_datasetController = DatasetController;

      core_defaults._set('global', {
        elements: {
          arc: {
            backgroundColor: core_defaults.global.defaultColor,
            borderColor: '#fff',
            borderWidth: 2,
            borderAlign: 'center'
          }
        }
      });

      var element_arc = core_element.extend({
        inLabelRange: function (mouseX) {
          var vm = this._view;

          if (vm) {
            return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
          }

          return false;
        },
        inRange: function (chartX, chartY) {
          var vm = this._view;

          if (vm) {
            var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
              x: chartX,
              y: chartY
            });
            var angle = pointRelativePosition.angle;
            var distance = pointRelativePosition.distance; // Sanitise angle range

            var startAngle = vm.startAngle;
            var endAngle = vm.endAngle;

            while (endAngle < startAngle) {
              endAngle += 2.0 * Math.PI;
            }

            while (angle > endAngle) {
              angle -= 2.0 * Math.PI;
            }

            while (angle < startAngle) {
              angle += 2.0 * Math.PI;
            } // Check if within the range of the open/close angle


            var betweenAngles = angle >= startAngle && angle <= endAngle;
            var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
            return betweenAngles && withinRadius;
          }

          return false;
        },
        getCenterPoint: function () {
          var vm = this._view;
          var halfAngle = (vm.startAngle + vm.endAngle) / 2;
          var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
          return {
            x: vm.x + Math.cos(halfAngle) * halfRadius,
            y: vm.y + Math.sin(halfAngle) * halfRadius
          };
        },
        getArea: function () {
          var vm = this._view;
          return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
        },
        tooltipPosition: function () {
          var vm = this._view;
          var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
          var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
          return {
            x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
            y: vm.y + Math.sin(centreAngle) * rangeFromCentre
          };
        },
        draw: function () {
          var ctx = this._chart.ctx;
          var vm = this._view;
          var sA = vm.startAngle;
          var eA = vm.endAngle;
          var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
          var angleMargin;
          ctx.save();
          ctx.beginPath();
          ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
          ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
          ctx.closePath();
          ctx.fillStyle = vm.backgroundColor;
          ctx.fill();

          if (vm.borderWidth) {
            if (vm.borderAlign === 'inner') {
              // Draw an inner border by cliping the arc and drawing a double-width border
              // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
              ctx.beginPath();
              angleMargin = pixelMargin / vm.outerRadius;
              ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

              if (vm.innerRadius > pixelMargin) {
                angleMargin = pixelMargin / vm.innerRadius;
                ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
              } else {
                ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
              }

              ctx.closePath();
              ctx.clip();
              ctx.beginPath();
              ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
              ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
              ctx.closePath();
              ctx.lineWidth = vm.borderWidth * 2;
              ctx.lineJoin = 'round';
            } else {
              ctx.lineWidth = vm.borderWidth;
              ctx.lineJoin = 'bevel';
            }

            ctx.strokeStyle = vm.borderColor;
            ctx.stroke();
          }

          ctx.restore();
        }
      });
      var valueOrDefault$1 = helpers$1.valueOrDefault;
      var defaultColor = core_defaults.global.defaultColor;

      core_defaults._set('global', {
        elements: {
          line: {
            tension: 0.4,
            backgroundColor: defaultColor,
            borderWidth: 3,
            borderColor: defaultColor,
            borderCapStyle: 'butt',
            borderDash: [],
            borderDashOffset: 0.0,
            borderJoinStyle: 'miter',
            capBezierPoints: true,
            fill: true // do we fill in the area between the line and its base axis

          }
        }
      });

      var element_line = core_element.extend({
        draw: function () {
          var me = this;
          var vm = me._view;
          var ctx = me._chart.ctx;
          var spanGaps = vm.spanGaps;

          var points = me._children.slice(); // clone array


          var globalDefaults = core_defaults.global;
          var globalOptionLineElements = globalDefaults.elements.line;
          var lastDrawnIndex = -1;
          var index, current, previous, currentVM; // If we are looping, adding the first point again

          if (me._loop && points.length) {
            points.push(points[0]);
          }

          ctx.save(); // Stroke Line Options

          ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

          if (ctx.setLineDash) {
            ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
          }

          ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
          ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
          ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
          ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

          ctx.beginPath();
          lastDrawnIndex = -1;

          for (index = 0; index < points.length; ++index) {
            current = points[index];
            previous = helpers$1.previousItem(points, index);
            currentVM = current._view; // First point moves to it's starting position no matter what

            if (index === 0) {
              if (!currentVM.skip) {
                ctx.moveTo(currentVM.x, currentVM.y);
                lastDrawnIndex = index;
              }
            } else {
              previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

              if (!currentVM.skip) {
                if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                  // There was a gap and this is the first point after the gap
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  // Line to next point
                  helpers$1.canvas.lineTo(ctx, previous._view, current._view);
                }

                lastDrawnIndex = index;
              }
            }
          }

          ctx.stroke();
          ctx.restore();
        }
      });
      var valueOrDefault$2 = helpers$1.valueOrDefault;
      var defaultColor$1 = core_defaults.global.defaultColor;

      core_defaults._set('global', {
        elements: {
          point: {
            radius: 3,
            pointStyle: 'circle',
            backgroundColor: defaultColor$1,
            borderColor: defaultColor$1,
            borderWidth: 1,
            // Hover
            hitRadius: 1,
            hoverRadius: 4,
            hoverBorderWidth: 1
          }
        }
      });

      function xRange(mouseX) {
        var vm = this._view;
        return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
      }

      function yRange(mouseY) {
        var vm = this._view;
        return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
      }

      var element_point = core_element.extend({
        inRange: function (mouseX, mouseY) {
          var vm = this._view;
          return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
        },
        inLabelRange: xRange,
        inXRange: xRange,
        inYRange: yRange,
        getCenterPoint: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y
          };
        },
        getArea: function () {
          return Math.PI * Math.pow(this._view.radius, 2);
        },
        tooltipPosition: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y,
            padding: vm.radius + vm.borderWidth
          };
        },
        draw: function (chartArea) {
          var vm = this._view;
          var ctx = this._chart.ctx;
          var pointStyle = vm.pointStyle;
          var rotation = vm.rotation;
          var radius = vm.radius;
          var x = vm.x;
          var y = vm.y;
          var globalDefaults = core_defaults.global;
          var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

          if (vm.skip) {
            return;
          } // Clipping for Points.


          if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
            ctx.strokeStyle = vm.borderColor || defaultColor;
            ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
            ctx.fillStyle = vm.backgroundColor || defaultColor;
            helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
          }
        }
      });
      var defaultColor$2 = core_defaults.global.defaultColor;

      core_defaults._set('global', {
        elements: {
          rectangle: {
            backgroundColor: defaultColor$2,
            borderColor: defaultColor$2,
            borderSkipped: 'bottom',
            borderWidth: 0
          }
        }
      });

      function isVertical(vm) {
        return vm && vm.width !== undefined;
      }
      /**
       * Helper function to get the bounds of the bar regardless of the orientation
       * @param bar {Chart.Element.Rectangle} the bar
       * @return {Bounds} bounds of the bar
       * @private
       */


      function getBarBounds(vm) {
        var x1, x2, y1, y2, half;

        if (isVertical(vm)) {
          half = vm.width / 2;
          x1 = vm.x - half;
          x2 = vm.x + half;
          y1 = Math.min(vm.y, vm.base);
          y2 = Math.max(vm.y, vm.base);
        } else {
          half = vm.height / 2;
          x1 = Math.min(vm.x, vm.base);
          x2 = Math.max(vm.x, vm.base);
          y1 = vm.y - half;
          y2 = vm.y + half;
        }

        return {
          left: x1,
          top: y1,
          right: x2,
          bottom: y2
        };
      }

      function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
      }

      function parseBorderSkipped(vm) {
        var edge = vm.borderSkipped;
        var res = {};

        if (!edge) {
          return res;
        }

        if (vm.horizontal) {
          if (vm.base > vm.x) {
            edge = swap(edge, 'left', 'right');
          }
        } else if (vm.base < vm.y) {
          edge = swap(edge, 'bottom', 'top');
        }

        res[edge] = true;
        return res;
      }

      function parseBorderWidth(vm, maxW, maxH) {
        var value = vm.borderWidth;
        var skip = parseBorderSkipped(vm);
        var t, r, b, l;

        if (helpers$1.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
          r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
          b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
          l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
        };
      }

      function boundingRects(vm) {
        var bounds = getBarBounds(vm);
        var width = bounds.right - bounds.left;
        var height = bounds.bottom - bounds.top;
        var border = parseBorderWidth(vm, width / 2, height / 2);
        return {
          outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height
          },
          inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b
          }
        };
      }

      function inRange(vm, x, y) {
        var skipX = x === null;
        var skipY = y === null;
        var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
        return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
      }

      var element_rectangle = core_element.extend({
        draw: function () {
          var ctx = this._chart.ctx;
          var vm = this._view;
          var rects = boundingRects(vm);
          var outer = rects.outer;
          var inner = rects.inner;
          ctx.fillStyle = vm.backgroundColor;
          ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

          if (outer.w === inner.w && outer.h === inner.h) {
            return;
          }

          ctx.save();
          ctx.beginPath();
          ctx.rect(outer.x, outer.y, outer.w, outer.h);
          ctx.clip();
          ctx.fillStyle = vm.borderColor;
          ctx.rect(inner.x, inner.y, inner.w, inner.h);
          ctx.fill('evenodd');
          ctx.restore();
        },
        height: function () {
          var vm = this._view;
          return vm.base - vm.y;
        },
        inRange: function (mouseX, mouseY) {
          return inRange(this._view, mouseX, mouseY);
        },
        inLabelRange: function (mouseX, mouseY) {
          var vm = this._view;
          return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
        },
        inXRange: function (mouseX) {
          return inRange(this._view, mouseX, null);
        },
        inYRange: function (mouseY) {
          return inRange(this._view, null, mouseY);
        },
        getCenterPoint: function () {
          var vm = this._view;
          var x, y;

          if (isVertical(vm)) {
            x = vm.x;
            y = (vm.y + vm.base) / 2;
          } else {
            x = (vm.x + vm.base) / 2;
            y = vm.y;
          }

          return {
            x: x,
            y: y
          };
        },
        getArea: function () {
          var vm = this._view;
          return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
        },
        tooltipPosition: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y
          };
        }
      });
      var elements = {};
      var Arc = element_arc;
      var Line = element_line;
      var Point = element_point;
      var Rectangle = element_rectangle;
      elements.Arc = Arc;
      elements.Line = Line;
      elements.Point = Point;
      elements.Rectangle = Rectangle;
      var resolve$1 = helpers$1.options.resolve;

      core_defaults._set('bar', {
        hover: {
          mode: 'label'
        },
        scales: {
          xAxes: [{
            type: 'category',
            categoryPercentage: 0.8,
            barPercentage: 0.9,
            offset: true,
            gridLines: {
              offsetGridLines: true
            }
          }],
          yAxes: [{
            type: 'linear'
          }]
        }
      });
      /**
       * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
       * @private
       */


      function computeMinSampleSize(scale, pixels) {
        var min = scale.isHorizontal() ? scale.width : scale.height;
        var ticks = scale.getTicks();
        var prev, curr, i, ilen;

        for (i = 1, ilen = pixels.length; i < ilen; ++i) {
          min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
        }

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          curr = scale.getPixelForTick(i);
          min = i > 0 ? Math.min(min, curr - prev) : min;
          prev = curr;
        }

        return min;
      }
      /**
       * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
       * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
       * mode currently always generates bars equally sized (until we introduce scriptable options?).
       * @private
       */


      function computeFitCategoryTraits(index, ruler, options) {
        var thickness = options.barThickness;
        var count = ruler.stackCount;
        var curr = ruler.pixels[index];
        var size, ratio;

        if (helpers$1.isNullOrUndef(thickness)) {
          size = ruler.min * options.categoryPercentage;
          ratio = options.barPercentage;
        } else {
          // When bar thickness is enforced, category and bar percentages are ignored.
          // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
          // and deprecate barPercentage since this value is ignored when thickness is absolute.
          size = thickness * count;
          ratio = 1;
        }

        return {
          chunk: size / count,
          ratio: ratio,
          start: curr - size / 2
        };
      }
      /**
       * Computes an "optimal" category that globally arranges bars side by side (no gap when
       * percentage options are 1), based on the previous and following categories. This mode
       * generates bars with different widths when data are not evenly spaced.
       * @private
       */


      function computeFlexCategoryTraits(index, ruler, options) {
        var pixels = ruler.pixels;
        var curr = pixels[index];
        var prev = index > 0 ? pixels[index - 1] : null;
        var next = index < pixels.length - 1 ? pixels[index + 1] : null;
        var percent = options.categoryPercentage;
        var start, size;

        if (prev === null) {
          // first data: its size is double based on the next point or,
          // if it's also the last data, we use the scale size.
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }

        if (next === null) {
          // last data: its size is also double based on the previous point.
          next = curr + curr - prev;
        }

        start = curr - (curr - Math.min(prev, next)) / 2 * percent;
        size = Math.abs(next - prev) / 2 * percent;
        return {
          chunk: size / ruler.stackCount,
          ratio: options.barPercentage,
          start: start
        };
      }

      var controller_bar = core_datasetController.extend({
        dataElementType: elements.Rectangle,
        initialize: function () {
          var me = this;
          var meta;
          core_datasetController.prototype.initialize.apply(me, arguments);
          meta = me.getMeta();
          meta.stack = me.getDataset().stack;
          meta.bar = true;
        },
        update: function (reset) {
          var me = this;
          var rects = me.getMeta().data;
          var i, ilen;
          me._ruler = me.getRuler();

          for (i = 0, ilen = rects.length; i < ilen; ++i) {
            me.updateElement(rects[i], i, reset);
          }
        },
        updateElement: function (rectangle, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var dataset = me.getDataset();

          var options = me._resolveElementOptions(rectangle, index);

          rectangle._xScale = me.getScaleForId(meta.xAxisID);
          rectangle._yScale = me.getScaleForId(meta.yAxisID);
          rectangle._datasetIndex = me.index;
          rectangle._index = index;
          rectangle._model = {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderSkipped: options.borderSkipped,
            borderWidth: options.borderWidth,
            datasetLabel: dataset.label,
            label: me.chart.data.labels[index]
          };

          me._updateElementGeometry(rectangle, index, reset);

          rectangle.pivot();
        },

        /**
         * @private
         */
        _updateElementGeometry: function (rectangle, index, reset) {
          var me = this;
          var model = rectangle._model;

          var vscale = me._getValueScale();

          var base = vscale.getBasePixel();
          var horizontal = vscale.isHorizontal();
          var ruler = me._ruler || me.getRuler();
          var vpixels = me.calculateBarValuePixels(me.index, index);
          var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
          model.horizontal = horizontal;
          model.base = reset ? base : vpixels.base;
          model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
          model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
          model.height = horizontal ? ipixels.size : undefined;
          model.width = horizontal ? undefined : ipixels.size;
        },

        /**
         * Returns the stacks based on groups and bar visibility.
         * @param {number} [last] - The dataset index
         * @returns {string[]} The list of stack IDs
         * @private
         */
        _getStacks: function (last) {
          var me = this;
          var chart = me.chart;

          var scale = me._getIndexScale();

          var stacked = scale.options.stacked;
          var ilen = last === undefined ? chart.data.datasets.length : last + 1;
          var stacks = [];
          var i, meta;

          for (i = 0; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);

            if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
              stacks.push(meta.stack);
            }
          }

          return stacks;
        },

        /**
         * Returns the effective number of stacks based on groups and bar visibility.
         * @private
         */
        getStackCount: function () {
          return this._getStacks().length;
        },

        /**
         * Returns the stack index for the given dataset based on groups and bar visibility.
         * @param {number} [datasetIndex] - The dataset index
         * @param {string} [name] - The stack name to find
         * @returns {number} The stack index
         * @private
         */
        getStackIndex: function (datasetIndex, name) {
          var stacks = this._getStacks(datasetIndex);

          var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

          return index === -1 ? stacks.length - 1 : index;
        },

        /**
         * @private
         */
        getRuler: function () {
          var me = this;

          var scale = me._getIndexScale();

          var stackCount = me.getStackCount();
          var datasetIndex = me.index;
          var isHorizontal = scale.isHorizontal();
          var start = isHorizontal ? scale.left : scale.top;
          var end = start + (isHorizontal ? scale.width : scale.height);
          var pixels = [];
          var i, ilen, min;

          for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
            pixels.push(scale.getPixelForValue(null, i, datasetIndex));
          }

          min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
          return {
            min: min,
            pixels: pixels,
            start: start,
            end: end,
            stackCount: stackCount,
            scale: scale
          };
        },

        /**
         * Note: pixel values are not clamped to the scale area.
         * @private
         */
        calculateBarValuePixels: function (datasetIndex, index) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();

          var scale = me._getValueScale();

          var isHorizontal = scale.isHorizontal();
          var datasets = chart.data.datasets;
          var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
          var minBarLength = scale.options.minBarLength;
          var stacked = scale.options.stacked;
          var stack = meta.stack;
          var start = 0;
          var i, imeta, ivalue, base, head, size;

          if (stacked || stacked === undefined && stack !== undefined) {
            for (i = 0; i < datasetIndex; ++i) {
              imeta = chart.getDatasetMeta(i);

              if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
                ivalue = +scale.getRightValue(datasets[i].data[index]);

                if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                  start += ivalue;
                }
              }
            }
          }

          base = scale.getPixelForValue(start);
          head = scale.getPixelForValue(start + value);
          size = head - base;

          if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
            size = minBarLength;

            if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
              head = base - minBarLength;
            } else {
              head = base + minBarLength;
            }
          }

          return {
            size: size,
            base: base,
            head: head,
            center: head + size / 2
          };
        },

        /**
         * @private
         */
        calculateBarIndexPixels: function (datasetIndex, index, ruler) {
          var me = this;
          var options = ruler.scale.options;
          var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
          var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
          var center = range.start + range.chunk * stackIndex + range.chunk / 2;
          var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
          return {
            base: center - size / 2,
            head: center + size / 2,
            center: center,
            size: size
          };
        },
        draw: function () {
          var me = this;
          var chart = me.chart;

          var scale = me._getValueScale();

          var rects = me.getMeta().data;
          var dataset = me.getDataset();
          var ilen = rects.length;
          var i = 0;
          helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

          for (; i < ilen; ++i) {
            if (!isNaN(scale.getRightValue(dataset.data[i]))) {
              rects[i].draw();
            }
          }

          helpers$1.canvas.unclipArea(chart.ctx);
        },

        /**
         * @private
         */
        _resolveElementOptions: function (rectangle, index) {
          var me = this;
          var chart = me.chart;
          var datasets = chart.data.datasets;
          var dataset = datasets[me.index];
          var custom = rectangle.custom || {};
          var options = chart.options.elements.rectangle;
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
          }

          return values;
        }
      });
      var valueOrDefault$3 = helpers$1.valueOrDefault;
      var resolve$2 = helpers$1.options.resolve;

      core_defaults._set('bubble', {
        hover: {
          mode: 'single'
        },
        scales: {
          xAxes: [{
            type: 'linear',
            // bubble should probably use a linear scale by default
            position: 'bottom',
            id: 'x-axis-0' // need an ID so datasets can reference the scale

          }],
          yAxes: [{
            type: 'linear',
            position: 'left',
            id: 'y-axis-0'
          }]
        },
        tooltips: {
          callbacks: {
            title: function () {
              // Title doesn't make sense for scatter since we format the data as a point
              return '';
            },
            label: function (item, data) {
              var datasetLabel = data.datasets[item.datasetIndex].label || '';
              var dataPoint = data.datasets[item.datasetIndex].data[item.index];
              return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
            }
          }
        }
      });

      var controller_bubble = core_datasetController.extend({
        /**
         * @protected
         */
        dataElementType: elements.Point,

        /**
         * @protected
         */
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var points = meta.data; // Update Points

          helpers$1.each(points, function (point, index) {
            me.updateElement(point, index, reset);
          });
        },

        /**
         * @protected
         */
        updateElement: function (point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var custom = point.custom || {};
          var xScale = me.getScaleForId(meta.xAxisID);
          var yScale = me.getScaleForId(meta.yAxisID);

          var options = me._resolveElementOptions(point, index);

          var data = me.getDataset().data[index];
          var dsIndex = me.index;
          var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
          var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
          point._xScale = xScale;
          point._yScale = yScale;
          point._options = options;
          point._datasetIndex = dsIndex;
          point._index = index;
          point._model = {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            hitRadius: options.hitRadius,
            pointStyle: options.pointStyle,
            rotation: options.rotation,
            radius: reset ? 0 : options.radius,
            skip: custom.skip || isNaN(x) || isNaN(y),
            x: x,
            y: y
          };
          point.pivot();
        },

        /**
         * @protected
         */
        setHoverStyle: function (point) {
          var model = point._model;
          var options = point._options;
          var getHoverColor = helpers$1.getHoverColor;
          point.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth,
            radius: model.radius
          };
          model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
          model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
          model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
          model.radius = options.radius + options.hoverRadius;
        },

        /**
         * @private
         */
        _resolveElementOptions: function (point, index) {
          var me = this;
          var chart = me.chart;
          var datasets = chart.data.datasets;
          var dataset = datasets[me.index];
          var custom = point.custom || {};
          var options = chart.options.elements.point;
          var data = dataset.data[index];
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
          } // Custom radius resolution


          values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
          return values;
        }
      });
      var resolve$3 = helpers$1.options.resolve;
      var valueOrDefault$4 = helpers$1.valueOrDefault;

      core_defaults._set('doughnut', {
        animation: {
          // Boolean - Whether we animate the rotation of the Doughnut
          animateRotate: true,
          // Boolean - Whether we animate scaling the Doughnut from the centre
          animateScale: false
        },
        hover: {
          mode: 'single'
        },
        legendCallback: function (chart) {
          var text = [];
          text.push('<ul class="' + chart.id + '-legend">');
          var data = chart.data;
          var datasets = data.datasets;
          var labels = data.labels;

          if (datasets.length) {
            for (var i = 0; i < datasets[0].data.length; ++i) {
              text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

              if (labels[i]) {
                text.push(labels[i]);
              }

              text.push('</li>');
            }
          }

          text.push('</ul>');
          return text.join('');
        },
        legend: {
          labels: {
            generateLabels: function (chart) {
              var data = chart.data;

              if (data.labels.length && data.datasets.length) {
                return data.labels.map(function (label, i) {
                  var meta = chart.getDatasetMeta(0);
                  var ds = data.datasets[0];
                  var arc = meta.data[i];
                  var custom = arc && arc.custom || {};
                  var arcOpts = chart.options.elements.arc;
                  var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                  var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                  var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                  return {
                    text: label,
                    fillStyle: fill,
                    strokeStyle: stroke,
                    lineWidth: bw,
                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                    // Extra data used for toggling the correct item
                    index: i
                  };
                });
              }

              return [];
            }
          },
          onClick: function (e, legendItem) {
            var index = legendItem.index;
            var chart = this.chart;
            var i, ilen, meta;

            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

              if (meta.data[index]) {
                meta.data[index].hidden = !meta.data[index].hidden;
              }
            }

            chart.update();
          }
        },
        // The percentage of the chart that we cut out of the middle.
        cutoutPercentage: 50,
        // The rotation of the chart, where the first data arc begins.
        rotation: Math.PI * -0.5,
        // The total circumference of the chart.
        circumference: Math.PI * 2.0,
        // Need to override these to give a nice default
        tooltips: {
          callbacks: {
            title: function () {
              return '';
            },
            label: function (tooltipItem, data) {
              var dataLabel = data.labels[tooltipItem.index];
              var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

              if (helpers$1.isArray(dataLabel)) {
                // show value on first line of multiline label
                // need to clone because we are changing the value
                dataLabel = dataLabel.slice();
                dataLabel[0] += value;
              } else {
                dataLabel += value;
              }

              return dataLabel;
            }
          }
        }
      });

      var controller_doughnut = core_datasetController.extend({
        dataElementType: elements.Arc,
        linkScales: helpers$1.noop,
        // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
        getRingIndex: function (datasetIndex) {
          var ringIndex = 0;

          for (var j = 0; j < datasetIndex; ++j) {
            if (this.chart.isDatasetVisible(j)) {
              ++ringIndex;
            }
          }

          return ringIndex;
        },
        update: function (reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var opts = chart.options;
          var availableWidth = chartArea.right - chartArea.left;
          var availableHeight = chartArea.bottom - chartArea.top;
          var minSize = Math.min(availableWidth, availableHeight);
          var offset = {
            x: 0,
            y: 0
          };
          var meta = me.getMeta();
          var arcs = meta.data;
          var cutoutPercentage = opts.cutoutPercentage;
          var circumference = opts.circumference;

          var chartWeight = me._getRingWeight(me.index);

          var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

          if (circumference < Math.PI * 2.0) {
            var startAngle = opts.rotation % (Math.PI * 2.0);
            startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
            var endAngle = startAngle + circumference;
            var start = {
              x: Math.cos(startAngle),
              y: Math.sin(startAngle)
            };
            var end = {
              x: Math.cos(endAngle),
              y: Math.sin(endAngle)
            };
            var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
            var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
            var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
            var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
            var cutout = cutoutPercentage / 100.0;
            var min = {
              x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
              y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
            };
            var max = {
              x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
              y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
            };
            var size = {
              width: (max.x - min.x) * 0.5,
              height: (max.y - min.y) * 0.5
            };
            minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
            offset = {
              x: (max.x + min.x) * -0.5,
              y: (max.y + min.y) * -0.5
            };
          }

          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          }

          chart.borderWidth = me.getMaxBorderWidth();
          chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
          chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
          chart.offsetX = offset.x * chart.outerRadius;
          chart.offsetY = offset.y * chart.outerRadius;
          meta.total = me.calculateTotal();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
          me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            me.updateElement(arcs[i], i, reset);
          }
        },
        updateElement: function (arc, index, reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var opts = chart.options;
          var animationOpts = opts.animation;
          var centerX = (chartArea.left + chartArea.right) / 2;
          var centerY = (chartArea.top + chartArea.bottom) / 2;
          var startAngle = opts.rotation; // non reset case handled later

          var endAngle = opts.rotation; // non reset case handled later

          var dataset = me.getDataset();
          var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
          var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
          var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
          var options = arc._options || {};
          helpers$1.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            // Desired view properties
            _model: {
              backgroundColor: options.backgroundColor,
              borderColor: options.borderColor,
              borderWidth: options.borderWidth,
              borderAlign: options.borderAlign,
              x: centerX + chart.offsetX,
              y: centerY + chart.offsetY,
              startAngle: startAngle,
              endAngle: endAngle,
              circumference: circumference,
              outerRadius: outerRadius,
              innerRadius: innerRadius,
              label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
            }
          });
          var model = arc._model; // Set correct angles if not resetting

          if (!reset || !animationOpts.animateRotate) {
            if (index === 0) {
              model.startAngle = opts.rotation;
            } else {
              model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
            }

            model.endAngle = model.startAngle + model.circumference;
          }

          arc.pivot();
        },
        calculateTotal: function () {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var total = 0;
          var value;
          helpers$1.each(meta.data, function (element, index) {
            value = dataset.data[index];

            if (!isNaN(value) && !element.hidden) {
              total += Math.abs(value);
            }
          });
          /* if (total === 0) {
          	total = NaN;
          }*/

          return total;
        },
        calculateCircumference: function (value) {
          var total = this.getMeta().total;

          if (total > 0 && !isNaN(value)) {
            return Math.PI * 2.0 * (Math.abs(value) / total);
          }

          return 0;
        },
        // gets the max border or hover width to properly scale pie charts
        getMaxBorderWidth: function (arcs) {
          var me = this;
          var max = 0;
          var chart = me.chart;
          var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

          if (!arcs) {
            // Find the outmost visible dataset
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;

                if (i !== me.index) {
                  controller = meta.controller;
                }

                break;
              }
            }
          }

          if (!arcs) {
            return 0;
          }

          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            arc = arcs[i];
            options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

            if (options.borderAlign !== 'inner') {
              borderWidth = options.borderWidth;
              hoverWidth = options.hoverBorderWidth;
              max = borderWidth > max ? borderWidth : max;
              max = hoverWidth > max ? hoverWidth : max;
            }
          }

          return max;
        },

        /**
         * @protected
         */
        setHoverStyle: function (arc) {
          var model = arc._model;
          var options = arc._options;
          var getHoverColor = helpers$1.getHoverColor;
          arc.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth
          };
          model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
          model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
          model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
        },

        /**
         * @private
         */
        _resolveElementOptions: function (arc, index) {
          var me = this;
          var chart = me.chart;
          var dataset = me.getDataset();
          var custom = arc.custom || {};
          var options = chart.options.elements.arc;
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
          }

          return values;
        },

        /**
         * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
         * @private
         */
        _getRingWeightOffset: function (datasetIndex) {
          var ringWeightOffset = 0;

          for (var i = 0; i < datasetIndex; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              ringWeightOffset += this._getRingWeight(i);
            }
          }

          return ringWeightOffset;
        },

        /**
         * @private
         */
        _getRingWeight: function (dataSetIndex) {
          return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
        },

        /**
         * Returns the sum of all visibile data set weights.  This value can be 0.
         * @private
         */
        _getVisibleDatasetWeightTotal: function () {
          return this._getRingWeightOffset(this.chart.data.datasets.length);
        }
      });

      core_defaults._set('horizontalBar', {
        hover: {
          mode: 'index',
          axis: 'y'
        },
        scales: {
          xAxes: [{
            type: 'linear',
            position: 'bottom'
          }],
          yAxes: [{
            type: 'category',
            position: 'left',
            categoryPercentage: 0.8,
            barPercentage: 0.9,
            offset: true,
            gridLines: {
              offsetGridLines: true
            }
          }]
        },
        elements: {
          rectangle: {
            borderSkipped: 'left'
          }
        },
        tooltips: {
          mode: 'index',
          axis: 'y'
        }
      });

      var controller_horizontalBar = controller_bar.extend({
        /**
         * @private
         */
        _getValueScaleId: function () {
          return this.getMeta().xAxisID;
        },

        /**
         * @private
         */
        _getIndexScaleId: function () {
          return this.getMeta().yAxisID;
        }
      });
      var valueOrDefault$5 = helpers$1.valueOrDefault;
      var resolve$4 = helpers$1.options.resolve;
      var isPointInArea = helpers$1.canvas._isPointInArea;

      core_defaults._set('line', {
        showLines: true,
        spanGaps: false,
        hover: {
          mode: 'label'
        },
        scales: {
          xAxes: [{
            type: 'category',
            id: 'x-axis-0'
          }],
          yAxes: [{
            type: 'linear',
            id: 'y-axis-0'
          }]
        }
      });

      function lineEnabled(dataset, options) {
        return valueOrDefault$5(dataset.showLine, options.showLines);
      }

      var controller_line = core_datasetController.extend({
        datasetElementType: elements.Line,
        dataElementType: elements.Point,
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data || [];
          var scale = me.getScaleForId(meta.yAxisID);
          var dataset = me.getDataset();
          var showLine = lineEnabled(dataset, me.chart.options);
          var i, ilen; // Update Line

          if (showLine) {
            // Compatibility: If the properties are defined with only the old name, use those values
            if (dataset.tension !== undefined && dataset.lineTension === undefined) {
              dataset.lineTension = dataset.tension;
            } // Utility


            line._scale = scale;
            line._datasetIndex = me.index; // Data

            line._children = points; // Model

            line._model = me._resolveLineOptions(line);
            line.pivot();
          } // Update Points


          for (i = 0, ilen = points.length; i < ilen; ++i) {
            me.updateElement(points[i], i, reset);
          }

          if (showLine && line._model.tension !== 0) {
            me.updateBezierControlPoints();
          } // Now pivot the point for animation


          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].pivot();
          }
        },
        updateElement: function (point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var datasetIndex = me.index;
          var value = dataset.data[index];
          var yScale = me.getScaleForId(meta.yAxisID);
          var xScale = me.getScaleForId(meta.xAxisID);
          var lineModel = meta.dataset._model;
          var x, y;

          var options = me._resolvePointOptions(point, index);

          x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
          y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

          point._xScale = xScale;
          point._yScale = yScale;
          point._options = options;
          point._datasetIndex = datasetIndex;
          point._index = index; // Desired view properties

          point._model = {
            x: x,
            y: y,
            skip: custom.skip || isNaN(x) || isNaN(y),
            // Appearance
            radius: options.radius,
            pointStyle: options.pointStyle,
            rotation: options.rotation,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
            steppedLine: lineModel ? lineModel.steppedLine : false,
            // Tooltip
            hitRadius: options.hitRadius
          };
        },

        /**
         * @private
         */
        _resolvePointOptions: function (element, index) {
          var me = this;
          var chart = me.chart;
          var dataset = chart.data.datasets[me.index];
          var custom = element.custom || {};
          var options = chart.options.elements.point;
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var ELEMENT_OPTIONS = {
            backgroundColor: 'pointBackgroundColor',
            borderColor: 'pointBorderColor',
            borderWidth: 'pointBorderWidth',
            hitRadius: 'pointHitRadius',
            hoverBackgroundColor: 'pointHoverBackgroundColor',
            hoverBorderColor: 'pointHoverBorderColor',
            hoverBorderWidth: 'pointHoverBorderWidth',
            hoverRadius: 'pointHoverRadius',
            pointStyle: 'pointStyle',
            radius: 'pointRadius',
            rotation: 'pointRotation'
          };
          var keys = Object.keys(ELEMENT_OPTIONS);

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
          }

          return values;
        },

        /**
         * @private
         */
        _resolveLineOptions: function (element) {
          var me = this;
          var chart = me.chart;
          var dataset = chart.data.datasets[me.index];
          var custom = element.custom || {};
          var options = chart.options;
          var elementOptions = options.elements.line;
          var values = {};
          var i, ilen, key;
          var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
          } // The default behavior of lines is to break at null values, according
          // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
          // This option gives lines the ability to span gaps


          values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
          values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
          values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
          return values;
        },
        calculatePointY: function (value, index, datasetIndex) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var sumPos = 0;
          var sumNeg = 0;
          var i, ds, dsMeta;

          if (yScale.options.stacked) {
            for (i = 0; i < datasetIndex; i++) {
              ds = chart.data.datasets[i];
              dsMeta = chart.getDatasetMeta(i);

              if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
                var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

                if (stackedRightValue < 0) {
                  sumNeg += stackedRightValue || 0;
                } else {
                  sumPos += stackedRightValue || 0;
                }
              }
            }

            var rightValue = Number(yScale.getRightValue(value));

            if (rightValue < 0) {
              return yScale.getPixelForValue(sumNeg + rightValue);
            }

            return yScale.getPixelForValue(sumPos + rightValue);
          }

          return yScale.getPixelForValue(value);
        },
        updateBezierControlPoints: function () {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var lineModel = meta.dataset._model;
          var area = chart.chartArea;
          var points = meta.data || [];
          var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

          if (lineModel.spanGaps) {
            points = points.filter(function (pt) {
              return !pt._model.skip;
            });
          }

          function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min);
          }

          if (lineModel.cubicInterpolationMode === 'monotone') {
            helpers$1.splineCurveMonotone(points);
          } else {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
              model.controlPointPreviousX = controlPoints.previous.x;
              model.controlPointPreviousY = controlPoints.previous.y;
              model.controlPointNextX = controlPoints.next.x;
              model.controlPointNextY = controlPoints.next.y;
            }
          }

          if (chart.options.elements.line.capBezierPoints) {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;

              if (isPointInArea(model, area)) {
                if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                  model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                  model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                }

                if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                  model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                  model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                }
              }
            }
          }
        },
        draw: function () {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var points = meta.data || [];
          var area = chart.chartArea;
          var ilen = points.length;
          var halfBorderWidth;
          var i = 0;

          if (lineEnabled(me.getDataset(), chart.options)) {
            halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
            helpers$1.canvas.clipArea(chart.ctx, {
              left: area.left,
              right: area.right,
              top: area.top - halfBorderWidth,
              bottom: area.bottom + halfBorderWidth
            });
            meta.dataset.draw();
            helpers$1.canvas.unclipArea(chart.ctx);
          } // Draw the points


          for (; i < ilen; ++i) {
            points[i].draw(area);
          }
        },

        /**
         * @protected
         */
        setHoverStyle: function (point) {
          var model = point._model;
          var options = point._options;
          var getHoverColor = helpers$1.getHoverColor;
          point.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth,
            radius: model.radius
          };
          model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
          model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
          model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
          model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
        }
      });
      var resolve$5 = helpers$1.options.resolve;

      core_defaults._set('polarArea', {
        scale: {
          type: 'radialLinear',
          angleLines: {
            display: false
          },
          gridLines: {
            circular: true
          },
          pointLabels: {
            display: false
          },
          ticks: {
            beginAtZero: true
          }
        },
        // Boolean - Whether to animate the rotation of the chart
        animation: {
          animateRotate: true,
          animateScale: true
        },
        startAngle: -0.5 * Math.PI,
        legendCallback: function (chart) {
          var text = [];
          text.push('<ul class="' + chart.id + '-legend">');
          var data = chart.data;
          var datasets = data.datasets;
          var labels = data.labels;

          if (datasets.length) {
            for (var i = 0; i < datasets[0].data.length; ++i) {
              text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

              if (labels[i]) {
                text.push(labels[i]);
              }

              text.push('</li>');
            }
          }

          text.push('</ul>');
          return text.join('');
        },
        legend: {
          labels: {
            generateLabels: function (chart) {
              var data = chart.data;

              if (data.labels.length && data.datasets.length) {
                return data.labels.map(function (label, i) {
                  var meta = chart.getDatasetMeta(0);
                  var ds = data.datasets[0];
                  var arc = meta.data[i];
                  var custom = arc.custom || {};
                  var arcOpts = chart.options.elements.arc;
                  var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                  var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                  var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                  return {
                    text: label,
                    fillStyle: fill,
                    strokeStyle: stroke,
                    lineWidth: bw,
                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                    // Extra data used for toggling the correct item
                    index: i
                  };
                });
              }

              return [];
            }
          },
          onClick: function (e, legendItem) {
            var index = legendItem.index;
            var chart = this.chart;
            var i, ilen, meta;

            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              meta = chart.getDatasetMeta(i);
              meta.data[index].hidden = !meta.data[index].hidden;
            }

            chart.update();
          }
        },
        // Need to override these to give a nice default
        tooltips: {
          callbacks: {
            title: function () {
              return '';
            },
            label: function (item, data) {
              return data.labels[item.index] + ': ' + item.yLabel;
            }
          }
        }
      });

      var controller_polarArea = core_datasetController.extend({
        dataElementType: elements.Arc,
        linkScales: helpers$1.noop,
        update: function (reset) {
          var me = this;
          var dataset = me.getDataset();
          var meta = me.getMeta();
          var start = me.chart.options.startAngle || 0;
          var starts = me._starts = [];
          var angles = me._angles = [];
          var arcs = meta.data;
          var i, ilen, angle;

          me._updateRadius();

          meta.count = me.countVisibleElements();

          for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
            starts[i] = start;
            angle = me._computeAngle(i);
            angles[i] = angle;
            start += angle;
          }

          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            arcs[i]._options = me._resolveElementOptions(arcs[i], i);
            me.updateElement(arcs[i], i, reset);
          }
        },

        /**
         * @private
         */
        _updateRadius: function () {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var opts = chart.options;
          var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          chart.outerRadius = Math.max(minSize / 2, 0);
          chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
          me.innerRadius = me.outerRadius - chart.radiusLength;
        },
        updateElement: function (arc, index, reset) {
          var me = this;
          var chart = me.chart;
          var dataset = me.getDataset();
          var opts = chart.options;
          var animationOpts = opts.animation;
          var scale = chart.scale;
          var labels = chart.data.labels;
          var centerX = scale.xCenter;
          var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

          var datasetStartAngle = opts.startAngle;
          var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          var startAngle = me._starts[index];
          var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
          var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          var options = arc._options || {};
          helpers$1.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            _scale: scale,
            // Desired view properties
            _model: {
              backgroundColor: options.backgroundColor,
              borderColor: options.borderColor,
              borderWidth: options.borderWidth,
              borderAlign: options.borderAlign,
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius: reset ? resetRadius : distance,
              startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
              endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
              label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
            }
          });
          arc.pivot();
        },
        countVisibleElements: function () {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var count = 0;
          helpers$1.each(meta.data, function (element, index) {
            if (!isNaN(dataset.data[index]) && !element.hidden) {
              count++;
            }
          });
          return count;
        },

        /**
         * @protected
         */
        setHoverStyle: function (arc) {
          var model = arc._model;
          var options = arc._options;
          var getHoverColor = helpers$1.getHoverColor;
          var valueOrDefault = helpers$1.valueOrDefault;
          arc.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth
          };
          model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
          model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
          model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
        },

        /**
         * @private
         */
        _resolveElementOptions: function (arc, index) {
          var me = this;
          var chart = me.chart;
          var dataset = me.getDataset();
          var custom = arc.custom || {};
          var options = chart.options.elements.arc;
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
          }

          return values;
        },

        /**
         * @private
         */
        _computeAngle: function (index) {
          var me = this;
          var count = this.getMeta().count;
          var dataset = me.getDataset();
          var meta = me.getMeta();

          if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
            return 0;
          } // Scriptable options


          var context = {
            chart: me.chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
        }
      });

      core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

      core_defaults._set('pie', {
        cutoutPercentage: 0
      }); // Pie charts are Doughnut chart with different defaults


      var controller_pie = controller_doughnut;
      var valueOrDefault$6 = helpers$1.valueOrDefault;
      var resolve$6 = helpers$1.options.resolve;

      core_defaults._set('radar', {
        scale: {
          type: 'radialLinear'
        },
        elements: {
          line: {
            tension: 0 // no bezier in radar

          }
        }
      });

      var controller_radar = core_datasetController.extend({
        datasetElementType: elements.Line,
        dataElementType: elements.Point,
        linkScales: helpers$1.noop,
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data || [];
          var scale = me.chart.scale;
          var dataset = me.getDataset();
          var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points;
          line._loop = true; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot(); // Update Points

          for (i = 0, ilen = points.length; i < ilen; ++i) {
            me.updateElement(points[i], i, reset);
          } // Update bezier control points


          me.updateBezierControlPoints(); // Now pivot the point for animation

          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].pivot();
          }
        },
        updateElement: function (point, index, reset) {
          var me = this;
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var scale = me.chart.scale;
          var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

          var options = me._resolvePointOptions(point, index);

          var lineModel = me.getMeta().dataset._model;

          var x = reset ? scale.xCenter : pointPosition.x;
          var y = reset ? scale.yCenter : pointPosition.y; // Utility

          point._scale = scale;
          point._options = options;
          point._datasetIndex = me.index;
          point._index = index; // Desired view properties

          point._model = {
            x: x,
            // value not used in dataset scale, but we want a consistent API between scales
            y: y,
            skip: custom.skip || isNaN(x) || isNaN(y),
            // Appearance
            radius: options.radius,
            pointStyle: options.pointStyle,
            rotation: options.rotation,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
            // Tooltip
            hitRadius: options.hitRadius
          };
        },

        /**
         * @private
         */
        _resolvePointOptions: function (element, index) {
          var me = this;
          var chart = me.chart;
          var dataset = chart.data.datasets[me.index];
          var custom = element.custom || {};
          var options = chart.options.elements.point;
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var ELEMENT_OPTIONS = {
            backgroundColor: 'pointBackgroundColor',
            borderColor: 'pointBorderColor',
            borderWidth: 'pointBorderWidth',
            hitRadius: 'pointHitRadius',
            hoverBackgroundColor: 'pointHoverBackgroundColor',
            hoverBorderColor: 'pointHoverBorderColor',
            hoverBorderWidth: 'pointHoverBorderWidth',
            hoverRadius: 'pointHoverRadius',
            pointStyle: 'pointStyle',
            radius: 'pointRadius',
            rotation: 'pointRotation'
          };
          var keys = Object.keys(ELEMENT_OPTIONS);

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
          }

          return values;
        },

        /**
         * @private
         */
        _resolveLineOptions: function (element) {
          var me = this;
          var chart = me.chart;
          var dataset = chart.data.datasets[me.index];
          var custom = element.custom || {};
          var options = chart.options.elements.line;
          var values = {};
          var i, ilen, key;
          var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve$6([custom[key], dataset[key], options[key]]);
          }

          values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
          return values;
        },
        updateBezierControlPoints: function () {
          var me = this;
          var meta = me.getMeta();
          var area = me.chart.chartArea;
          var points = meta.data || [];
          var i, ilen, model, controlPoints;

          function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min);
          }

          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

            model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
            model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
            model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
            model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
          }
        },
        setHoverStyle: function (point) {
          var model = point._model;
          var options = point._options;
          var getHoverColor = helpers$1.getHoverColor;
          point.$previousStyle = {
            backgroundColor: model.backgroundColor,
            borderColor: model.borderColor,
            borderWidth: model.borderWidth,
            radius: model.radius
          };
          model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
          model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
          model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
          model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
        }
      });

      core_defaults._set('scatter', {
        hover: {
          mode: 'single'
        },
        scales: {
          xAxes: [{
            id: 'x-axis-1',
            // need an ID so datasets can reference the scale
            type: 'linear',
            // scatter should not use a category axis
            position: 'bottom'
          }],
          yAxes: [{
            id: 'y-axis-1',
            type: 'linear',
            position: 'left'
          }]
        },
        showLines: false,
        tooltips: {
          callbacks: {
            title: function () {
              return ''; // doesn't make sense for scatter since data are formatted as a point
            },
            label: function (item) {
              return '(' + item.xLabel + ', ' + item.yLabel + ')';
            }
          }
        }
      }); // Scatter charts use line controllers


      var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
      // the class, and so must be CamelCase in order to be correctly retrieved
      // by the controller in core.controller.js (`controllers[meta.type]`).

      var controllers = {
        bar: controller_bar,
        bubble: controller_bubble,
        doughnut: controller_doughnut,
        horizontalBar: controller_horizontalBar,
        line: controller_line,
        polarArea: controller_polarArea,
        pie: controller_pie,
        radar: controller_radar,
        scatter: controller_scatter
      };
      /**
       * Helper function to get relative position for an event
       * @param {Event|IEvent} event - The event to get the position for
       * @param {Chart} chart - The chart
       * @returns {object} the event position
       */

      function getRelativePosition(e, chart) {
        if (e.native) {
          return {
            x: e.x,
            y: e.y
          };
        }

        return helpers$1.getRelativePosition(e, chart);
      }
      /**
       * Helper function to traverse all of the visible elements in the chart
       * @param {Chart} chart - the chart
       * @param {function} handler - the callback to execute for each visible item
       */


      function parseVisibleItems(chart, handler) {
        var datasets = chart.data.datasets;
        var meta, i, j, ilen, jlen;

        for (i = 0, ilen = datasets.length; i < ilen; ++i) {
          if (!chart.isDatasetVisible(i)) {
            continue;
          }

          meta = chart.getDatasetMeta(i);

          for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
            var element = meta.data[j];

            if (!element._view.skip) {
              handler(element);
            }
          }
        }
      }
      /**
       * Helper function to get the items that intersect the event position
       * @param {ChartElement[]} items - elements to filter
       * @param {object} position - the point to be nearest to
       * @return {ChartElement[]} the nearest items
       */


      function getIntersectItems(chart, position) {
        var elements = [];
        parseVisibleItems(chart, function (element) {
          if (element.inRange(position.x, position.y)) {
            elements.push(element);
          }
        });
        return elements;
      }
      /**
       * Helper function to get the items nearest to the event position considering all visible items in teh chart
       * @param {Chart} chart - the chart to look at elements from
       * @param {object} position - the point to be nearest to
       * @param {boolean} intersect - if true, only consider items that intersect the position
       * @param {function} distanceMetric - function to provide the distance between points
       * @return {ChartElement[]} the nearest items
       */


      function getNearestItems(chart, position, intersect, distanceMetric) {
        var minDistance = Number.POSITIVE_INFINITY;
        var nearestItems = [];
        parseVisibleItems(chart, function (element) {
          if (intersect && !element.inRange(position.x, position.y)) {
            return;
          }

          var center = element.getCenterPoint();
          var distance = distanceMetric(position, center);

          if (distance < minDistance) {
            nearestItems = [element];
            minDistance = distance;
          } else if (distance === minDistance) {
            // Can have multiple items at the same distance in which case we sort by size
            nearestItems.push(element);
          }
        });
        return nearestItems;
      }
      /**
       * Get a distance metric function for two points based on the
       * axis mode setting
       * @param {string} axis - the axis mode. x|y|xy
       */


      function getDistanceMetricForAxis(axis) {
        var useX = axis.indexOf('x') !== -1;
        var useY = axis.indexOf('y') !== -1;
        return function (pt1, pt2) {
          var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
      }

      function indexMode(chart, e, options) {
        var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

        options.axis = options.axis || 'x';
        var distanceMetric = getDistanceMetricForAxis(options.axis);
        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
        var elements = [];

        if (!items.length) {
          return [];
        }

        chart.data.datasets.forEach(function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

            if (element && !element._view.skip) {
              elements.push(element);
            }
          }
        });
        return elements;
      }
      /**
       * @interface IInteractionOptions
       */

      /**
       * If true, only consider items that intersect the point
       * @name IInterfaceOptions#boolean
       * @type Boolean
       */

      /**
       * Contains interaction related functions
       * @namespace Chart.Interaction
       */


      var core_interaction = {
        // Helper function for different modes
        modes: {
          single: function (chart, e) {
            var position = getRelativePosition(e, chart);
            var elements = [];
            parseVisibleItems(chart, function (element) {
              if (element.inRange(position.x, position.y)) {
                elements.push(element);
                return elements;
              }
            });
            return elements.slice(0, 1);
          },

          /**
           * @function Chart.Interaction.modes.label
           * @deprecated since version 2.4.0
           * @todo remove at version 3
           * @private
           */
          label: indexMode,

          /**
           * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
           * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
           * @function Chart.Interaction.modes.index
           * @since v2.4.0
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @param {IInteractionOptions} options - options to use during interaction
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          index: indexMode,

          /**
           * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
           * If the options.intersect is false, we find the nearest item and return the items in that dataset
           * @function Chart.Interaction.modes.dataset
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @param {IInteractionOptions} options - options to use during interaction
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          dataset: function (chart, e, options) {
            var position = getRelativePosition(e, chart);
            options.axis = options.axis || 'xy';
            var distanceMetric = getDistanceMetricForAxis(options.axis);
            var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

            if (items.length > 0) {
              items = chart.getDatasetMeta(items[0]._datasetIndex).data;
            }

            return items;
          },

          /**
           * @function Chart.Interaction.modes.x-axis
           * @deprecated since version 2.4.0. Use index mode and intersect == true
           * @todo remove at version 3
           * @private
           */
          'x-axis': function (chart, e) {
            return indexMode(chart, e, {
              intersect: false
            });
          },

          /**
           * Point mode returns all elements that hit test based on the event position
           * of the event
           * @function Chart.Interaction.modes.intersect
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          point: function (chart, e) {
            var position = getRelativePosition(e, chart);
            return getIntersectItems(chart, position);
          },

          /**
           * nearest mode returns the element closest to the point
           * @function Chart.Interaction.modes.intersect
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @param {IInteractionOptions} options - options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          nearest: function (chart, e, options) {
            var position = getRelativePosition(e, chart);
            options.axis = options.axis || 'xy';
            var distanceMetric = getDistanceMetricForAxis(options.axis);
            return getNearestItems(chart, position, options.intersect, distanceMetric);
          },

          /**
           * x mode returns the elements that hit-test at the current x coordinate
           * @function Chart.Interaction.modes.x
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @param {IInteractionOptions} options - options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          x: function (chart, e, options) {
            var position = getRelativePosition(e, chart);
            var items = [];
            var intersectsItem = false;
            parseVisibleItems(chart, function (element) {
              if (element.inXRange(position.x)) {
                items.push(element);
              }

              if (element.inRange(position.x, position.y)) {
                intersectsItem = true;
              }
            }); // If we want to trigger on an intersect and we don't have any items
            // that intersect the position, return nothing

            if (options.intersect && !intersectsItem) {
              items = [];
            }

            return items;
          },

          /**
           * y mode returns the elements that hit-test at the current y coordinate
           * @function Chart.Interaction.modes.y
           * @param {Chart} chart - the chart we are returning items from
           * @param {Event} e - the event we are find things at
           * @param {IInteractionOptions} options - options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
          y: function (chart, e, options) {
            var position = getRelativePosition(e, chart);
            var items = [];
            var intersectsItem = false;
            parseVisibleItems(chart, function (element) {
              if (element.inYRange(position.y)) {
                items.push(element);
              }

              if (element.inRange(position.x, position.y)) {
                intersectsItem = true;
              }
            }); // If we want to trigger on an intersect and we don't have any items
            // that intersect the position, return nothing

            if (options.intersect && !intersectsItem) {
              items = [];
            }

            return items;
          }
        }
      };

      function filterByPosition(array, position) {
        return helpers$1.where(array, function (v) {
          return v.position === position;
        });
      }

      function sortByWeight(array, reverse) {
        array.forEach(function (v, i) {
          v._tmpIndex_ = i;
          return v;
        });
        array.sort(function (a, b) {
          var v0 = reverse ? b : a;
          var v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
        });
        array.forEach(function (v) {
          delete v._tmpIndex_;
        });
      }

      function findMaxPadding(boxes) {
        var top = 0;
        var left = 0;
        var bottom = 0;
        var right = 0;
        helpers$1.each(boxes, function (box) {
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            top = Math.max(top, boxPadding.top);
            left = Math.max(left, boxPadding.left);
            bottom = Math.max(bottom, boxPadding.bottom);
            right = Math.max(right, boxPadding.right);
          }
        });
        return {
          top: top,
          left: left,
          bottom: bottom,
          right: right
        };
      }

      function addSizeByPosition(boxes, size) {
        helpers$1.each(boxes, function (box) {
          size[box.position] += box.isHorizontal() ? box.height : box.width;
        });
      }

      core_defaults._set('global', {
        layout: {
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        }
      });
      /**
       * @interface ILayoutItem
       * @prop {string} position - The position of the item in the chart layout. Possible values are
       * 'left', 'top', 'right', 'bottom', and 'chartArea'
       * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
       * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
       * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
       * @prop {function} update - Takes two parameters: width and height. Returns size of item
       * @prop {function} getPadding -  Returns an object with padding on the edges
       * @prop {number} width - Width of item. Must be valid after update()
       * @prop {number} height - Height of item. Must be valid after update()
       * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
       * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
       * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
       * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
       */
      // The layout service is very self explanatory.  It's responsible for the layout within a chart.
      // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
      // It is this service's responsibility of carrying out that layout.


      var core_layouts = {
        defaults: {},

        /**
         * Register a box to a chart.
         * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
         * @param {Chart} chart - the chart to use
         * @param {ILayoutItem} item - the item to add to be layed out
         */
        addBox: function (chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          } // initialize item with default values


          item.fullWidth = item.fullWidth || false;
          item.position = item.position || 'top';
          item.weight = item.weight || 0;
          chart.boxes.push(item);
        },

        /**
         * Remove a layoutItem from a chart
         * @param {Chart} chart - the chart to remove the box from
         * @param {ILayoutItem} layoutItem - the item to remove from the layout
         */
        removeBox: function (chart, layoutItem) {
          var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

          if (index !== -1) {
            chart.boxes.splice(index, 1);
          }
        },

        /**
         * Sets (or updates) options on the given `item`.
         * @param {Chart} chart - the chart in which the item lives (or will be added to)
         * @param {ILayoutItem} item - the item to configure with the given options
         * @param {object} options - the new item options.
         */
        configure: function (chart, item, options) {
          var props = ['fullWidth', 'position', 'weight'];
          var ilen = props.length;
          var i = 0;
          var prop;

          for (; i < ilen; ++i) {
            prop = props[i];

            if (options.hasOwnProperty(prop)) {
              item[prop] = options[prop];
            }
          }
        },

        /**
         * Fits boxes of the given chart into the given size by having each box measure itself
         * then running a fitting algorithm
         * @param {Chart} chart - the chart
         * @param {number} width - the width to fit into
         * @param {number} height - the height to fit into
         */
        update: function (chart, width, height) {
          if (!chart) {
            return;
          }

          var layoutOptions = chart.options.layout || {};
          var padding = helpers$1.options.toPadding(layoutOptions.padding);
          var leftPadding = padding.left;
          var rightPadding = padding.right;
          var topPadding = padding.top;
          var bottomPadding = padding.bottom;
          var leftBoxes = filterByPosition(chart.boxes, 'left');
          var rightBoxes = filterByPosition(chart.boxes, 'right');
          var topBoxes = filterByPosition(chart.boxes, 'top');
          var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
          var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

          sortByWeight(leftBoxes, true);
          sortByWeight(rightBoxes, false);
          sortByWeight(topBoxes, true);
          sortByWeight(bottomBoxes, false);
          var verticalBoxes = leftBoxes.concat(rightBoxes);
          var horizontalBoxes = topBoxes.concat(bottomBoxes);
          var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
          // Our canvas looks like the following.
          // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
          // B1 is the bottom axis
          // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
          // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
          // an error will be thrown.
          //
          // |----------------------------------------------------|
          // |                  T1 (Full Width)                   |
          // |----------------------------------------------------|
          // |    |    |                 T2                  |    |
          // |    |----|-------------------------------------|----|
          // |    |    | C1 |                           | C2 |    |
          // |    |    |----|                           |----|    |
          // |    |    |                                     |    |
          // | L1 | L2 |           ChartArea (C0)            | R1 |
          // |    |    |                                     |    |
          // |    |    |----|                           |----|    |
          // |    |    | C3 |                           | C4 |    |
          // |    |----|-------------------------------------|----|
          // |    |    |                 B1                  |    |
          // |----------------------------------------------------|
          // |                  B2 (Full Width)                   |
          // |----------------------------------------------------|
          //
          // What we do to find the best sizing, we do the following
          // 1. Determine the minimum size of the chart area.
          // 2. Split the remaining width equally between each vertical axis
          // 3. Split the remaining height equally between each horizontal axis
          // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
          // 5. Adjust the sizes of each axis based on it's minimum reported size.
          // 6. Refit each axis
          // 7. Position each axis in the final location
          // 8. Tell the chart the final location of the chart area
          // 9. Tell any axes that overlay the chart area the positions of the chart area
          // Step 1

          var chartWidth = width - leftPadding - rightPadding;
          var chartHeight = height - topPadding - bottomPadding;
          var chartAreaWidth = chartWidth / 2; // min 50%
          // Step 2

          var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
          // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
          // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
          // Step 4

          var maxChartAreaWidth = chartWidth;
          var maxChartAreaHeight = chartHeight;
          var outerBoxSizes = {
            top: topPadding,
            left: leftPadding,
            bottom: bottomPadding,
            right: rightPadding
          };
          var minBoxSizes = [];
          var maxPadding;

          function getMinimumBoxSize(box) {
            var minSize;
            var isHorizontal = box.isHorizontal();

            if (isHorizontal) {
              minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
              maxChartAreaHeight -= minSize.height;
            } else {
              minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
              maxChartAreaWidth -= minSize.width;
            }

            minBoxSizes.push({
              horizontal: isHorizontal,
              width: minSize.width,
              box: box
            });
          }

          helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

          maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
          // be if the axes are drawn at their minimum sizes.
          // Steps 5 & 6
          // Function to fit a box

          function fitBox(box) {
            var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
              return minBox.box === box;
            });

            if (minBoxSize) {
              if (minBoxSize.horizontal) {
                var scaleMargin = {
                  left: Math.max(outerBoxSizes.left, maxPadding.left),
                  right: Math.max(outerBoxSizes.right, maxPadding.right),
                  top: 0,
                  bottom: 0
                }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
                // on the margin. Sometimes they need to increase in size slightly

                box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
              } else {
                box.update(minBoxSize.width, maxChartAreaHeight);
              }
            }
          } // Update, and calculate the left and right margins for the horizontal boxes


          helpers$1.each(verticalBoxes, fitBox);
          addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

          helpers$1.each(horizontalBoxes, fitBox);
          addSizeByPosition(horizontalBoxes, outerBoxSizes);

          function finalFitVerticalBox(box) {
            var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
              return minSize.box === box;
            });
            var scaleMargin = {
              left: 0,
              right: 0,
              top: outerBoxSizes.top,
              bottom: outerBoxSizes.bottom
            };

            if (minBoxSize) {
              box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
            }
          } // Let the left layout know the final margin


          helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

          outerBoxSizes = {
            top: topPadding,
            left: leftPadding,
            bottom: bottomPadding,
            right: rightPadding
          };
          addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

          var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
          outerBoxSizes.left += leftPaddingAddition;
          outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
          var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
          outerBoxSizes.top += topPaddingAddition;
          outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
          // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
          // without calling `fit` again

          var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
          var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

          if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
            helpers$1.each(verticalBoxes, function (box) {
              box.height = newMaxChartAreaHeight;
            });
            helpers$1.each(horizontalBoxes, function (box) {
              if (!box.fullWidth) {
                box.width = newMaxChartAreaWidth;
              }
            });
            maxChartAreaHeight = newMaxChartAreaHeight;
            maxChartAreaWidth = newMaxChartAreaWidth;
          } // Step 7 - Position the boxes


          var left = leftPadding + leftPaddingAddition;
          var top = topPadding + topPaddingAddition;

          function placeBox(box) {
            if (box.isHorizontal()) {
              box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
              box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
              box.top = top;
              box.bottom = top + box.height; // Move to next point

              top = box.bottom;
            } else {
              box.left = left;
              box.right = left + box.width;
              box.top = outerBoxSizes.top;
              box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

              left = box.right;
            }
          }

          helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

          left += maxChartAreaWidth;
          top += maxChartAreaHeight;
          helpers$1.each(rightBoxes, placeBox);
          helpers$1.each(bottomBoxes, placeBox); // Step 8

          chart.chartArea = {
            left: outerBoxSizes.left,
            top: outerBoxSizes.top,
            right: outerBoxSizes.left + maxChartAreaWidth,
            bottom: outerBoxSizes.top + maxChartAreaHeight
          }; // Step 9

          helpers$1.each(chartAreaBoxes, function (box) {
            box.left = chart.chartArea.left;
            box.top = chart.chartArea.top;
            box.right = chart.chartArea.right;
            box.bottom = chart.chartArea.bottom;
            box.update(maxChartAreaWidth, maxChartAreaHeight);
          });
        }
      };
      /**
       * Platform fallback implementation (minimal).
       * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
       */

      var platform_basic = {
        acquireContext: function (item) {
          if (item && item.canvas) {
            // Support for any object associated to a canvas (including a context2d)
            item = item.canvas;
          }

          return item && item.getContext('2d') || null;
        }
      };
      var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
      var platform_dom$1 =
      /*#__PURE__*/
      Object.freeze({
        default: platform_dom
      });

      function getCjsExportFromNamespace(n) {
        return n && n.default || n;
      }

      var stylesheet = getCjsExportFromNamespace(platform_dom$1);
      var EXPANDO_KEY = '$chartjs';
      var CSS_PREFIX = 'chartjs-';
      var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
      var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
      var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
      var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
      /**
       * DOM event types -> Chart.js event types.
       * Note: only events with different types are mapped.
       * @see https://developer.mozilla.org/en-US/docs/Web/Events
       */

      var EVENT_TYPES = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup',
        pointerenter: 'mouseenter',
        pointerdown: 'mousedown',
        pointermove: 'mousemove',
        pointerup: 'mouseup',
        pointerleave: 'mouseout',
        pointerout: 'mouseout'
      };
      /**
       * The "used" size is the final value of a dimension property after all calculations have
       * been performed. This method uses the computed style of `element` but returns undefined
       * if the computed style is not expressed in pixels. That can happen in some cases where
       * `element` has a size relative to its parent and this last one is not yet displayed,
       * for example because of `display: none` on a parent node.
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
       * @returns {number} Size in pixels or undefined if unknown.
       */

      function readUsedSize(element, property) {
        var value = helpers$1.getStyle(element, property);
        var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? Number(matches[1]) : undefined;
      }
      /**
       * Initializes the canvas style and render size without modifying the canvas display size,
       * since responsiveness is handled by the controller.resize() method. The config is used
       * to determine the aspect ratio to apply in case no explicit height has been specified.
       */


      function initCanvas(canvas, config) {
        var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
        // returns null or '' if no explicit value has been set to the canvas attribute.

        var renderHeight = canvas.getAttribute('height');
        var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

        canvas[EXPANDO_KEY] = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        }; // Force canvas to display as block to avoid extra space caused by inline
        // elements, which would interfere with the responsive resize process.
        // https://github.com/chartjs/Chart.js/issues/2538

        style.display = style.display || 'block';

        if (renderWidth === null || renderWidth === '') {
          var displayWidth = readUsedSize(canvas, 'width');

          if (displayWidth !== undefined) {
            canvas.width = displayWidth;
          }
        }

        if (renderHeight === null || renderHeight === '') {
          if (canvas.style.height === '') {
            // If no explicit render height and style height, let's apply the aspect ratio,
            // which one can be specified by the user but also by charts as default option
            // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
            canvas.height = canvas.width / (config.options.aspectRatio || 2);
          } else {
            var displayHeight = readUsedSize(canvas, 'height');

            if (displayWidth !== undefined) {
              canvas.height = displayHeight;
            }
          }
        }

        return canvas;
      }
      /**
       * Detects support for options object argument in addEventListener.
       * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
       * @private
       */


      var supportsEventListenerOptions = function () {
        var supports = false;

        try {
          var options = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line getter-return
            get: function () {
              supports = true;
            }
          });
          window.addEventListener('e', null, options);
        } catch (e) {// continue regardless of error
        }

        return supports;
      }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
      // https://github.com/chartjs/Chart.js/issues/4287


      var eventListenerOptions = supportsEventListenerOptions ? {
        passive: true
      } : false;

      function addListener(node, type, listener) {
        node.addEventListener(type, listener, eventListenerOptions);
      }

      function removeListener(node, type, listener) {
        node.removeEventListener(type, listener, eventListenerOptions);
      }

      function createEvent(type, chart, x, y, nativeEvent) {
        return {
          type: type,
          chart: chart,
          native: nativeEvent || null,
          x: x !== undefined ? x : null,
          y: y !== undefined ? y : null
        };
      }

      function fromNativeEvent(event, chart) {
        var type = EVENT_TYPES[event.type] || event.type;
        var pos = helpers$1.getRelativePosition(event, chart);
        return createEvent(type, chart, pos.x, pos.y, event);
      }

      function throttled(fn, thisArg) {
        var ticking = false;
        var args = [];
        return function () {
          args = Array.prototype.slice.call(arguments);
          thisArg = thisArg || this;

          if (!ticking) {
            ticking = true;
            helpers$1.requestAnimFrame.call(window, function () {
              ticking = false;
              fn.apply(thisArg, args);
            });
          }
        };
      }

      function createDiv(cls) {
        var el = document.createElement('div');
        el.className = cls || '';
        return el;
      } // Implementation based on https://github.com/marcj/css-element-queries


      function createResizer(handler) {
        var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
        // https://github.com/chartjs/Chart.js/issues/5902

        var resizer = createDiv(CSS_SIZE_MONITOR);
        var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
        var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
        expand.appendChild(createDiv());
        shrink.appendChild(createDiv());
        resizer.appendChild(expand);
        resizer.appendChild(shrink);

        resizer._reset = function () {
          expand.scrollLeft = maxSize;
          expand.scrollTop = maxSize;
          shrink.scrollLeft = maxSize;
          shrink.scrollTop = maxSize;
        };

        var onScroll = function () {
          resizer._reset();

          handler();
        };

        addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
        addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
        return resizer;
      } // https://davidwalsh.name/detect-node-insertion


      function watchForRender(node, handler) {
        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

        var proxy = expando.renderProxy = function (e) {
          if (e.animationName === CSS_RENDER_ANIMATION) {
            handler();
          }
        };

        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          addListener(node, type, proxy);
        }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
        // is removed then added back immediately (same animation frame?). Accessing the
        // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
        // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
        // https://github.com/chartjs/Chart.js/issues/4737

        expando.reflow = !!node.offsetParent;
        node.classList.add(CSS_RENDER_MONITOR);
      }

      function unwatchForRender(node) {
        var expando = node[EXPANDO_KEY] || {};
        var proxy = expando.renderProxy;

        if (proxy) {
          helpers$1.each(ANIMATION_START_EVENTS, function (type) {
            removeListener(node, type, proxy);
          });
          delete expando.renderProxy;
        }

        node.classList.remove(CSS_RENDER_MONITOR);
      }

      function addResizeListener(node, listener, chart) {
        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

        var resizer = expando.resizer = createResizer(throttled(function () {
          if (expando.resizer) {
            var container = chart.options.maintainAspectRatio && node.parentNode;
            var w = container ? container.clientWidth : 0;
            listener(createEvent('resize', chart));

            if (container && container.clientWidth < w && chart.canvas) {
              // If the container size shrank during chart resize, let's assume
              // scrollbar appeared. So we resize again with the scrollbar visible -
              // effectively making chart smaller and the scrollbar hidden again.
              // Because we are inside `throttled`, and currently `ticking`, scroll
              // events are ignored during this whole 2 resize process.
              // If we assumed wrong and something else happened, we are resizing
              // twice in a frame (potential performance issue)
              listener(createEvent('resize', chart));
            }
          }
        })); // The resizer needs to be attached to the node parent, so we first need to be
        // sure that `node` is attached to the DOM before injecting the resizer element.

        watchForRender(node, function () {
          if (expando.resizer) {
            var container = node.parentNode;

            if (container && container !== resizer.parentNode) {
              container.insertBefore(resizer, container.firstChild);
            } // The container size might have changed, let's reset the resizer state.


            resizer._reset();
          }
        });
      }

      function removeResizeListener(node) {
        var expando = node[EXPANDO_KEY] || {};
        var resizer = expando.resizer;
        delete expando.resizer;
        unwatchForRender(node);

        if (resizer && resizer.parentNode) {
          resizer.parentNode.removeChild(resizer);
        }
      }

      function injectCSS(platform, css) {
        // https://stackoverflow.com/q/3922139
        var style = platform._style || document.createElement('style');

        if (!platform._style) {
          platform._style = style;
          css = '/* Chart.js */\n' + css;
          style.setAttribute('type', 'text/css');
          document.getElementsByTagName('head')[0].appendChild(style);
        }

        style.appendChild(document.createTextNode(css));
      }

      var platform_dom$2 = {
        /**
         * When `true`, prevents the automatic injection of the stylesheet required to
         * correctly detect when the chart is added to the DOM and then resized. This
         * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
         * to be manually imported to make this library compatible with any CSP.
         * See https://github.com/chartjs/Chart.js/issues/5208
         */
        disableCSSInjection: false,

        /**
         * This property holds whether this platform is enabled for the current environment.
         * Currently used by platform.js to select the proper implementation.
         * @private
         */
        _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

        /**
         * @private
         */
        _ensureLoaded: function () {
          if (this._loaded) {
            return;
          }

          this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

          if (!this.disableCSSInjection) {
            injectCSS(this, stylesheet);
          }
        },
        acquireContext: function (item, config) {
          if (typeof item === 'string') {
            item = document.getElementById(item);
          } else if (item.length) {
            // Support for array based queries (such as jQuery)
            item = item[0];
          }

          if (item && item.canvas) {
            // Support for any object associated to a canvas (including a context2d)
            item = item.canvas;
          } // To prevent canvas fingerprinting, some add-ons undefine the getContext
          // method, for example: https://github.com/kkapsner/CanvasBlocker
          // https://github.com/chartjs/Chart.js/issues/2807


          var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
          // platform options after importing the library (e.g. `disableCSSInjection`).

          this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
          // inside an iframe or when running in a protected environment. We could guess the
          // types from their toString() value but let's keep things flexible and assume it's
          // a sufficient condition if the item has a context2D which has item as `canvas`.
          // https://github.com/chartjs/Chart.js/issues/3887
          // https://github.com/chartjs/Chart.js/issues/4102
          // https://github.com/chartjs/Chart.js/issues/4152


          if (context && context.canvas === item) {
            initCanvas(item, config);
            return context;
          }

          return null;
        },
        releaseContext: function (context) {
          var canvas = context.canvas;

          if (!canvas[EXPANDO_KEY]) {
            return;
          }

          var initial = canvas[EXPANDO_KEY].initial;
          ['height', 'width'].forEach(function (prop) {
            var value = initial[prop];

            if (helpers$1.isNullOrUndef(value)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value);
            }
          });
          helpers$1.each(initial.style || {}, function (value, key) {
            canvas.style[key] = value;
          }); // The canvas render size might have been changed (and thus the state stack discarded),
          // we can't use save() and restore() to restore the initial state. So make sure that at
          // least the canvas context is reset to the default state by setting the canvas width.
          // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
          // eslint-disable-next-line no-self-assign

          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
        },
        addEventListener: function (chart, type, listener) {
          var canvas = chart.canvas;

          if (type === 'resize') {
            // Note: the resize event is not supported on all browsers.
            addResizeListener(canvas, listener, chart);
            return;
          }

          var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
          var proxies = expando.proxies || (expando.proxies = {});

          var proxy = proxies[chart.id + '_' + type] = function (event) {
            listener(fromNativeEvent(event, chart));
          };

          addListener(canvas, type, proxy);
        },
        removeEventListener: function (chart, type, listener) {
          var canvas = chart.canvas;

          if (type === 'resize') {
            // Note: the resize event is not supported on all browsers.
            removeResizeListener(canvas);
            return;
          }

          var expando = listener[EXPANDO_KEY] || {};
          var proxies = expando.proxies || {};
          var proxy = proxies[chart.id + '_' + type];

          if (!proxy) {
            return;
          }

          removeListener(canvas, type, proxy);
        }
      }; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use EventTarget.addEventListener instead.
       * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
       * @function Chart.helpers.addEvent
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers$1.addEvent = addListener;
      /**
       * Provided for backward compatibility, use EventTarget.removeEventListener instead.
       * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
       * @function Chart.helpers.removeEvent
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */

      helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

      var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
      /**
       * @namespace Chart.platform
       * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
       * @since 2.4.0
       */

      var platform = helpers$1.extend({
        /**
         * @since 2.7.0
         */
        initialize: function () {},

        /**
         * Called at chart construction time, returns a context2d instance implementing
         * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
         * @param {*} item - The native item from which to acquire context (platform specific)
         * @param {object} options - The chart options
         * @returns {CanvasRenderingContext2D} context2d instance
         */
        acquireContext: function () {},

        /**
         * Called at chart destruction time, releases any resources associated to the context
         * previously returned by the acquireContext() method.
         * @param {CanvasRenderingContext2D} context - The context2d instance
         * @returns {boolean} true if the method succeeded, else false
         */
        releaseContext: function () {},

        /**
         * Registers the specified listener on the given chart.
         * @param {Chart} chart - Chart from which to listen for event
         * @param {string} type - The ({@link IEvent}) type to listen for
         * @param {function} listener - Receives a notification (an object that implements
         * the {@link IEvent} interface) when an event of the specified type occurs.
         */
        addEventListener: function () {},

        /**
         * Removes the specified listener previously registered with addEventListener.
         * @param {Chart} chart - Chart from which to remove the listener
         * @param {string} type - The ({@link IEvent}) type to remove
         * @param {function} listener - The listener function to remove from the event target.
         */
        removeEventListener: function () {}
      }, implementation);

      core_defaults._set('global', {
        plugins: {}
      });
      /**
       * The plugin service singleton
       * @namespace Chart.plugins
       * @since 2.1.0
       */


      var core_plugins = {
        /**
         * Globally registered plugins.
         * @private
         */
        _plugins: [],

        /**
         * This identifier is used to invalidate the descriptors cache attached to each chart
         * when a global plugin is registered or unregistered. In this case, the cache ID is
         * incremented and descriptors are regenerated during following API calls.
         * @private
         */
        _cacheId: 0,

        /**
         * Registers the given plugin(s) if not already registered.
         * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
         */
        register: function (plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            if (p.indexOf(plugin) === -1) {
              p.push(plugin);
            }
          });
          this._cacheId++;
        },

        /**
         * Unregisters the given plugin(s) only if registered.
         * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
         */
        unregister: function (plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            var idx = p.indexOf(plugin);

            if (idx !== -1) {
              p.splice(idx, 1);
            }
          });
          this._cacheId++;
        },

        /**
         * Remove all registered plugins.
         * @since 2.1.5
         */
        clear: function () {
          this._plugins = [];
          this._cacheId++;
        },

        /**
         * Returns the number of registered plugins?
         * @returns {number}
         * @since 2.1.5
         */
        count: function () {
          return this._plugins.length;
        },

        /**
         * Returns all registered plugin instances.
         * @returns {IPlugin[]} array of plugin objects.
         * @since 2.1.5
         */
        getAll: function () {
          return this._plugins;
        },

        /**
         * Calls enabled plugins for `chart` on the specified hook and with the given args.
         * This method immediately returns as soon as a plugin explicitly returns false. The
         * returned value can be used, for instance, to interrupt the current action.
         * @param {Chart} chart - The chart instance for which plugins should be called.
         * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
         * @param {Array} [args] - Extra arguments to apply to the hook call.
         * @returns {boolean} false if any of the plugins return false, else returns true.
         */
        notify: function (chart, hook, args) {
          var descriptors = this.descriptors(chart);
          var ilen = descriptors.length;
          var i, descriptor, plugin, params, method;

          for (i = 0; i < ilen; ++i) {
            descriptor = descriptors[i];
            plugin = descriptor.plugin;
            method = plugin[hook];

            if (typeof method === 'function') {
              params = [chart].concat(args || []);
              params.push(descriptor.options);

              if (method.apply(plugin, params) === false) {
                return false;
              }
            }
          }

          return true;
        },

        /**
         * Returns descriptors of enabled plugins for the given chart.
         * @returns {object[]} [{ plugin, options }]
         * @private
         */
        descriptors: function (chart) {
          var cache = chart.$plugins || (chart.$plugins = {});

          if (cache.id === this._cacheId) {
            return cache.descriptors;
          }

          var plugins = [];
          var descriptors = [];
          var config = chart && chart.config || {};
          var options = config.options && config.options.plugins || {};

          this._plugins.concat(config.plugins || []).forEach(function (plugin) {
            var idx = plugins.indexOf(plugin);

            if (idx !== -1) {
              return;
            }

            var id = plugin.id;
            var opts = options[id];

            if (opts === false) {
              return;
            }

            if (opts === true) {
              opts = helpers$1.clone(core_defaults.global.plugins[id]);
            }

            plugins.push(plugin);
            descriptors.push({
              plugin: plugin,
              options: opts || {}
            });
          });

          cache.descriptors = descriptors;
          cache.id = this._cacheId;
          return descriptors;
        },

        /**
         * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
         * but in some cases, this reference can be changed by the user when updating options.
         * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
         * @private
         */
        _invalidate: function (chart) {
          delete chart.$plugins;
        }
      };
      var core_scaleService = {
        // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
        // use the new chart options to grab the correct scale
        constructors: {},
        // Use a registration function so that we can move to an ES6 map when we no longer need to support
        // old browsers
        // Scale config defaults
        defaults: {},
        registerScaleType: function (type, scaleConstructor, scaleDefaults) {
          this.constructors[type] = scaleConstructor;
          this.defaults[type] = helpers$1.clone(scaleDefaults);
        },
        getScaleConstructor: function (type) {
          return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
        },
        getScaleDefaults: function (type) {
          // Return the scale defaults merged with the global settings so that we always use the latest ones
          return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
        },
        updateScaleDefaults: function (type, additions) {
          var me = this;

          if (me.defaults.hasOwnProperty(type)) {
            me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
          }
        },
        addScalesToLayout: function (chart) {
          // Adds each scale to the chart.boxes array to be sized accordingly
          helpers$1.each(chart.scales, function (scale) {
            // Set ILayoutItem parameters for backwards compatibility
            scale.fullWidth = scale.options.fullWidth;
            scale.position = scale.options.position;
            scale.weight = scale.options.weight;
            core_layouts.addBox(chart, scale);
          });
        }
      };
      var valueOrDefault$7 = helpers$1.valueOrDefault;

      core_defaults._set('global', {
        tooltips: {
          enabled: true,
          custom: null,
          mode: 'nearest',
          position: 'average',
          intersect: true,
          backgroundColor: 'rgba(0,0,0,0.8)',
          titleFontStyle: 'bold',
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleFontColor: '#fff',
          titleAlign: 'left',
          bodySpacing: 2,
          bodyFontColor: '#fff',
          bodyAlign: 'left',
          footerFontStyle: 'bold',
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFontColor: '#fff',
          footerAlign: 'left',
          yPadding: 6,
          xPadding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          multiKeyBackground: '#fff',
          displayColors: true,
          borderColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          callbacks: {
            // Args are: (tooltipItems, data)
            beforeTitle: helpers$1.noop,
            title: function (tooltipItems, data) {
              var title = '';
              var labels = data.labels;
              var labelCount = labels ? labels.length : 0;

              if (tooltipItems.length > 0) {
                var item = tooltipItems[0];

                if (item.label) {
                  title = item.label;
                } else if (item.xLabel) {
                  title = item.xLabel;
                } else if (labelCount > 0 && item.index < labelCount) {
                  title = labels[item.index];
                }
              }

              return title;
            },
            afterTitle: helpers$1.noop,
            // Args are: (tooltipItems, data)
            beforeBody: helpers$1.noop,
            // Args are: (tooltipItem, data)
            beforeLabel: helpers$1.noop,
            label: function (tooltipItem, data) {
              var label = data.datasets[tooltipItem.datasetIndex].label || '';

              if (label) {
                label += ': ';
              }

              if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                label += tooltipItem.value;
              } else {
                label += tooltipItem.yLabel;
              }

              return label;
            },
            labelColor: function (tooltipItem, chart) {
              var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
              var activeElement = meta.data[tooltipItem.index];
              var view = activeElement._view;
              return {
                borderColor: view.borderColor,
                backgroundColor: view.backgroundColor
              };
            },
            labelTextColor: function () {
              return this._options.bodyFontColor;
            },
            afterLabel: helpers$1.noop,
            // Args are: (tooltipItems, data)
            afterBody: helpers$1.noop,
            // Args are: (tooltipItems, data)
            beforeFooter: helpers$1.noop,
            footer: helpers$1.noop,
            afterFooter: helpers$1.noop
          }
        }
      });

      var positioners = {
        /**
         * Average mode places the tooltip at the average position of the elements shown
         * @function Chart.Tooltip.positioners.average
         * @param elements {ChartElement[]} the elements being displayed in the tooltip
         * @returns {object} tooltip position
         */
        average: function (elements) {
          if (!elements.length) {
            return false;
          }

          var i, len;
          var x = 0;
          var y = 0;
          var count = 0;

          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];

            if (el && el.hasValue()) {
              var pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }

          return {
            x: x / count,
            y: y / count
          };
        },

        /**
         * Gets the tooltip position nearest of the item nearest to the event position
         * @function Chart.Tooltip.positioners.nearest
         * @param elements {Chart.Element[]} the tooltip elements
         * @param eventPosition {object} the position of the event in canvas coordinates
         * @returns {object} the tooltip position
         */
        nearest: function (elements, eventPosition) {
          var x = eventPosition.x;
          var y = eventPosition.y;
          var minDistance = Number.POSITIVE_INFINITY;
          var i, len, nearestElement;

          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];

            if (el && el.hasValue()) {
              var center = el.getCenterPoint();
              var d = helpers$1.distanceBetweenPoints(eventPosition, center);

              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }

          if (nearestElement) {
            var tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }

          return {
            x: x,
            y: y
          };
        }
      }; // Helper to push or concat based on if the 2nd parameter is an array or not

      function pushOrConcat(base, toPush) {
        if (toPush) {
          if (helpers$1.isArray(toPush)) {
            // base = base.concat(toPush);
            Array.prototype.push.apply(base, toPush);
          } else {
            base.push(toPush);
          }
        }

        return base;
      }
      /**
       * Returns array of strings split by newline
       * @param {string} value - The value to split by newline.
       * @returns {string[]} value if newline present - Returned from String split() method
       * @function
       */


      function splitNewlines(str) {
        if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
          return str.split('\n');
        }

        return str;
      }
      /**
       * Private helper to create a tooltip item model
       * @param element - the chart element (point, arc, bar) to create the tooltip item for
       * @return new tooltip item
       */


      function createTooltipItem(element) {
        var xScale = element._xScale;
        var yScale = element._yScale || element._scale; // handle radar || polarArea charts

        var index = element._index;
        var datasetIndex = element._datasetIndex;

        var controller = element._chart.getDatasetMeta(datasetIndex).controller;

        var indexScale = controller._getIndexScale();

        var valueScale = controller._getValueScale();

        return {
          xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
          yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
          label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
          value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
          index: index,
          datasetIndex: datasetIndex,
          x: element._model.x,
          y: element._model.y
        };
      }
      /**
       * Helper to get the reset model for the tooltip
       * @param tooltipOpts {object} the tooltip options
       */


      function getBaseModel(tooltipOpts) {
        var globalDefaults = core_defaults.global;
        return {
          // Positioning
          xPadding: tooltipOpts.xPadding,
          yPadding: tooltipOpts.yPadding,
          xAlign: tooltipOpts.xAlign,
          yAlign: tooltipOpts.yAlign,
          // Body
          bodyFontColor: tooltipOpts.bodyFontColor,
          _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
          _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
          _bodyAlign: tooltipOpts.bodyAlign,
          bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
          bodySpacing: tooltipOpts.bodySpacing,
          // Title
          titleFontColor: tooltipOpts.titleFontColor,
          _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
          _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
          titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
          _titleAlign: tooltipOpts.titleAlign,
          titleSpacing: tooltipOpts.titleSpacing,
          titleMarginBottom: tooltipOpts.titleMarginBottom,
          // Footer
          footerFontColor: tooltipOpts.footerFontColor,
          _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
          _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
          footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
          _footerAlign: tooltipOpts.footerAlign,
          footerSpacing: tooltipOpts.footerSpacing,
          footerMarginTop: tooltipOpts.footerMarginTop,
          // Appearance
          caretSize: tooltipOpts.caretSize,
          cornerRadius: tooltipOpts.cornerRadius,
          backgroundColor: tooltipOpts.backgroundColor,
          opacity: 0,
          legendColorBackground: tooltipOpts.multiKeyBackground,
          displayColors: tooltipOpts.displayColors,
          borderColor: tooltipOpts.borderColor,
          borderWidth: tooltipOpts.borderWidth
        };
      }
      /**
       * Get the size of the tooltip
       */


      function getTooltipSize(tooltip, model) {
        var ctx = tooltip._chart.ctx;
        var height = model.yPadding * 2; // Tooltip Padding

        var width = 0; // Count of all lines in the body

        var body = model.body;
        var combinedBodyLength = body.reduce(function (count, bodyItem) {
          return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
        }, 0);
        combinedBodyLength += model.beforeBody.length + model.afterBody.length;
        var titleLineCount = model.title.length;
        var footerLineCount = model.footer.length;
        var titleFontSize = model.titleFontSize;
        var bodyFontSize = model.bodyFontSize;
        var footerFontSize = model.footerFontSize;
        height += titleLineCount * titleFontSize; // Title Lines

        height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

        height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

        height += combinedBodyLength * bodyFontSize; // Body Lines

        height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

        height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

        height += footerLineCount * footerFontSize; // Footer Lines

        height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
        // Title width

        var widthPadding = 0;

        var maxLineWidth = function (line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };

        ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
        helpers$1.each(model.title, maxLineWidth); // Body width

        ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
        helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

        widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
        helpers$1.each(body, function (bodyItem) {
          helpers$1.each(bodyItem.before, maxLineWidth);
          helpers$1.each(bodyItem.lines, maxLineWidth);
          helpers$1.each(bodyItem.after, maxLineWidth);
        }); // Reset back to 0

        widthPadding = 0; // Footer width

        ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
        helpers$1.each(model.footer, maxLineWidth); // Add padding

        width += 2 * model.xPadding;
        return {
          width: width,
          height: height
        };
      }
      /**
       * Helper to get the alignment of a tooltip given the size
       */


      function determineAlignment(tooltip, size) {
        var model = tooltip._model;
        var chart = tooltip._chart;
        var chartArea = tooltip._chart.chartArea;
        var xAlign = 'center';
        var yAlign = 'center';

        if (model.y < size.height) {
          yAlign = 'top';
        } else if (model.y > chart.height - size.height) {
          yAlign = 'bottom';
        }

        var lf, rf; // functions to determine left, right alignment

        var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

        var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

        var midX = (chartArea.left + chartArea.right) / 2;
        var midY = (chartArea.top + chartArea.bottom) / 2;

        if (yAlign === 'center') {
          lf = function (x) {
            return x <= midX;
          };

          rf = function (x) {
            return x > midX;
          };
        } else {
          lf = function (x) {
            return x <= size.width / 2;
          };

          rf = function (x) {
            return x >= chart.width - size.width / 2;
          };
        }

        olf = function (x) {
          return x + size.width + model.caretSize + model.caretPadding > chart.width;
        };

        orf = function (x) {
          return x - size.width - model.caretSize - model.caretPadding < 0;
        };

        yf = function (y) {
          return y <= midY ? 'top' : 'bottom';
        };

        if (lf(model.x)) {
          xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

          if (olf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y);
          }
        } else if (rf(model.x)) {
          xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

          if (orf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y);
          }
        }

        var opts = tooltip._options;
        return {
          xAlign: opts.xAlign ? opts.xAlign : xAlign,
          yAlign: opts.yAlign ? opts.yAlign : yAlign
        };
      }
      /**
       * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
       */


      function getBackgroundPoint(vm, size, alignment, chart) {
        // Background Position
        var x = vm.x;
        var y = vm.y;
        var caretSize = vm.caretSize;
        var caretPadding = vm.caretPadding;
        var cornerRadius = vm.cornerRadius;
        var xAlign = alignment.xAlign;
        var yAlign = alignment.yAlign;
        var paddingAndSize = caretSize + caretPadding;
        var radiusAndPadding = cornerRadius + caretPadding;

        if (xAlign === 'right') {
          x -= size.width;
        } else if (xAlign === 'center') {
          x -= size.width / 2;

          if (x + size.width > chart.width) {
            x = chart.width - size.width;
          }

          if (x < 0) {
            x = 0;
          }
        }

        if (yAlign === 'top') {
          y += paddingAndSize;
        } else if (yAlign === 'bottom') {
          y -= size.height + paddingAndSize;
        } else {
          y -= size.height / 2;
        }

        if (yAlign === 'center') {
          if (xAlign === 'left') {
            x += paddingAndSize;
          } else if (xAlign === 'right') {
            x -= paddingAndSize;
          }
        } else if (xAlign === 'left') {
          x -= radiusAndPadding;
        } else if (xAlign === 'right') {
          x += radiusAndPadding;
        }

        return {
          x: x,
          y: y
        };
      }

      function getAlignedX(vm, align) {
        return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
      }
      /**
       * Helper to build before and after body lines
       */


      function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback));
      }

      var exports$3 = core_element.extend({
        initialize: function () {
          this._model = getBaseModel(this._options);
          this._lastActive = [];
        },
        // Get the title
        // Args are: (tooltipItem, data)
        getTitle: function () {
          var me = this;
          var opts = me._options;
          var callbacks = opts.callbacks;
          var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
          var title = callbacks.title.apply(me, arguments);
          var afterTitle = callbacks.afterTitle.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        },
        // Args are: (tooltipItem, data)
        getBeforeBody: function () {
          return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
        },
        // Args are: (tooltipItem, data)
        getBody: function (tooltipItems, data) {
          var me = this;
          var callbacks = me._options.callbacks;
          var bodyItems = [];
          helpers$1.each(tooltipItems, function (tooltipItem) {
            var bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
            pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
            pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        },
        // Args are: (tooltipItem, data)
        getAfterBody: function () {
          return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
        },
        // Get the footer and beforeFooter and afterFooter lines
        // Args are: (tooltipItem, data)
        getFooter: function () {
          var me = this;
          var callbacks = me._options.callbacks;
          var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
          var footer = callbacks.footer.apply(me, arguments);
          var afterFooter = callbacks.afterFooter.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        },
        update: function (changed) {
          var me = this;
          var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
          // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
          // which breaks any animations.

          var existingModel = me._model;
          var model = me._model = getBaseModel(opts);
          var active = me._active;
          var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

          var alignment = {
            xAlign: existingModel.xAlign,
            yAlign: existingModel.yAlign
          };
          var backgroundPoint = {
            x: existingModel.x,
            y: existingModel.y
          };
          var tooltipSize = {
            width: existingModel.width,
            height: existingModel.height
          };
          var tooltipPosition = {
            x: existingModel.caretX,
            y: existingModel.caretY
          };
          var i, len;

          if (active.length) {
            model.opacity = 1;
            var labelColors = [];
            var labelTextColors = [];
            tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
            var tooltipItems = [];

            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(active[i]));
            } // If the user provided a filter function, use it to modify the tooltip items


            if (opts.filter) {
              tooltipItems = tooltipItems.filter(function (a) {
                return opts.filter(a, data);
              });
            } // If the user provided a sorting function, use it to modify the tooltip items


            if (opts.itemSort) {
              tooltipItems = tooltipItems.sort(function (a, b) {
                return opts.itemSort(a, b, data);
              });
            } // Determine colors for boxes


            helpers$1.each(tooltipItems, function (tooltipItem) {
              labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
              labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
            }); // Build the Text Lines

            model.title = me.getTitle(tooltipItems, data);
            model.beforeBody = me.getBeforeBody(tooltipItems, data);
            model.body = me.getBody(tooltipItems, data);
            model.afterBody = me.getAfterBody(tooltipItems, data);
            model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

            model.x = tooltipPosition.x;
            model.y = tooltipPosition.y;
            model.caretPadding = opts.caretPadding;
            model.labelColors = labelColors;
            model.labelTextColors = labelTextColors; // data points

            model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

            tooltipSize = getTooltipSize(this, model);
            alignment = determineAlignment(this, tooltipSize); // Final Size and Position

            backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
          } else {
            model.opacity = 0;
          }

          model.xAlign = alignment.xAlign;
          model.yAlign = alignment.yAlign;
          model.x = backgroundPoint.x;
          model.y = backgroundPoint.y;
          model.width = tooltipSize.width;
          model.height = tooltipSize.height; // Point where the caret on the tooltip points to

          model.caretX = tooltipPosition.x;
          model.caretY = tooltipPosition.y;
          me._model = model;

          if (changed && opts.custom) {
            opts.custom.call(me, model);
          }

          return me;
        },
        drawCaret: function (tooltipPoint, size) {
          var ctx = this._chart.ctx;
          var vm = this._view;
          var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        },
        getCaretPosition: function (tooltipPoint, size, vm) {
          var x1, x2, x3, y1, y2, y3;
          var caretSize = vm.caretSize;
          var cornerRadius = vm.cornerRadius;
          var xAlign = vm.xAlign;
          var yAlign = vm.yAlign;
          var ptX = tooltipPoint.x;
          var ptY = tooltipPoint.y;
          var width = size.width;
          var height = size.height;

          if (yAlign === 'center') {
            y2 = ptY + height / 2;

            if (xAlign === 'left') {
              x1 = ptX;
              x2 = x1 - caretSize;
              x3 = x1;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              x3 = x1;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
          } else {
            if (xAlign === 'left') {
              x2 = ptX + cornerRadius + caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else if (xAlign === 'right') {
              x2 = ptX + width - cornerRadius - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              x2 = vm.caretX;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            }

            if (yAlign === 'top') {
              y1 = ptY;
              y2 = y1 - caretSize;
              y3 = y1;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              y3 = y1; // invert drawing order

              var tmp = x3;
              x3 = x1;
              x1 = tmp;
            }
          }

          return {
            x1: x1,
            x2: x2,
            x3: x3,
            y1: y1,
            y2: y2,
            y3: y3
          };
        },
        drawTitle: function (pt, vm, ctx) {
          var title = vm.title;

          if (title.length) {
            pt.x = getAlignedX(vm, vm._titleAlign);
            ctx.textAlign = vm._titleAlign;
            ctx.textBaseline = 'top';
            var titleFontSize = vm.titleFontSize;
            var titleSpacing = vm.titleSpacing;
            ctx.fillStyle = vm.titleFontColor;
            ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
            var i, len;

            for (i = 0, len = title.length; i < len; ++i) {
              ctx.fillText(title[i], pt.x, pt.y);
              pt.y += titleFontSize + titleSpacing; // Line Height and spacing

              if (i + 1 === title.length) {
                pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
              }
            }
          }
        },
        drawBody: function (pt, vm, ctx) {
          var bodyFontSize = vm.bodyFontSize;
          var bodySpacing = vm.bodySpacing;
          var bodyAlign = vm._bodyAlign;
          var body = vm.body;
          var drawColorBoxes = vm.displayColors;
          var labelColors = vm.labelColors;
          var xLinePadding = 0;
          var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
          var textColor;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = 'top';
          ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
          pt.x = getAlignedX(vm, bodyAlign); // Before Body

          var fillLineOfText = function (line) {
            ctx.fillText(line, pt.x + xLinePadding, pt.y);
            pt.y += bodyFontSize + bodySpacing;
          }; // Before body lines


          ctx.fillStyle = vm.bodyFontColor;
          helpers$1.each(vm.beforeBody, fillLineOfText);
          xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

          helpers$1.each(body, function (bodyItem, i) {
            textColor = vm.labelTextColors[i];
            ctx.fillStyle = textColor;
            helpers$1.each(bodyItem.before, fillLineOfText);
            helpers$1.each(bodyItem.lines, function (line) {
              // Draw Legend-like boxes if needed
              if (drawColorBoxes) {
                // Fill a white rect so that colours merge nicely if the opacity is < 1
                ctx.fillStyle = vm.legendColorBackground;
                ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

                ctx.lineWidth = 1;
                ctx.strokeStyle = labelColors[i].borderColor;
                ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

                ctx.fillStyle = labelColors[i].backgroundColor;
                ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                ctx.fillStyle = textColor;
              }

              fillLineOfText(line);
            });
            helpers$1.each(bodyItem.after, fillLineOfText);
          }); // Reset back to 0 for after body

          xLinePadding = 0; // After body lines

          helpers$1.each(vm.afterBody, fillLineOfText);
          pt.y -= bodySpacing; // Remove last body spacing
        },
        drawFooter: function (pt, vm, ctx) {
          var footer = vm.footer;

          if (footer.length) {
            pt.x = getAlignedX(vm, vm._footerAlign);
            pt.y += vm.footerMarginTop;
            ctx.textAlign = vm._footerAlign;
            ctx.textBaseline = 'top';
            ctx.fillStyle = vm.footerFontColor;
            ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
            helpers$1.each(footer, function (line) {
              ctx.fillText(line, pt.x, pt.y);
              pt.y += vm.footerFontSize + vm.footerSpacing;
            });
          }
        },
        drawBackground: function (pt, vm, ctx, tooltipSize) {
          ctx.fillStyle = vm.backgroundColor;
          ctx.strokeStyle = vm.borderColor;
          ctx.lineWidth = vm.borderWidth;
          var xAlign = vm.xAlign;
          var yAlign = vm.yAlign;
          var x = pt.x;
          var y = pt.y;
          var width = tooltipSize.width;
          var height = tooltipSize.height;
          var radius = vm.cornerRadius;
          ctx.beginPath();
          ctx.moveTo(x + radius, y);

          if (yAlign === 'top') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

          if (yAlign === 'center' && xAlign === 'right') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

          if (yAlign === 'bottom') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

          if (yAlign === 'center' && xAlign === 'left') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();

          if (vm.borderWidth > 0) {
            ctx.stroke();
          }
        },
        draw: function () {
          var ctx = this._chart.ctx;
          var vm = this._view;

          if (vm.opacity === 0) {
            return;
          }

          var tooltipSize = {
            width: vm.width,
            height: vm.height
          };
          var pt = {
            x: vm.x,
            y: vm.y
          }; // IE11/Edge does not like very small opacities, so snap to 0

          var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

          var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

          if (this._options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity; // Draw Background

            this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

            pt.y += vm.yPadding; // Titles

            this.drawTitle(pt, vm, ctx); // Body

            this.drawBody(pt, vm, ctx); // Footer

            this.drawFooter(pt, vm, ctx);
            ctx.restore();
          }
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         * @returns {boolean} true if the tooltip changed
         */
        handleEvent: function (e) {
          var me = this;
          var options = me._options;
          var changed = false;
          me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

          if (e.type === 'mouseout') {
            me._active = [];
          } else {
            me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
          } // Remember Last Actives


          changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

          if (changed) {
            me._lastActive = me._active;

            if (options.enabled || options.custom) {
              me._eventPosition = {
                x: e.x,
                y: e.y
              };
              me.update(true);
              me.pivot();
            }
          }

          return changed;
        }
      });
      /**
       * @namespace Chart.Tooltip.positioners
       */

      var positioners_1 = positioners;
      var core_tooltip = exports$3;
      core_tooltip.positioners = positioners_1;
      var valueOrDefault$8 = helpers$1.valueOrDefault;

      core_defaults._set('global', {
        elements: {},
        events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
        hover: {
          onHover: null,
          mode: 'nearest',
          intersect: true,
          animationDuration: 400
        },
        onClick: null,
        maintainAspectRatio: true,
        responsive: true,
        responsiveAnimationDuration: 0
      });
      /**
       * Recursively merge the given config objects representing the `scales` option
       * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
       * returns a deep copy of the result, thus doesn't alter inputs.
       */


      function mergeScaleConfig()
      /* config objects ... */
      {
        return helpers$1.merge({}, [].slice.call(arguments), {
          merger: function (key, target, source, options) {
            if (key === 'xAxes' || key === 'yAxes') {
              var slen = source[key].length;
              var i, type, scale;

              if (!target[key]) {
                target[key] = [];
              }

              for (i = 0; i < slen; ++i) {
                scale = source[key][i];
                type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

                if (i >= target[key].length) {
                  target[key].push({});
                }

                if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                  // new/untyped scale or type changed: let's apply the new defaults
                  // then merge source scale to correctly overwrite the defaults.
                  helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
                } else {
                  // scales type are the same
                  helpers$1.merge(target[key][i], scale);
                }
              }
            } else {
              helpers$1._merger(key, target, source, options);
            }
          }
        });
      }
      /**
       * Recursively merge the given config objects as the root options by handling
       * default scale options for the `scales` and `scale` properties, then returns
       * a deep copy of the result, thus doesn't alter inputs.
       */


      function mergeConfig()
      /* config objects ... */
      {
        return helpers$1.merge({}, [].slice.call(arguments), {
          merger: function (key, target, source, options) {
            var tval = target[key] || {};
            var sval = source[key];

            if (key === 'scales') {
              // scale config merging is complex. Add our own function here for that
              target[key] = mergeScaleConfig(tval, sval);
            } else if (key === 'scale') {
              // used in polar area & radar charts since there is only one scale
              target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
            } else {
              helpers$1._merger(key, target, source, options);
            }
          }
        });
      }

      function initConfig(config) {
        config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
        // and so would change references to labels and datasets, preventing data updates.

        var data = config.data = config.data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
        return config;
      }

      function updateConfig(chart) {
        var newOptions = chart.options;
        helpers$1.each(chart.scales, function (scale) {
          core_layouts.removeBox(chart, scale);
        });
        newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
        chart.options = chart.config.options = newOptions;
        chart.ensureScalesHaveIDs();
        chart.buildOrUpdateScales(); // Tooltip

        chart.tooltip._options = newOptions.tooltips;
        chart.tooltip.initialize();
      }

      function positionIsHorizontal(position) {
        return position === 'top' || position === 'bottom';
      }

      var Chart = function (item, config) {
        this.construct(item, config);
        return this;
      };

      helpers$1.extend(Chart.prototype,
      /** @lends Chart */
      {
        /**
         * @private
         */
        construct: function (item, config) {
          var me = this;
          config = initConfig(config);
          var context = platform.acquireContext(item, config);
          var canvas = context && context.canvas;
          var height = canvas && canvas.height;
          var width = canvas && canvas.width;
          me.id = helpers$1.uid();
          me.ctx = context;
          me.canvas = canvas;
          me.config = config;
          me.width = width;
          me.height = height;
          me.aspectRatio = height ? width / height : null;
          me.options = config.options;
          me._bufferedRender = false;
          /**
           * Provided for backward compatibility, Chart and Chart.Controller have been merged,
           * the "instance" still need to be defined since it might be called from plugins.
           * @prop Chart#chart
           * @deprecated since version 2.6.0
           * @todo remove at version 3
           * @private
           */

          me.chart = me;
          me.controller = me; // chart.chart.controller #inception
          // Add the chart instance to the global namespace

          Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

          Object.defineProperty(me, 'data', {
            get: function () {
              return me.config.data;
            },
            set: function (value) {
              me.config.data = value;
            }
          });

          if (!context || !canvas) {
            // The given item is not a compatible context2d element, let's return before finalizing
            // the chart initialization but after setting basic chart / controller properties that
            // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
            // https://github.com/chartjs/Chart.js/issues/2807
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }

          me.initialize();
          me.update();
        },

        /**
         * @private
         */
        initialize: function () {
          var me = this; // Before init plugin notification

          core_plugins.notify(me, 'beforeInit');
          helpers$1.retinaScale(me, me.options.devicePixelRatio);
          me.bindEvents();

          if (me.options.responsive) {
            // Initial resize before chart draws (must be silent to preserve initial animations).
            me.resize(true);
          } // Make sure scales have IDs and are built before we build any controllers.


          me.ensureScalesHaveIDs();
          me.buildOrUpdateScales();
          me.initToolTip(); // After init plugin notification

          core_plugins.notify(me, 'afterInit');
          return me;
        },
        clear: function () {
          helpers$1.canvas.clear(this);
          return this;
        },
        stop: function () {
          // Stops any current animation loop occurring
          core_animations.cancelAnimation(this);
          return this;
        },
        resize: function (silent) {
          var me = this;
          var options = me.options;
          var canvas = me.canvas;
          var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
          // the canvas display style uses the same integer values to avoid blurring effect.
          // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

          var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
          var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

          if (me.width === newWidth && me.height === newHeight) {
            return;
          }

          canvas.width = me.width = newWidth;
          canvas.height = me.height = newHeight;
          canvas.style.width = newWidth + 'px';
          canvas.style.height = newHeight + 'px';
          helpers$1.retinaScale(me, options.devicePixelRatio);

          if (!silent) {
            // Notify any plugins about the resize
            var newSize = {
              width: newWidth,
              height: newHeight
            };
            core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

            if (options.onResize) {
              options.onResize(me, newSize);
            }

            me.stop();
            me.update({
              duration: options.responsiveAnimationDuration
            });
          }
        },
        ensureScalesHaveIDs: function () {
          var options = this.options;
          var scalesOptions = options.scales || {};
          var scaleOptions = options.scale;
          helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
            xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
          });
          helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
            yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
          });

          if (scaleOptions) {
            scaleOptions.id = scaleOptions.id || 'scale';
          }
        },

        /**
         * Builds a map of scale ID to scale object for future lookup.
         */
        buildOrUpdateScales: function () {
          var me = this;
          var options = me.options;
          var scales = me.scales || {};
          var items = [];
          var updated = Object.keys(scales).reduce(function (obj, id) {
            obj[id] = false;
            return obj;
          }, {});

          if (options.scales) {
            items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
              return {
                options: xAxisOptions,
                dtype: 'category',
                dposition: 'bottom'
              };
            }), (options.scales.yAxes || []).map(function (yAxisOptions) {
              return {
                options: yAxisOptions,
                dtype: 'linear',
                dposition: 'left'
              };
            }));
          }

          if (options.scale) {
            items.push({
              options: options.scale,
              dtype: 'radialLinear',
              isDefault: true,
              dposition: 'chartArea'
            });
          }

          helpers$1.each(items, function (item) {
            var scaleOptions = item.options;
            var id = scaleOptions.id;
            var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

            if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }

            updated[id] = true;
            var scale = null;

            if (id in scales && scales[id].type === scaleType) {
              scale = scales[id];
              scale.options = scaleOptions;
              scale.ctx = me.ctx;
              scale.chart = me;
            } else {
              var scaleClass = core_scaleService.getScaleConstructor(scaleType);

              if (!scaleClass) {
                return;
              }

              scale = new scaleClass({
                id: id,
                type: scaleType,
                options: scaleOptions,
                ctx: me.ctx,
                chart: me
              });
              scales[scale.id] = scale;
            }

            scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
            // and consider it as a regular scale part of the "scales"" map only! This would
            // make the logic easier and remove some useless? custom code.

            if (item.isDefault) {
              me.scale = scale;
            }
          }); // clear up discarded scales

          helpers$1.each(updated, function (hasUpdated, id) {
            if (!hasUpdated) {
              delete scales[id];
            }
          });
          me.scales = scales;
          core_scaleService.addScalesToLayout(this);
        },
        buildOrUpdateControllers: function () {
          var me = this;
          var newControllers = [];
          helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
            var meta = me.getDatasetMeta(datasetIndex);
            var type = dataset.type || me.config.type;

            if (meta.type && meta.type !== type) {
              me.destroyDatasetMeta(datasetIndex);
              meta = me.getDatasetMeta(datasetIndex);
            }

            meta.type = type;

            if (meta.controller) {
              meta.controller.updateIndex(datasetIndex);
              meta.controller.linkScales();
            } else {
              var ControllerClass = controllers[meta.type];

              if (ControllerClass === undefined) {
                throw new Error('"' + meta.type + '" is not a chart type.');
              }

              meta.controller = new ControllerClass(me, datasetIndex);
              newControllers.push(meta.controller);
            }
          }, me);
          return newControllers;
        },

        /**
         * Reset the elements of all datasets
         * @private
         */
        resetElements: function () {
          var me = this;
          helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.reset();
          }, me);
        },

        /**
        * Resets the chart back to it's state before the initial animation
        */
        reset: function () {
          this.resetElements();
          this.tooltip.initialize();
        },
        update: function (config) {
          var me = this;

          if (!config || typeof config !== 'object') {
            // backwards compatibility
            config = {
              duration: config,
              lazy: arguments[1]
            };
          }

          updateConfig(me); // plugins options references might have change, let's invalidate the cache
          // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

          core_plugins._invalidate(me);

          if (core_plugins.notify(me, 'beforeUpdate') === false) {
            return;
          } // In case the entire data object changed


          me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

          var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

          helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
          }, me);
          me.updateLayout(); // Can only reset the new controllers after the scales have been updated

          if (me.options.animation && me.options.animation.duration) {
            helpers$1.each(newControllers, function (controller) {
              controller.reset();
            });
          }

          me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
          // after update.

          me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
          // When we reset the tooltip, we need to clear it

          me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

          core_plugins.notify(me, 'afterUpdate');

          if (me._bufferedRender) {
            me._bufferedRequest = {
              duration: config.duration,
              easing: config.easing,
              lazy: config.lazy
            };
          } else {
            me.render(config);
          }
        },

        /**
         * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
         * hook, in which case, plugins will not be called on `afterLayout`.
         * @private
         */
        updateLayout: function () {
          var me = this;

          if (core_plugins.notify(me, 'beforeLayout') === false) {
            return;
          }

          core_layouts.update(this, this.width, this.height);
          /**
           * Provided for backward compatibility, use `afterLayout` instead.
           * @method IPlugin#afterScaleUpdate
           * @deprecated since version 2.5.0
           * @todo remove at version 3
           * @private
           */

          core_plugins.notify(me, 'afterScaleUpdate');
          core_plugins.notify(me, 'afterLayout');
        },

        /**
         * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
         * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
         * @private
         */
        updateDatasets: function () {
          var me = this;

          if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
            return;
          }

          for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me.updateDataset(i);
          }

          core_plugins.notify(me, 'afterDatasetsUpdate');
        },

        /**
         * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
         * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
         * @private
         */
        updateDataset: function (index) {
          var me = this;
          var meta = me.getDatasetMeta(index);
          var args = {
            meta: meta,
            index: index
          };

          if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
            return;
          }

          meta.controller.update();
          core_plugins.notify(me, 'afterDatasetUpdate', [args]);
        },
        render: function (config) {
          var me = this;

          if (!config || typeof config !== 'object') {
            // backwards compatibility
            config = {
              duration: config,
              lazy: arguments[1]
            };
          }

          var animationOptions = me.options.animation;
          var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
          var lazy = config.lazy;

          if (core_plugins.notify(me, 'beforeRender') === false) {
            return;
          }

          var onComplete = function (animation) {
            core_plugins.notify(me, 'afterRender');
            helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
          };

          if (animationOptions && duration) {
            var animation = new core_animation({
              numSteps: duration / 16.66,
              // 60 fps
              easing: config.easing || animationOptions.easing,
              render: function (chart, animationObject) {
                var easingFunction = helpers$1.easing.effects[animationObject.easing];
                var currentStep = animationObject.currentStep;
                var stepDecimal = currentStep / animationObject.numSteps;
                chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
              },
              onAnimationProgress: animationOptions.onProgress,
              onAnimationComplete: onComplete
            });
            core_animations.addAnimation(me, animation, duration, lazy);
          } else {
            me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

            onComplete(new core_animation({
              numSteps: 0,
              chart: me
            }));
          }

          return me;
        },
        draw: function (easingValue) {
          var me = this;
          me.clear();

          if (helpers$1.isNullOrUndef(easingValue)) {
            easingValue = 1;
          }

          me.transition(easingValue);

          if (me.width <= 0 || me.height <= 0) {
            return;
          }

          if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
            return;
          } // Draw all the scales


          helpers$1.each(me.boxes, function (box) {
            box.draw(me.chartArea);
          }, me);
          me.drawDatasets(easingValue);

          me._drawTooltip(easingValue);

          core_plugins.notify(me, 'afterDraw', [easingValue]);
        },

        /**
         * @private
         */
        transition: function (easingValue) {
          var me = this;

          for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
            if (me.isDatasetVisible(i)) {
              me.getDatasetMeta(i).controller.transition(easingValue);
            }
          }

          me.tooltip.transition(easingValue);
        },

        /**
         * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
         * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
         * @private
         */
        drawDatasets: function (easingValue) {
          var me = this;

          if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
            return;
          } // Draw datasets reversed to support proper line stacking


          for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
            if (me.isDatasetVisible(i)) {
              me.drawDataset(i, easingValue);
            }
          }

          core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
        },

        /**
         * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
         * hook, in which case, plugins will not be called on `afterDatasetDraw`.
         * @private
         */
        drawDataset: function (index, easingValue) {
          var me = this;
          var meta = me.getDatasetMeta(index);
          var args = {
            meta: meta,
            index: index,
            easingValue: easingValue
          };

          if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
            return;
          }

          meta.controller.draw(easingValue);
          core_plugins.notify(me, 'afterDatasetDraw', [args]);
        },

        /**
         * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
         * hook, in which case, plugins will not be called on `afterTooltipDraw`.
         * @private
         */
        _drawTooltip: function (easingValue) {
          var me = this;
          var tooltip = me.tooltip;
          var args = {
            tooltip: tooltip,
            easingValue: easingValue
          };

          if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
            return;
          }

          tooltip.draw();
          core_plugins.notify(me, 'afterTooltipDraw', [args]);
        },

        /**
         * Get the single element that was clicked on
         * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
         */
        getElementAtEvent: function (e) {
          return core_interaction.modes.single(this, e);
        },
        getElementsAtEvent: function (e) {
          return core_interaction.modes.label(this, e, {
            intersect: true
          });
        },
        getElementsAtXAxis: function (e) {
          return core_interaction.modes['x-axis'](this, e, {
            intersect: true
          });
        },
        getElementsAtEventForMode: function (e, mode, options) {
          var method = core_interaction.modes[mode];

          if (typeof method === 'function') {
            return method(this, e, options);
          }

          return [];
        },
        getDatasetAtEvent: function (e) {
          return core_interaction.modes.dataset(this, e, {
            intersect: true
          });
        },
        getDatasetMeta: function (datasetIndex) {
          var me = this;
          var dataset = me.data.datasets[datasetIndex];

          if (!dataset._meta) {
            dataset._meta = {};
          }

          var meta = dataset._meta[me.id];

          if (!meta) {
            meta = dataset._meta[me.id] = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              // See isDatasetVisible() comment
              xAxisID: null,
              yAxisID: null
            };
          }

          return meta;
        },
        getVisibleDatasetCount: function () {
          var count = 0;

          for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            if (this.isDatasetVisible(i)) {
              count++;
            }
          }

          return count;
        },
        isDatasetVisible: function (datasetIndex) {
          var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
          // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

          return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
        },
        generateLegend: function () {
          return this.options.legendCallback(this);
        },

        /**
         * @private
         */
        destroyDatasetMeta: function (datasetIndex) {
          var id = this.id;
          var dataset = this.data.datasets[datasetIndex];
          var meta = dataset._meta && dataset._meta[id];

          if (meta) {
            meta.controller.destroy();
            delete dataset._meta[id];
          }
        },
        destroy: function () {
          var me = this;
          var canvas = me.canvas;
          var i, ilen;
          me.stop(); // dataset controllers need to cleanup associated data

          for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me.destroyDatasetMeta(i);
          }

          if (canvas) {
            me.unbindEvents();
            helpers$1.canvas.clear(me);
            platform.releaseContext(me.ctx);
            me.canvas = null;
            me.ctx = null;
          }

          core_plugins.notify(me, 'destroy');
          delete Chart.instances[me.id];
        },
        toBase64Image: function () {
          return this.canvas.toDataURL.apply(this.canvas, arguments);
        },
        initToolTip: function () {
          var me = this;
          me.tooltip = new core_tooltip({
            _chart: me,
            _chartInstance: me,
            // deprecated, backward compatibility
            _data: me.data,
            _options: me.options.tooltips
          }, me);
        },

        /**
         * @private
         */
        bindEvents: function () {
          var me = this;
          var listeners = me._listeners = {};

          var listener = function () {
            me.eventHandler.apply(me, arguments);
          };

          helpers$1.each(me.options.events, function (type) {
            platform.addEventListener(me, type, listener);
            listeners[type] = listener;
          }); // Elements used to detect size change should not be injected for non responsive charts.
          // See https://github.com/chartjs/Chart.js/issues/2210

          if (me.options.responsive) {
            listener = function () {
              me.resize();
            };

            platform.addEventListener(me, 'resize', listener);
            listeners.resize = listener;
          }
        },

        /**
         * @private
         */
        unbindEvents: function () {
          var me = this;
          var listeners = me._listeners;

          if (!listeners) {
            return;
          }

          delete me._listeners;
          helpers$1.each(listeners, function (listener, type) {
            platform.removeEventListener(me, type, listener);
          });
        },
        updateHoverStyle: function (elements, mode, enabled) {
          var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
          var element, i, ilen;

          for (i = 0, ilen = elements.length; i < ilen; ++i) {
            element = elements[i];

            if (element) {
              this.getDatasetMeta(element._datasetIndex).controller[method](element);
            }
          }
        },

        /**
         * @private
         */
        eventHandler: function (e) {
          var me = this;
          var tooltip = me.tooltip;

          if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
            return;
          } // Buffer any update calls so that renders do not occur


          me._bufferedRender = true;
          me._bufferedRequest = null;
          var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
          // the tooltip should be the source of change
          // Animation check workaround:
          // tooltip._start will be null when tooltip isn't animating

          if (tooltip) {
            changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
          }

          core_plugins.notify(me, 'afterEvent', [e]);
          var bufferedRequest = me._bufferedRequest;

          if (bufferedRequest) {
            // If we have an update that was triggered, we need to do a normal render
            me.render(bufferedRequest);
          } else if (changed && !me.animating) {
            // If entering, leaving, or changing elements, animate the change via pivot
            me.stop(); // We only need to render at this point. Updating will cause scales to be
            // recomputed generating flicker & using more memory than necessary.

            me.render({
              duration: me.options.hover.animationDuration,
              lazy: true
            });
          }

          me._bufferedRender = false;
          me._bufferedRequest = null;
          return me;
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event the event to handle
         * @return {boolean} true if the chart needs to re-render
         */
        handleEvent: function (e) {
          var me = this;
          var options = me.options || {};
          var hoverOptions = options.hover;
          var changed = false;
          me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

          if (e.type === 'mouseout') {
            me.active = [];
          } else {
            me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
          } // Invoke onHover hook
          // Need to call with native event here to not break backwards compatibility


          helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

          if (e.type === 'mouseup' || e.type === 'click') {
            if (options.onClick) {
              // Use e.native here for backwards compatibility
              options.onClick.call(me, e.native, me.active);
            }
          } // Remove styling for last active (even if it may still be active)


          if (me.lastActive.length) {
            me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
          } // Built in hover styling


          if (me.active.length && hoverOptions.mode) {
            me.updateHoverStyle(me.active, hoverOptions.mode, true);
          }

          changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

          me.lastActive = me.active;
          return changed;
        }
      });
      /**
       * NOTE(SB) We actually don't use this container anymore but we need to keep it
       * for backward compatibility. Though, it can still be useful for plugins that
       * would need to work on multiple charts?!
       */

      Chart.instances = {};
      var core_controller = Chart; // DEPRECATIONS

      /**
       * Provided for backward compatibility, use Chart instead.
       * @class Chart.Controller
       * @deprecated since version 2.6
       * @todo remove at version 3
       * @private
       */

      Chart.Controller = Chart;
      /**
       * Provided for backward compatibility, not available anymore.
       * @namespace Chart
       * @deprecated since version 2.8
       * @todo remove at version 3
       * @private
       */

      Chart.types = {};
      /**
       * Provided for backward compatibility, not available anymore.
       * @namespace Chart.helpers.configMerge
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */

      helpers$1.configMerge = mergeConfig;
      /**
       * Provided for backward compatibility, not available anymore.
       * @namespace Chart.helpers.scaleMerge
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */

      helpers$1.scaleMerge = mergeScaleConfig;

      var core_helpers = function () {
        // -- Basic js utility methods
        helpers$1.where = function (collection, filterCallback) {
          if (helpers$1.isArray(collection) && Array.prototype.filter) {
            return collection.filter(filterCallback);
          }

          var filtered = [];
          helpers$1.each(collection, function (item) {
            if (filterCallback(item)) {
              filtered.push(item);
            }
          });
          return filtered;
        };

        helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
          return array.findIndex(callback, scope);
        } : function (array, callback, scope) {
          scope = scope === undefined ? array : scope;

          for (var i = 0, ilen = array.length; i < ilen; ++i) {
            if (callback.call(scope, array[i], i, array)) {
              return i;
            }
          }

          return -1;
        };

        helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
          // Default to start of the array
          if (helpers$1.isNullOrUndef(startIndex)) {
            startIndex = -1;
          }

          for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
            var currentItem = arrayToSearch[i];

            if (filterCallback(currentItem)) {
              return currentItem;
            }
          }
        };

        helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
          // Default to end of the array
          if (helpers$1.isNullOrUndef(startIndex)) {
            startIndex = arrayToSearch.length;
          }

          for (var i = startIndex - 1; i >= 0; i--) {
            var currentItem = arrayToSearch[i];

            if (filterCallback(currentItem)) {
              return currentItem;
            }
          }
        }; // -- Math methods


        helpers$1.isNumber = function (n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        };

        helpers$1.almostEquals = function (x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        };

        helpers$1.almostWhole = function (x, epsilon) {
          var rounded = Math.round(x);
          return rounded - epsilon < x && rounded + epsilon > x;
        };

        helpers$1.max = function (array) {
          return array.reduce(function (max, value) {
            if (!isNaN(value)) {
              return Math.max(max, value);
            }

            return max;
          }, Number.NEGATIVE_INFINITY);
        };

        helpers$1.min = function (array) {
          return array.reduce(function (min, value) {
            if (!isNaN(value)) {
              return Math.min(min, value);
            }

            return min;
          }, Number.POSITIVE_INFINITY);
        };

        helpers$1.sign = Math.sign ? function (x) {
          return Math.sign(x);
        } : function (x) {
          x = +x; // convert to a number

          if (x === 0 || isNaN(x)) {
            return x;
          }

          return x > 0 ? 1 : -1;
        };
        helpers$1.log10 = Math.log10 ? function (x) {
          return Math.log10(x);
        } : function (x) {
          var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
          // Check for whole powers of 10,
          // which due to floating point rounding error should be corrected.

          var powerOf10 = Math.round(exponent);
          var isPowerOf10 = x === Math.pow(10, powerOf10);
          return isPowerOf10 ? powerOf10 : exponent;
        };

        helpers$1.toRadians = function (degrees) {
          return degrees * (Math.PI / 180);
        };

        helpers$1.toDegrees = function (radians) {
          return radians * (180 / Math.PI);
        };
        /**
         * Returns the number of decimal places
         * i.e. the number of digits after the decimal point, of the value of this Number.
         * @param {number} x - A number.
         * @returns {number} The number of decimal places.
         * @private
         */


        helpers$1._decimalPlaces = function (x) {
          if (!helpers$1.isFinite(x)) {
            return;
          }

          var e = 1;
          var p = 0;

          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }

          return p;
        }; // Gets the angle from vertical upright to the point about a centre.


        helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
          var distanceFromXCenter = anglePoint.x - centrePoint.x;
          var distanceFromYCenter = anglePoint.y - centrePoint.y;
          var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

          if (angle < -0.5 * Math.PI) {
            angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
          }

          return {
            angle: angle,
            distance: radialDistanceFromCenter
          };
        };

        helpers$1.distanceBetweenPoints = function (pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        };
        /**
         * Provided for backward compatibility, not available anymore
         * @function Chart.helpers.aliasPixel
         * @deprecated since version 2.8.0
         * @todo remove at version 3
         */


        helpers$1.aliasPixel = function (pixelWidth) {
          return pixelWidth % 2 === 0 ? 0 : 0.5;
        };
        /**
         * Returns the aligned pixel value to avoid anti-aliasing blur
         * @param {Chart} chart - The chart instance.
         * @param {number} pixel - A pixel value.
         * @param {number} width - The width of the element.
         * @returns {number} The aligned pixel value.
         * @private
         */


        helpers$1._alignPixel = function (chart, pixel, width) {
          var devicePixelRatio = chart.currentDevicePixelRatio;
          var halfWidth = width / 2;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        };

        helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
          // Props to Rob Spencer at scaled innovation for his post on splining between points
          // http://scaledinnovation.com/analytics/splines/aboutSplines.html
          // This function must also respect "skipped" points
          var previous = firstPoint.skip ? middlePoint : firstPoint;
          var current = middlePoint;
          var next = afterPoint.skip ? middlePoint : afterPoint;
          var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
          var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
          var s01 = d01 / (d01 + d12);
          var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          var fa = t * s01; // scaling factor for triangle Ta

          var fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        };

        helpers$1.EPSILON = Number.EPSILON || 1e-14;

        helpers$1.splineCurveMonotone = function (points) {
          // This function calculates Bézier control points in a similar way than |splineCurve|,
          // but preserves monotonicity of the provided data and ensures no local extremums are added
          // between the dataset discrete points due to the interpolation.
          // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
          var pointsWithTangents = (points || []).map(function (point) {
            return {
              model: point._model,
              deltaK: 0,
              mK: 0
            };
          }); // Calculate slopes (deltaK) and initialize tangents (mK)

          var pointsLen = pointsWithTangents.length;
          var i, pointBefore, pointCurrent, pointAfter;

          for (i = 0; i < pointsLen; ++i) {
            pointCurrent = pointsWithTangents[i];

            if (pointCurrent.model.skip) {
              continue;
            }

            pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
            pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

            if (pointAfter && !pointAfter.model.skip) {
              var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

              pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
            }

            if (!pointBefore || pointBefore.model.skip) {
              pointCurrent.mK = pointCurrent.deltaK;
            } else if (!pointAfter || pointAfter.model.skip) {
              pointCurrent.mK = pointBefore.deltaK;
            } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
              pointCurrent.mK = 0;
            } else {
              pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
            }
          } // Adjust tangents to ensure monotonic properties


          var alphaK, betaK, tauK, squaredMagnitude;

          for (i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointsWithTangents[i];
            pointAfter = pointsWithTangents[i + 1];

            if (pointCurrent.model.skip || pointAfter.model.skip) {
              continue;
            }

            if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
              pointCurrent.mK = pointAfter.mK = 0;
              continue;
            }

            alphaK = pointCurrent.mK / pointCurrent.deltaK;
            betaK = pointAfter.mK / pointCurrent.deltaK;
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

            if (squaredMagnitude <= 9) {
              continue;
            }

            tauK = 3 / Math.sqrt(squaredMagnitude);
            pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
            pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
          } // Compute control points


          var deltaX;

          for (i = 0; i < pointsLen; ++i) {
            pointCurrent = pointsWithTangents[i];

            if (pointCurrent.model.skip) {
              continue;
            }

            pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
            pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

            if (pointBefore && !pointBefore.model.skip) {
              deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
              pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
              pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
            }

            if (pointAfter && !pointAfter.model.skip) {
              deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
              pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
              pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
            }
          }
        };

        helpers$1.nextItem = function (collection, index, loop) {
          if (loop) {
            return index >= collection.length - 1 ? collection[0] : collection[index + 1];
          }

          return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
        };

        helpers$1.previousItem = function (collection, index, loop) {
          if (loop) {
            return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
          }

          return index <= 0 ? collection[0] : collection[index - 1];
        }; // Implementation of the nice number algorithm used in determining where axis labels will go


        helpers$1.niceNum = function (range, round) {
          var exponent = Math.floor(helpers$1.log10(range));
          var fraction = range / Math.pow(10, exponent);
          var niceFraction;

          if (round) {
            if (fraction < 1.5) {
              niceFraction = 1;
            } else if (fraction < 3) {
              niceFraction = 2;
            } else if (fraction < 7) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
          } else if (fraction <= 1.0) {
            niceFraction = 1;
          } else if (fraction <= 2) {
            niceFraction = 2;
          } else if (fraction <= 5) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }

          return niceFraction * Math.pow(10, exponent);
        }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


        helpers$1.requestAnimFrame = function () {
          if (typeof window === 'undefined') {
            return function (callback) {
              callback();
            };
          }

          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
            return window.setTimeout(callback, 1000 / 60);
          };
        }(); // -- DOM methods


        helpers$1.getRelativePosition = function (evt, chart) {
          var mouseX, mouseY;
          var e = evt.originalEvent || evt;
          var canvas = evt.target || evt.srcElement;
          var boundingRect = canvas.getBoundingClientRect();
          var touches = e.touches;

          if (touches && touches.length > 0) {
            mouseX = touches[0].clientX;
            mouseY = touches[0].clientY;
          } else {
            mouseX = e.clientX;
            mouseY = e.clientY;
          } // Scale mouse coordinates into canvas coordinates
          // by following the pattern laid out by 'jerryj' in the comments of
          // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


          var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
          var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
          var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
          var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
          var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
          var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
          // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

          mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
          mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
          return {
            x: mouseX,
            y: mouseY
          };
        }; // Private helper function to convert max-width/max-height values that may be percentages into a number


        function parseMaxStyle(styleValue, node, parentProperty) {
          var valueInPixels;

          if (typeof styleValue === 'string') {
            valueInPixels = parseInt(styleValue, 10);

            if (styleValue.indexOf('%') !== -1) {
              // percentage * size in dimension
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }

          return valueInPixels;
        }
        /**
         * Returns if the given value contains an effective constraint.
         * @private
         */


        function isConstrainedValue(value) {
          return value !== undefined && value !== null && value !== 'none';
        }
        /**
         * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
         * @param {HTMLElement} domNode - the node to check the constraint on
         * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
         * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
         * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
         */


        function getConstraintDimension(domNode, maxStyle, percentageProperty) {
          var view = document.defaultView;

          var parentNode = helpers$1._getParentNode(domNode);

          var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
          var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
          var hasCNode = isConstrainedValue(constrainedNode);
          var hasCContainer = isConstrainedValue(constrainedContainer);
          var infinity = Number.POSITIVE_INFINITY;

          if (hasCNode || hasCContainer) {
            return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
          }

          return 'none';
        } // returns Number or undefined if no constraint


        helpers$1.getConstraintWidth = function (domNode) {
          return getConstraintDimension(domNode, 'max-width', 'clientWidth');
        }; // returns Number or undefined if no constraint


        helpers$1.getConstraintHeight = function (domNode) {
          return getConstraintDimension(domNode, 'max-height', 'clientHeight');
        };
        /**
         * @private
        	 */


        helpers$1._calculatePadding = function (container, padding, parentDimension) {
          padding = helpers$1.getStyle(container, padding);
          return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
        };
        /**
         * @private
         */


        helpers$1._getParentNode = function (domNode) {
          var parent = domNode.parentNode;

          if (parent && parent.toString() === '[object ShadowRoot]') {
            parent = parent.host;
          }

          return parent;
        };

        helpers$1.getMaximumWidth = function (domNode) {
          var container = helpers$1._getParentNode(domNode);

          if (!container) {
            return domNode.clientWidth;
          }

          var clientWidth = container.clientWidth;

          var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

          var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

          var w = clientWidth - paddingLeft - paddingRight;
          var cw = helpers$1.getConstraintWidth(domNode);
          return isNaN(cw) ? w : Math.min(w, cw);
        };

        helpers$1.getMaximumHeight = function (domNode) {
          var container = helpers$1._getParentNode(domNode);

          if (!container) {
            return domNode.clientHeight;
          }

          var clientHeight = container.clientHeight;

          var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

          var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

          var h = clientHeight - paddingTop - paddingBottom;
          var ch = helpers$1.getConstraintHeight(domNode);
          return isNaN(ch) ? h : Math.min(h, ch);
        };

        helpers$1.getStyle = function (el, property) {
          return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
        };

        helpers$1.retinaScale = function (chart, forceRatio) {
          var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

          if (pixelRatio === 1) {
            return;
          }

          var canvas = chart.canvas;
          var height = chart.height;
          var width = chart.width;
          canvas.height = height * pixelRatio;
          canvas.width = width * pixelRatio;
          chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
          // making the chart visually bigger, so let's enforce it to the "correct" values.
          // See https://github.com/chartjs/Chart.js/issues/3575

          if (!canvas.style.height && !canvas.style.width) {
            canvas.style.height = height + 'px';
            canvas.style.width = width + 'px';
          }
        }; // -- Canvas methods


        helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
          return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
        };

        helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          var data = cache.data = cache.data || {};
          var gc = cache.garbageCollect = cache.garbageCollect || [];

          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }

          ctx.font = font;
          var longest = 0;
          helpers$1.each(arrayOfThings, function (thing) {
            // Undefined strings and arrays should not be measured
            if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
              longest = helpers$1.measureText(ctx, data, gc, longest, thing);
            } else if (helpers$1.isArray(thing)) {
              // if it is an array lets measure each element
              // to do maybe simplify this function a bit so we can do this more recursively?
              helpers$1.each(thing, function (nestedThing) {
                // Undefined strings and arrays should not be measured
                if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                  longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                }
              });
            }
          });
          var gcLen = gc.length / 2;

          if (gcLen > arrayOfThings.length) {
            for (var i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }

            gc.splice(0, gcLen);
          }

          return longest;
        };

        helpers$1.measureText = function (ctx, data, gc, longest, string) {
          var textWidth = data[string];

          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }

          if (textWidth > longest) {
            longest = textWidth;
          }

          return longest;
        };

        helpers$1.numberOfLabelLines = function (arrayOfThings) {
          var numberOfLines = 1;
          helpers$1.each(arrayOfThings, function (thing) {
            if (helpers$1.isArray(thing)) {
              if (thing.length > numberOfLines) {
                numberOfLines = thing.length;
              }
            }
          });
          return numberOfLines;
        };

        helpers$1.color = !chartjsColor ? function (value) {
          console.error('Color.js not found!');
          return value;
        } : function (value) {
          /* global CanvasGradient */
          if (value instanceof CanvasGradient) {
            value = core_defaults.global.defaultColor;
          }

          return chartjsColor(value);
        };

        helpers$1.getHoverColor = function (colorValue) {
          /* global CanvasPattern */
          return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
        };
      };

      function abstract() {
        throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
      }
      /**
       * Date adapter (current used by the time scale)
       * @namespace Chart._adapters._date
       * @memberof Chart._adapters
       * @private
       */

      /**
       * Currently supported unit string values.
       * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
       * @memberof Chart._adapters._date
       * @name Unit
       */

      /**
       * @class
       */


      function DateAdapter(options) {
        this.options = options || {};
      }

      helpers$1.extend(DateAdapter.prototype,
      /** @lends DateAdapter */
      {
        /**
         * Returns a map of time formats for the supported formatting units defined
         * in Unit as well as 'datetime' representing a detailed date/time string.
         * @returns {{string: string}}
         */
        formats: abstract,

        /**
         * Parses the given `value` and return the associated timestamp.
         * @param {any} value - the value to parse (usually comes from the data)
         * @param {string} [format] - the expected data format
         * @returns {(number|null)}
         * @function
         */
        parse: abstract,

        /**
         * Returns the formatted date in the specified `format` for a given `timestamp`.
         * @param {number} timestamp - the timestamp to format
         * @param {string} format - the date/time token
         * @return {string}
         * @function
         */
        format: abstract,

        /**
         * Adds the specified `amount` of `unit` to the given `timestamp`.
         * @param {number} timestamp - the input timestamp
         * @param {number} amount - the amount to add
         * @param {Unit} unit - the unit as string
         * @return {number}
         * @function
         */
        add: abstract,

        /**
         * Returns the number of `unit` between the given timestamps.
         * @param {number} max - the input timestamp (reference)
         * @param {number} min - the timestamp to substract
         * @param {Unit} unit - the unit as string
         * @return {number}
         * @function
         */
        diff: abstract,

        /**
         * Returns start of `unit` for the given `timestamp`.
         * @param {number} timestamp - the input timestamp
         * @param {Unit} unit - the unit as string
         * @param {number} [weekday] - the ISO day of the week with 1 being Monday
         * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
         * @function
         */
        startOf: abstract,

        /**
         * Returns end of `unit` for the given `timestamp`.
         * @param {number} timestamp - the input timestamp
         * @param {Unit} unit - the unit as string
         * @function
         */
        endOf: abstract,
        // DEPRECATIONS

        /**
         * Provided for backward compatibility for scale.getValueForPixel(),
         * this method should be overridden only by the moment adapter.
         * @deprecated since version 2.8.0
         * @todo remove at version 3
         * @private
         */
        _create: function (value) {
          return value;
        }
      });

      DateAdapter.override = function (members) {
        helpers$1.extend(DateAdapter.prototype, members);
      };

      var _date = DateAdapter;
      var core_adapters = {
        _date: _date
      };
      /**
       * Namespace to hold static tick generation functions
       * @namespace Chart.Ticks
       */

      var core_ticks = {
        /**
         * Namespace to hold formatters for different types of ticks
         * @namespace Chart.Ticks.formatters
         */
        formatters: {
          /**
           * Formatter for value labels
           * @method Chart.Ticks.formatters.values
           * @param value the value to display
           * @return {string|string[]} the label to display
           */
          values: function (value) {
            return helpers$1.isArray(value) ? value : '' + value;
          },

          /**
           * Formatter for linear numeric ticks
           * @method Chart.Ticks.formatters.linear
           * @param tickValue {number} the value to be formatted
           * @param index {number} the position of the tickValue parameter in the ticks array
           * @param ticks {number[]} the list of ticks being converted
           * @return {string} string representation of the tickValue parameter
           */
          linear: function (tickValue, index, ticks) {
            // If we have lots of ticks, don't use the ones
            var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

            if (Math.abs(delta) > 1) {
              if (tickValue !== Math.floor(tickValue)) {
                // not an integer
                delta = tickValue - Math.floor(tickValue);
              }
            }

            var logDelta = helpers$1.log10(Math.abs(delta));
            var tickString = '';

            if (tickValue !== 0) {
              var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

              if (maxTick < 1e-4) {
                // all ticks are small numbers; use scientific notation
                var logTick = helpers$1.log10(Math.abs(tickValue));
                tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
              } else {
                var numDecimal = -1 * Math.floor(logDelta);
                numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

                tickString = tickValue.toFixed(numDecimal);
              }
            } else {
              tickString = '0'; // never show decimal places for 0
            }

            return tickString;
          },
          logarithmic: function (tickValue, index, ticks) {
            var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

            if (tickValue === 0) {
              return '0';
            } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
              return tickValue.toExponential();
            }

            return '';
          }
        }
      };
      var valueOrDefault$9 = helpers$1.valueOrDefault;
      var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

      core_defaults._set('scale', {
        display: true,
        position: 'left',
        offset: false,
        // grid line settings
        gridLines: {
          display: true,
          color: 'rgba(0, 0, 0, 0.1)',
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickMarkLength: 10,
          zeroLineWidth: 1,
          zeroLineColor: 'rgba(0,0,0,0.25)',
          zeroLineBorderDash: [],
          zeroLineBorderDashOffset: 0.0,
          offsetGridLines: false,
          borderDash: [],
          borderDashOffset: 0.0
        },
        // scale label
        scaleLabel: {
          // display property
          display: false,
          // actual label
          labelString: '',
          // top/bottom padding
          padding: {
            top: 4,
            bottom: 4
          }
        },
        // label settings
        ticks: {
          beginAtZero: false,
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          padding: 0,
          reverse: false,
          display: true,
          autoSkip: true,
          autoSkipPadding: 0,
          labelOffset: 0,
          // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
          callback: core_ticks.formatters.values,
          minor: {},
          major: {}
        }
      });

      function labelsFromTicks(ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(ticks[i].label);
        }

        return labels;
      }

      function getPixelForGridLine(scale, index, offsetGridLines) {
        var lineValue = scale.getPixelForTick(index);

        if (offsetGridLines) {
          if (scale.getTicks().length === 1) {
            lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
          } else if (index === 0) {
            lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
            lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
          }
        }

        return lineValue;
      }

      function computeTextSize(context, tick, font) {
        return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
      }

      var core_scale = core_element.extend({
        /**
         * Get the padding needed for the scale
         * @method getPadding
         * @private
         * @returns {Padding} the necessary padding
         */
        getPadding: function () {
          var me = this;
          return {
            left: me.paddingLeft || 0,
            top: me.paddingTop || 0,
            right: me.paddingRight || 0,
            bottom: me.paddingBottom || 0
          };
        },

        /**
         * Returns the scale tick objects ({label, major})
         * @since 2.7
         */
        getTicks: function () {
          return this._ticks;
        },
        // These methods are ordered by lifecyle. Utilities then follow.
        // Any function defined here is inherited by all scale types.
        // Any function can be extended by the scale type
        mergeTicksOptions: function () {
          var ticks = this.options.ticks;

          if (ticks.minor === false) {
            ticks.minor = {
              display: false
            };
          }

          if (ticks.major === false) {
            ticks.major = {
              display: false
            };
          }

          for (var key in ticks) {
            if (key !== 'major' && key !== 'minor') {
              if (typeof ticks.minor[key] === 'undefined') {
                ticks.minor[key] = ticks[key];
              }

              if (typeof ticks.major[key] === 'undefined') {
                ticks.major[key] = ticks[key];
              }
            }
          }
        },
        beforeUpdate: function () {
          helpers$1.callback(this.options.beforeUpdate, [this]);
        },
        update: function (maxWidth, maxHeight, margins) {
          var me = this;
          var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = helpers$1.extend({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          me._maxLabelLines = 0;
          me.longestLabelWidth = 0;
          me.longestTextCache = me.longestTextCache || {}; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Data min/max

          me.beforeDataLimits();
          me.determineDataLimits();
          me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
          // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
          // and must not be accessed directly from outside this class. `this.ticks` being
          // around for long time and not marked as private, we can't change its structure
          // without unexpected breaking changes. If you need to access the scale ticks,
          // use scale.getTicks() instead.

          me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
          // we still support no return (`this.ticks` internally set by calling this method).

          ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

          ticks = me.afterBuildTicks(ticks) || ticks;
          me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
          // COMPAT, we still support no return (`this.ticks` internally changed by calling
          // this method and supposed to contain only string values).

          labels = me.convertTicksToLabels(ticks) || me.ticks;
          me.afterTickToLabelConversion();
          me.ticks = labels; // BACKWARD COMPATIBILITY
          // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
          // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            tick = ticks[i];

            if (!tick) {
              ticks.push(tick = {
                label: label,
                major: false
              });
            } else {
              tick.label = label;
            }
          }

          me._ticks = ticks; // Tick Rotation

          me.beforeCalculateTickRotation();
          me.calculateTickRotation();
          me.afterCalculateTickRotation(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: function () {
          helpers$1.callback(this.options.afterUpdate, [this]);
        },
        //
        beforeSetDimensions: function () {
          helpers$1.callback(this.options.beforeSetDimensions, [this]);
        },
        setDimensions: function () {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
        },
        afterSetDimensions: function () {
          helpers$1.callback(this.options.afterSetDimensions, [this]);
        },
        // Data limits
        beforeDataLimits: function () {
          helpers$1.callback(this.options.beforeDataLimits, [this]);
        },
        determineDataLimits: helpers$1.noop,
        afterDataLimits: function () {
          helpers$1.callback(this.options.afterDataLimits, [this]);
        },
        //
        beforeBuildTicks: function () {
          helpers$1.callback(this.options.beforeBuildTicks, [this]);
        },
        buildTicks: helpers$1.noop,
        afterBuildTicks: function (ticks) {
          var me = this; // ticks is empty for old axis implementations here

          if (helpers$1.isArray(ticks) && ticks.length) {
            return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
          } // Support old implementations (that modified `this.ticks` directly in buildTicks)


          me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
          return ticks;
        },
        beforeTickToLabelConversion: function () {
          helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
        },
        convertTicksToLabels: function () {
          var me = this; // Convert ticks to strings

          var tickOpts = me.options.ticks;
          me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
        },
        afterTickToLabelConversion: function () {
          helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
        },
        //
        beforeCalculateTickRotation: function () {
          helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
        },
        calculateTickRotation: function () {
          var me = this;
          var context = me.ctx;
          var tickOpts = me.options.ticks;
          var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
          // between x offsets between 0 and 1.

          var tickFont = helpers$1.options._parseFont(tickOpts);

          context.font = tickFont.string;
          var labelRotation = tickOpts.minRotation || 0;

          if (labels.length && me.options.display && me.isHorizontal()) {
            var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
            var labelWidth = originalLabelWidth;
            var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

            var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

            while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
              var angleRadians = helpers$1.toRadians(labelRotation);
              cosRotation = Math.cos(angleRadians);
              sinRotation = Math.sin(angleRadians);

              if (sinRotation * originalLabelWidth > me.maxHeight) {
                // go back one step
                labelRotation--;
                break;
              }

              labelRotation++;
              labelWidth = cosRotation * originalLabelWidth;
            }
          }

          me.labelRotation = labelRotation;
        },
        afterCalculateTickRotation: function () {
          helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
        },
        //
        beforeFit: function () {
          helpers$1.callback(this.options.beforeFit, [this]);
        },
        fit: function () {
          var me = this; // Reset

          var minSize = me.minSize = {
            width: 0,
            height: 0
          };
          var labels = labelsFromTicks(me._ticks);
          var opts = me.options;
          var tickOpts = opts.ticks;
          var scaleLabelOpts = opts.scaleLabel;
          var gridLineOpts = opts.gridLines;

          var display = me._isVisible();

          var position = opts.position;
          var isHorizontal = me.isHorizontal();
          var parseFont = helpers$1.options._parseFont;
          var tickFont = parseFont(tickOpts);
          var tickMarkLength = opts.gridLines.tickMarkLength; // Width

          if (isHorizontal) {
            // subtract the margins to line up with the chartArea if we are a full width scale
            minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
          } else {
            minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
          } // height


          if (isHorizontal) {
            minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
          } else {
            minSize.height = me.maxHeight; // fill all the height
          } // Are we showing a title for the scale?


          if (scaleLabelOpts.display && display) {
            var scaleLabelFont = parseFont(scaleLabelOpts);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
            var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

            if (isHorizontal) {
              minSize.height += deltaHeight;
            } else {
              minSize.width += deltaHeight;
            }
          } // Don't bother fitting the ticks if we are not showing the labels


          if (tickOpts.display && display) {
            var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
            var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
            var lineSpace = tickFont.size * 0.5;
            var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

            me._maxLabelLines = tallestLabelHeightInLines;
            me.longestLabelWidth = largestTextWidth;

            if (isHorizontal) {
              var angleRadians = helpers$1.toRadians(me.labelRotation);
              var cosRotation = Math.cos(angleRadians);
              var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

              var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

              minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
              me.ctx.font = tickFont.string;
              var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
              var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
              var offsetLeft = me.getPixelForTick(0) - me.left;
              var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
              var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
              // which means that the right padding is dominated by the font height

              if (me.labelRotation !== 0) {
                paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
                paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
              } else {
                paddingLeft = firstLabelWidth / 2;
                paddingRight = lastLabelWidth / 2;
              }

              me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

              me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
            } else {
              // A vertical axis is more constrained by the width. Labels are the
              // dominant factor here, so get that length first and account for padding
              if (tickOpts.mirror) {
                largestTextWidth = 0;
              } else {
                // use lineSpace for consistency with horizontal axis
                // tickPadding is not implemented for horizontal
                largestTextWidth += tickPadding + lineSpace;
              }

              minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
              me.paddingTop = tickFont.size / 2;
              me.paddingBottom = tickFont.size / 2;
            }
          }

          me.handleMargins();
          me.width = minSize.width;
          me.height = minSize.height;
        },

        /**
         * Handle margins and padding interactions
         * @private
         */
        handleMargins: function () {
          var me = this;

          if (me.margins) {
            me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
            me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
            me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
            me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
          }
        },
        afterFit: function () {
          helpers$1.callback(this.options.afterFit, [this]);
        },
        // Shared Methods
        isHorizontal: function () {
          return this.options.position === 'top' || this.options.position === 'bottom';
        },
        isFullWidth: function () {
          return this.options.fullWidth;
        },
        // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
        getRightValue: function (rawValue) {
          // Null and undefined values first
          if (helpers$1.isNullOrUndef(rawValue)) {
            return NaN;
          } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


          if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
            return NaN;
          } // If it is in fact an object, dive in one more level


          if (rawValue) {
            if (this.isHorizontal()) {
              if (rawValue.x !== undefined) {
                return this.getRightValue(rawValue.x);
              }
            } else if (rawValue.y !== undefined) {
              return this.getRightValue(rawValue.y);
            }
          } // Value is good, return it


          return rawValue;
        },

        /**
         * Used to get the value to display in the tooltip for the data at the given index
         * @param index
         * @param datasetIndex
         */
        getLabelForIndex: helpers$1.noop,

        /**
         * Returns the location of the given data point. Value can either be an index or a numerical value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param value
         * @param index
         * @param datasetIndex
         */
        getPixelForValue: helpers$1.noop,

        /**
         * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param pixel
         */
        getValueForPixel: helpers$1.noop,

        /**
         * Returns the location of the tick at the given index
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getPixelForTick: function (index) {
          var me = this;
          var offset = me.options.offset;

          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
            var pixel = tickWidth * index + me.paddingLeft;

            if (offset) {
              pixel += tickWidth / 2;
            }

            var finalVal = me.left + pixel;
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal;
          }

          var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
          return me.top + index * (innerHeight / (me._ticks.length - 1));
        },

        /**
         * Utility for getting the pixel location of a percentage of scale
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getPixelForDecimal: function (decimal) {
          var me = this;

          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var valueOffset = innerWidth * decimal + me.paddingLeft;
            var finalVal = me.left + valueOffset;
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal;
          }

          return me.top + decimal * me.height;
        },

        /**
         * Returns the pixel for the minimum chart value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getBasePixel: function () {
          return this.getPixelForValue(this.getBaseValue());
        },
        getBaseValue: function () {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        },

        /**
         * Returns a subset of ticks to be plotted to avoid overlapping labels.
         * @private
         */
        _autoSkip: function (ticks) {
          var me = this;
          var isHorizontal = me.isHorizontal();
          var optionTicks = me.options.ticks.minor;
          var tickCount = ticks.length;
          var skipRatio = false;
          var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
          // drawn as their center at end of axis, so tickCount-1

          var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

          var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
          var result = [];
          var i, tick;

          if (ticksLength > axisLength) {
            skipRatio = 1 + Math.floor(ticksLength / axisLength);
          } // if they defined a max number of optionTicks,
          // increase skipRatio until that number is met


          if (tickCount > maxTicks) {
            skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
          }

          for (i = 0; i < tickCount; i++) {
            tick = ticks[i];

            if (skipRatio > 1 && i % skipRatio > 0) {
              // leave tick in place but make sure it's not displayed (#4635)
              delete tick.label;
            }

            result.push(tick);
          }

          return result;
        },

        /**
         * @private
         */
        _tickSize: function () {
          var me = this;
          var isHorizontal = me.isHorizontal();
          var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

          var rot = helpers$1.toRadians(me.labelRotation);
          var cos = Math.abs(Math.cos(rot));
          var sin = Math.abs(Math.sin(rot));
          var padding = optionTicks.autoSkipPadding || 0;
          var w = me.longestLabelWidth + padding || 0;

          var tickFont = helpers$1.options._parseFont(optionTicks);

          var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

          return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        },

        /**
         * @private
         */
        _isVisible: function () {
          var me = this;
          var chart = me.chart;
          var display = me.options.display;
          var i, ilen, meta;

          if (display !== 'auto') {
            return !!display;
          } // When 'auto', the scale is visible if at least one associated dataset is visible.


          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);

              if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                return true;
              }
            }
          }

          return false;
        },

        /**
         * Actually draw the scale on the canvas
         * @param {object} chartArea - the area of the chart to draw full grid lines on
         */
        draw: function (chartArea) {
          var me = this;
          var options = me.options;

          if (!me._isVisible()) {
            return;
          }

          var chart = me.chart;
          var context = me.ctx;
          var globalDefaults = core_defaults.global;
          var defaultFontColor = globalDefaults.defaultFontColor;
          var optionTicks = options.ticks.minor;
          var optionMajorTicks = options.ticks.major || optionTicks;
          var gridLines = options.gridLines;
          var scaleLabel = options.scaleLabel;
          var position = options.position;
          var isRotated = me.labelRotation !== 0;
          var isMirrored = optionTicks.mirror;
          var isHorizontal = me.isHorizontal();
          var parseFont = helpers$1.options._parseFont;
          var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
          var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
          var tickFont = parseFont(optionTicks);
          var lineHeight = tickFont.lineHeight;
          var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
          var majorTickFont = parseFont(optionMajorTicks);
          var tickPadding = optionTicks.padding;
          var labelOffset = optionTicks.labelOffset;
          var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
          var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
          var scaleLabelFont = parseFont(scaleLabel);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
          var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
          var itemsToDraw = [];
          var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
          var alignPixel = helpers$1._alignPixel;
          var borderValue, tickStart, tickEnd;

          if (position === 'top') {
            borderValue = alignPixel(chart, me.bottom, axisWidth);
            tickStart = me.bottom - tl;
            tickEnd = borderValue - axisWidth / 2;
          } else if (position === 'bottom') {
            borderValue = alignPixel(chart, me.top, axisWidth);
            tickStart = borderValue + axisWidth / 2;
            tickEnd = me.top + tl;
          } else if (position === 'left') {
            borderValue = alignPixel(chart, me.right, axisWidth);
            tickStart = me.right - tl;
            tickEnd = borderValue - axisWidth / 2;
          } else {
            borderValue = alignPixel(chart, me.left, axisWidth);
            tickStart = borderValue + axisWidth / 2;
            tickEnd = me.left + tl;
          }

          var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

          helpers$1.each(ticks, function (tick, index) {
            // autoskipper skipped this tick (#4635)
            if (helpers$1.isNullOrUndef(tick.label)) {
              return;
            }

            var label = tick.label;
            var lineWidth, lineColor, borderDash, borderDashOffset;

            if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
              // Draw the first index specially
              lineWidth = gridLines.zeroLineWidth;
              lineColor = gridLines.zeroLineColor;
              borderDash = gridLines.zeroLineBorderDash || [];
              borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
            } else {
              lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
              lineColor = valueAtIndexOrDefault(gridLines.color, index);
              borderDash = gridLines.borderDash || [];
              borderDashOffset = gridLines.borderDashOffset || 0.0;
            } // Common properties


            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
            var labelCount = helpers$1.isArray(label) ? label.length : 1;
            var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

            if (isHorizontal) {
              var labelYOffset = tl + tickPadding;

              if (lineValue < me.left - epsilon) {
                lineColor = 'rgba(0,0,0,0)';
              }

              tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
              ty1 = tickStart;
              ty2 = tickEnd;
              labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

              if (position === 'top') {
                y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
                y2 = chartArea.bottom;
                textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
                textAlign = !isRotated ? 'center' : 'left';
                labelY = me.bottom - labelYOffset;
              } else {
                y1 = chartArea.top;
                y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
                textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
                textAlign = !isRotated ? 'center' : 'right';
                labelY = me.top + labelYOffset;
              }
            } else {
              var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

              if (lineValue < me.top - epsilon) {
                lineColor = 'rgba(0,0,0,0)';
              }

              tx1 = tickStart;
              tx2 = tickEnd;
              ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
              labelY = me.getPixelForTick(index) + labelOffset;
              textOffset = (1 - labelCount) * lineHeight / 2;

              if (position === 'left') {
                x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
                x2 = chartArea.right;
                textAlign = isMirrored ? 'left' : 'right';
                labelX = me.right - labelXOffset;
              } else {
                x1 = chartArea.left;
                x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
                textAlign = isMirrored ? 'right' : 'left';
                labelX = me.left + labelXOffset;
              }
            }

            itemsToDraw.push({
              tx1: tx1,
              ty1: ty1,
              tx2: tx2,
              ty2: ty2,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              labelX: labelX,
              labelY: labelY,
              glWidth: lineWidth,
              glColor: lineColor,
              glBorderDash: borderDash,
              glBorderDashOffset: borderDashOffset,
              rotation: -1 * labelRotationRadians,
              label: label,
              major: tick.major,
              textOffset: textOffset,
              textAlign: textAlign
            });
          }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

          helpers$1.each(itemsToDraw, function (itemToDraw) {
            var glWidth = itemToDraw.glWidth;
            var glColor = itemToDraw.glColor;

            if (gridLines.display && glWidth && glColor) {
              context.save();
              context.lineWidth = glWidth;
              context.strokeStyle = glColor;

              if (context.setLineDash) {
                context.setLineDash(itemToDraw.glBorderDash);
                context.lineDashOffset = itemToDraw.glBorderDashOffset;
              }

              context.beginPath();

              if (gridLines.drawTicks) {
                context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
                context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
              }

              if (gridLines.drawOnChartArea) {
                context.moveTo(itemToDraw.x1, itemToDraw.y1);
                context.lineTo(itemToDraw.x2, itemToDraw.y2);
              }

              context.stroke();
              context.restore();
            }

            if (optionTicks.display) {
              // Make sure we draw text in the correct color and font
              context.save();
              context.translate(itemToDraw.labelX, itemToDraw.labelY);
              context.rotate(itemToDraw.rotation);
              context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
              context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
              context.textBaseline = 'middle';
              context.textAlign = itemToDraw.textAlign;
              var label = itemToDraw.label;
              var y = itemToDraw.textOffset;

              if (helpers$1.isArray(label)) {
                for (var i = 0; i < label.length; ++i) {
                  // We just make sure the multiline element is a string here..
                  context.fillText('' + label[i], 0, y);
                  y += lineHeight;
                }
              } else {
                context.fillText(label, 0, y);
              }

              context.restore();
            }
          });

          if (scaleLabel.display) {
            // Draw the scale label
            var scaleLabelX;
            var scaleLabelY;
            var rotation = 0;
            var halfLineHeight = scaleLabelFont.lineHeight / 2;

            if (isHorizontal) {
              scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

              scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === 'left';
              scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me.top + (me.bottom - me.top) / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }

            context.save();
            context.translate(scaleLabelX, scaleLabelY);
            context.rotate(rotation);
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = scaleLabelFontColor; // render in correct colour

            context.font = scaleLabelFont.string;
            context.fillText(scaleLabel.labelString, 0, 0);
            context.restore();
          }

          if (axisWidth) {
            // Draw the line at the edge of the axis
            var firstLineWidth = axisWidth;
            var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
            var x1, x2, y1, y2;

            if (isHorizontal) {
              x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
              x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
              y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }

            context.lineWidth = axisWidth;
            context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.stroke();
          }
        }
      });
      var defaultConfig = {
        position: 'bottom'
      };
      var scale_category = core_scale.extend({
        /**
        * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
        * else fall back to data.labels
        * @private
        */
        getLabels: function () {
          var data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
        },
        determineDataLimits: function () {
          var me = this;
          var labels = me.getLabels();
          me.minIndex = 0;
          me.maxIndex = labels.length - 1;
          var findIndex;

          if (me.options.ticks.min !== undefined) {
            // user specified min value
            findIndex = labels.indexOf(me.options.ticks.min);
            me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
          }

          if (me.options.ticks.max !== undefined) {
            // user specified max value
            findIndex = labels.indexOf(me.options.ticks.max);
            me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
          }

          me.min = labels[me.minIndex];
          me.max = labels[me.maxIndex];
        },
        buildTicks: function () {
          var me = this;
          var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

          me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
        },
        getLabelForIndex: function (index, datasetIndex) {
          var me = this;
          var chart = me.chart;

          if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
            return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
          }

          return me.ticks[index - me.minIndex];
        },
        // Used to get data value locations.  Value can either be an index or a numerical value
        getPixelForValue: function (value, index) {
          var me = this;
          var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

          var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
          // not the index of the scale. We need to change that.

          var valueCategory;

          if (value !== undefined && value !== null) {
            valueCategory = me.isHorizontal() ? value.x : value.y;
          }

          if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
            var labels = me.getLabels();
            value = valueCategory || value;
            var idx = labels.indexOf(value);
            index = idx !== -1 ? idx : index;
          }

          if (me.isHorizontal()) {
            var valueWidth = me.width / offsetAmt;
            var widthOffset = valueWidth * (index - me.minIndex);

            if (offset) {
              widthOffset += valueWidth / 2;
            }

            return me.left + widthOffset;
          }

          var valueHeight = me.height / offsetAmt;
          var heightOffset = valueHeight * (index - me.minIndex);

          if (offset) {
            heightOffset += valueHeight / 2;
          }

          return me.top + heightOffset;
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var offset = me.options.offset;
          var value;
          var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var horz = me.isHorizontal();
          var valueDimension = (horz ? me.width : me.height) / offsetAmt;
          pixel -= horz ? me.left : me.top;

          if (offset) {
            pixel -= valueDimension / 2;
          }

          if (pixel <= 0) {
            value = 0;
          } else {
            value = Math.round(pixel / valueDimension);
          }

          return value + me.minIndex;
        },
        getBasePixel: function () {
          return this.bottom;
        }
      }); // INTERNAL: static default options, registered in src/index.js

      var _defaults = defaultConfig;
      scale_category._defaults = _defaults;
      var noop = helpers$1.noop;
      var isNullOrUndef = helpers$1.isNullOrUndef;
      /**
       * Generate a set of linear ticks
       * @param generationOptions the options used to generate the ticks
       * @param dataRange the range of the data
       * @returns {number[]} array of tick values
       */

      function generateTicks(generationOptions, dataRange) {
        var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
        // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
        // for details.

        var MIN_SPACING = 1e-14;
        var stepSize = generationOptions.stepSize;
        var unit = stepSize || 1;
        var maxNumSpaces = generationOptions.maxTicks - 1;
        var min = generationOptions.min;
        var max = generationOptions.max;
        var precision = generationOptions.precision;
        var rmin = dataRange.min;
        var rmax = dataRange.max;
        var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
        var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
        // such that we can't do the math necessary to generate ticks

        if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
          return [rmin, rmax];
        }

        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

        if (numSpaces > maxNumSpaces) {
          // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
          spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
        }

        if (stepSize || isNullOrUndef(precision)) {
          // If a precision is not specified, calculate factor based on spacing
          factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
        } else {
          // If the user specified a precision, round to that number of decimal places
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
        }

        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

        if (stepSize) {
          // If very close to our whole number, use it.
          if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
            niceMin = min;
          }

          if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
            niceMax = max;
          }
        }

        numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

        if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
          numSpaces = Math.round(numSpaces);
        } else {
          numSpaces = Math.ceil(numSpaces);
        }

        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        ticks.push(isNullOrUndef(min) ? niceMin : min);

        for (var j = 1; j < numSpaces; ++j) {
          ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
        }

        ticks.push(isNullOrUndef(max) ? niceMax : max);
        return ticks;
      }

      var scale_linearbase = core_scale.extend({
        getRightValue: function (value) {
          if (typeof value === 'string') {
            return +value;
          }

          return core_scale.prototype.getRightValue.call(this, value);
        },
        handleTickRangeOptions: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
          // do nothing since that would make the chart weird. If the user really wants a weird chart
          // axis, they can manually override it

          if (tickOpts.beginAtZero) {
            var minSign = helpers$1.sign(me.min);
            var maxSign = helpers$1.sign(me.max);

            if (minSign < 0 && maxSign < 0) {
              // move the top up to 0
              me.max = 0;
            } else if (minSign > 0 && maxSign > 0) {
              // move the bottom down to 0
              me.min = 0;
            }
          }

          var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
          var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

          if (tickOpts.min !== undefined) {
            me.min = tickOpts.min;
          } else if (tickOpts.suggestedMin !== undefined) {
            if (me.min === null) {
              me.min = tickOpts.suggestedMin;
            } else {
              me.min = Math.min(me.min, tickOpts.suggestedMin);
            }
          }

          if (tickOpts.max !== undefined) {
            me.max = tickOpts.max;
          } else if (tickOpts.suggestedMax !== undefined) {
            if (me.max === null) {
              me.max = tickOpts.suggestedMax;
            } else {
              me.max = Math.max(me.max, tickOpts.suggestedMax);
            }
          }

          if (setMin !== setMax) {
            // We set the min or the max but not both.
            // So ensure that our range is good
            // Inverted or 0 length range can happen when
            // ticks.min is set, and no datasets are visible
            if (me.min >= me.max) {
              if (setMin) {
                me.max = me.min + 1;
              } else {
                me.min = me.max - 1;
              }
            }
          }

          if (me.min === me.max) {
            me.max++;

            if (!tickOpts.beginAtZero) {
              me.min--;
            }
          }
        },
        getTickLimit: function () {
          var me = this;
          var tickOpts = me.options.ticks;
          var stepSize = tickOpts.stepSize;
          var maxTicksLimit = tickOpts.maxTicksLimit;
          var maxTicks;

          if (stepSize) {
            maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
          } else {
            maxTicks = me._computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }

          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }

          return maxTicks;
        },
        _computeTickLimit: function () {
          return Number.POSITIVE_INFINITY;
        },
        handleDirectionalChanges: noop,
        buildTicks: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
          // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
          // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
          // the graph. Make sure we always have at least 2 ticks

          var maxTicks = me.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          var numericGeneratorOptions = {
            maxTicks: maxTicks,
            min: tickOpts.min,
            max: tickOpts.max,
            precision: tickOpts.precision,
            stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
          };
          var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
          me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale

          me.max = helpers$1.max(ticks);
          me.min = helpers$1.min(ticks);

          if (tickOpts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
        },
        convertTicksToLabels: function () {
          var me = this;
          me.ticksAsNumbers = me.ticks.slice();
          me.zeroLineIndex = me.ticks.indexOf(0);
          core_scale.prototype.convertTicksToLabels.call(me);
        }
      });
      var defaultConfig$1 = {
        position: 'left',
        ticks: {
          callback: core_ticks.formatters.linear
        }
      };
      var scale_linear = scale_linearbase.extend({
        determineDataLimits: function () {
          var me = this;
          var opts = me.options;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var isHorizontal = me.isHorizontal();
          var DEFAULT_MIN = 0;
          var DEFAULT_MAX = 1;

          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
          } // First Calculate the range


          me.min = null;
          me.max = null;
          var hasStacks = opts.stacked;

          if (hasStacks === undefined) {
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              if (hasStacks) {
                return;
              }

              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
                hasStacks = true;
              }
            });
          }

          if (opts.stacked || hasStacks) {
            var valuesPerStack = {};
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
              opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = {
                  positiveValues: [],
                  negativeValues: []
                };
              } // Store these per type


              var positiveValues = valuesPerStack[key].positiveValues;
              var negativeValues = valuesPerStack[key].negativeValues;

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers$1.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  positiveValues[index] = positiveValues[index] || 0;
                  negativeValues[index] = negativeValues[index] || 0;

                  if (opts.relativePoints) {
                    positiveValues[index] = 100;
                  } else if (value < 0) {
                    negativeValues[index] += value;
                  } else {
                    positiveValues[index] += value;
                  }
                });
              }
            });
            helpers$1.each(valuesPerStack, function (valuesForType) {
              var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
              var minVal = helpers$1.min(values);
              var maxVal = helpers$1.max(values);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            });
          } else {
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers$1.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  if (me.min === null) {
                    me.min = value;
                  } else if (value < me.min) {
                    me.min = value;
                  }

                  if (me.max === null) {
                    me.max = value;
                  } else if (value > me.max) {
                    me.max = value;
                  }
                });
              }
            });
          }

          me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
          me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

          this.handleTickRangeOptions();
        },
        // Returns the maximum number of ticks based on the scale dimension
        _computeTickLimit: function () {
          var me = this;
          var tickFont;

          if (me.isHorizontal()) {
            return Math.ceil(me.width / 40);
          }

          tickFont = helpers$1.options._parseFont(me.options.ticks);
          return Math.ceil(me.height / tickFont.lineHeight);
        },
        // Called after the ticks are built. We need
        handleDirectionalChanges: function () {
          if (!this.isHorizontal()) {
            // We are in a vertical orientation. The top value is the highest. So reverse the array
            this.ticks.reverse();
          }
        },
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        // Utils
        getPixelForValue: function (value) {
          // This must be called after fit has been run so that
          // this.left, this.top, this.right, and this.bottom have been defined
          var me = this;
          var start = me.start;
          var rightValue = +me.getRightValue(value);
          var pixel;
          var range = me.end - start;

          if (me.isHorizontal()) {
            pixel = me.left + me.width / range * (rightValue - start);
          } else {
            pixel = me.bottom - me.height / range * (rightValue - start);
          }

          return pixel;
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var isHorizontal = me.isHorizontal();
          var innerDimension = isHorizontal ? me.width : me.height;
          var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
          return me.start + (me.end - me.start) * offset;
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.ticksAsNumbers[index]);
        }
      }); // INTERNAL: static default options, registered in src/index.js

      var _defaults$1 = defaultConfig$1;
      scale_linear._defaults = _defaults$1;
      var valueOrDefault$a = helpers$1.valueOrDefault;
      /**
       * Generate a set of logarithmic ticks
       * @param generationOptions the options used to generate the ticks
       * @param dataRange the range of the data
       * @returns {number[]} array of tick values
       */

      function generateTicks$1(generationOptions, dataRange) {
        var ticks = [];
        var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
        var endExp = Math.floor(helpers$1.log10(dataRange.max));
        var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
        var exp, significand;

        if (tickVal === 0) {
          exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
          significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
          ticks.push(tickVal);
          tickVal = significand * Math.pow(10, exp);
        } else {
          exp = Math.floor(helpers$1.log10(tickVal));
          significand = Math.floor(tickVal / Math.pow(10, exp));
        }

        var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

        do {
          ticks.push(tickVal);
          ++significand;

          if (significand === 10) {
            significand = 1;
            ++exp;
            precision = exp >= 0 ? 1 : precision;
          }

          tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
        } while (exp < endExp || exp === endExp && significand < endSignificand);

        var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
        ticks.push(lastTick);
        return ticks;
      }

      var defaultConfig$2 = {
        position: 'left',
        // label settings
        ticks: {
          callback: core_ticks.formatters.logarithmic
        }
      }; // TODO(v3): change this to positiveOrDefault

      function nonNegativeOrDefault(value, defaultValue) {
        return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
      }

      var scale_logarithmic = core_scale.extend({
        determineDataLimits: function () {
          var me = this;
          var opts = me.options;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var isHorizontal = me.isHorizontal();

          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
          } // Calculate Range


          me.min = null;
          me.max = null;
          me.minNotZero = null;
          var hasStacks = opts.stacked;

          if (hasStacks === undefined) {
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              if (hasStacks) {
                return;
              }

              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
                hasStacks = true;
              }
            });
          }

          if (opts.stacked || hasStacks) {
            var valuesPerStack = {};
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
              opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                if (valuesPerStack[key] === undefined) {
                  valuesPerStack[key] = [];
                }

                helpers$1.each(dataset.data, function (rawValue, index) {
                  var values = valuesPerStack[key];
                  var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                  if (isNaN(value) || meta.data[index].hidden || value < 0) {
                    return;
                  }

                  values[index] = values[index] || 0;
                  values[index] += value;
                });
              }
            });
            helpers$1.each(valuesPerStack, function (valuesForType) {
              if (valuesForType.length > 0) {
                var minVal = helpers$1.min(valuesForType);
                var maxVal = helpers$1.max(valuesForType);
                me.min = me.min === null ? minVal : Math.min(me.min, minVal);
                me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
              }
            });
          } else {
            helpers$1.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers$1.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                  if (isNaN(value) || meta.data[index].hidden || value < 0) {
                    return;
                  }

                  if (me.min === null) {
                    me.min = value;
                  } else if (value < me.min) {
                    me.min = value;
                  }

                  if (me.max === null) {
                    me.max = value;
                  } else if (value > me.max) {
                    me.max = value;
                  }

                  if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                    me.minNotZero = value;
                  }
                });
              }
            });
          } // Common base implementation to handle ticks.min, ticks.max


          this.handleTickRangeOptions();
        },
        handleTickRangeOptions: function () {
          var me = this;
          var tickOpts = me.options.ticks;
          var DEFAULT_MIN = 1;
          var DEFAULT_MAX = 10;
          me.min = nonNegativeOrDefault(tickOpts.min, me.min);
          me.max = nonNegativeOrDefault(tickOpts.max, me.max);

          if (me.min === me.max) {
            if (me.min !== 0 && me.min !== null) {
              me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
              me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
            } else {
              me.min = DEFAULT_MIN;
              me.max = DEFAULT_MAX;
            }
          }

          if (me.min === null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
          }

          if (me.max === null) {
            me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
          }

          if (me.minNotZero === null) {
            if (me.min > 0) {
              me.minNotZero = me.min;
            } else if (me.max < 1) {
              me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
            } else {
              me.minNotZero = DEFAULT_MIN;
            }
          }
        },
        buildTicks: function () {
          var me = this;
          var tickOpts = me.options.ticks;
          var reverse = !me.isHorizontal();
          var generationOptions = {
            min: nonNegativeOrDefault(tickOpts.min),
            max: nonNegativeOrDefault(tickOpts.max)
          };
          var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale

          me.max = helpers$1.max(ticks);
          me.min = helpers$1.min(ticks);

          if (tickOpts.reverse) {
            reverse = !reverse;
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }

          if (reverse) {
            ticks.reverse();
          }
        },
        convertTicksToLabels: function () {
          this.tickValues = this.ticks.slice();
          core_scale.prototype.convertTicksToLabels.call(this);
        },
        // Get the correct tooltip label
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.tickValues[index]);
        },

        /**
         * Returns the value of the first tick.
         * @param {number} value - The minimum not zero value.
         * @return {number} The first tick value.
         * @private
         */
        _getFirstTickValue: function (value) {
          var exp = Math.floor(helpers$1.log10(value));
          var significand = Math.floor(value / Math.pow(10, exp));
          return significand * Math.pow(10, exp);
        },
        getPixelForValue: function (value) {
          var me = this;
          var tickOpts = me.options.ticks;
          var reverse = tickOpts.reverse;
          var log10 = helpers$1.log10;

          var firstTickValue = me._getFirstTickValue(me.minNotZero);

          var offset = 0;
          var innerDimension, pixel, start, end, sign;
          value = +me.getRightValue(value);

          if (reverse) {
            start = me.end;
            end = me.start;
            sign = -1;
          } else {
            start = me.start;
            end = me.end;
            sign = 1;
          }

          if (me.isHorizontal()) {
            innerDimension = me.width;
            pixel = reverse ? me.right : me.left;
          } else {
            innerDimension = me.height;
            sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

            pixel = reverse ? me.top : me.bottom;
          }

          if (value !== start) {
            if (start === 0) {
              // include zero tick
              offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
              innerDimension -= offset;
              start = firstTickValue;
            }

            if (value !== 0) {
              offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
            }

            pixel += sign * offset;
          }

          return pixel;
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var tickOpts = me.options.ticks;
          var reverse = tickOpts.reverse;
          var log10 = helpers$1.log10;

          var firstTickValue = me._getFirstTickValue(me.minNotZero);

          var innerDimension, start, end, value;

          if (reverse) {
            start = me.end;
            end = me.start;
          } else {
            start = me.start;
            end = me.end;
          }

          if (me.isHorizontal()) {
            innerDimension = me.width;
            value = reverse ? me.right - pixel : pixel - me.left;
          } else {
            innerDimension = me.height;
            value = reverse ? pixel - me.top : me.bottom - pixel;
          }

          if (value !== start) {
            if (start === 0) {
              // include zero tick
              var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
              value -= offset;
              innerDimension -= offset;
              start = firstTickValue;
            }

            value *= log10(end) - log10(start);
            value /= innerDimension;
            value = Math.pow(10, log10(start) + value);
          }

          return value;
        }
      }); // INTERNAL: static default options, registered in src/index.js

      var _defaults$2 = defaultConfig$2;
      scale_logarithmic._defaults = _defaults$2;
      var valueOrDefault$b = helpers$1.valueOrDefault;
      var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
      var resolve$7 = helpers$1.options.resolve;
      var defaultConfig$3 = {
        display: true,
        // Boolean - Whether to animate scaling the chart from the centre
        animate: true,
        position: 'chartArea',
        angleLines: {
          display: true,
          color: 'rgba(0, 0, 0, 0.1)',
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0.0
        },
        gridLines: {
          circular: false
        },
        // label settings
        ticks: {
          // Boolean - Show a backdrop to the scale label
          showLabelBackdrop: true,
          // String - The colour of the label backdrop
          backdropColor: 'rgba(255,255,255,0.75)',
          // Number - The backdrop padding above & below the label in pixels
          backdropPaddingY: 2,
          // Number - The backdrop padding to the side of the label in pixels
          backdropPaddingX: 2,
          callback: core_ticks.formatters.linear
        },
        pointLabels: {
          // Boolean - if true, show point labels
          display: true,
          // Number - Point label font size in pixels
          fontSize: 10,
          // Function - Used to convert point labels
          callback: function (label) {
            return label;
          }
        }
      };

      function getValueCount(scale) {
        var opts = scale.options;
        return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
      }

      function getTickBackdropHeight(opts) {
        var tickOpts = opts.ticks;

        if (tickOpts.display && opts.display) {
          return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
        }

        return 0;
      }

      function measureLabelSize(ctx, lineHeight, label) {
        if (helpers$1.isArray(label)) {
          return {
            w: helpers$1.longestText(ctx, ctx.font, label),
            h: label.length * lineHeight
          };
        }

        return {
          w: ctx.measureText(label).width,
          h: lineHeight
        };
      }

      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size,
            end: pos
          };
        }

        return {
          start: pos,
          end: pos + size
        };
      }
      /**
       * Helper function to fit a radial linear scale with point labels
       */


      function fitWithPointLabels(scale) {
        // Right, this is really confusing and there is a lot of maths going on here
        // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
        //
        // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
        //
        // Solution:
        //
        // We assume the radius of the polygon is half the size of the canvas at first
        // at each index we check if the text overlaps.
        //
        // Where it does, we store that angle and that index.
        //
        // After finding the largest index and angle we calculate how much we need to remove
        // from the shape radius to move the point inwards by that x.
        //
        // We average the left and right distances to get the maximum shape radius that can fit in the box
        // along with labels.
        //
        // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
        // on each side, removing that from the size, halving it and adding the left x protrusion width.
        //
        // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
        // and position it in the most space efficient manner
        //
        // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
        var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
        // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


        var furthestLimits = {
          l: 0,
          r: scale.width,
          t: 0,
          b: scale.height - scale.paddingTop
        };
        var furthestAngles = {};
        var i, textSize, pointPosition;
        scale.ctx.font = plFont.string;
        scale._pointLabelSizes = [];
        var valueCount = getValueCount(scale);

        for (i = 0; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
          textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
          scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians) % 360;
          var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

          if (hLimits.start < furthestLimits.l) {
            furthestLimits.l = hLimits.start;
            furthestAngles.l = angleRadians;
          }

          if (hLimits.end > furthestLimits.r) {
            furthestLimits.r = hLimits.end;
            furthestAngles.r = angleRadians;
          }

          if (vLimits.start < furthestLimits.t) {
            furthestLimits.t = vLimits.start;
            furthestAngles.t = angleRadians;
          }

          if (vLimits.end > furthestLimits.b) {
            furthestLimits.b = vLimits.end;
            furthestAngles.b = angleRadians;
          }
        }

        scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
      }

      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return 'center';
        } else if (angle < 180) {
          return 'left';
        }

        return 'right';
      }

      function fillText(ctx, text, position, lineHeight) {
        var y = position.y + lineHeight / 2;
        var i, ilen;

        if (helpers$1.isArray(text)) {
          for (i = 0, ilen = text.length; i < ilen; ++i) {
            ctx.fillText(text[i], position.x, y);
            y += lineHeight;
          }
        } else {
          ctx.fillText(text, position.x, y);
        }
      }

      function adjustPointPositionForLabelHeight(angle, textSize, position) {
        if (angle === 90 || angle === 270) {
          position.y -= textSize.h / 2;
        } else if (angle > 270 || angle < 90) {
          position.y -= textSize.h;
        }
      }

      function drawPointLabels(scale) {
        var ctx = scale.ctx;
        var opts = scale.options;
        var angleLineOpts = opts.angleLines;
        var gridLineOpts = opts.gridLines;
        var pointLabelOpts = opts.pointLabels;
        var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
        var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
        var tickBackdropHeight = getTickBackdropHeight(opts);
        ctx.save();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = lineColor;

        if (ctx.setLineDash) {
          ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
          ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
        }

        var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

        var plFont = helpers$1.options._parseFont(pointLabelOpts);

        ctx.font = plFont.string;
        ctx.textBaseline = 'middle';

        for (var i = getValueCount(scale) - 1; i >= 0; i--) {
          if (angleLineOpts.display && lineWidth && lineColor) {
            var outerPosition = scale.getPointPosition(i, outerDistance);
            ctx.beginPath();
            ctx.moveTo(scale.xCenter, scale.yCenter);
            ctx.lineTo(outerPosition.x, outerPosition.y);
            ctx.stroke();
          }

          if (pointLabelOpts.display) {
            // Extra pixels out for some label spacing
            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
          }
        }

        ctx.restore();
      }

      function drawRadiusLine(scale, gridLineOpts, radius, index) {
        var ctx = scale.ctx;
        var circular = gridLineOpts.circular;
        var valueCount = getValueCount(scale);
        var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
        var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
        var pointPosition;

        if (!circular && !valueCount || !lineColor || !lineWidth) {
          return;
        }

        ctx.save();
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = lineWidth;

        if (ctx.setLineDash) {
          ctx.setLineDash(gridLineOpts.borderDash || []);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
        }

        ctx.beginPath();

        if (circular) {
          // Draw circular arcs between the points
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
        } else {
          // Draw straight lines connecting each index
          pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);

          for (var i = 1; i < valueCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }
        }

        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      function numberOrZero(param) {
        return helpers$1.isNumber(param) ? param : 0;
      }

      var scale_radialLinear = scale_linearbase.extend({
        setDimensions: function () {
          var me = this; // Set the unconstrained dimension before label rotation

          me.width = me.maxWidth;
          me.height = me.maxHeight;
          me.paddingTop = getTickBackdropHeight(me.options) / 2;
          me.xCenter = Math.floor(me.width / 2);
          me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
          me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
        },
        determineDataLimits: function () {
          var me = this;
          var chart = me.chart;
          var min = Number.POSITIVE_INFINITY;
          var max = Number.NEGATIVE_INFINITY;
          helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
            if (chart.isDatasetVisible(datasetIndex)) {
              var meta = chart.getDatasetMeta(datasetIndex);
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                min = Math.min(value, min);
                max = Math.max(value, max);
              });
            }
          });
          me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
          me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

          me.handleTickRangeOptions();
        },
        // Returns the maximum number of ticks based on the scale dimension
        _computeTickLimit: function () {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        },
        convertTicksToLabels: function () {
          var me = this;
          scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

          me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
        },
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        fit: function () {
          var me = this;
          var opts = me.options;

          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(me);
          } else {
            me.setCenterPoint(0, 0, 0, 0);
          }
        },

        /**
         * Set radius reductions and determine new radius and center point
         * @private
         */
        setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
          var me = this;
          var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
          var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
          var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
          var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
          radiusReductionLeft = numberOrZero(radiusReductionLeft);
          radiusReductionRight = numberOrZero(radiusReductionRight);
          radiusReductionTop = numberOrZero(radiusReductionTop);
          radiusReductionBottom = numberOrZero(radiusReductionBottom);
          me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
          me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
        },
        setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
          var me = this;
          var maxRight = me.width - rightMovement - me.drawingArea;
          var maxLeft = leftMovement + me.drawingArea;
          var maxTop = topMovement + me.drawingArea;
          var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
          me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
          me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
        },
        getIndexAngle: function (index) {
          var angleMultiplier = Math.PI * 2 / getValueCount(this);
          var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
          var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

          return index * angleMultiplier + startAngleRadians;
        },
        getDistanceFromCenterForValue: function (value) {
          var me = this;

          if (value === null) {
            return 0; // null always in center
          } // Take into account half font size + the yPadding of the top value


          var scalingFactor = me.drawingArea / (me.max - me.min);

          if (me.options.ticks.reverse) {
            return (me.max - value) * scalingFactor;
          }

          return (value - me.min) * scalingFactor;
        },
        getPointPosition: function (index, distanceFromCenter) {
          var me = this;
          var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
          return {
            x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
            y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
          };
        },
        getPointPositionForValue: function (index, value) {
          return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
        },
        getBasePosition: function () {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
        },
        draw: function () {
          var me = this;
          var opts = me.options;
          var gridLineOpts = opts.gridLines;
          var tickOpts = opts.ticks;

          if (opts.display) {
            var ctx = me.ctx;
            var startAngle = this.getIndexAngle(0);

            var tickFont = helpers$1.options._parseFont(tickOpts);

            if (opts.angleLines.display || opts.pointLabels.display) {
              drawPointLabels(me);
            }

            helpers$1.each(me.ticks, function (label, index) {
              // Don't draw a centre value (if it is minimum)
              if (index > 0 || tickOpts.reverse) {
                var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

                if (gridLineOpts.display && index !== 0) {
                  drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
                }

                if (tickOpts.display) {
                  var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                  ctx.font = tickFont.string;
                  ctx.save();
                  ctx.translate(me.xCenter, me.yCenter);
                  ctx.rotate(startAngle);

                  if (tickOpts.showLabelBackdrop) {
                    var labelWidth = ctx.measureText(label).width;
                    ctx.fillStyle = tickOpts.backdropColor;
                    ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                  }

                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillStyle = tickFontColor;
                  ctx.fillText(label, 0, -yCenterOffset);
                  ctx.restore();
                }
              }
            });
          }
        }
      }); // INTERNAL: static default options, registered in src/index.js

      var _defaults$3 = defaultConfig$3;
      scale_radialLinear._defaults = _defaults$3;
      var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

      var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
      var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      var INTERVALS = {
        millisecond: {
          common: true,
          size: 1,
          steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
        },
        second: {
          common: true,
          size: 1000,
          steps: [1, 2, 5, 10, 15, 30]
        },
        minute: {
          common: true,
          size: 60000,
          steps: [1, 2, 5, 10, 15, 30]
        },
        hour: {
          common: true,
          size: 3600000,
          steps: [1, 2, 3, 6, 12]
        },
        day: {
          common: true,
          size: 86400000,
          steps: [1, 2, 5]
        },
        week: {
          common: false,
          size: 604800000,
          steps: [1, 2, 3, 4]
        },
        month: {
          common: true,
          size: 2.628e9,
          steps: [1, 2, 3]
        },
        quarter: {
          common: false,
          size: 7.884e9,
          steps: [1, 2, 3, 4]
        },
        year: {
          common: true,
          size: 3.154e10
        }
      };
      var UNITS = Object.keys(INTERVALS);

      function sorter(a, b) {
        return a - b;
      }

      function arrayUnique(items) {
        var hash = {};
        var out = [];
        var i, ilen, item;

        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];

          if (!hash[item]) {
            hash[item] = true;
            out.push(item);
          }
        }

        return out;
      }
      /**
       * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
       * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
       * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
       * extremity (left + width or top + height). Note that it would be more optimized to directly
       * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
       * to create the lookup table. The table ALWAYS contains at least two items: min and max.
       *
       * @param {number[]} timestamps - timestamps sorted from lowest to highest.
       * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
       * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
       * If 'series', timestamps will be positioned at the same distance from each other. In this
       * case, only timestamps that break the time linearity are registered, meaning that in the
       * best case, all timestamps are linear, the table contains only min and max.
       */


      function buildLookupTable(timestamps, min, max, distribution) {
        if (distribution === 'linear' || !timestamps.length) {
          return [{
            time: min,
            pos: 0
          }, {
            time: max,
            pos: 1
          }];
        }

        var table = [];
        var items = [min];
        var i, ilen, prev, curr, next;

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          curr = timestamps[i];

          if (curr > min && curr < max) {
            items.push(curr);
          }
        }

        items.push(max);

        for (i = 0, ilen = items.length; i < ilen; ++i) {
          next = items[i + 1];
          prev = items[i - 1];
          curr = items[i]; // only add points that breaks the scale linearity

          if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
            table.push({
              time: curr,
              pos: i / (ilen - 1)
            });
          }
        }

        return table;
      } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


      function lookup(table, key, value) {
        var lo = 0;
        var hi = table.length - 1;
        var mid, i0, i1;

        while (lo >= 0 && lo <= hi) {
          mid = lo + hi >> 1;
          i0 = table[mid - 1] || null;
          i1 = table[mid];

          if (!i0) {
            // given value is outside table (before first item)
            return {
              lo: null,
              hi: i1
            };
          } else if (i1[key] < value) {
            lo = mid + 1;
          } else if (i0[key] > value) {
            hi = mid - 1;
          } else {
            return {
              lo: i0,
              hi: i1
            };
          }
        } // given value is outside table (after last item)


        return {
          lo: i1,
          hi: null
        };
      }
      /**
       * Linearly interpolates the given source `value` using the table items `skey` values and
       * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
       * returns the position for a timestamp equal to 42. If value is out of bounds, values at
       * index [0, 1] or [n - 1, n] are used for the interpolation.
       */


      function interpolate$1(table, skey, sval, tkey) {
        var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

        var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
        var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
        var span = next[skey] - prev[skey];
        var ratio = span ? (sval - prev[skey]) / span : 0;
        var offset = (next[tkey] - prev[tkey]) * ratio;
        return prev[tkey] + offset;
      }

      function toTimestamp(scale, input) {
        var adapter = scale._adapter;
        var options = scale.options.time;
        var parser = options.parser;
        var format = parser || options.format;
        var value = input;

        if (typeof parser === 'function') {
          value = parser(value);
        } // Only parse if its not a timestamp already


        if (!helpers$1.isFinite(value)) {
          value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
        }

        if (value !== null) {
          return +value;
        } // Labels are in an incompatible format and no `parser` has been provided.
        // The user might still use the deprecated `format` option for parsing.


        if (!parser && typeof format === 'function') {
          value = format(input); // `format` could return something else than a timestamp, if so, parse it

          if (!helpers$1.isFinite(value)) {
            value = adapter.parse(value);
          }
        }

        return value;
      }

      function parse(scale, input) {
        if (helpers$1.isNullOrUndef(input)) {
          return null;
        }

        var options = scale.options.time;
        var value = toTimestamp(scale, scale.getRightValue(input));

        if (value === null) {
          return value;
        }

        if (options.round) {
          value = +scale._adapter.startOf(value, options.round);
        }

        return value;
      }
      /**
       * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
       * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
       */


      function determineStepSize(min, max, unit, capacity) {
        var range = max - min;
        var interval = INTERVALS[unit];
        var milliseconds = interval.size;
        var steps = interval.steps;
        var i, ilen, factor;

        if (!steps) {
          return Math.ceil(range / (capacity * milliseconds));
        }

        for (i = 0, ilen = steps.length; i < ilen; ++i) {
          factor = steps[i];

          if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
            break;
          }
        }

        return factor;
      }
      /**
       * Figures out what unit results in an appropriate number of auto-generated ticks
       */


      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        var ilen = UNITS.length;
        var i, interval, factor;

        for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          interval = INTERVALS[UNITS[i]];
          factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
          }
        }

        return UNITS[ilen - 1];
      }
      /**
       * Figures out what unit to format a set of ticks with
       */


      function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
        var ilen = UNITS.length;
        var i, unit;

        for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
          unit = UNITS[i];

          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
            return unit;
          }
        }

        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
      }

      function determineMajorUnit(unit) {
        for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
          if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
          }
        }
      }
      /**
       * Generates a maximum of `capacity` timestamps between min and max, rounded to the
       * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
       * Important: this method can return ticks outside the min and max range, it's the
       * responsibility of the calling code to clamp values if needed.
       */


      function generate(scale, min, max, capacity) {
        var adapter = scale._adapter;
        var options = scale.options;
        var timeOpts = options.time;
        var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
        var major = determineMajorUnit(minor);
        var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
        var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        var majorTicksEnabled = options.ticks.major.enabled;
        var interval = INTERVALS[minor];
        var first = min;
        var last = max;
        var ticks = [];
        var time;

        if (!stepSize) {
          stepSize = determineStepSize(min, max, minor, capacity);
        } // For 'week' unit, handle the first day of week option


        if (weekday) {
          first = +adapter.startOf(first, 'isoWeek', weekday);
          last = +adapter.startOf(last, 'isoWeek', weekday);
        } // Align first/last ticks on unit


        first = +adapter.startOf(first, weekday ? 'day' : minor);
        last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

        if (last < max) {
          last = +adapter.add(last, 1, minor);
        }

        time = first;

        if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
          // Align the first tick on the previous `minor` unit aligned on the `major` unit:
          // we first aligned time on the previous `major` unit then add the number of full
          // stepSize there is between first and the previous major time.
          time = +adapter.startOf(time, major);
          time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
        }

        for (; time < last; time = +adapter.add(time, stepSize, minor)) {
          ticks.push(+time);
        }

        ticks.push(+time);
        return ticks;
      }
      /**
       * Returns the start and end offsets from edges in the form of {start, end}
       * where each value is a relative width to the scale and ranges between 0 and 1.
       * They add extra margins on the both sides by scaling down the original scale.
       * Offsets are added when the `offset` option is true.
       */


      function computeOffsets(table, ticks, min, max, options) {
        var start = 0;
        var end = 0;
        var first, last;

        if (options.offset && ticks.length) {
          if (!options.time.min) {
            first = interpolate$1(table, 'time', ticks[0], 'pos');

            if (ticks.length === 1) {
              start = 1 - first;
            } else {
              start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
            }
          }

          if (!options.time.max) {
            last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

            if (ticks.length === 1) {
              end = last;
            } else {
              end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
            }
          }
        }

        return {
          start: start,
          end: end
        };
      }

      function ticksFromTimestamps(scale, values, majorUnit) {
        var ticks = [];
        var i, ilen, value, major;

        for (i = 0, ilen = values.length; i < ilen; ++i) {
          value = values[i];
          major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
          ticks.push({
            value: value,
            major: major
          });
        }

        return ticks;
      }

      var defaultConfig$4 = {
        position: 'bottom',

        /**
         * Data distribution along the scale:
         * - 'linear': data are spread according to their time (distances can vary),
         * - 'series': data are spread at the same distance from each other.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        distribution: 'linear',

        /**
         * Scale boundary strategy (bypassed by min/max time options)
         * - `data`: make sure data are fully visible, ticks outside are removed
         * - `ticks`: make sure ticks are fully visible, data outside are truncated
         * @see https://github.com/chartjs/Chart.js/pull/4556
         * @since 2.7.0
         */
        bounds: 'data',
        adapters: {},
        time: {
          parser: false,
          // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
          format: false,
          // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
          unit: false,
          // false == automatic or override with week, month, year, etc.
          round: false,
          // none, or override with week, month, year, etc.
          displayFormat: false,
          // DEPRECATED
          isoWeekday: false,
          // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
          minUnit: 'millisecond',
          displayFormats: {}
        },
        ticks: {
          autoSkip: false,

          /**
           * Ticks generation input values:
           * - 'auto': generates "optimal" ticks based on scale size and time options.
           * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
           * - 'labels': generates ticks from user given `data.labels` values ONLY.
           * @see https://github.com/chartjs/Chart.js/pull/4507
           * @since 2.7.0
           */
          source: 'auto',
          major: {
            enabled: false
          }
        }
      };
      var scale_time = core_scale.extend({
        initialize: function () {
          this.mergeTicksOptions();
          core_scale.prototype.initialize.call(this);
        },
        update: function () {
          var me = this;
          var options = me.options;
          var time = options.time || (options.time = {});
          var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

          if (time.format) {
            console.warn('options.time.format is deprecated and replaced by options.time.parser.');
          } // Backward compatibility: before introducing adapter, `displayFormats` was
          // supposed to contain *all* unit/string pairs but this can't be resolved
          // when loading the scale (adapters are loaded afterward), so let's populate
          // missing formats on update


          helpers$1.mergeIf(time.displayFormats, adapter.formats());
          return core_scale.prototype.update.apply(me, arguments);
        },

        /**
         * Allows data to be referenced via 't' attribute
         */
        getRightValue: function (rawValue) {
          if (rawValue && rawValue.t !== undefined) {
            rawValue = rawValue.t;
          }

          return core_scale.prototype.getRightValue.call(this, rawValue);
        },
        determineDataLimits: function () {
          var me = this;
          var chart = me.chart;
          var adapter = me._adapter;
          var timeOpts = me.options.time;
          var unit = timeOpts.unit || 'day';
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var timestamps = [];
          var datasets = [];
          var labels = [];
          var i, j, ilen, jlen, data, timestamp;
          var dataLabels = chart.data.labels || []; // Convert labels to timestamps

          for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
            labels.push(parse(me, dataLabels[i]));
          } // Convert data to timestamps


          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

              if (helpers$1.isObject(data[0])) {
                datasets[i] = [];

                for (j = 0, jlen = data.length; j < jlen; ++j) {
                  timestamp = parse(me, data[j]);
                  timestamps.push(timestamp);
                  datasets[i][j] = timestamp;
                }
              } else {
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  timestamps.push(labels[j]);
                }

                datasets[i] = labels.slice(0);
              }
            } else {
              datasets[i] = [];
            }
          }

          if (labels.length) {
            // Sort labels **after** data have been converted
            labels = arrayUnique(labels).sort(sorter);
            min = Math.min(min, labels[0]);
            max = Math.max(max, labels[labels.length - 1]);
          }

          if (timestamps.length) {
            timestamps = arrayUnique(timestamps).sort(sorter);
            min = Math.min(min, timestamps[0]);
            max = Math.max(max, timestamps[timestamps.length - 1]);
          }

          min = parse(me, timeOpts.min) || min;
          max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

          min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
          max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

          me.min = Math.min(min, max);
          me.max = Math.max(min + 1, max); // PRIVATE

          me._horizontal = me.isHorizontal();
          me._table = [];
          me._timestamps = {
            data: timestamps,
            datasets: datasets,
            labels: labels
          };
        },
        buildTicks: function () {
          var me = this;
          var min = me.min;
          var max = me.max;
          var options = me.options;
          var timeOpts = options.time;
          var timestamps = [];
          var ticks = [];
          var i, ilen, timestamp;

          switch (options.ticks.source) {
            case 'data':
              timestamps = me._timestamps.data;
              break;

            case 'labels':
              timestamps = me._timestamps.labels;
              break;

            case 'auto':
            default:
              timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
          }

          if (options.bounds === 'ticks' && timestamps.length) {
            min = timestamps[0];
            max = timestamps[timestamps.length - 1];
          } // Enforce limits with user min/max options


          min = parse(me, timeOpts.min) || min;
          max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            timestamp = timestamps[i];

            if (timestamp >= min && timestamp <= max) {
              ticks.push(timestamp);
            }
          }

          me.min = min;
          me.max = max; // PRIVATE

          me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
          me._majorUnit = determineMajorUnit(me._unit);
          me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
          me._offsets = computeOffsets(me._table, ticks, min, max, options);

          if (options.ticks.reverse) {
            ticks.reverse();
          }

          return ticksFromTimestamps(me, ticks, me._majorUnit);
        },
        getLabelForIndex: function (index, datasetIndex) {
          var me = this;
          var adapter = me._adapter;
          var data = me.chart.data;
          var timeOpts = me.options.time;
          var label = data.labels && index < data.labels.length ? data.labels[index] : '';
          var value = data.datasets[datasetIndex].data[index];

          if (helpers$1.isObject(value)) {
            label = me.getRightValue(value);
          }

          if (timeOpts.tooltipFormat) {
            return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
          }

          if (typeof label === 'string') {
            return label;
          }

          return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
        },

        /**
         * Function to format an individual tick mark
         * @private
         */
        tickFormatFunction: function (time, index, ticks, format) {
          var me = this;
          var adapter = me._adapter;
          var options = me.options;
          var formats = options.time.displayFormats;
          var minorFormat = formats[me._unit];
          var majorUnit = me._majorUnit;
          var majorFormat = formats[majorUnit];
          var majorTime = +adapter.startOf(time, majorUnit);
          var majorTickOpts = options.ticks.major;
          var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
          var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
          var tickOpts = major ? majorTickOpts : options.ticks.minor;
          var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
          return formatter ? formatter(label, index, ticks) : label;
        },
        convertTicksToLabels: function (ticks) {
          var labels = [];
          var i, ilen;

          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
          }

          return labels;
        },

        /**
         * @private
         */
        getPixelForOffset: function (time) {
          var me = this;
          var isReverse = me.options.ticks.reverse;
          var size = me._horizontal ? me.width : me.height;
          var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
          var pos = interpolate$1(me._table, 'time', time, 'pos');
          var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
          return isReverse ? start - offset : start + offset;
        },
        getPixelForValue: function (value, index, datasetIndex) {
          var me = this;
          var time = null;

          if (index !== undefined && datasetIndex !== undefined) {
            time = me._timestamps.datasets[datasetIndex][index];
          }

          if (time === null) {
            time = parse(me, value);
          }

          if (time !== null) {
            return me.getPixelForOffset(time);
          }
        },
        getPixelForTick: function (index) {
          var ticks = this.getTicks();
          return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var size = me._horizontal ? me.width : me.height;
          var start = me._horizontal ? me.left : me.top;
          var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
          var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

          return me._adapter._create(time);
        },

        /**
         * Crude approximation of what the label width might be
         * @private
         */
        getLabelWidth: function (label) {
          var me = this;
          var ticksOpts = me.options.ticks;
          var tickLabelWidth = me.ctx.measureText(label).width;
          var angle = helpers$1.toRadians(ticksOpts.maxRotation);
          var cosRotation = Math.cos(angle);
          var sinRotation = Math.sin(angle);
          var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
          return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
        },

        /**
         * @private
         */
        getLabelCapacity: function (exampleTime) {
          var me = this; // pick the longest format (milliseconds) for guestimation

          var format = me.options.time.displayFormats.millisecond;
          var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
          var tickLabelWidth = me.getLabelWidth(exampleLabel);
          var innerWidth = me.isHorizontal() ? me.width : me.height;
          var capacity = Math.floor(innerWidth / tickLabelWidth);
          return capacity > 0 ? capacity : 1;
        }
      }); // INTERNAL: static default options, registered in src/index.js

      var _defaults$4 = defaultConfig$4;
      scale_time._defaults = _defaults$4;
      var scales = {
        category: scale_category,
        linear: scale_linear,
        logarithmic: scale_logarithmic,
        radialLinear: scale_radialLinear,
        time: scale_time
      };
      var FORMATS = {
        datetime: 'MMM D, YYYY, h:mm:ss a',
        millisecond: 'h:mm:ss.SSS a',
        second: 'h:mm:ss a',
        minute: 'h:mm a',
        hour: 'hA',
        day: 'MMM D',
        week: 'll',
        month: 'MMM YYYY',
        quarter: '[Q]Q - YYYY',
        year: 'YYYY'
      };

      core_adapters._date.override(typeof moment === 'function' ? {
        _id: 'moment',
        // DEBUG ONLY
        formats: function () {
          return FORMATS;
        },
        parse: function (value, format) {
          if (typeof value === 'string' && typeof format === 'string') {
            value = moment(value, format);
          } else if (!(value instanceof moment)) {
            value = moment(value);
          }

          return value.isValid() ? value.valueOf() : null;
        },
        format: function (time, format) {
          return moment(time).format(format);
        },
        add: function (time, amount, unit) {
          return moment(time).add(amount, unit).valueOf();
        },
        diff: function (max, min, unit) {
          return moment.duration(moment(max).diff(moment(min))).as(unit);
        },
        startOf: function (time, unit, weekday) {
          time = moment(time);

          if (unit === 'isoWeek') {
            return time.isoWeekday(weekday).valueOf();
          }

          return time.startOf(unit).valueOf();
        },
        endOf: function (time, unit) {
          return moment(time).endOf(unit).valueOf();
        },
        // DEPRECATIONS

        /**
         * Provided for backward compatibility with scale.getValueForPixel().
         * @deprecated since version 2.8.0
         * @todo remove at version 3
         * @private
         */
        _create: function (time) {
          return moment(time);
        }
      } : {});

      core_defaults._set('global', {
        plugins: {
          filler: {
            propagate: true
          }
        }
      });

      var mappers = {
        dataset: function (source) {
          var index = source.fill;
          var chart = source.chart;
          var meta = chart.getDatasetMeta(index);
          var visible = meta && chart.isDatasetVisible(index);
          var points = visible && meta.dataset._children || [];
          var length = points.length || 0;
          return !length ? null : function (point, i) {
            return i < length && points[i]._view || null;
          };
        },
        boundary: function (source) {
          var boundary = source.boundary;
          var x = boundary ? boundary.x : null;
          var y = boundary ? boundary.y : null;
          return function (point) {
            return {
              x: x === null ? point.x : x,
              y: y === null ? point.y : y
            };
          };
        }
      }; // @todo if (fill[0] === '#')

      function decodeFill(el, index, count) {
        var model = el._model || {};
        var fill = model.fill;
        var target;

        if (fill === undefined) {
          fill = !!model.backgroundColor;
        }

        if (fill === false || fill === null) {
          return false;
        }

        if (fill === true) {
          return 'origin';
        }

        target = parseFloat(fill, 10);

        if (isFinite(target) && Math.floor(target) === target) {
          if (fill[0] === '-' || fill[0] === '+') {
            target = index + target;
          }

          if (target === index || target < 0 || target >= count) {
            return false;
          }

          return target;
        }

        switch (fill) {
          // compatibility
          case 'bottom':
            return 'start';

          case 'top':
            return 'end';

          case 'zero':
            return 'origin';
          // supported boundaries

          case 'origin':
          case 'start':
          case 'end':
            return fill;
          // invalid fill values

          default:
            return false;
        }
      }

      function computeBoundary(source) {
        var model = source.el._model || {};
        var scale = source.el._scale || {};
        var fill = source.fill;
        var target = null;
        var horizontal;

        if (isFinite(fill)) {
          return null;
        } // Backward compatibility: until v3, we still need to support boundary values set on
        // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
        // controllers might still use it (e.g. the Smith chart).


        if (fill === 'start') {
          target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
        } else if (fill === 'end') {
          target = model.scaleTop === undefined ? scale.top : model.scaleTop;
        } else if (model.scaleZero !== undefined) {
          target = model.scaleZero;
        } else if (scale.getBasePosition) {
          target = scale.getBasePosition();
        } else if (scale.getBasePixel) {
          target = scale.getBasePixel();
        }

        if (target !== undefined && target !== null) {
          if (target.x !== undefined && target.y !== undefined) {
            return target;
          }

          if (helpers$1.isFinite(target)) {
            horizontal = scale.isHorizontal();
            return {
              x: horizontal ? target : null,
              y: horizontal ? null : target
            };
          }
        }

        return null;
      }

      function resolveTarget(sources, index, propagate) {
        var source = sources[index];
        var fill = source.fill;
        var visited = [index];
        var target;

        if (!propagate) {
          return fill;
        }

        while (fill !== false && visited.indexOf(fill) === -1) {
          if (!isFinite(fill)) {
            return fill;
          }

          target = sources[fill];

          if (!target) {
            return false;
          }

          if (target.visible) {
            return fill;
          }

          visited.push(fill);
          fill = target.fill;
        }

        return false;
      }

      function createMapper(source) {
        var fill = source.fill;
        var type = 'dataset';

        if (fill === false) {
          return null;
        }

        if (!isFinite(fill)) {
          type = 'boundary';
        }

        return mappers[type](source);
      }

      function isDrawable(point) {
        return point && !point.skip;
      }

      function drawArea(ctx, curve0, curve1, len0, len1) {
        var i;

        if (!len0 || !len1) {
          return;
        } // building first area curve (normal)


        ctx.moveTo(curve0[0].x, curve0[0].y);

        for (i = 1; i < len0; ++i) {
          helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
        } // joining the two area curves


        ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

        for (i = len1 - 1; i > 0; --i) {
          helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
        }
      }

      function doFill(ctx, points, mapper, view, color, loop) {
        var count = points.length;
        var span = view.spanGaps;
        var curve0 = [];
        var curve1 = [];
        var len0 = 0;
        var len1 = 0;
        var i, ilen, index, p0, p1, d0, d1;
        ctx.beginPath();

        for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
          index = i % count;
          p0 = points[index]._view;
          p1 = mapper(p0, index, view);
          d0 = isDrawable(p0);
          d1 = isDrawable(p1);

          if (d0 && d1) {
            len0 = curve0.push(p0);
            len1 = curve1.push(p1);
          } else if (len0 && len1) {
            if (!span) {
              drawArea(ctx, curve0, curve1, len0, len1);
              len0 = len1 = 0;
              curve0 = [];
              curve1 = [];
            } else {
              if (d0) {
                curve0.push(p0);
              }

              if (d1) {
                curve1.push(p1);
              }
            }
          }
        }

        drawArea(ctx, curve0, curve1, len0, len1);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }

      var plugin_filler = {
        id: 'filler',
        afterDatasetsUpdate: function (chart, options) {
          var count = (chart.data.datasets || []).length;
          var propagate = options.propagate;
          var sources = [];
          var meta, i, el, source;

          for (i = 0; i < count; ++i) {
            meta = chart.getDatasetMeta(i);
            el = meta.dataset;
            source = null;

            if (el && el._model && el instanceof elements.Line) {
              source = {
                visible: chart.isDatasetVisible(i),
                fill: decodeFill(el, i, count),
                chart: chart,
                el: el
              };
            }

            meta.$filler = source;
            sources.push(source);
          }

          for (i = 0; i < count; ++i) {
            source = sources[i];

            if (!source) {
              continue;
            }

            source.fill = resolveTarget(sources, i, propagate);
            source.boundary = computeBoundary(source);
            source.mapper = createMapper(source);
          }
        },
        beforeDatasetDraw: function (chart, args) {
          var meta = args.meta.$filler;

          if (!meta) {
            return;
          }

          var ctx = chart.ctx;
          var el = meta.el;
          var view = el._view;
          var points = el._children || [];
          var mapper = meta.mapper;
          var color = view.backgroundColor || core_defaults.global.defaultColor;

          if (mapper && color && points.length) {
            helpers$1.canvas.clipArea(ctx, chart.chartArea);
            doFill(ctx, points, mapper, view, color, el._loop);
            helpers$1.canvas.unclipArea(ctx);
          }
        }
      };
      var noop$1 = helpers$1.noop;
      var valueOrDefault$d = helpers$1.valueOrDefault;

      core_defaults._set('global', {
        legend: {
          display: true,
          position: 'top',
          fullWidth: true,
          reverse: false,
          weight: 1000,
          // a callback that will handle
          onClick: function (e, legendItem) {
            var index = legendItem.datasetIndex;
            var ci = this.chart;
            var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

            ci.update();
          },
          onHover: null,
          onLeave: null,
          labels: {
            boxWidth: 40,
            padding: 10,
            // Generates labels shown in the legend
            // Valid properties to return:
            // text : text to display
            // fillStyle : fill of coloured box
            // strokeStyle: stroke of coloured box
            // hidden : if this legend item refers to a hidden item
            // lineCap : cap style for line
            // lineDash
            // lineDashOffset :
            // lineJoin :
            // lineWidth :
            generateLabels: function (chart) {
              var data = chart.data;
              return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
                return {
                  text: dataset.label,
                  fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                  hidden: !chart.isDatasetVisible(i),
                  lineCap: dataset.borderCapStyle,
                  lineDash: dataset.borderDash,
                  lineDashOffset: dataset.borderDashOffset,
                  lineJoin: dataset.borderJoinStyle,
                  lineWidth: dataset.borderWidth,
                  strokeStyle: dataset.borderColor,
                  pointStyle: dataset.pointStyle,
                  // Below is extra data used for toggling the datasets
                  datasetIndex: i
                };
              }, this) : [];
            }
          }
        },
        legendCallback: function (chart) {
          var text = [];
          text.push('<ul class="' + chart.id + '-legend">');

          for (var i = 0; i < chart.data.datasets.length; i++) {
            text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

            if (chart.data.datasets[i].label) {
              text.push(chart.data.datasets[i].label);
            }

            text.push('</li>');
          }

          text.push('</ul>');
          return text.join('');
        }
      });
      /**
       * Helper function to get the box width based on the usePointStyle option
       * @param {object} labelopts - the label options on the legend
       * @param {number} fontSize - the label font size
       * @return {number} width of the color box area
       */


      function getBoxWidth(labelOpts, fontSize) {
        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
      }
      /**
       * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
       */


      var Legend = core_element.extend({
        initialize: function (config) {
          helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

          this.legendHitBoxes = [];
          /**
          	 * @private
          	 */

          this._hoveredItem = null; // Are we in doughnut mode which has a different data type

          this.doughnutMode = false;
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        // Any function defined here is inherited by all legend types.
        // Any function can be extended by the legend type
        beforeUpdate: noop$1,
        update: function (maxWidth, maxHeight, margins) {
          var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Labels

          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: noop$1,
        //
        beforeSetDimensions: noop$1,
        setDimensions: function () {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0; // Reset minSize

          me.minSize = {
            width: 0,
            height: 0
          };
        },
        afterSetDimensions: noop$1,
        //
        beforeBuildLabels: noop$1,
        buildLabels: function () {
          var me = this;
          var labelOpts = me.options.labels || {};
          var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

          if (labelOpts.filter) {
            legendItems = legendItems.filter(function (item) {
              return labelOpts.filter(item, me.chart.data);
            });
          }

          if (me.options.reverse) {
            legendItems.reverse();
          }

          me.legendItems = legendItems;
        },
        afterBuildLabels: noop$1,
        //
        beforeFit: noop$1,
        fit: function () {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var display = opts.display;
          var ctx = me.ctx;

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size; // Reset hit boxes

          var hitboxes = me.legendHitBoxes = [];
          var minSize = me.minSize;
          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            minSize.width = me.maxWidth; // fill all the width

            minSize.height = display ? 10 : 0;
          } else {
            minSize.width = display ? 10 : 0;
            minSize.height = me.maxHeight; // fill all the height
          } // Increase sizes here


          if (display) {
            ctx.font = labelFont.string;

            if (isHorizontal) {
              // Labels
              // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
              var lineWidths = me.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              helpers$1.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

                if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
                } // Store the hitbox width and height here. Final position will be updated in `draw`


                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              var itemHeight = fontSize + vPadding;
              helpers$1.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

                if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth); // previous column width

                  currentColWidth = 0;
                  currentColHeight = 0;
                } // Get max width


                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              minSize.width += totalWidth;
            }
          }

          me.width = minSize.width;
          me.height = minSize.height;
        },
        afterFit: noop$1,
        // Shared Methods
        isHorizontal: function () {
          return this.options.position === 'top' || this.options.position === 'bottom';
        },
        // Actually draw the legend on the canvas
        draw: function () {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var globalDefaults = core_defaults.global;
          var defaultColor = globalDefaults.defaultColor;
          var lineDefault = globalDefaults.elements.line;
          var legendWidth = me.width;
          var lineWidths = me.lineWidths;

          if (opts.display) {
            var ctx = me.ctx;
            var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

            var labelFont = helpers$1.options._parseFont(labelOpts);

            var fontSize = labelFont.size;
            var cursor; // Canvas setup

            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor; // for strikethrough effect

            ctx.fillStyle = fontColor; // render in correct colour

            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes; // current position

            var drawLegendBox = function (x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              } // Set the ctx for the box


              ctx.save();
              var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

              if (ctx.setLineDash) {
                // IE 9 and 10 do not support line dash
                ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
              }

              if (opts.labels && opts.labels.usePointStyle) {
                // Recalculate x and y for drawPoint() because its expecting
                // x and y to be center of figure (instead of top left)
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = x + boxWidth / 2;
                var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
              } else {
                // Draw box as legend symbol
                if (lineWidth !== 0) {
                  ctx.strokeRect(x, y, boxWidth, fontSize);
                }

                ctx.fillRect(x, y, boxWidth, fontSize);
              }

              ctx.restore();
            };

            var fillText = function (x, y, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = boxWidth + halfFontSize + x;
              var yMiddle = y + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);

              if (legendItem.hidden) {
                // Strikethrough the text if hidden
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(xLeft + textWidth, yMiddle);
                ctx.stroke();
              }
            }; // Horizontal


            var isHorizontal = me.isHorizontal();

            if (isHorizontal) {
              cursor = {
                x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
                y: me.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + labelOpts.padding,
                line: 0
              };
            }

            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width = boxWidth + fontSize / 2 + textWidth;
              var x = cursor.x;
              var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
              // instead of me.right and me.bottom because me.width and me.height
              // may have been changed since me.minSize was calculated

              if (isHorizontal) {
                if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
                }
              } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                y = cursor.y = me.top + labelOpts.padding;
                cursor.line++;
              }

              drawLegendBox(x, y, legendItem);
              hitboxes[i].left = x;
              hitboxes[i].top = y; // Fill the actual label

              fillText(x, y, legendItem, textWidth);

              if (isHorizontal) {
                cursor.x += width + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
          }
        },

        /**
         * @private
         */
        _getLegendItemAt: function (x, y) {
          var me = this;
          var i, hitBox, lh;

          if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
            // See if we are touching one of the dataset boxes
            lh = me.legendHitBoxes;

            for (i = 0; i < lh.length; ++i) {
              hitBox = lh[i];

              if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                // Touching an element
                return me.legendItems[i];
              }
            }
          }

          return null;
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         */
        handleEvent: function (e) {
          var me = this;
          var opts = me.options;
          var type = e.type === 'mouseup' ? 'click' : e.type;
          var hoveredItem;

          if (type === 'mousemove') {
            if (!opts.onHover && !opts.onLeave) {
              return;
            }
          } else if (type === 'click') {
            if (!opts.onClick) {
              return;
            }
          } else {
            return;
          } // Chart event already has relative position in it


          hoveredItem = me._getLegendItemAt(e.x, e.y);

          if (type === 'click') {
            if (hoveredItem && opts.onClick) {
              // use e.native for backwards compatibility
              opts.onClick.call(me, e.native, hoveredItem);
            }
          } else {
            if (opts.onLeave && hoveredItem !== me._hoveredItem) {
              if (me._hoveredItem) {
                opts.onLeave.call(me, e.native, me._hoveredItem);
              }

              me._hoveredItem = hoveredItem;
            }

            if (opts.onHover && hoveredItem) {
              // use e.native for backwards compatibility
              opts.onHover.call(me, e.native, hoveredItem);
            }
          }
        }
      });

      function createNewLegendAndAttach(chart, legendOpts) {
        var legend = new Legend({
          ctx: chart.ctx,
          options: legendOpts,
          chart: chart
        });
        core_layouts.configure(chart, legend, legendOpts);
        core_layouts.addBox(chart, legend);
        chart.legend = legend;
      }

      var plugin_legend = {
        id: 'legend',

        /**
         * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
         * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
         * the plugin, which one will be re-exposed in the chart.js file.
         * https://github.com/chartjs/Chart.js/pull/2640
         * @private
         */
        _element: Legend,
        beforeInit: function (chart) {
          var legendOpts = chart.options.legend;

          if (legendOpts) {
            createNewLegendAndAttach(chart, legendOpts);
          }
        },
        beforeUpdate: function (chart) {
          var legendOpts = chart.options.legend;
          var legend = chart.legend;

          if (legendOpts) {
            helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

            if (legend) {
              core_layouts.configure(chart, legend, legendOpts);
              legend.options = legendOpts;
            } else {
              createNewLegendAndAttach(chart, legendOpts);
            }
          } else if (legend) {
            core_layouts.removeBox(chart, legend);
            delete chart.legend;
          }
        },
        afterEvent: function (chart, e) {
          var legend = chart.legend;

          if (legend) {
            legend.handleEvent(e);
          }
        }
      };
      var noop$2 = helpers$1.noop;

      core_defaults._set('global', {
        title: {
          display: false,
          fontStyle: 'bold',
          fullWidth: true,
          padding: 10,
          position: 'top',
          text: '',
          weight: 2000 // by default greater than legend (1000) to be above

        }
      });
      /**
       * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
       */


      var Title = core_element.extend({
        initialize: function (config) {
          var me = this;
          helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

          me.legendHitBoxes = [];
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        beforeUpdate: noop$2,
        update: function (maxWidth, maxHeight, margins) {
          var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Labels

          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: noop$2,
        //
        beforeSetDimensions: noop$2,
        setDimensions: function () {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0; // Reset minSize

          me.minSize = {
            width: 0,
            height: 0
          };
        },
        afterSetDimensions: noop$2,
        //
        beforeBuildLabels: noop$2,
        buildLabels: noop$2,
        afterBuildLabels: noop$2,
        //
        beforeFit: noop$2,
        fit: function () {
          var me = this;
          var opts = me.options;
          var display = opts.display;
          var minSize = me.minSize;
          var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

          var fontOpts = helpers$1.options._parseFont(opts);

          var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

          if (me.isHorizontal()) {
            minSize.width = me.maxWidth; // fill all the width

            minSize.height = textSize;
          } else {
            minSize.width = textSize;
            minSize.height = me.maxHeight; // fill all the height
          }

          me.width = minSize.width;
          me.height = minSize.height;
        },
        afterFit: noop$2,
        // Shared Methods
        isHorizontal: function () {
          var pos = this.options.position;
          return pos === 'top' || pos === 'bottom';
        },
        // Actually draw the title block on the canvas
        draw: function () {
          var me = this;
          var ctx = me.ctx;
          var opts = me.options;

          if (opts.display) {
            var fontOpts = helpers$1.options._parseFont(opts);

            var lineHeight = fontOpts.lineHeight;
            var offset = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me.top;
            var left = me.left;
            var bottom = me.bottom;
            var right = me.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

            ctx.font = fontOpts.string; // Horizontal

            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2; // midpoint of the width

              titleY = top + offset;
              maxWidth = right - left;
            } else {
              titleX = opts.position === 'left' ? left + offset : right - offset;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
            }

            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            var text = opts.text;

            if (helpers$1.isArray(text)) {
              var y = 0;

              for (var i = 0; i < text.length; ++i) {
                ctx.fillText(text[i], 0, y, maxWidth);
                y += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }

            ctx.restore();
          }
        }
      });

      function createNewTitleBlockAndAttach(chart, titleOpts) {
        var title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart: chart
        });
        core_layouts.configure(chart, title, titleOpts);
        core_layouts.addBox(chart, title);
        chart.titleBlock = title;
      }

      var plugin_title = {
        id: 'title',

        /**
         * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
         * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
         * the plugin, which one will be re-exposed in the chart.js file.
         * https://github.com/chartjs/Chart.js/pull/2640
         * @private
         */
        _element: Title,
        beforeInit: function (chart) {
          var titleOpts = chart.options.title;

          if (titleOpts) {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        },
        beforeUpdate: function (chart) {
          var titleOpts = chart.options.title;
          var titleBlock = chart.titleBlock;

          if (titleOpts) {
            helpers$1.mergeIf(titleOpts, core_defaults.global.title);

            if (titleBlock) {
              core_layouts.configure(chart, titleBlock, titleOpts);
              titleBlock.options = titleOpts;
            } else {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          } else if (titleBlock) {
            core_layouts.removeBox(chart, titleBlock);
            delete chart.titleBlock;
          }
        }
      };
      var plugins = {};
      var filler = plugin_filler;
      var legend = plugin_legend;
      var title = plugin_title;
      plugins.filler = filler;
      plugins.legend = legend;
      plugins.title = title;
      /**
       * @namespace Chart
       */

      core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

      core_helpers(core_controller);
      core_controller._adapters = core_adapters;
      core_controller.Animation = core_animation;
      core_controller.animationService = core_animations;
      core_controller.controllers = controllers;
      core_controller.DatasetController = core_datasetController;
      core_controller.defaults = core_defaults;
      core_controller.Element = core_element;
      core_controller.elements = elements;
      core_controller.Interaction = core_interaction;
      core_controller.layouts = core_layouts;
      core_controller.platform = platform;
      core_controller.plugins = core_plugins;
      core_controller.Scale = core_scale;
      core_controller.scaleService = core_scaleService;
      core_controller.Ticks = core_ticks;
      core_controller.Tooltip = core_tooltip; // Register built-in scales

      core_controller.helpers.each(scales, function (scale, type) {
        core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
      }); // Load to register built-in adapters (as side effects)
      // Loading built-in plugins

      for (var k in plugins) {
        if (plugins.hasOwnProperty(k)) {
          core_controller.plugins.register(plugins[k]);
        }
      }

      core_controller.platform.initialize();
      var src = core_controller;

      if (typeof window !== 'undefined') {
        window.Chart = core_controller;
      } // DEPRECATIONS

      /**
       * Provided for backward compatibility, not available anymore
       * @namespace Chart.Chart
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */


      core_controller.Chart = core_controller;
      /**
       * Provided for backward compatibility, not available anymore
       * @namespace Chart.Legend
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */

      core_controller.Legend = plugins.legend._element;
      /**
       * Provided for backward compatibility, not available anymore
       * @namespace Chart.Title
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */

      core_controller.Title = plugins.title._element;
      /**
       * Provided for backward compatibility, use Chart.plugins instead
       * @namespace Chart.pluginService
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */

      core_controller.pluginService = core_controller.plugins;
      /**
       * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
       * effect, instead simply create/register plugins via plain JavaScript objects.
       * @interface Chart.PluginBase
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */

      core_controller.PluginBase = core_controller.Element.extend({});
      /**
       * Provided for backward compatibility, use Chart.helpers.canvas instead.
       * @namespace Chart.canvasHelpers
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */

      core_controller.canvasHelpers = core_controller.helpers.canvas;
      /**
       * Provided for backward compatibility, use Chart.layouts instead.
       * @namespace Chart.layoutService
       * @deprecated since version 2.7.3
       * @todo remove at version 3
       * @private
       */

      core_controller.layoutService = core_controller.layouts;
      /**
       * Provided for backward compatibility, not available anymore.
       * @namespace Chart.LinearScaleBase
       * @deprecated since version 2.8
       * @todo remove at version 3
       * @private
       */

      core_controller.LinearScaleBase = scale_linearbase;
      /**
       * Provided for backward compatibility, instead we should create a new Chart
       * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */

      core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
        core_controller[klass] = function (ctx, cfg) {
          return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
            type: klass.charAt(0).toLowerCase() + klass.slice(1)
          }));
        };
      });
      return src;
    });
  });

  function generateChart(chartId, chartType) {
    return {
      render: function render(createElement) {
        return createElement('div', {
          style: this.styles,
          class: this.cssClasses
        }, [createElement('canvas', {
          attrs: {
            id: this.chartId,
            width: this.width,
            height: this.height
          },
          ref: 'canvas'
        })]);
      },
      props: {
        chartId: {
          default: chartId,
          type: String
        },
        width: {
          default: 400,
          type: Number
        },
        height: {
          default: 400,
          type: Number
        },
        cssClasses: {
          type: String,
          default: ''
        },
        styles: {
          type: Object
        },
        plugins: {
          type: Array,
          default: function _default() {
            return [];
          }
        }
      },
      data: function data() {
        return {
          _chart: null,
          _plugins: this.plugins
        };
      },
      methods: {
        addPlugin: function addPlugin(plugin) {
          this.$data._plugins.push(plugin);
        },
        generateLegend: function generateLegend() {
          if (this.$data._chart) {
            return this.$data._chart.generateLegend();
          }
        },
        renderChart: function renderChart(data, options) {
          if (this.$data._chart) {
            this.$data._chart.destroy();
          }

          this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
            type: chartType,
            data: data,
            options: options,
            plugins: this.$data._plugins
          });
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }
      }
    };
  }
  var Bar = generateChart('bar-chart', 'bar');
  var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
  var Line = generateChart('line-chart', 'line');
  var Pie = generateChart('pie-chart', 'pie');

  var reactiveProp$1 = mixins.reactiveProp;
  Chart.defaults.global.title.padding = 20;
  Chart.defaults.global.title.fontSize = 16;
  Chart.defaults.global.title.lineHeight = 1.6;
  var script$1 = {
    "extends": Bar,
    mixins: [reactiveProp$1],
    props: {
      options: {
        type: Object,
        "default": function default$1() {
          return {
            legend: {
              display: false
            },
            lineTension: 1
          };
        }
      }
    },
    mounted: function mounted() {
      this.renderChart(this.chartData, this.options);
    }
  };

  /* script */
  var __vue_script__$1 = script$1;

  /* template */

    /* style */
    var __vue_inject_styles__$1 = undefined;
    /* scoped */
    var __vue_scope_id__$1 = undefined;
    /* module identifier */
    var __vue_module_identifier__$1 = undefined;
    /* functional template */
    var __vue_is_functional_template__$1 = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var ChartComponent = normalizeComponent_1(
      {},
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      undefined,
      undefined
    );

  var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
  var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
  var ChartData = {
    data: {
      labels: chartLabels,
      datasets: [{
        data: chartDataList,
        fill: false,
        // used by line chart
        backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
        borderColor: ['#ACAEB9'],
        borderWidth: 1
      }]
    },
    bar: {
      options: {
        title: {
          display: true,
          text: 'Population Chart'
        },
        legend: {
          display: false
        },
        lineTension: 1,
        scales: {
          xAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Years'
            }
          }],
          yAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Population'
            },
            ticks: {
              padding: 25
            }
          }]
        }
      }
    },
    horizontalBar: {
      options: {
        title: {
          display: true,
          text: 'Population Chart'
        },
        legend: {
          display: false
        },
        lineTension: 1,
        scales: {
          xAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Population'
            }
          }],
          yAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Years'
            },
            ticks: {
              padding: 25
            }
          }]
        }
      }
    },
    pie: {
      options: {
        title: {
          display: true,
          text: 'Population Chart'
        },
        legend: {
          display: true
        },
        lineTension: 1
      }
    }
  };

  var chartType = 'bar';

  var ChartBar = function ChartBar(settings, data) {
    if (settings === void 0) settings = {};
    if (data === void 0) data = {};
    this.data = data;
    this.settings = settings;
    this.init();
  };
  /**
   * Initializes the module
   */


  ChartBar.prototype.init = function init() {
    Vue.component("nyco-chart-" + chartType, ChartComponent);
    new Vue({
      el: "[data-js=\"chart-" + chartType + "\"]",
      delimiters: ['v{', '}'],
      data: function data() {
        return {
          data: ChartData.data,
          options: ChartData.bar.options
        };
      }
    });
  };
  /**
   * Logs constants to the debugger
   * @param{object} param - our constants
   */


  ChartBar.prototype._constants = function _constants(param) {
    console.dir(param);
  };

  var reactiveProp$2 = mixins.reactiveProp;
  Chart.defaults.global.title.padding = 20;
  Chart.defaults.global.title.fontSize = 16;
  Chart.defaults.global.title.lineHeight = 1.6;
  var script$2 = {
    "extends": HorizontalBar,
    mixins: [reactiveProp$2],
    props: {
      options: {
        type: Object,
        "default": function default$1() {
          return {
            legend: {
              display: false
            },
            lineTension: 1
          };
        }
      }
    },
    mounted: function mounted() {
      this.renderChart(this.chartData, this.options);
    }
  };

  /* script */
  var __vue_script__$2 = script$2;

  /* template */

    /* style */
    var __vue_inject_styles__$2 = undefined;
    /* scoped */
    var __vue_scope_id__$2 = undefined;
    /* module identifier */
    var __vue_module_identifier__$2 = undefined;
    /* functional template */
    var __vue_is_functional_template__$2 = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var ChartComponent$1 = normalizeComponent_1(
      {},
      __vue_inject_styles__$2,
      __vue_script__$2,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      undefined,
      undefined
    );

  var chartType$1 = 'horizontal-bar';

  var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
    if (settings === void 0) settings = {};
    if (data === void 0) data = {};
    this.data = data;
    this.settings = settings;
    this.init();
  };
  /**
   * Initializes the module
   */


  ChartHorizontalBar.prototype.init = function init() {
    Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
    new Vue({
      el: "[data-js=\"chart-" + chartType$1 + "\"]",
      delimiters: ['v{', '}'],
      data: function data() {
        return {
          data: ChartData.data,
          options: ChartData.horizontalBar.options
        };
      }
    });
  };
  /**
   * Logs constants to the debugger
   * @param{object} param - our constants
   */


  ChartHorizontalBar.prototype._constants = function _constants(param) {
    console.dir(param);
  };

  var reactiveProp$3 = mixins.reactiveProp;
  Chart.defaults.global.title.padding = 20;
  Chart.defaults.global.title.fontSize = 16;
  Chart.defaults.global.title.lineHeight = 1.6;
  var script$3 = {
    "extends": Line,
    mixins: [reactiveProp$3],
    props: {
      options: {
        type: Object,
        "default": function default$1() {
          return {
            legend: {
              display: false
            },
            lineTension: 1
          };
        }
      }
    },
    mounted: function mounted() {
      this.renderChart(this.chartData, this.options);
    }
  };

  /* script */
  var __vue_script__$3 = script$3;

  /* template */

    /* style */
    var __vue_inject_styles__$3 = undefined;
    /* scoped */
    var __vue_scope_id__$3 = undefined;
    /* module identifier */
    var __vue_module_identifier__$3 = undefined;
    /* functional template */
    var __vue_is_functional_template__$3 = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var ChartComponent$2 = normalizeComponent_1(
      {},
      __vue_inject_styles__$3,
      __vue_script__$3,
      __vue_scope_id__$3,
      __vue_is_functional_template__$3,
      __vue_module_identifier__$3,
      undefined,
      undefined
    );

  var chartType$2 = 'line';

  var ChartLine = function ChartLine(settings, data) {
    if (settings === void 0) settings = {};
    if (data === void 0) data = {};
    this.data = data;
    this.settings = settings;
    this.init();
  };
  /**
   * Initializes the module
   */


  ChartLine.prototype.init = function init() {
    Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
    new Vue({
      el: "[data-js=\"chart-" + chartType$2 + "\"]",
      delimiters: ['v{', '}'],
      data: function data() {
        return {
          data: ChartData.data,
          options: ChartData.bar.options
        };
      }
    });
  };
  /**
   * Logs constants to the debugger
   * @param{object} param - our constants
   */


  ChartLine.prototype._constants = function _constants(param) {
    console.dir(param);
  };

  var reactiveProp$4 = mixins.reactiveProp;
  Chart.defaults.global.title.padding = 20;
  Chart.defaults.global.title.fontSize = 16;
  Chart.defaults.global.title.lineHeight = 1.6;
  var script$4 = {
    "extends": Pie,
    mixins: [reactiveProp$4],
    props: {
      options: {
        type: Object,
        "default": function default$1() {
          return {
            legend: {
              display: true
            },
            lineTension: 1
          };
        }
      }
    },
    mounted: function mounted() {
      this.renderChart(this.chartData, this.options);
    }
  };

  /* script */
  var __vue_script__$4 = script$4;

  /* template */

    /* style */
    var __vue_inject_styles__$4 = undefined;
    /* scoped */
    var __vue_scope_id__$4 = undefined;
    /* module identifier */
    var __vue_module_identifier__$4 = undefined;
    /* functional template */
    var __vue_is_functional_template__$4 = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var ChartComponent$3 = normalizeComponent_1(
      {},
      __vue_inject_styles__$4,
      __vue_script__$4,
      __vue_scope_id__$4,
      __vue_is_functional_template__$4,
      __vue_module_identifier__$4,
      undefined,
      undefined
    );

  var chartType$3 = 'pie';

  var ChartPie = function ChartPie(settings, data) {
    if (settings === void 0) settings = {};
    if (data === void 0) data = {};
    this.data = data;
    this.settings = settings;
    this.init();
  };
  /**
   * Initializes the module
   */


  ChartPie.prototype.init = function init() {
    Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
    new Vue({
      el: "[data-js=\"chart-" + chartType$3 + "\"]",
      delimiters: ['v{', '}'],
      data: function data() {
        return {
          data: ChartData.data,
          options: ChartData.pie.options
        };
      }
    });
  };
  /**
   * Logs constants to the debugger
   * @param{object} param - our constants
   */


  ChartPie.prototype._constants = function _constants(param) {
    console.dir(param);
  };

  /** import modules here as they are written */

  /**
   * Methods for the global NycoPatterns instance
   */

  var nyco = function nyco() {};

  nyco.prototype.icons = function icons(path) {
    return new Icons(path);
  };
  /**
   * Method for the Feed Object
   * @param {Object}settingsSetting for the feed
   * @return{Object}          Feed instance
   */


  nyco.prototype.feed = function feed(settings) {
    return new Feed(settings);
  };
  /**
   * Method for the Toggle Utility
   * @return{Object} Toggle instance
   */


  nyco.prototype.toggle = function toggle(settings) {
    return new Toggle();
  };
  /**
   * Method for the Track Module
   * @return{Object} Track Module
   */


  nyco.prototype.track = function track(settings) {
    return new Track();
  };

  nyco.prototype.select = function select() {
    return new Select();
  };
  /**
   * Method for the Chart Objects
   * @return{Object} Chart instance
   */


  nyco.prototype.chart = function chart(type) {
    if (type === 'bar') {
      return new ChartBar();
    }

    if (type === 'horizontalBar') {
      return new ChartHorizontalBar();
    }

    if (type === 'line') {
      return new ChartLine();
    }

    if (type === 'pie') {
      return new ChartPie();
    }
  };

  return nyco;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvanMvbW9kdWxlcy91dGlsaXR5LmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL2ljb25zL0ljb25zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaWRlbnRpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jb25zdGFudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Nob3J0T3V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQXNzaWduZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvYXNzaWduSW5XaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvYXR0ZW1wdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lc2NhcGVTdHJpbmdDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVJbnRlcnBvbGF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlSHRtbENoYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFc2NhcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUV2YWx1YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZVNldHRpbmdzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5RWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUJhc2VGb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvck93bi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0RnVuY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZvckVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVDbGVhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZVNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xpc3RDYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0RlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrR2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVDcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fSGFzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleWFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXBDYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3RhY2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2FmZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9QbGFpbk9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUFkZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNvbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VxdWFsQXJyYXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwVG9BcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEJ5VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUZpbHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9scy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEFsbEtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbE9iamVjdHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19EYXRhVmlldy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1Byb21pc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19XZWFrTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXRjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hdGNoRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21lbW9pemVDYXBwZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0UGF0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUhhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzUGF0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGFzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcHJvcGVydHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXRlcmF0ZWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNvcnRCeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvbXBhcmVBc2NlbmRpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlTXVsdGlwbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlT3JkZXJCeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvb3JkZXJCeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaW5kSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYU4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25vb3AuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVTZXQuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9mZWVkL0ZlZWQuanMiLCIuLi8uLi9zcmMvdXRpbGl0aWVzL3RvZ2dsZS9Ub2dnbGUuanMiLCIuLi8uLi9zcmMvdXRpbGl0aWVzL3RyYWNrL1RyYWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlci5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9zZWxlY3Qvc2VsZWN0LnZ1ZSIsIi4uLy4uL3NyYy9lbGVtZW50cy9zZWxlY3Qvc2VsZWN0LmRhdGEuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9taXhpbnMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L0NoYXJ0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1jaGFydGpzL2VzL0Jhc2VDaGFydHMuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQuZGF0YS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tYmFyLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWhvcml6b250YWwtYmFyLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1saW5lLnZ1ZSIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tcGllLnZ1ZSIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tcGllLmpzIiwiLi4vLi4vc3JjL2pzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBVdGlsaXR5IGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVXRpbGl0eSB7XG4gIC8qKlxuICAgKiBUaGUgVXRpbGl0eSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBVdGlsaXR5IGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIEJvb2xlYW4gZm9yIGRlYnVnIG1vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciBvciBub3QgdGhlIGZyb250LWVuZCBpcyBpbiBkZWJ1ZyBtb2RlLlxuICovXG5VdGlsaXR5LmRlYnVnID0gKCkgPT4gKFV0aWxpdHkuZ2V0VXJsUGFyYW1ldGVyKFV0aWxpdHkuUEFSQU1TLkRFQlVHKSA9PT0gJzEnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGtleSBpbiBhIFVSTCBxdWVyeSBzdHJpbmcuIElmIG5vIFVSTCBxdWVyeVxuICogc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgY3VycmVudCBVUkwgbG9jYXRpb24gaXMgdXNlZC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAgICAgIC0gS2V5IG5hbWUuXG4gKiBAcGFyYW0gIHs/c3RyaW5nfSBxdWVyeVN0cmluZyAtIE9wdGlvbmFsIHF1ZXJ5IHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFF1ZXJ5IHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIgPSAobmFtZSwgcXVlcnlTdHJpbmcpID0+IHtcbiAgY29uc3QgcXVlcnkgPSBxdWVyeVN0cmluZyB8fCB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICBjb25zdCBwYXJhbSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpO1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScpO1xuICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyhxdWVyeSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyAnJyA6XG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xufTtcblxuLyoqXG4gKiBGb3IgdHJhbnNsYXRpbmcgc3RyaW5ncywgdGhlcmUgaXMgYSBnbG9iYWwgTE9DQUxJWkVEX1NUUklOR1MgYXJyYXkgdGhhdFxuICogaXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0ZW1wbGF0ZSBsZXZlbCBzbyB0aGF0IHRob3NlIHN0cmluZ3MgYXJlIGV4cG9zZWQgdG9cbiAqIFdQTUwgdHJhbnNsYXRpb24uIFRoZSBMT0NBTElaRURfU1RSSU5HUyBhcnJheSBpcyBjb21wb3NlZCBvZiBvYmplY3RzIHdpdGggYVxuICogYHNsdWdgIGtleSB3aG9zZSB2YWx1ZSBpcyBzb21lIGNvbnN0YW50LCBhbmQgYSBgbGFiZWxgIHZhbHVlIHdoaWNoIGlzIHRoZVxuICogdHJhbnNsYXRlZCBlcXVpdmFsZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgc2x1ZyBuYW1lIGFuZCByZXR1cm5zIHRoZVxuICogbGFiZWwuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNsdWdcbiAqIEByZXR1cm4ge3N0cmluZ30gbG9jYWxpemVkIHZhbHVlXG4gKi9cblV0aWxpdHkubG9jYWxpemUgPSBmdW5jdGlvbihzbHVnKSB7XG4gIGxldCB0ZXh0ID0gc2x1ZyB8fCAnJztcbiAgY29uc3Qgc3RyaW5ncyA9IHdpbmRvdy5MT0NBTElaRURfU1RSSU5HUyB8fCBbXTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmdzLmZpbHRlcihcbiAgICAocykgPT4gKHMuaGFzT3duUHJvcGVydHkoJ3NsdWcnKSAmJiBzWydzbHVnJ10gPT09IHNsdWcpID8gcyA6IGZhbHNlXG4gICk7XG4gIHJldHVybiAobWF0Y2hbMF0gJiYgbWF0Y2hbMF0uaGFzT3duUHJvcGVydHkoJ2xhYmVsJykpID8gbWF0Y2hbMF0ubGFiZWwgOiB0ZXh0O1xufTtcblxuLyoqXG4gKiBBcHBsaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlsaXR5LlBBUkFNUyA9IHtcbiAgREVCVUc6ICdkZWJ1Zydcbn07XG5cbi8qKlxuICogU2VsZWN0b3JzIGZvciB0aGUgVXRpbGl0eSBtb2R1bGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuU0VMRUNUT1JTID0ge1xuICBwYXJzZU1hcmtkb3duOiAnW2RhdGEtanM9XCJtYXJrZG93blwiXSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVdGlsaXR5IGZyb20gJy4uLy4uL2pzL21vZHVsZXMvdXRpbGl0eSc7XG5cbi8qKlxuICogVGhlIEljb24gbW9kdWxlXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgSWNvbnMge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgcGF0aCA9IChwYXRoKSA/IHBhdGggOiBJY29ucy5wYXRoO1xuXG4gICAgZmV0Y2gocGF0aClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzcHJpdGUuaW5uZXJIVE1MID0gZGF0YTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcHJpdGUpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIHBhdGggb2YgdGhlIGljb24gZmlsZSAqL1xuSWNvbnMucGF0aCA9ICdpY29ucy5zdmcnO1xuXG5leHBvcnQgZGVmYXVsdCBJY29ucztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25zdGFudDtcbiIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZXN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSXRlcmF0ZWVDYWxsO1xuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluV2l0aDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcnJvcjtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGF0dGVtcHQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcbiIsIi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlU3RyaW5nQ2hhcjtcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlSW50ZXJwb2xhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eU9mO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eU9mIGZyb20gJy4vX2Jhc2VQcm9wZXJ0eU9mLmpzJztcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZUh0bWxDaGFyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG4iLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG4iLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcbiIsImltcG9ydCBlc2NhcGUgZnJvbSAnLi9lc2NhcGUuanMnO1xuaW1wb3J0IHJlRXNjYXBlIGZyb20gJy4vX3JlRXNjYXBlLmpzJztcbmltcG9ydCByZUV2YWx1YXRlIGZyb20gJy4vX3JlRXZhbHVhdGUuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVTZXR0aW5ncztcbiIsImltcG9ydCBhc3NpZ25JbldpdGggZnJvbSAnLi9hc3NpZ25JbldpdGguanMnO1xuaW1wb3J0IGF0dGVtcHQgZnJvbSAnLi9hdHRlbXB0LmpzJztcbmltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGN1c3RvbURlZmF1bHRzQXNzaWduSW4gZnJvbSAnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nQ2hhciBmcm9tICcuL19lc2NhcGVTdHJpbmdDaGFyLmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHRlbXBsYXRlU2V0dGluZ3MgZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICB2YXIgc291cmNlVVJMID0gJ3NvdXJjZVVSTCcgaW4gb3B0aW9ucyA/ICcvLyMgc291cmNlVVJMPScgKyBvcHRpb25zLnNvdXJjZVVSTCArICdcXG4nIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG4iLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RGdW5jdGlvbjtcbiIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrU2V0O1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IHN0YWNrQ2xlYXIgZnJvbSAnLi9fc3RhY2tDbGVhci5qcyc7XG5pbXBvcnQgc3RhY2tEZWxldGUgZnJvbSAnLi9fc3RhY2tEZWxldGUuanMnO1xuaW1wb3J0IHN0YWNrR2V0IGZyb20gJy4vX3N0YWNrR2V0LmpzJztcbmltcG9ydCBzdGFja0hhcyBmcm9tICcuL19zdGFja0hhcy5qcyc7XG5pbXBvcnQgc3RhY2tTZXQgZnJvbSAnLi9fc3RhY2tTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQnVmZmVyO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IFVpbnQ4QXJyYXk7XG4iLCJpbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUFycmF5QnVmZmVyO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDcmVhdGU7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUdldDtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9QbGFpbk9iamVjdDtcbiIsImltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5pbXBvcnQgdG9QbGFpbk9iamVjdCBmcm9tICcuL3RvUGxhaW5PYmplY3QuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlSGFzO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcbmltcG9ydCBzZXRDYWNoZUFkZCBmcm9tICcuL19zZXRDYWNoZUFkZC5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVIYXMgZnJvbSAnLi9fc2V0Q2FjaGVIYXMuanMnO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvQXJyYXk7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgbWFwVG9BcnJheSBmcm9tICcuL19tYXBUb0FycmF5LmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVB1c2g7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJBcnJheTtcbiIsImltcG9ydCBhcnJheUZpbHRlciBmcm9tICcuL19hcnJheUZpbHRlci5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5cztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVZpZXc7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdlYWtNYXA7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVDYXBwZWQ7XG4iLCJpbXBvcnQgbWVtb2l6ZUNhcHBlZCBmcm9tICcuL19tZW1vaXplQ2FwcGVkLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb1BhdGg7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdFBhdGg7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0tleTtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VIYXNJbjtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcbiIsImltcG9ydCBiYXNlSGFzSW4gZnJvbSAnLi9fYmFzZUhhc0luLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcbmltcG9ydCBnZXQgZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTb3J0Qnk7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZUFzY2VuZGluZztcbiIsImltcG9ydCBjb21wYXJlQXNjZW5kaW5nIGZyb20gJy4vX2NvbXBhcmVBc2NlbmRpbmcuanMnO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlTXVsdGlwbGU7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgYmFzZVNvcnRCeSBmcm9tICcuL19iYXNlU29ydEJ5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjb21wYXJlTXVsdGlwbGUgZnJvbSAnLi9fY29tcGFyZU11bHRpcGxlLmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VPcmRlckJ5O1xuIiwiaW1wb3J0IGJhc2VPcmRlckJ5IGZyb20gJy4vX2Jhc2VPcmRlckJ5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqIF07XG4gKlxuICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqL1xuZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgfVxuICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3JkZXJCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEluZGV4O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmFOO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpY3RJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5leHBvcnQgZGVmYXVsdCBub29wO1xuIiwiaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBfdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gtZXMvZm9yRWFjaCc7XG5pbXBvcnQgX21lcmdlIGZyb20gJ2xvZGFzaC1lcy9tZXJnZSc7XG5pbXBvcnQgX3ZhbHVlcyBmcm9tICdsb2Rhc2gtZXMvdmFsdWVzJztcbmltcG9ydCBfb3JkZXJCeSBmcm9tICdsb2Rhc2gtZXMvb3JkZXJCeSc7XG5pbXBvcnQgX3VuaXFCeSBmcm9tICdsb2Rhc2gtZXMvdW5pcUJ5JztcblxuLyoqXG4gKlxuICovXG5jbGFzcyBGZWVkIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0ID0gRmVlZC5kZWZhdWx0O1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfbWVyZ2Uoe30sIEZlZWQuZGVmYXVsdCwgY29uZmlnKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgbGV0IGRhdGEgPSBbXTtcbiAgICBsZXQgZmVlZCA9IHRoaXMuX3NldHRpbmdzLmZlZWQ7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHJzc1RvSnNvbjogRmVlZC5yc3NUb0pzb24sXG4gICAgICByc3NVcmw6IChBcnJheS5pc0FycmF5KGZlZWQpKSA/IGZlZWQgOiBbZmVlZF1cbiAgICB9O1xuXG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIGZlZWRcbiAgICBfZm9yRWFjaChjb25maWcucnNzVXJsLCAodXJsLCBpbmRleCkgPT4ge1xuICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdFxuICAgICAgdGhpcy5fcmVxdWVzdChjb25maWcsIHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhXG4gICAgICAgICAgZGF0YS5wdXNoKHRoaXMuX3Byb2Nlc3MoSlNPTi5wYXJzZShyZXNwb25zZSksIHRoaXMuX3NldHRpbmdzKSk7XG4gICAgICAgICAgLy8gV2hlbiBhbGwgZmVlZHMgaGF2ZSBiZWVuIHJlcXVlc3RlZCwgbWVyZ2UgdGhlIGRhdGEgYW5kIGNvbXBpbGVcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGNvbmZpZy5yc3NVcmwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGxldCBjb21waWxlZCA9IHRoaXMuX3JlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5fbWVyZ2UoZGF0YSwgdGhpcy5fc2V0dGluZ3MpLFxuICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9zZXR0aW5ncy5zZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGNvbXBpbGVkO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0IGZvciB0aGUgZmVlZCBkYXRhXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnIFRoZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgVGhlIHJlcXVlc3QgdXJsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFJlc29sdmVzIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHJlYWR5LCByZWplY3RzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXQgb3IgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAqL1xuICBfcmVxdWVzdChjb25maWcsIHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbGV0IF94aHIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChfeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoX3hoci5zdGF0dXMgPj0gMjAwICYmIF94aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKF94aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF94aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgRmVlZCByZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgIH07XG4gICAgICB4aHIub3BlbignR0VUJywgYCR7Y29uZmlnLnJzc1RvSnNvbn0/cnNzX3VybD0ke3VybH1gLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICB4aHIgPSBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgcHJvY2Vzc2luZyBmdW5jdGlvbiBiYXNlZCBvbiB0eXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBwcm9jZXNzZWQgZGF0YVxuICAgKi9cbiAgX3Byb2Nlc3MoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gRmVlZC5wcm9jZXNzW3NldHRpbmdzLnR5cGVdKGRhdGEsIHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzIGRhdGEgdG8gdGhlIGFwcHJvcHJpYXRlIG1lcmdlIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIG1lcmdlZCBmZWVkIGRhdGFcbiAgICovXG4gIF9tZXJnZShkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLm1lcmdlW3NldHRpbmdzLnR5cGVdKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGVtcGxhdGUgY29tcG9uZW50cywgcGFzcyBkYXRhLCBhbmQgcmV0dXJuIGNvbXBpbGVkIHRlbWxhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgVGhlIGNvbXBsaWVkIGh0bWwgc3RyaW5nXG4gICAqL1xuICBfcmVuZGVyKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgaWYgKHNldHRpbmdzLmxvZylcbiAgICAgIGNvbnNvbGUuZGlyKGRhdGEpO1xuXG4gICAgbGV0IHRlbXBsYXRlID0gX3ZhbHVlcyhzZXR0aW5ncy50ZW1wbGF0ZXMpLmpvaW4oJycpO1xuICAgIGxldCBjb21waWxlZCA9IF90ZW1wbGF0ZShcbiAgICAgIHRlbXBsYXRlLFxuICAgICAge1xuICAgICAgICAnaW1wb3J0cyc6IHtcbiAgICAgICAgICAnX2VhY2gnOiBfZm9yRWFjaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29tcGlsZWQoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvcGVuIFJTUyB0byBKU09OIGFwaSwgc2VlIGh0dHBzOi8vcnNzMmpzb24uY29tXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5GZWVkLnJzc1RvSnNvbiA9ICdodHRwczovL2FwaS5yc3MyanNvbi5jb20vdjEvYXBpLmpzb24nO1xuXG4vKipcbiAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdpZGdldC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQudGVtcGxhdGVzID0ge1xuICBtZWRpdW06IHtcbiAgICBvcGVuZXI6IFtcbiAgICAgICc8c2VjdGlvbiBjbGFzcz1cIm8tZmVlZCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy53cmFwcGVyICU+XCIgc3R5bGU9XCInLFxuICAgICAgICAnPCUgaWYgKHNldHRpbmdzLmZvbnRTaXplKSB7ICU+Zm9udC1zaXplOiA8JS0gc2V0dGluZ3MuZm9udFNpemUgJT47PCUgfSAlPicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yKSB7ICU+Ym9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OzwlIH0gJT4nLFxuICAgICAgJ1wiPidcbiAgICBdLFxuICAgIGhlYWRlcjogW1xuICAgICAgJzxoZWFkZXIgY2xhc3M9XCJvLWZlZWRfX2hlYWRlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5oZWFkZXIgJT5cIj4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9fYXZhdGFyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmF2YXRhciAlPlwiPicsXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnByb2ZpbGVJbWcgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy5wcm9maWxlSW1nICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBmZWVkLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9ICU+XCIgJyxcbiAgICAgICAgICAgICAgICd3aWR0aD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMF0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ2hlaWdodD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMV0gJT5cIj4nLFxuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzxhIGNsYXNzPVwiby1mZWVkX191cmwgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCIgJyxcbiAgICAgICAgICAnaHJlZj1cIjwlIGlmIChzZXR0aW5ncy50aXRsZVVybCAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlVXJsICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnVybCAlPicsXG4gICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgJzwlIGlmIChzZXR0aW5ncy50aXRsZSAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSAlPicsXG4gICAgICAgICc8L2E+JyxcbiAgICAgICc8L2hlYWRlcj4nXG4gICAgXSxcbiAgICBwb3N0czogW1xuICAgICAgJzxkaXYgY2xhc3M9XCJvLWZlZWRfX2l0ZW1zXCIgc3R5bGU9XCInLFxuICAgICAgICAnYm9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OycsXG4gICAgICAnXCI+JyxcbiAgICAgICAgJzwlIF9lYWNoKGl0ZW1zLCBmdW5jdGlvbihwb3N0KSB7ICU+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmZlZWRJdGVtICU+XCI+JyxcbiAgICAgICAgICAgICc8aDQgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGl0bGUgPCUtIHNldHRpbmdzLmNsYXNzZXMudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJjLWZlZWQtaXRlbV9fbGluayA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5saW5rICU+XCInLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIicsXG4gICAgICAgICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIicsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHBvc3QudGl0bGUgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9oND4nLFxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2RhdGUgPCUtIHNldHRpbmdzLmNsYXNzZXMuZGF0ZSAlPlwiICcsXG4gICAgICAgICAgICAgICAgICAndGl0bGU9XCI8JS0gc2V0dGluZ3MucG9zdERhdGVUaXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8JS0gcG9zdC5kYXRlICU+JyxcbiAgICAgICAgICAgICc8L3NwYW4+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX3RodW1ibmFpbCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aHVtYm5haWwgJT5cIicsXG4gICAgICAgICAgICAgICAgICdzdHlsZT1cIicsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlOiB1cmwoPCUtIHBvc3QudGh1bWJuYWlsICU+KTsnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0OiA8JS0gc2V0dGluZ3MucG9zdEltZ0hlaWdodCAlPjtcIicsXG4gICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbj1cInRydWVcIj4nLFxuICAgICAgICAgICAgICAnPGltZyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgc3JjPVwiPCUtIHBvc3QudGh1bWJuYWlsICU+XCIgYWx0PVwiPCUtIHBvc3QudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPHAgY2xhc3M9XCJjLWZlZWQtaXRlbV9fZXhjZXJwdCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5leGNlcnB0ICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmV4Y2VycHQgJT48JS0gc2V0dGluZ3MucG9zdEV4Y2VycHRUcmFpbCAlPicsXG4gICAgICAgICAgICAnPC9wPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtX19mb290ZXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuaXRlbUZvb3RlciAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19jdGEgPCUtIHNldHRpbmdzLmNsYXNzZXMuY3RhICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ2hyZWY9XCI8JS0gcG9zdC5ndWlkICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnBvc3RDdGFUZXh0ICU+JyxcbiAgICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8JSB9KTsgJT4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLFxuICAgIGNsb3NlcjogW1xuICAgICAgJzwvc2VjdGlvbj4nXG4gICAgXVxuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgcHJvY2Vzc2luZyB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5wcm9jZXNzID0ge1xuICBtZWRpdW06IGZ1bmN0aW9uKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgbGV0IGxlbmd0aCA9IHNldHRpbmdzLnBvc3RFeGNlcnB0TGVuZ3RoO1xuXG4gICAgX2ZvckVhY2goZGF0YS5pdGVtcywgZnVuY3Rpb24ocG9zdCwgaW5kZXgpIHtcbiAgICAgIGxldCBleGNlcnB0ID0gJyc7XG4gICAgICBsZXQgZGF0ZSA9ICcnO1xuXG4gICAgICAvLyBSZW1vdmUgZmlndXJlcyBmaXJzdFxuICAgICAgZXhjZXJwdCA9IHBvc3QuZGVzY3JpcHRpb25cbiAgICAgICAgLnJlcGxhY2UoLzxmaWd1cmUuKj4uKj88XFwvZmlndXJlPi9nLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgdGFnc1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQucmVwbGFjZSgvPCgufFxcbikqPz4vZywgJycpO1xuXG4gICAgICAvLyBUcmltIHRoZSBleGNlcnB0XG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLFxuICAgICAgICBNYXRoLm1pbihleGNlcnB0Lmxlbmd0aCwgZXhjZXJwdC5sYXN0SW5kZXhPZignICcpKVxuICAgICAgKTtcblxuICAgICAgcG9zdC5leGNlcnB0ID0gZXhjZXJwdDtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlXG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShwb3N0LnB1YkRhdGUucmVwbGFjZSgnICcsICdUJykpKVxuICAgICAgICAudG9Mb2NhbGVEYXRlU3RyaW5nKHNldHRpbmdzLnBvc3REYXRlTG9jYWwsIHNldHRpbmdzLnBvc3REYXRlRm9ybWF0KTtcblxuICAgICAgcG9zdC5kYXRlID0gZGF0ZTtcblxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgbWVyZ2luZyB0aGUgZGF0YSBmZWVkcyB0b2dldGhlciwgYmFzZWQgb24gdGhlIGZlZWQgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQubWVyZ2UgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSkge1xuICAgIGxldCBtZXJnZWQgPSB7fTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIC8vIENvbWJpbmUgdGhlIHBvc3QgaXRlbXNcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KGZlZWQuaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGRhdGEsIHRoaXMgd2lsbCBvdmVycmlkZSB2YWx1ZXMsIGl0IHByb2JhYmx5IHdvbid0IGJlXG4gICAgLy8gcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZmVlZHMgdGhhdCBhcmUgdGhlIHNhbWUsIGJ1dCBwb3RlbnRpYWxseVxuICAgIC8vIGRpZmZlcmVudCBmZWVkIHR5cGVzIGNvdWxkIHVzZSB0aGlzIGFuZCBjb21iaW5lIHVuaXF1ZSBkYXRhXG4gICAgZGF0YS5mb3JFYWNoKChmZWVkKSA9PiB7XG4gICAgICBtZXJnZWQgPSBfbWVyZ2UobWVyZ2VkLCBmZWVkKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCB1bmlxdWUgcG9zdHNcbiAgICAvLyBpdGVtcyA9IF91bmlxQnkoaXRlbXMsIChpdGVtKSA9PiBpdGVtLmd1aWQpO1xuXG4gICAgbWVyZ2VkLml0ZW1zID0gX29yZGVyQnkoaXRlbXMsICdwdWJEYXRlJywgJ2Rlc2MnKTtcblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9yc3MyanNvbi5jb20vZG9jcyBmb3IgZGV0YWlscyBvbiBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQuZGVmYXVsdCA9IHtcbiAgZmVlZDogJycsXG4gIHNlbGVjdG9yOiAnI2pzLWZlZWQnLFxuICB0eXBlOiAnbWVkaXVtJyxcbiAgdGl0bGU6ICcnLFxuICB0aXRsZVVybDogJycsXG4gIHByb2ZpbGVJbWc6ICcnLFxuICBmb250U2l6ZTogJycsXG4gIHJhdGlvUHJvZmlsZTogWyc1MCcsICc1MCddLFxuICBwb3N0Qm9yZGVyQ29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gIHBvc3RJbWdIZWlnaHQ6ICcyMDBweCcsXG4gIHBvc3RFeGNlcnB0TGVuZ3RoOiAxMjAsXG4gIHBvc3RFeGNlcnB0VHJhaWw6ICfigKYnLFxuICBwb3N0Q3RhVGV4dDogJ1JlYWQgdGhlIGZ1bGwgcG9zdCcsXG4gIHBvc3REYXRlTG9jYWw6ICdlbi1VUycsXG4gIHBvc3REYXRlRm9ybWF0OiB7XG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYydcbiAgfSxcbiAgcG9zdERhdGVUaXRsZTogJ1B1Ymxpc2hlZCBEYXRlJyxcbiAgY2xhc3Nlczoge1xuICAgIHdyYXBwZXI6ICcnLFxuICAgIGhlYWRlcjogJycsXG4gICAgdXJsOiAnJyxcbiAgICBmZWVkSXRlbTogJycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGxpbms6ICcnLFxuICAgIHRodW1ibmFpbDogJycsXG4gICAgZXhjZXJwdDogJycsXG4gICAgaXRlbUZvb3RlcjogJycsXG4gICAgY3RhOiAnJyxcbiAgICBkYXRlOiAnJ1xuICB9LFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBvcGVuZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5vcGVuZXIuam9pbignJyksXG4gICAgaGVhZGVyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uaGVhZGVyLmpvaW4oJycpLFxuICAgIHBvc3RzOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0ucG9zdHMuam9pbignJyksXG4gICAgY2xvc2VyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uY2xvc2VyLmpvaW4oJycpXG4gIH0sXG4gIGxvZzogZmFsc2UsXG4gIHVuaXF1ZTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZlZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFNpbXBsZSBUb2dnbGUgY2xhc3MuIFRoaXMgd2lsbCB0b2dnbGUgdGhlIGNsYXNzICdhY3RpdmUnIGFuZCAnaGlkZGVuJ1xuICogb24gdGFyZ2V0IGVsZW1lbnRzLCBkZXRlcm1pbmVkIGJ5IGEgY2xpY2sgZXZlbnQgb24gYSBzZWxlY3RlZCBsaW5rIG9yXG4gKiBlbGVtZW50LiBUaGlzIHdpbGwgYWxzbyB0b2dnbGUgdGhlIGFyaWEtaGlkZGVuIGF0dHJpYnV0ZSBmb3IgdGFyZ2V0ZWRcbiAqIGVsZW1lbnRzIHRvIHN1cHBvcnQgc2NyZWVuIHJlYWRlcnMuIFRhcmdldCBzZXR0aW5ncyBhbmQgb3RoZXIgZnVuY3Rpb25hbGl0eVxuICogY2FuIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBkYXRhIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyB1c2VzIHRoZSAubWF0Y2hlcygpIG1ldGhvZCB3aGljaCB3aWxsIHJlcXVpcmUgYSBwb2x5ZmlsbCBmb3IgSUVcbiAqIGh0dHBzOi8vcG9seWZpbGwuaW8vdjIvZG9jcy9mZWF0dXJlcy8jRWxlbWVudF9wcm90b3R5cGVfbWF0Y2hlc1xuICpcbiAqIEJhc2ljIFVzYWdlO1xuICpcbiAqIGphdmFzY3JpcHQ6XG4gKiAgIG5ldyBUb2dnbGUoKS5pbml0KCk7XG4gKlxuICogVG9nZ2xpbmcgQW5jaG9yIGxpbmtzOlxuICogICA8YSBkYXRhLWpzPSd0b2dnbGUnIGhyZWY9JyNtYWluLW1lbnUnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogVG9nZ2xpbmcgYXJpYS1jb250cm9sIGVsZW1lbnRzOlxuICpcbiAqICAgPGJ1dHRvbiBkYXRhLWpzPSd0b2dnbGUnIGFyaWEtY29udHJvbHM9JyNtYWluLW1lbnUnIGFyaWEtcHJlc3NlZD0nZmFsc2UnPlxuICogICAgICBNZW51XG4gKiAgIDwvYnV0dG9uPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz4gLi4uIDwvZGl2PlxuICpcbiAqIENyZWF0ZSBcIlVuZG9cIiBFdmVudCAodG8gY2xvc2UgYSBkaWFsb2d1ZSk7XG4gKiAgIDxhIGhyZWY9JyNtYWluLW1lbnUnIGRhdGEtanM9J3RvZ2dsZScgZGF0YS10b2dnbGUtdW5kbz0nI2Nsb3NlJz5NZW51PC9hPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAqICAgICA8YSBpZD1cImNsb3NlXCI+Q2xvc2U8L2E+XG4gKiAgIDwvZGl2PlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRvZ2dsZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzIFNldHRpbmdzIGZvciB0aGlzIFRvZ2dsZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHMgPSAoIXMpID8ge30gOiBzO1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICBzZWxlY3RvcjogKHMuc2VsZWN0b3IpID8gcy5zZWxlY3RvciA6IFRvZ2dsZS5zZWxlY3RvcixcbiAgICAgIG5hbWVzcGFjZTogKHMubmFtZXNwYWNlKSA/IHMubmFtZXNwYWNlIDogVG9nZ2xlLm5hbWVzcGFjZSxcbiAgICAgIGluYWN0aXZlQ2xhc3M6IChzLmluYWN0aXZlQ2xhc3MpID8gcy5pbmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmluYWN0aXZlQ2xhc3MsXG4gICAgICBhY3RpdmVDbGFzczogKHMuYWN0aXZlQ2xhc3MpID8gcy5hY3RpdmVDbGFzcyA6IFRvZ2dsZS5hY3RpdmVDbGFzcyxcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGV2ZW50ICBUaGUgbWFpbiBjbGljayBldmVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgY2xhc3NcbiAgICovXG4gIF90b2dnbGUoZXZlbnQpIHtcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IHRhcmdldCA9IGZhbHNlO1xuXG4gICAgLyoqIEFuY2hvciBMaW5rcyAqL1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgOiB0YXJnZXQ7XG5cbiAgICAvKiogVG9nZ2xlIENvbnRyb2xzICovXG4gICAgLy8gY29uc29sZS5kaXIoZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7ZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyl9YCkgOiB0YXJnZXQ7XG5cbiAgICAvKiogTWFpbiBGdW5jdGlvbmFsaXR5ICovXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcblxuICAgIC8qKiBVbmRvICovXG4gICAgaWYgKGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXSkge1xuICAgICAgY29uc3QgdW5kbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXVxuICAgICAgKTtcblxuICAgICAgdW5kby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG4gICAgICAgIHVuZG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIHRvZ2dsaW5nIG1ldGhvZFxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsICAgICBUaGUgY3VycmVudCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmVcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmUvaGlkZGVuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzICE9PSAnJykge1xuICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgZWxlbWVudCBmb3IgZGVmaW5lZCBhcmlhIHJvbGVzIGFuZCB0b2dnbGUgdGhlbSBpZiB0aGV5IGV4aXN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUb2dnbGUuZWxBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS50YXJnZXRBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pKVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0sXG4gICAgICAgICAgISh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcykpXG4gICAge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdG9nZ2xpbmcgZnVuY3Rpb24gdG8gKi9cblRvZ2dsZS5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0b2dnbGVcIl0nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG5hbWVzcGFjZSBmb3Igb3VyIGRhdGEgYXR0cmlidXRlIHNldHRpbmdzICovXG5Ub2dnbGUubmFtZXNwYWNlID0gJ3RvZ2dsZSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgaGlkZSBjbGFzcyAqL1xuVG9nZ2xlLmluYWN0aXZlQ2xhc3MgPSAnaGlkZGVuJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBhY3RpdmUgY2xhc3MgKi9cblRvZ2dsZS5hY3RpdmVDbGFzcyA9ICdhY3RpdmUnO1xuXG4vKiogQHR5cGUge0FycmF5fSBBcmlhIHJvbGVzIHRvIHRvZ2dsZSB0cnVlL2ZhbHNlIG9uIHRoZSB0b2dnbGluZyBlbGVtZW50ICovXG5Ub2dnbGUuZWxBcmlhUm9sZXMgPSBbJ2FyaWEtcHJlc3NlZCcsICdhcmlhLWV4cGFuZGVkJ107XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRhcmdldCBlbGVtZW50ICovXG5Ub2dnbGUudGFyZ2V0QXJpYVJvbGVzID0gWydhcmlhLWhpZGRlbiddO1xuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbGl0eSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL3V0aWxpdHknO1xuXG4vKipcbiAqIFRyYWNraW5nIGJ1cyBmb3IgR29vZ2xlIGFuYWx5dGljcyBhbmQgV2VidHJlbmRzLlxuICovXG5jbGFzcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVHJhY2suc2VsZWN0b3IsXG4gICAgfTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCBrZXkgPSBldmVudC50YXJnZXQuZGF0YXNldC50cmFja0tleTtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuZGF0YXNldC50cmFja0RhdGEpO1xuXG4gICAgICB0aGlzLmNsaWNrKGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB3cmFwcGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIGZpbmFsIGRhdGEgb2JqZWN0XG4gICAqL1xuICBjbGljayhrZXksIGRhdGEpIHtcbiAgICAvLyBTZXQgdGhlIHBhdGggbmFtZSBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgICBjb25zdCBkID0gZGF0YS5tYXAoZWwgPT4ge1xuICAgICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSlcbiAgICAgICAgICBlbFtUcmFjay5rZXldID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfS8ke2VsW1RyYWNrLmtleV19YFxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcblxuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZCk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnKGtleSwgZCk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERhdGEgYnVzIGZvciB0cmFja2luZyB2aWV3cyBpbiBXZWJ0cmVuZHMgYW5kIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgU2luZ2xlIFBhZ2UgQXBwbGljYXRpb24gdG8gdHJhY2tcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHZpZXcoYXBwLCBrZXksIGRhdGEpIHtcbiAgICBsZXQgd3QgPSB0aGlzLndlYnRyZW5kcyhrZXksIGRhdGEpO1xuICAgIGxldCBnYSA9IHRoaXMuZ3RhZ1ZpZXcoYXBwLCBrZXkpO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpXG4gICAgICBjb25zb2xlLmRpcih7J1RyYWNrJzogW3d0LCBnYV19KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBFdmVudHMgdG8gV2VidHJlbmRzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICB3ZWJ0cmVuZHMoa2V5LCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50ID0gW3tcbiAgICAgICdXVC50aSc6IGtleVxuICAgIH1dO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKSB7XG4gICAgICBldmVudC5wdXNoKHtcbiAgICAgICAgJ0RDUy5kY3N1cmknOiBkYXRhWzBdW1RyYWNrLmtleV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgZGF0YSBmb3IgV2VidHJlbmRzXG4gICAgbGV0IHd0ZCA9IHthcmdzYTogZXZlbnQuZmxhdE1hcChlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mbGF0TWFwKGsgPT4gW2ssIGVba11dKTtcbiAgICB9KX07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgV2VidHJlbmRzICE9PSAndW5kZWZpbmVkJylcbiAgICAgIFdlYnRyZW5kcy5tdWx0aVRyYWNrKHd0ZCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ1dlYnRyZW5kcycsIHd0ZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggQ2xpY2sgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIGd0YWcoa2V5LCBkYXRhKSB7XG4gICAgbGV0IHVyaSA9IGRhdGEuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKTtcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgICdldmVudF9jYXRlZ29yeSc6IGtleVxuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgZ3RhZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBndGFnKFRyYWNrLmtleSwgdXJpW1RyYWNrLmtleV0sIGV2ZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIFNjcmVlbiBWaWV3IEV2ZW50cyB0byBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGFwcCAgVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKi9cbiAgZ3RhZ1ZpZXcoYXBwLCBrZXkpIHtcbiAgICBsZXQgdmlldyA9IHtcbiAgICAgIGFwcF9uYW1lOiBhcHAsXG4gICAgICBzY3JlZW5fbmFtZToga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoJ2V2ZW50JywgJ3NjcmVlbl92aWV3Jywgdmlldyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnZ3RhZycsIFRyYWNrLmtleSwgJ3NjcmVlbl92aWV3Jywgdmlld107XG4gIH07XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBzZWxlY3RvciB0byBhZGQgdGhlIHRyYWNraW5nIGZ1bmN0aW9uIHRvICovXG5UcmFjay5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0cmFja1wiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBldmVudCB0cmFja2luZyBrZXkgdG8gbWFwIHRvIFdlYnRyZW5kcyBEQ1MudXJpICovXG5UcmFjay5rZXkgPSAnZXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjazsiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjZcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbmNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IHZhbCA9PiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldXG4gICAgOiB2YWwgPT4gbWFwW3ZhbF1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xuY29uc3QgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IG5vID0gKGEsIGIsIGMpID0+IGZhbHNlO1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5jb25zdCBpZGVudGl0eSA9IChfKSA9PiBfO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZSgoa2V5cywgbSkgPT4ge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgY29uc3QgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIGNvbnN0IGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG5jb25zdCBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxuY29uc3QgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlTGV0dGVycyA9ICdhLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIGNvbnN0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xuY29uc3QgYmFpbFJFID0gbmV3IFJlZ0V4cChgW14ke3VuaWNvZGVMZXR0ZXJzfS4kX1xcXFxkXWApO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSByZXR1cm5cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5jb25zdCBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG5jb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG5jb25zdCB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbmNvbnN0IGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuY29uc3QgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbmNvbnN0IGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5jb25zdCBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuY29uc3QgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxuY29uc3QgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxubGV0IF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGNsYXNzIFNldCAgIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH1cbiAgICBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgd2FybiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICBjb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICBjb25zdCBjbGFzc2lmeSA9IHN0ciA9PiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5cbiAgd2FybiA9IChtc2csIHZtKSA9PiB7XG4gICAgY29uc3QgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtWdWUgd2Fybl06ICR7bXNnfSR7dHJhY2V9YCk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IChtc2csIHZtKSA9PiB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbVnVlIHRpcF06ICR7bXNnfWAgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSAodm0sIGluY2x1ZGVGaWxlKSA9PiB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIGNvbnN0IGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpXG4gICAgKVxuICB9O1xuXG4gIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgcmVzICs9IHN0cjtcbiAgICAgIGlmIChuID4gMSkgc3RyICs9IHN0cjtcbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gdm0gPT4ge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7XG4gICAgICAgICAgaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpXG4gICAgICAgIH0ke1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/IGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pfS4uLiAoJHt2bVsxXX0gcmVjdXJzaXZlIGNhbGxzKWBcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSlcbiAgICAgICAgfWApXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFxcblxcbihmb3VuZCBpbiAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSlgXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG5jbGFzcyBEZXAge1xuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmlkID0gdWlkKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH1cblxuICBhZGRTdWIgKHN1Yikge1xuICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gIH1cblxuICByZW1vdmVTdWIgKHN1Yikge1xuICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gIH1cblxuICBkZXBlbmQgKCkge1xuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnkgKCkge1xuICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbmNvbnN0IHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG5jbGFzcyBWTm9kZSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gICAvLyByZW5kZXJlZCBpbiB0aGlzIGNvbXBvbmVudCdzIHNjb3BlXG4gIFxuICBcbiAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgLy8gY29tcG9uZW50IHBsYWNlaG9sZGVyIG5vZGVcblxuICAvLyBzdHJpY3RseSBpbnRlcm5hbFxuICAgLy8gY29udGFpbnMgcmF3IEhUTUw/IChzZXJ2ZXIgb25seSlcbiAgIC8vIGhvaXN0ZWQgc3RhdGljIG5vZGVcbiAgIC8vIG5lY2Vzc2FyeSBmb3IgZW50ZXIgdHJhbnNpdGlvbiBjaGVja1xuICAgLy8gZW1wdHkgY29tbWVudCBwbGFjZWhvbGRlcj9cbiAgIC8vIGlzIGEgY2xvbmVkIG5vZGU/XG4gICAvLyBpcyBhIHYtb25jZSBub2RlP1xuICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAgXG4gIFxuICBcbiAgIC8vIHJlYWwgY29udGV4dCB2bSBmb3IgZnVuY3Rpb25hbCBub2Rlc1xuICAgLy8gZm9yIFNTUiBjYWNoaW5nXG4gICAvLyB1c2VkIHRvIHN0b3JlIGZ1bmN0aW9uYWwgcmVuZGVyIGNvbnRleHQgZm9yIGRldnRvb2xzXG4gICAvLyBmdW5jdGlvbmFsIHNjb3BlIGlkIHN1cHBvcnRcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgdGV4dCxcbiAgICBlbG0sXG4gICAgY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIGFzeW5jRmFjdG9yeVxuICApIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZWxtID0gZWxtO1xuICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBjaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICBjb25zdCBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbmNvbnN0IG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICBjb25zdCBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfXztcbiAgICBsZXQgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xubGV0IHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICBcbiAgXG4gICAvLyBudW1iZXIgb2Ygdm1zIHRoYXQgaGF2ZSB0aGlzIG9iamVjdCBhcyByb290ICRkYXRhXG5cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICB3YWxrIChvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKi9cbiAgb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICBjb25zdCBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICBjb25zdCBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgbGV0IGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSByZXR1cm5cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yIChsZXQgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbmNvbnN0IHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBvcHRpb24gXCIke2tleX1cIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBgICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvXG4gIGxldCBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICBjb25zdCBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICBjb25zdCByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGhvb2sgPT4ge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5jb25zdCBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoYF5bYS16QS1aXVtcXFxcLVxcXFwuMC05XyR7dW5pY29kZUxldHRlcnN9XSokYCkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgbGV0IGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwicHJvcHNcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHByb3BzKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHJldHVyblxuICBjb25zdCBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3QpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcImluamVjdFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUoaW5qZWN0KX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgY29uc3QgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkaXJzKSB7XG4gICAgICBjb25zdCBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcIiR7bmFtZX1cIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHZhbHVlKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge307XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICBjb25zdCBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHJldHVybiBhc3NldHNbaWRdXG4gIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXVxuICBjb25zdCBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgY29uc3QgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIGxldCB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICBjb25zdCBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHR5cGUgPSBwcm9wLnR5cGU7XG4gIGxldCB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIGNvbnN0IG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJyl9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICBsZXQgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSByZXR1cm5cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKGBFcnJvciBpbiAke2luZm99OiBcIiR7ZXJyLnRvU3RyaW5nKCl9XCJgLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xubGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIGNvbnN0IGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG5sZXQgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHNldFRpbWVvdXQobm9vcCk7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICBsZXQgY291bnRlciA9IDE7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIGxldCBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBtYXJrO1xubGV0IG1lYXN1cmU7XG5cbntcbiAgY29uc3QgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gdGFnID0+IHBlcmYubWFyayh0YWcpO1xuICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxubGV0IGluaXRQcm94eTtcblxue1xuICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgb3IgbWV0aG9kIFwiJHtrZXl9XCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBgICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYFByb3BlcnR5IFwiJHtrZXl9XCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFwiJGRhdGEuJHtrZXl9XCIgYmVjYXVzZSBgICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgY29uc3QgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKGBBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC4ke2tleX1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIGxldCBpLCBrZXlzO1xuICBjb25zdCBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIGNvbnN0IGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBub3JtYWxpemVFdmVudCA9IGNhY2hlZCgobmFtZSkgPT4ge1xuICBjb25zdCBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3Qgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmUsXG4gICAgcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIGNvbnN0IGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYClcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIGxldCBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcIiR7ZXZlbnQubmFtZX1cIjogZ290IGAgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICBsZXQgaW52b2tlcjtcbiAgY29uc3Qgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICBjb25zdCBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IHsgYXR0cnMsIHByb3BzIH0gPSBkYXRhO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBjb25zdCBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBgUHJvcCBcIiR7a2V5SW5Mb3dlckNhc2V9XCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpfSwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNgICtcbiAgICAgICAgICAgIGAgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBgICtcbiAgICAgICAgICAgIGBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIGAgK1xuICAgICAgICAgICAgYHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2FsdEtleX1cIiBpbnN0ZWFkIG9mIFwiJHtrZXl9XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgY29udGludWVcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsIGAke25lc3RlZEluZGV4IHx8ICcnfV8ke2l9YCk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IGBfX3ZsaXN0JHtuZXN0ZWRJbmRleH1fJHtpfV9fYDtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIGNvbnN0IHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgKCkgPT4ge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgYGluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgY29udGludWVcbiAgICAgIGNvbnN0IHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgbGV0IHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihgSW5qZWN0aW9uIFwiJHtrZXl9XCIgbm90IGZvdW5kYCwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICBjb25zdCBzbG90cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3QgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICBjb25zdCBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIGxldCByZXM7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIHNsb3RzLiRzdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleV0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6IHRydWUpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gKCkgPT4gc2xvdHNba2V5XVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICBsZXQgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGxldCBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIGNvbnN0IHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIGNvbnN0IG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBsZXQgaGFzaDtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtjYW1lbGl6ZWRLZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIGxldCB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX29uY2VfXyR7aW5kZXh9JHtrZXkgPyBgXyR7a2V5fWAgOiBgYH1gLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBgJHtrZXl9XyR7aX1gLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgY29uc3Qgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICBoYXNEeW5hbWljS2V5cyxcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIGhhc0R5bmFtaWNLZXlzLCByZXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6ICR7a2V5fWAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICBsZXQgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICBjb25zdCBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgY29uc3QgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiB7XG4gICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XG4gIH1cblxuICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICBjb25zdCB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIGNvbnN0IGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuY29uc3QgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICBjb25zdCBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydCAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveSAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybihgSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogJHtTdHJpbmcoQ3Rvcil9YCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGxldCBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIGNvbnN0IGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICBjb25zdCBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIGNvbnN0IG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIGB2dWUtY29tcG9uZW50LSR7Q3Rvci5jaWR9JHtuYW1lID8gYC0ke25hbWV9YCA6ICcnfWAsXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3IsIHByb3BzRGF0YSwgbGlzdGVuZXJzLCB0YWcsIGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIGNvbnN0IGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICBjb25zdCB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIGNvbnN0IG1lcmdlZCA9IChhLCBiKSA9PiB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICBjb25zdCBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICBjb25zdCBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBTSU1QTEVfTk9STUFMSVpFID0gMTtcbmNvbnN0IEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICBsZXQgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgYXBwbHlOUyh2bm9kZSwgbnMpO1xuICAgIGlmIChpc0RlZihkYXRhKSkgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIGNvbnN0IHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgY29uc3QgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgeyByZW5kZXIsIF9wYXJlbnRWbm9kZSB9ID0gdm0uJG9wdGlvbnM7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICBsZXQgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlcmApO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyRXJyb3JgKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGNvbnN0IG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIGxldCBzeW5jID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0gKHJlbmRlckNvbXBsZXRlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXNvbHZlID0gb25jZSgocmVzKSA9PiB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVqZWN0ID0gb25jZShyZWFzb24gPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJHtTdHJpbmcoZmFjdG9yeSl9YCArXG4gICAgICAgIChyZWFzb24gPyBgXFxuUmVhc29uOiAke3JlYXNvbn1gIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBgdGltZW91dCAoJHtyZXMudGltZW91dH1tcylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICBjb25zdCBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbmxldCB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgY29uc3QgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIGNvbnN0IGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgbGV0IGNiO1xuICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xuICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgY29uc3QgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIGxldCBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHByZXZFbCA9IHZtLiRlbDtcbiAgICBjb25zdCBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgY29uc3QgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgbGV0IGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgY29uc3QgaWQgPSB2bS5fdWlkO1xuICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHtpZH1gO1xuICAgICAgY29uc3QgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke2lkfWA7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcGF0Y2hgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzICYmICFwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIXZtLiRzY29wZWRTbG90cy4kc3RhYmxlKVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICBjb25zdCBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBjb25zdCBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIGNvbnN0IHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgY29uc3Qgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgY29uc3QgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuY29uc3QgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbmxldCBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbmlmIChpbkJyb3dzZXIgJiYgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcbiAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcbiAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXG4gIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgbGV0IHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IGBpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYFxuICAgICAgICAgICAgICA6IGBpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uYFxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgY29uc3QgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICBjb25zdCB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgbGV0IGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgY29uc3Qgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIGNvbnN0IGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxubGV0IHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXCIke2V4cE9yRm59XCIgYCArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICBwdXNoVGFyZ2V0KHRoaXMpO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGFkZERlcCAoZGVwKSB7XG4gICAgY29uc3QgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgY2xlYW51cERlcHMgKCkge1xuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0bXAgPSB0aGlzLmRlcElkcztcbiAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgdG1wID0gdGhpcy5kZXBzO1xuICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICB0aGlzLmRlZXBcbiAgICAgICkge1xuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIGBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgZXZhbHVhdGUgKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIGRlcGVuZCAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7XG4gIGlmIChvcHRzLm1ldGhvZHMpIGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpO1xuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTtcbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICBjb25zdCBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICBjb25zdCBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIGNvbnN0IGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFwiJHtoeXBoZW5hdGVkS2V5fVwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgYCArXG4gICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIGAgK1xuICAgICAgICAgICAgYHZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgbGV0IGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGNvbnN0IG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIGAgK1xuICAgICAgICBgVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLmAsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5jb25zdCBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBjb25zdCB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgY29uc3QgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgY29uc3QgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgY29uc3QgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIGNvbnN0IHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kc1trZXldfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gYCArXG4gICAgICAgICAgYEF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHdhdGNoKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgY29uc3QgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgY29uc3QgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oYCRwcm9wcyBpcyByZWFkb25seS5gLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCBgY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICBsZXQgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke3ZtLl9uYW1lfSBpbml0YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIGNvbnN0IHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICBjb25zdCBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG1vZGlmaWVkO1xuICBjb25zdCBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgbW9kaWZpZWQgPSB7fTtcbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICBsZXQgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICBjb25zdCBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICBjb25zdCBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgYF9wcm9wc2AsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgY29uc3QgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUgfSA9IGtlZXBBbGl2ZUluc3RhbmNlO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIGNvbnN0IGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxuY29uc3QgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+ICFtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgY29uc3Qgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSB9ID0gdGhpcztcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBjYWNoZSwga2V5cyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gYDo6JHtjb21wb25lbnRPcHRpb25zLnRhZ31gIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgY29uc3QgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gIHtcbiAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2FybixcbiAgICBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IChvYmopID0+IHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjYnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuY29uc3QgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG5jb25zdCBtdXN0VXNlUHJvcCA9ICh0YWcsIHR5cGUsIGF0dHIpID0+IHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG5jb25zdCBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbmNvbnN0IGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuY29uc3QgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxuY29uc3QgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbmNvbnN0IGlzWGxpbmsgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG5jb25zdCBnZXRYbGlua1Byb3AgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbmNvbnN0IGlzRmFsc3lBdHRyVmFsdWUgPSAodmFsKSA9PiB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgbGV0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IHN0cmluZ2lmaWVkO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxuY29uc3QgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5jb25zdCBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5jb25zdCBpc1ByZVRhZyA9ICh0YWcpID0+IHRhZyA9PT0gJ3ByZSc7XG5cbmNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSAodGFnKSA9PiB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG5jb25zdCB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuY29uc3QgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgY29uc3Qga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgcmV0dXJuXG5cbiAgY29uc3Qgdm0gPSB2bm9kZS5jb250ZXh0O1xuICBjb25zdCByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuY29uc3QgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgcmV0dXJuIHRydWVcbiAgbGV0IGk7XG4gIGNvbnN0IHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgY29uc3QgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgbGV0IGksIGtleTtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIGxldCBpLCBqO1xuICBjb25zdCBjYnMgPSB7fTtcblxuICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICBsZXQgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgY29uc3QgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgbGV0IGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIGxldCBpLCBqO1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY29uc3QgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGxldCBvbGRTdGFydElkeCA9IDA7XG4gICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICBjb25zdCBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICcke2tleX0nLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuYCxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIGNvbnN0IGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgdGFnLCBkYXRhLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBsZXQgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIGNvbnN0IHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICBjb25zdCBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIGNvbnN0IGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICBjb25zdCBkaXJzV2l0aEluc2VydCA9IFtdO1xuICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIGxldCBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICBjb25zdCBjYWxsSW5zZXJ0ID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICBsZXQgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCBgJHtkaXIubmFtZX0uJHtPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJyl9YFxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCBgZGlyZWN0aXZlICR7ZGlyLm5hbWV9ICR7aG9va30gaG9va2ApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1ciwgb2xkO1xuICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgbGV0IGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIGNvbnN0IGJsb2NrZXIgPSBlID0+IHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgbGV0IGluU2luZ2xlID0gZmFsc2U7XG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICBsZXQgaW5SZWdleCA9IGZhbHNlO1xuICBsZXQgY3VybHkgPSAwO1xuICBsZXQgc3F1YXJlID0gMDtcbiAgbGV0IHBhcmVuID0gMDtcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSBpblJlZ2V4ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gYF9mKFwiJHtuYW1lfVwiKSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWBcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKGBbVnVlIGNvbXBpbGVyXTogJHttc2d9YCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAobSA9PiBtW2tleV0pLmZpbHRlcihfID0+IF8pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYFxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gYCgke25hbWV9KT09PSdjbGljayc/J2NvbnRleHRtZW51JzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICBsZXQgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgY29uc3QgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICBjb25zdCBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIGxldCB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuXG4gIGNvbnN0IGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIGAodHlwZW9mICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0gPT09ICdzdHJpbmcnYCArXG4gICAgICBgPyAke2Jhc2VWYWx1ZUV4cHJlc3Npb259LnRyaW0oKWAgK1xuICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgX24oJHt2YWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiBgKCR7dmFsdWV9KWAsXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIGNvbnN0IHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt2YWx1ZX09JHthc3NpZ25tZW50fWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCRzZXQoJHtyZXMuZXhwfSwgJHtyZXMua2V5fSwgJHthc3NpZ25tZW50fSlgXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICBsZXQgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIGluQnJhY2tldCsrO1xuICAgIGlmIChjaHIgPT09IDB4NUQpIGluQnJhY2tldC0tO1xuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICBjb25zdCBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmxldCB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG5jb25zdCBSQU5HRV9UT0tFTiA9ICdfX3InO1xuY29uc3QgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICBjb25zdCB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgY29uc3QgdGFnID0gZWwudGFnO1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgYEZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgd2FybiQxKFxuICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgIGB2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIGAgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBjb25zdCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICBjb25zdCBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgYEFycmF5LmlzQXJyYXkoJHt2YWx1ZX0pYCArXG4gICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IGA6KCR7dmFsdWV9KWBcbiAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYFxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgYHZhciAkJGE9JHt2YWx1ZX0sYCArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIGAkJGM9JCRlbC5jaGVja2VkPygke3RydWVWYWx1ZUJpbmRpbmd9KTooJHtmYWxzZVZhbHVlQmluZGluZ30pO2AgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgYHZhciAkJHY9JHtudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZ30sYCArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIGBpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJyl9KX1gICtcbiAgICAgIGBlbHNleyQkaT4tMSYmKCR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpfSl9YCArXG4gICAgYH1lbHNleyR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKX19YCxcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gYF9uKCR7dmFsdWVCaW5kaW5nfSlgIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIGBfcSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pYCk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHNlbGVjdGVkVmFsID0gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgICtcbiAgICBgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlgICtcbiAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgIGByZXR1cm4gJHtudW1iZXIgPyAnX24odmFsKScgOiAndmFsJ319KWA7XG5cbiAgY29uc3QgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gIGNvZGUgPSBgJHtjb2RlfSAke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KX1gO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICBjb25zdCBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIGNvbnN0IGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGAkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuXG4gIGxldCBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBgaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuOyR7Y29kZX1gO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgYCgke3ZhbHVlfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG5sZXQgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbmNvbnN0IHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICBjb25zdCBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vICM5NDYyIGJhaWwgZm9yIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgZS50aW1lU3RhbXAgPT09IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlLCBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5sZXQgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQga2V5LCBjdXI7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICBsZXQgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSBjb250aW51ZVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAvLyB0aGUgb25seSBleGNlcHRpb24gaXMgYHZhbHVlYCB3aGVyZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgLy8gVGhpcyBhbHNvIGNvdmVycyAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmIGN1ciA9PT0gb2xkUHJvcHNba2V5XSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgY29uc3Qgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxzdmc+JHtjdXJ9PC9zdmc+YDtcbiAgICAgIGNvbnN0IHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgbGV0IG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgY29uc3QgdmFsdWUgPSBlbG0udmFsdWU7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBjb25zdCBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgY29uc3Qgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmNvbnN0IGNzc1ZhclJFID0gL14tLS87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuY29uc3Qgc2V0UHJvcCA9IChlbCwgbmFtZSwgdmFsKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG5sZXQgZW1wdHlTdHlsZTtcbmNvbnN0IG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGN1ciwgbmFtZTtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgY29uc3Qgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICBjb25zdCBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgY29uc3QgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgZW50ZXJUb0NsYXNzOiBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgbGVhdmVUb0NsYXNzOiBgJHtuYW1lfS1sZWF2ZS10b2AsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogYCR7bmFtZX0tbGVhdmUtYWN0aXZlYFxuICB9XG59KTtcblxuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmxldCB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbmxldCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xubGV0IGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5jb25zdCByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuID0+IGZuKCk7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKCgpID0+IHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkgcmV0dXJuIGNiKClcbiAgY29uc3QgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4ge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGVudGVyQ2xhc3MsXG4gICAgZW50ZXJUb0NsYXNzLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVFbnRlcixcbiAgICBlbnRlcixcbiAgICBhZnRlckVudGVyLFxuICAgIGVudGVyQ2FuY2VsbGVkLFxuICAgIGJlZm9yZUFwcGVhcixcbiAgICBhcHBlYXIsXG4gICAgYWZ0ZXJBcHBlYXIsXG4gICAgYXBwZWFyQ2FuY2VsbGVkLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICBsZXQgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICBsZXQgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICBjb25zdCB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIGNvbnN0IGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIGNvbnN0IGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgY29uc3QgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICBjb25zdCBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIGNvbnN0IGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGxlYXZlQ2xhc3MsXG4gICAgbGVhdmVUb0NsYXNzLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MsXG4gICAgYmVmb3JlTGVhdmUsXG4gICAgbGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZSxcbiAgICBsZWF2ZUNhbmNlbGxlZCxcbiAgICBkZWxheUxlYXZlLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIGNvbnN0IGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5jb25zdCBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbmNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHMsIG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICBjb25zdCBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIGNvbnN0IGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKChvLCBpKSA9PiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSkpKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIGNvbnN0IG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUodiA9PiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpKVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCIke2JpbmRpbmcuZXhwcmVzc2lvbn1cIj4gYCArXG4gICAgICBgZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbiAgICAgIH1gLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShvID0+ICFsb29zZUVxdWFsKG8sIHZhbHVlKSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHJldHVyblxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQgKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGUgKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3dcbn07XG5cbi8qICAqL1xuXG5jb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIGNvbnN0IGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIGNvbnN0IGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuY29uc3QgaXNOb3RUZXh0Tm9kZSA9IChjKSA9PiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7XG5cbmNvbnN0IGlzVlNob3dEaXJlY3RpdmUgPSBkID0+IGQubmFtZSA9PT0gJ3Nob3cnO1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXIgKGgpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIGNvbnN0IGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICBjb25zdCBpZCA9IGBfX3RyYW5zaXRpb24tJHt0aGlzLl91aWR9LWA7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgY29uc3QgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIGNvbnN0IG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4geyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wcyxcblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9ICh2bm9kZSwgaHlkcmF0aW5nKSA9PiB7XG4gICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgICB0aGlzLl92bm9kZSxcbiAgICAgICAgdGhpcy5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPCR7bmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBrZXB0ID0gW107XG4gICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYy5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgY29uc3QgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsbTtcbiAgICAgICAgY29uc3QgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgY29uc3QgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICBjb25zdCBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICBjb25zdCBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgY29uc3QgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIGBZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuYCArXG4gICAgICAgIGBNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuYCArXG4gICAgICAgIGBTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbGBcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmNvbnN0IGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuY29uc3QgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbmNvbnN0IGJ1aWxkUmVnZXggPSBjYWNoZWQoZGVsaW1pdGVycyA9PiB7XG4gIGNvbnN0IG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICBjb25zdCBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICBjb25zdCB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcmF3VG9rZW5zID0gW107XG4gIGxldCBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICBsZXQgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBjb25zdCBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaChgX3MoJHtleHB9KWApO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBjbGFzcz1cIiR7c3RhdGljQ2xhc3N9XCI6IGAgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgY29uc3QgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBgc3RhdGljQ2xhc3M6JHtlbC5zdGF0aWNDbGFzc30sYDtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgY2xhc3M6JHtlbC5jbGFzc0JpbmRpbmd9LGA7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBzdHlsZT1cIiR7c3RhdGljU3R5bGV9XCI6IGAgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBgc3RhdGljU3R5bGU6JHtlbC5zdGF0aWNTdHlsZX0sYDtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgc3R5bGU6KCR7ZWwuc3R5bGVCaW5kaW5nfSksYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmxldCBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5jb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbmNvbnN0IGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5jb25zdCBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBuY25hbWUgPSBgW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHt1bmljb2RlTGV0dGVyc31dKmA7XG5jb25zdCBxbmFtZUNhcHR1cmUgPSBgKCg/OiR7bmNuYW1lfVxcXFw6KT8ke25jbmFtZX0pYDtcbmNvbnN0IHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoYF48JHtxbmFtZUNhcHR1cmV9YCk7XG5jb25zdCBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5jb25zdCBlbmRUYWcgPSBuZXcgUmVnRXhwKGBePFxcXFwvJHtxbmFtZUNhcHR1cmV9W14+XSo+YCk7XG5jb25zdCBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG5jb25zdCBjb21tZW50ID0gL148IVxcLS0vO1xuY29uc3QgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuY29uc3QgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCByZUNhY2hlID0ge307XG5cbmNvbnN0IGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbmNvbnN0IGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xuY29uc3QgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxuY29uc3QgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSAodGFnLCBodG1sKSA9PiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICBjb25zdCByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIG1hdGNoID0+IGRlY29kaW5nTWFwW21hdGNoXSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIGNvbnN0IGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIGNvbnN0IGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIGxldCB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICBjb25zdCBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgY29uc3QgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0LCByZXN0LCBuZXh0O1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSBicmVha1xuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgY29uc3Qgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgY29uc3QgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oYE1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXCIke2h0bWx9XCJgLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICBjb25zdCBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICBsZXQgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIGNvbnN0IHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgY29uc3QgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSBpbmRleDtcbiAgICBpZiAoZW5kID09IG51bGwpIGVuZCA9IGluZGV4O1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKGkgPiBwb3MgfHwgIXRhZ05hbWUgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgb25SRSA9IC9eQHxedi1vbjovO1xuY29uc3QgZGlyUkUgPSAvXnYtfF5AfF46LztcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmNvbnN0IGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxuY29uc3Qgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbmNvbnN0IGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbmNvbnN0IHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxuY29uc3QgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxuY29uc3QgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbmxldCB3YXJuJDI7XG5sZXQgZGVsaW1pdGVycztcbmxldCB0cmFuc2Zvcm1zO1xubGV0IHByZVRyYW5zZm9ybXM7XG5sZXQgcG9zdFRyYW5zZm9ybXM7XG5sZXQgcGxhdGZvcm1Jc1ByZVRhZztcbmxldCBwbGF0Zm9ybU11c3RVc2VQcm9wO1xubGV0IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xubGV0IG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gKGVsKSA9PiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgY29uc3Qgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBjdXJyZW50UGFyZW50O1xuICBsZXQgaW5WUHJlID0gZmFsc2U7XG4gIGxldCBpblByZSA9IGZhbHNlO1xuICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgYCArXG4gICAgICAgICAgYHVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLmAsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGMgPT4gIShjKS5zbG90U2NvcGUpO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihgW2ApLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIGA8JHt0YWd9PmAgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQgKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgdGV4dCBcIiR7dGV4dH1cIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIGNvbnN0IGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLmAsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIGAgK1xuICAgICAgICAgICAgYHRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuYCxcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIGNvbnN0IHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICBsZXQgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246ICR7ZXhwfWAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBjb25zdCBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDIoXG4gICAgICBgdi0ke2VsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJ30gYCArXG4gICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgYHRleHQgXCIke2NoaWxkcmVuW2ldLnRleHQudHJpbSgpfVwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgYCArXG4gICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgY29uc3Qgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIGxldCBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgYHJlcGxhY2VkIGJ5IFwic2xvdC1zY29wZVwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcInNsb3Qtc2NvcGVcIiBhdHRyaWJ1dGUgYCArXG4gICAgICAgIGBjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gYCArXG4gICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgYCh2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBgICtcbiAgICAgICAgYHNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgY29uc3Qgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICBgdGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50YCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZHluYW1pYyB9ID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIGNvbnN0IHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5gLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIGAgK1xuICAgICAgICAgICAgICBgPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGNvbnN0IHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgbGV0IG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBcXGBrZXlcXGAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBgICtcbiAgICAgICAgYGFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIGAgK1xuICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCxcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgbGV0IGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGxldCBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXCJ2LWJpbmQ6JHtuYW1lfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBgJGV2ZW50YCk7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtjYW1lbGl6ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6XCIrKCR7bmFtZX0pYCxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgY29uc3QgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICBsZXQgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2gobSA9PiB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbmNvbnN0IGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG5jb25zdCBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIGxldCBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgYFlvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBgICtcbiAgICAgICAgYFRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIGAgK1xuICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgIGBDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgY29uc3QgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGAoJHttYXBbJ3YtYmluZCddfSkudHlwZWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyBgJiYoJHtpZkNvbmRpdGlvbn0pYCA6IGBgO1xuICAgICAgY29uc3QgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgY29uc3QgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIGNvbnN0IGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IGAoJHt0eXBlQmluZGluZ30pPT09J2NoZWNrYm94J2AgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgY29uc3QgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYCgke3R5cGVCaW5kaW5nfSk9PT0ncmFkaW8nYCArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsLFxuICB0ZXh0LFxuICBodG1sXG59O1xuXG4vKiAgKi9cblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxubGV0IGlzU3RhdGljS2V5O1xubGV0IGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHJldHVyblxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG5jb25zdCBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG5jb25zdCBnZW5HdWFyZCA9IGNvbmRpdGlvbiA9PiBgaWYoJHtjb25kaXRpb259KXJldHVybiBudWxsO2A7XG5cbmNvbnN0IG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoYCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0YCksXG4gIGN0cmw6IGdlbkd1YXJkKGAhJGV2ZW50LmN0cmxLZXlgKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gIGFsdDogZ2VuR3VhcmQoYCEkZXZlbnQuYWx0S2V5YCksXG4gIG1ldGE6IGdlbkd1YXJkKGAhJGV2ZW50Lm1ldGFLZXlgKSxcbiAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gIG1pZGRsZTogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxYCksXG4gIHJpZ2h0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJgKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICBsZXQgc3RhdGljSGFuZGxlcnMgPSBgYDtcbiAgbGV0IGR5bmFtaWNIYW5kbGVycyA9IGBgO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgY29uc3QgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IGBcIiR7bmFtZX1cIjoke2hhbmRsZXJDb2RlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGBbJHtoYW5kbGVyLm1hcChoYW5kbGVyID0+IGdlbkhhbmRsZXIoaGFuZGxlcikpLmpvaW4oJywnKX1dYFxuICB9XG5cbiAgY29uc3QgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICBjb25zdCBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtcbiAgICAgIGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9YCA6IGhhbmRsZXIudmFsdWVcbiAgICB9fWAgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIGxldCBjb2RlID0gJyc7XG4gICAgbGV0IGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAubWFwKGtleU1vZGlmaWVyID0+IGAkZXZlbnQuJHtrZXlNb2RpZmllcn1LZXlgKVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX0oJGV2ZW50KWBcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KSgkZXZlbnQpYFxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske2NvZGV9JHtoYW5kbGVyQ29kZX19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBgaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZgICtcbiAgICBgJHtrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpfSlyZXR1cm4gbnVsbDtgXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIGNvbnN0IGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIGAkZXZlbnQua2V5Q29kZSE9PSR7a2V5VmFsfWBcbiAgfVxuICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgY29uc3Qga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgYF9rKCRldmVudC5rZXlDb2RlLGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleSl9LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICBgJGV2ZW50LmtleSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXlOYW1lKX1gICtcbiAgICBgKWBcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IChjb2RlKSA9PiBgX2coJHtjb2RlfSwke2Rpci52YWx1ZX0pYDtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IChjb2RlKSA9PiB7XG4gICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke1xuICAgICAgZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgfSR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJ1xuICAgIH0pYFxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxuY2xhc3MgQ29kZWdlblN0YXRlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICBjb25zdCBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIHRoaXMubWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG4gICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gICAgdGhpcy5wcmUgPSBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIGNvbnN0IGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IGB3aXRoKHRoaXMpe3JldHVybiAke2NvZGV9fWAsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIGxldCBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IGBfYygnJHtlbC50YWd9JyR7XG4gICAgICAgIGRhdGEgPyBgLCR7ZGF0YX1gIDogJycgLy8gZGF0YVxuICAgICAgfSR7XG4gICAgICAgIGNoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgfSlgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goYHdpdGgodGhpcyl7cmV0dXJuICR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfX1gKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIGBfbSgke1xuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxXG4gIH0ke1xuICAgIGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnXG4gIH0pYFxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICBsZXQga2V5ID0gJyc7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgIGB2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIGNvbnN0IGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5leHB9KT8ke1xuICAgICAgZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spXG4gICAgfToke1xuICAgICAgZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICAgIH1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2dlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKX1gXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgY29uc3QgYWxpYXMgPSBlbC5hbGlhcztcbiAgY29uc3QgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gYCwke2VsLml0ZXJhdG9yMX1gIDogJyc7XG4gIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuXG4gIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIGA8JHtlbC50YWd9IHYtZm9yPVwiJHthbGlhc30gaW4gJHtleHB9XCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBgICtcbiAgICAgIGB2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBgICtcbiAgICAgIGBTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gYCR7YWx0SGVscGVyIHx8ICdfbCd9KCgke2V4cH0pLGAgK1xuICAgIGBmdW5jdGlvbigke2FsaWFzfSR7aXRlcmF0b3IxfSR7aXRlcmF0b3IyfSl7YCArXG4gICAgICBgcmV0dXJuICR7KGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfWAgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgbGV0IGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgY29uc3QgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIGRhdGEgKz0gZGlycyArICcsJztcblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gYGtleToke2VsLmtleX0sYDtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gYHJlZjoke2VsLnJlZn0sYDtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IGByZWZJbkZvcjp0cnVlLGA7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IGBwcmU6dHJ1ZSxgO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IGBhdHRyczoke2dlblByb3BzKGVsLmF0dHJzKX0sYDtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSl9LGA7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKX0sYDtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IGBtb2RlbDp7dmFsdWU6JHtcbiAgICAgIGVsLm1vZGVsLnZhbHVlXG4gICAgfSxjYWxsYmFjazoke1xuICAgICAgZWwubW9kZWwuY2FsbGJhY2tcbiAgICB9LGV4cHJlc3Npb246JHtcbiAgICAgIGVsLm1vZGVsLmV4cHJlc3Npb25cbiAgICB9fSxgO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGAke2lubGluZVRlbXBsYXRlfSxgO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgcmV0dXJuXG4gIGxldCByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgbGV0IGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIGNvbnN0IGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IGB7bmFtZTpcIiR7ZGlyLm5hbWV9XCIscmF3TmFtZTpcIiR7ZGlyLnJhd05hbWV9XCIke1xuICAgICAgICBkaXIudmFsdWUgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5hcmcgPyBgLGFyZzoke2Rpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogYFwiJHtkaXIuYXJnfVwiYH1gIDogJydcbiAgICAgIH0ke1xuICAgICAgICBkaXIubW9kaWZpZXJzID8gYCxtb2RpZmllcnM6JHtKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKX1gIDogJydcbiAgICAgIH19LGA7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIGBpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7JHtcbiAgICAgIGlubGluZVJlbmRlckZucy5yZW5kZXJcbiAgICB9fSxzdGF0aWNSZW5kZXJGbnM6WyR7XG4gICAgICBpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IGBmdW5jdGlvbigpeyR7Y29kZX19YCkuam9pbignLCcpXG4gICAgfV19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgbGV0IG5lZWRzRm9yY2VVcGRhdGUgPSBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgIGNvbnN0IHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90ICh0aGUgcmVhY3Rpdml0eSBpcyBkaXNjb25uZWN0ZWQpXG4gIC8vICM5NDM4XG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBzY29wZWRTbG90czpfdShbJHtcbiAgICBPYmplY3Qua2V5cyhzbG90cykubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJylcbiAgfV0ke25lZWRzRm9yY2VVcGRhdGUgPyBgLHRydWVgIDogYGB9KWBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgY29uc3Qgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBgYFxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgYHJldHVybiAke2VsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfX1gO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgcmV0dXJuIGB7a2V5OiR7ZWwuc2xvdFRhcmdldCB8fCBgXCJkZWZhdWx0XCJgfSxmbjoke2ZufSR7cmV2ZXJzZVByb3h5fX1gXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbC5mb3IgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpID8gYCwxYCA6IGAsMGBcbiAgICAgICAgOiBgYDtcbiAgICAgIHJldHVybiBgJHsoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfSR7bm9ybWFsaXphdGlvblR5cGV9YFxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiBgWyR7Y2hpbGRyZW4ubWFwKGMgPT4gZ2VuKGMsIHN0YXRlKSkuam9pbignLCcpfV0ke1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPyBgLCR7bm9ybWFsaXphdGlvblR5cGV9YCA6ICcnXG4gICAgfWBcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoYyA9PiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gYF92KCR7dGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIGNvbnN0IGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgbGV0IHJlcyA9IGBfdCgke3Nsb3ROYW1lfSR7Y2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnfWA7XG4gIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChhdHRyID0+ICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KSkpXG4gICAgOiBudWxsO1xuICBjb25zdCBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBgLG51bGxgO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBgLCR7YXR0cnN9YDtcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kJCQxfWA7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEkMihlbCwgc3RhdGUpfSR7XG4gICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gIGxldCBkeW5hbWljUHJvcHMgPSBgYDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gYCR7cHJvcC5uYW1lfSwke3ZhbHVlfSxgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBgXCIke3Byb3AubmFtZX1cIjoke3ZhbHVlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IGB7JHtzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gYF9kKCR7c3RhdGljUHJvcHN9LFske2R5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCBgdi1mb3I9XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNvbnN0IHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIGNvbnN0IGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiIGluIGV4cHJlc3Npb24gJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBpbnZhbGlkICR7dHlwZX0gXCIke2lkZW50fVwiIGluIGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oYHJldHVybiAke2V4cH1gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBpbnZhbGlkIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICBgICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1cXG5gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0ID0gMCxcbiAgZW5kID0gc291cmNlLmxlbmd0aFxuKSB7XG4gIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZVxuICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGAgYCwgcGFkKSArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgbikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gICAgbiA+Pj49IDE7XG4gICAgaWYgKG4gPD0gMCkgYnJlYWtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVyciwgY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIGNvbnN0IGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke3RlbXBsYXRlfVxcblxcbmAgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChlID0+IGAtICR7ZX1gKS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2gobXNnID0+IHRpcChtc2csIHZtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYCkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdGlwcyA9IFtdO1xuXG4gICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgY29uc3QgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5sZXQgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBgPGEgaHJlZj1cIlxcblwiLz5gIDogYDxkaXYgYT1cIlxcblwiLz5gO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gIGNvbnN0IGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2FybihcbiAgICAgIGBEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoYHZ1ZSAke3RoaXMuX25hbWV9IGNvbXBpbGVgLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHNlbGVjdCBjbGFzcz0nc2VsZWN0JyB2LW1vZGVsPSdzZWxlY3RlZCcgQGlucHV0PSdldmVudCA9PiB7ICRlbWl0KFwiaW5wdXRcIiwgZXZlbnQudGFyZ2V0LnZhbHVlKSB9Jz5cbiAgICAgIDxvcHRpb24gdi1mb3I9J29wdGlvbiBpbiBvcHRpb25zJyA6a2V5PSdvcHRpb24udmFsdWUnIDp2YWx1ZT0nb3B0aW9uLnZhbHVlJz5cbiAgICAgICAge3sgb3B0aW9uLnRleHQgfX1cbiAgICAgIDwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnb3B0aW9ucycsICd2YWx1ZSddLFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZDogbnVsbCxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTZWxlY3REYXRhID0gW1xuICB7IHRleHQ6ICdBbGwgQm9yb3VnaHMnLCB2YWx1ZTogJ2FsbCcgfSxcbiAgeyB0ZXh0OiAnQnJvb2tseW4nLCB2YWx1ZTogJ2Jyb29rbHluJyB9LFxuICB7IHRleHQ6ICdRdWVlbnMnLCB2YWx1ZTogJ3F1ZWVucycgfSxcbiAgeyB0ZXh0OiAnTWFuaGF0dGFuJywgdmFsdWU6ICdtYW5oYXR0YW4nIH0sXG4gIHsgdGV4dDogJ1N0YXRlbiBJc2xhbmQnLCB2YWx1ZTogJ3N0YXRlbiBpc2xhbmQnIH0sXG4gIHsgdGV4dDogJ1RoZSBCcm9ueCcsIHZhbHVlOiAnYnJvbngnIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7IC8vXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4vc2VsZWN0LnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBTZWxlY3REYXRhIGZyb20gJy4vc2VsZWN0LmRhdGEuanMnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY2xhc3MgU2VsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLXNlbGVjdCcsIFNlbGVjdENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJhcHBcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IFNlbGVjdC5kYXRhLFxuICAgICAgICAgIHNlbGVjdGVkOiAnYWxsJyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5TZWxlY3QuZGF0YSA9IFNlbGVjdERhdGE7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDsiLCJmdW5jdGlvbiBkYXRhSGFuZGxlcihuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGlmIChvbGREYXRhKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy4kZGF0YS5fY2hhcnQ7XG4gICAgdmFyIG5ld0RhdGFzZXRMYWJlbHMgPSBuZXdEYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZERhdGFzZXRMYWJlbHMgPSBvbGREYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZExhYmVscyA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGFzZXRMYWJlbHMpO1xuICAgIHZhciBuZXdMYWJlbHMgPSBKU09OLnN0cmluZ2lmeShuZXdEYXRhc2V0TGFiZWxzKTtcblxuICAgIGlmIChuZXdMYWJlbHMgPT09IG9sZExhYmVscyAmJiBvbGREYXRhLmRhdGFzZXRzLmxlbmd0aCA9PT0gbmV3RGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIG5ld0RhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCwgaSkge1xuICAgICAgICB2YXIgb2xkRGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhLmRhdGFzZXRzW2ldKTtcbiAgICAgICAgdmFyIG5ld0RhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoZGF0YXNldCk7XG4gICAgICAgIHZhciBkZWxldGlvbktleXMgPSBvbGREYXRhc2V0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgIT09ICdfbWV0YScgJiYgbmV3RGF0YXNldEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChkZWxldGlvbktleSkge1xuICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2RlbGV0aW9uS2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGRhdGFzZXQpIHtcbiAgICAgICAgICBpZiAoZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2F0dHJpYnV0ZV0gPSBkYXRhc2V0W2F0dHJpYnV0ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ2xhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEubGFiZWxzID0gbmV3RGF0YS5sYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2xhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3hMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnhMYWJlbHMgPSBuZXdEYXRhLnhMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3hsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCd5TGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS55TGFiZWxzID0gbmV3RGF0YS55TGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCd5bGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnVwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhcnQpIHtcbiAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFydDpkZXN0cm95Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDpyZW5kZXInKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICB9XG59XG5cbmV4cG9ydCB2YXIgcmVhY3RpdmVEYXRhID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydERhdGE6IG51bGxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IHZhciByZWFjdGl2ZVByb3AgPSB7XG4gIHByb3BzOiB7XG4gICAgY2hhcnREYXRhOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hhcnREYXRhJzogZGF0YUhhbmRsZXJcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVhY3RpdmVEYXRhOiByZWFjdGl2ZURhdGEsXG4gIHJlYWN0aXZlUHJvcDogcmVhY3RpdmVQcm9wXG59OyIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohXG4gKiBDaGFydC5qcyB2Mi44LjBcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAxOSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KGdsb2JhbC5tb21lbnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5tb21lbnQgPSBtb21lbnQgJiYgbW9tZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBtb21lbnRbJ2RlZmF1bHQnXSA6IG1vbWVudDtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxudmFyIGNvbnZlcnNpb25zID0ge1xuICByZ2IyaHNsOiByZ2IyaHNsLFxuICByZ2IyaHN2OiByZ2IyaHN2LFxuICByZ2IyaHdiOiByZ2IyaHdiLFxuICByZ2IyY215azogcmdiMmNteWssXG4gIHJnYjJrZXl3b3JkOiByZ2Iya2V5d29yZCxcbiAgcmdiMnh5ejogcmdiMnh5eixcbiAgcmdiMmxhYjogcmdiMmxhYixcbiAgcmdiMmxjaDogcmdiMmxjaCxcblxuICBoc2wycmdiOiBoc2wycmdiLFxuICBoc2wyaHN2OiBoc2wyaHN2LFxuICBoc2wyaHdiOiBoc2wyaHdiLFxuICBoc2wyY215azogaHNsMmNteWssXG4gIGhzbDJrZXl3b3JkOiBoc2wya2V5d29yZCxcblxuICBoc3YycmdiOiBoc3YycmdiLFxuICBoc3YyaHNsOiBoc3YyaHNsLFxuICBoc3YyaHdiOiBoc3YyaHdiLFxuICBoc3YyY215azogaHN2MmNteWssXG4gIGhzdjJrZXl3b3JkOiBoc3Yya2V5d29yZCxcblxuICBod2IycmdiOiBod2IycmdiLFxuICBod2IyaHNsOiBod2IyaHNsLFxuICBod2IyaHN2OiBod2IyaHN2LFxuICBod2IyY215azogaHdiMmNteWssXG4gIGh3YjJrZXl3b3JkOiBod2Iya2V5d29yZCxcblxuICBjbXlrMnJnYjogY215azJyZ2IsXG4gIGNteWsyaHNsOiBjbXlrMmhzbCxcbiAgY215azJoc3Y6IGNteWsyaHN2LFxuICBjbXlrMmh3YjogY215azJod2IsXG4gIGNteWsya2V5d29yZDogY215azJrZXl3b3JkLFxuXG4gIGtleXdvcmQycmdiOiBrZXl3b3JkMnJnYixcbiAga2V5d29yZDJoc2w6IGtleXdvcmQyaHNsLFxuICBrZXl3b3JkMmhzdjoga2V5d29yZDJoc3YsXG4gIGtleXdvcmQyaHdiOiBrZXl3b3JkMmh3YixcbiAga2V5d29yZDJjbXlrOiBrZXl3b3JkMmNteWssXG4gIGtleXdvcmQybGFiOiBrZXl3b3JkMmxhYixcbiAga2V5d29yZDJ4eXo6IGtleXdvcmQyeHl6LFxuXG4gIHh5ejJyZ2I6IHh5ejJyZ2IsXG4gIHh5ejJsYWI6IHh5ejJsYWIsXG4gIHh5ejJsY2g6IHh5ejJsY2gsXG5cbiAgbGFiMnh5ejogbGFiMnh5eixcbiAgbGFiMnJnYjogbGFiMnJnYixcbiAgbGFiMmxjaDogbGFiMmxjaCxcblxuICBsY2gybGFiOiBsY2gybGFiLFxuICBsY2gyeHl6OiBsY2gyeHl6LFxuICBsY2gycmdiOiBsY2gycmdiXG59O1xuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufTtcblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9O1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG52YXIgY29sb3JTdHJpbmcgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59O1xuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszLDR9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KFthLWZBLUYwLTldezJ9KT8pJC9pLFxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIGtleXdvcmQgPSAvKFxcdyspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSxcbiAgICAgICBoZXhBbHBoYSA9IFwiXCI7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFsyXTtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiYSwgYSkge1xuICAgdmFyIGEgPSAoYSAhPT0gdW5kZWZpbmVkICYmIHJnYmEubGVuZ3RoID09PSAzKSA/IGEgOiByZ2JhWzNdO1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pIFxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzJdKVxuICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgKGEgPj0gMCAmJiBhIDwgMSlcbiAgICAgICAgICAgICAgICAgPyBoZXhEb3VibGUoTWF0aC5yb3VuZChhICogMjU1KSlcbiAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVbbmFtZV1dID0gbmFtZTtcbn1cblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gY29sb3JTdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb2xvckNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxudmFyIGNoYXJ0anNDb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG52YXIgaGVscGVycyA9IHtcblx0LyoqXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG5cdCAqL1xuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0dWlkOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaWQrKztcblx0XHR9O1xuXHR9KCkpLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzTnVsbE9yVW5kZWY6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNGaW5pdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IGhlbHBlcnMuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XG5cblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRtZXJnZSA9IG9wdGlvbnMubWVyZ2VyIHx8IGhlbHBlcnMuX21lcmdlcjtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIG9iamVjdHMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBzZXRGbiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMSwgaWxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGhlbHBlcnMuZWFjaChhcmd1bWVudHNbaV0sIHNldEZuKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogQmFzaWMgamF2YXNjcmlwdCBpbmhlcml0YW5jZSBiYXNlZCBvbiB0aGUgbW9kZWwgY3JlYXRlZCBpbiBCYWNrYm9uZS5qc1xuXHQgKi9cblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBDaGFydEVsZW1lbnQgPSAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSA/IGV4dGVuc2lvbnMuY29uc3RydWN0b3IgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gQ2hhcnRFbGVtZW50O1xuXHRcdH07XG5cblx0XHRTdXJyb2dhdGUucHJvdG90eXBlID0gbWUucHJvdG90eXBlO1xuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG5cblx0XHRpZiAoZXh0ZW5zaW9ucykge1xuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XG5cdFx0fVxuXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuaW5kZXhPZlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSwgZnJvbUluZGV4KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xudmFyIGVmZmVjdHMgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0O1xuXHR9LFxuXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLU1hdGguY29zKHQgKiAoTWF0aC5QSSAvIDIpKSArIDE7XG5cdH0sXG5cblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0fSxcblxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdH0sXG5cblx0ZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjQ1O1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRpZiAodCA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHR9LFxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuXHR9LFxuXG5cdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0fSxcblxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XG5cdFx0fVxuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzU7XG5cdH0sXG5cblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAwLjUpIHtcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0fVxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xuXHRlZmZlY3RzOiBlZmZlY3RzXG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHMgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5lYXNpbmdFZmZlY3RzID0gZWZmZWN0cztcblxudmFyIFBJID0gTWF0aC5QSTtcbnZhciBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xudmFyIERPVUJMRV9QSSA9IFBJICogMjtcbnZhciBIQUxGX1BJID0gUEkgLyAyO1xudmFyIFFVQVJURVJfUEkgPSBQSSAvIDQ7XG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xuICovXG52YXIgZXhwb3J0cyQxID0ge1xuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXG5cdCAqIGdpdmVuIHNpemUgKHdpZHRoLCBoZWlnaHQpIGFuZCB0aGUgc2FtZSBgcmFkaXVzYCBmb3IgYWxsIGNvcm5lcnMuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJvdW5kZWQgYW1vdW50IChpbiBwaXhlbHMpIGZvciB0aGUgZm91ciBjb3JuZXJzLlxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XG5cdCAqL1xuXHRyb3VuZGVkUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcblx0XHRcdHZhciBsZWZ0ID0geCArIHI7XG5cdFx0XHR2YXIgdG9wID0geSArIHI7XG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xuXHRcdFx0dmFyIGJvdHRvbSA9IHkgKyBoZWlnaHQgLSByO1xuXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XG5cdFx0XHRpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAtSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgUEkpO1xuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhsZWZ0LCB5KTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xuXHRcdFx0fSBlbHNlIGlmICh0b3AgPCBib3R0b20pIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCBQSSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKSB7XG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcblx0XHR2YXIgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShzdHlsZSwgeCAtIHN0eWxlLndpZHRoIC8gMiwgeSAtIHN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRzd2l0Y2ggKHN0eWxlKSB7XG5cdFx0Ly8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIERPVUJMRV9QSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0cmlhbmdsZSc6XG5cdFx0XHRjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxuXHRcdFx0Ly8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG5cdFx0XHQvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuXHRcdFx0Ly8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcblx0XHRcdC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcblx0XHRcdGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcblx0XHRcdGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdGlmICghcm90YXRpb24pIHtcblx0XHRcdFx0c2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ3JlY3RSb3QnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Nyb3NzUm90Jzpcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ2Nyb3NzJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJlYSAtIFRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXG5cdFx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBlcHNpbG9uICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIGVwc2lsb247XG5cdH0sXG5cblx0Y2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCwgYXJlYSkge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuXHRcdGN0eC5jbGlwKCk7XG5cdH0sXG5cblx0dW5jbGlwQXJlYTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuXHRcdHZhciBzdGVwcGVkID0gdGFyZ2V0LnN0ZXBwZWRMaW5lO1xuXHRcdGlmIChzdGVwcGVkKSB7XG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcblx0XHRcdFx0dmFyIG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyB0YXJnZXQueSA6IHByZXZpb3VzLnkpO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSBpZiAoKHN0ZXBwZWQgPT09ICdhZnRlcicgJiYgIWZsaXApIHx8IChzdGVwcGVkICE9PSAnYWZ0ZXInICYmIGZsaXApKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXQudGVuc2lvbikge1xuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWCA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRYLFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWSA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRZLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRZIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWSxcblx0XHRcdHRhcmdldC54LFxuXHRcdFx0dGFyZ2V0LnkpO1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jYW52YXMgPSBleHBvcnRzJDE7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jbGVhclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5kcmF3Um91bmRlZFJlY3RhbmdsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0ZXhwb3J0cyQxLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMkMSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0OiBmdW5jdGlvbihzY29wZSwgdmFsdWVzKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnNfY29yZS5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XG5cdH1cbn07XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZGVmYXVsdENvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRkZWZhdWx0Rm9udFNpemU6IDEyLFxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcblx0c2hvd0xpbmVzOiB0cnVlXG59KTtcblxudmFyIGNvcmVfZGVmYXVsdHMgPSBkZWZhdWx0cztcblxudmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVyc19jb3JlLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG5cdGlmICghZm9udCB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdCwgciwgYiwgbDtcblxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogdCxcblx0XHRcdHJpZ2h0OiByLFxuXHRcdFx0Ym90dG9tOiBiLFxuXHRcdFx0bGVmdDogbCxcblx0XHRcdGhlaWdodDogdCArIGIsXG5cdFx0XHR3aWR0aDogbCArIHJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gVGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAdG9kbyBTdXBwb3J0IGZvbnQuKiBvcHRpb25zIGFuZCByZW5hbWVkIHRvIHRvRm9udCgpLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BhcnNlRm9udDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udCA9IHtcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRsaW5lSGVpZ2h0OiBoZWxwZXJzX2NvcmUub3B0aW9ucy50b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0TGluZUhlaWdodCksIHNpemUpLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHR3ZWlnaHQ6IG51bGwsXG5cdFx0XHRzdHJpbmc6ICcnXG5cdFx0fTtcblxuXHRcdGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuXHRcdHJldHVybiBmb250O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcblx0ICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCkge1xuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzJDEgPSBoZWxwZXJzX2NvcmU7XG52YXIgZWFzaW5nID0gaGVscGVyc19lYXNpbmc7XG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XG52YXIgb3B0aW9ucyA9IGhlbHBlcnNfb3B0aW9ucztcbmhlbHBlcnMkMS5lYXNpbmcgPSBlYXNpbmc7XG5oZWxwZXJzJDEuY2FudmFzID0gY2FudmFzO1xuaGVscGVycyQxLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2RlbCk7XG5cdHZhciBpLCBpbGVuLCBrZXksIGFjdHVhbCwgb3JpZ2luLCB0YXJnZXQsIHR5cGUsIGMwLCBjMTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRrZXkgPSBrZXlzW2ldO1xuXG5cdFx0dGFyZ2V0ID0gbW9kZWxba2V5XTtcblxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xuXHRcdC8vIGRvZXNuJ3QgY29udGFpbiBpdCwgc28gbGV0J3MgaW5pdGlhbGl6ZSB0aGUgdmlldyB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuXHRcdGlmICghdmlldy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xuXG5cdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHN0YXJ0W2tleV0gPSBhY3R1YWw7XG5cdFx0fVxuXG5cdFx0b3JpZ2luID0gc3RhcnRba2V5XTtcblxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xuXG5cdFx0aWYgKHR5cGUgPT09IHR5cGVvZiBvcmlnaW4pIHtcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjMCA9IGNoYXJ0anNDb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdGlmIChjMS52YWxpZCkge1xuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0fVxufVxuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0fSxcblxuXHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5jbG9uZShtZS5fbW9kZWwpO1xuXHRcdH1cblx0XHRtZS5fc3RhcnQgPSB7fTtcblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xuXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcblx0XHRcdG1lLl92aWV3ID0gbW9kZWw7XG5cdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH1cblxuXHRcdGlmICghdmlldykge1xuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0c3RhcnQgPSBtZS5fc3RhcnQgPSB7fTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0fTtcblx0fSxcblxuXHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XG5cdH1cbn0pO1xuXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZWxlbWVudCA9IEVsZW1lbnQ7XG5cbnZhciBleHBvcnRzJDIgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxuXHRjdXJyZW50U3RlcDogMCwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXBcblx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cblx0cmVuZGVyOiBudWxsLCAvLyByZW5kZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgYW5pbWF0aW9uIHNlcnZpY2VcblxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzXG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9uID0gZXhwb3J0cyQyO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnYW5pbWF0aW9uT2JqZWN0Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jY2hhcnRJbnN0YW5jZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQyLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQ7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNoYXJ0ID0gdmFsdWU7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0Jyxcblx0XHRvblByb2dyZXNzOiBoZWxwZXJzJDEubm9vcCxcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzJDEubm9vcFxuXHR9XG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcblx0YW5pbWF0aW9uczogW10sXG5cdHJlcXVlc3Q6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcblx0ICovXG5cdGFkZEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0aWYgKCFsYXp5KSB7XG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuXHRcdC8vIElmIHRoZXJlIGFyZSBubyBhbmltYXRpb25zIHF1ZXVlZCwgbWFudWFsbHkga2lja3N0YXJ0IGEgZGlnZXN0LCBmb3IgbGFjayBvZiBhIGJldHRlciB3b3JkXG5cdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGluZGV4ID0gaGVscGVycyQxLmZpbmRJbmRleCh0aGlzLmFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcHJvY2Vzc2luZyBtb3VzZSBldmVudHMsIGUuZy4gJ21vdXNlbW92ZSdcblx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRtZS5zdGFydERpZ2VzdCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhcnREaWdlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRtZS5hZHZhbmNlKCk7XG5cblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cblx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uLCBjaGFydCwgbnVtU3RlcHMsIG5leHRTdGVwO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdC8vIDEgYW5pbWF0aW9uIHBlciBjaGFydCwgc28gd2UgYXJlIGxvb3BpbmcgY2hhcnRzIGhlcmVcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb25zW2ldO1xuXHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY3VycmVudFN0ZXAgc3RhcnRzIGF0IDFcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XG5cdFx0XHRuZXh0U3RlcCA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBhbmltYXRpb24uc3RhcnRUaW1lKSAvIGFuaW1hdGlvbi5kdXJhdGlvbiAqIG51bVN0ZXBzKSArIDE7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihuZXh0U3RlcCwgbnVtU3RlcHMpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdGlmIChhbmltYXRpb24uY3VycmVudFN0ZXAgPj0gbnVtU3RlcHMpIHtcblx0XHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0YW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgcmVzb2x2ZSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiB7XG5cdFx0XHRsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cblx0XHR9XG5cdH0pO1xuXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIG1ldGhvZCA9ICdvbkRhdGEnICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9iamVjdFttZXRob2RdLmFwcGx5KG9iamVjdCwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRpZiAoIXN0dWIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG5cdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRkZWxldGUgYXJyYXlba2V5XTtcblx0fSk7XG5cblx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdHRoaXMuaW5pdGlhbGl6ZShjaGFydCwgZGF0YXNldEluZGV4KTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZSkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhc2V0RWxlbWVudFR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnQpLlxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHQgKi9cblx0ZGF0YUVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdG1lLmFkZEVsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdH0sXG5cblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLmlkO1xuXHRcdH1cblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIG1lLmNoYXJ0LnNjYWxlcykpIHtcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcblx0fSxcblxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcblx0fSxcblxuXHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldFZhbHVlU2NhbGVJZCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkge1xuXHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0YWRkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YSB8fCBbXTtcblx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0fVxuXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XG5cdH0sXG5cblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVNZXRhRGF0YShpbmRleCk7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHQvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbiB0aHVzIHNpbXVsYXRlXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG5cdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRpZiAobWUuX2RhdGEgIT09IGRhdGEpIHtcblx0XHRcdGlmIChtZS5fZGF0YSkge1xuXHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKG1lLl9kYXRhLCBtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xuXHRcdFx0fVxuXHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRtZS5yZXN5bmNFbGVtZW50cygpO1xuXHR9LFxuXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0bWV0YS5kYXRhc2V0LnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdH1cblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRoZWxwZXJzJDEubWVyZ2UoZWxlbWVudC5fbW9kZWwsIGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgfHwge30pO1xuXHRcdGRlbGV0ZSBlbGVtZW50LiRwcmV2aW91c1N0eWxlO1xuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJDb2xvciwgZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJvcmRlckNvbG9yKV0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGgsIGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgbW9kZWwuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0dmFyIG51bU1ldGEgPSBtZXRhLmRhdGEubGVuZ3RoO1xuXHRcdHZhciBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG5cblx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcblx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHR0aGlzLmFkZEVsZW1lbnRBbmRSZXNldChzdGFydCArIGkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyh0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdH1cbn0pO1xuXG5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQgPSBoZWxwZXJzJDEuaW5oZXJpdHM7XG5cbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGFyYzoge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXJcdGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xuXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gdm0uZW5kQW5nbGU7XG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXG5cdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRyZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXG5cdFx0XHR5OiB2bS55ICsgKE1hdGguc2luKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSlcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgc0EgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdHZhciBlQSA9IHZtLmVuZEFuZ2xlO1xuXHRcdHZhciBwaXhlbE1hcmdpbiA9ICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcblx0XHR2YXIgYW5nbGVNYXJnaW47XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksIHNBLCBlQSk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGlmICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykge1xuXHRcdFx0XHQvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG5cdFx0XHRcdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIHZtLm91dGVyUmFkaXVzO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSAtIGFuZ2xlTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luKTtcblx0XHRcdFx0aWYgKHZtLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcblx0XHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0uaW5uZXJSYWRpdXM7XG5cdFx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luLCBzQSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHBpeGVsTWFyZ2luLCBlQSArIE1hdGguUEkgLyAyLCBzQSAtIE1hdGguUEkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5jbGlwKCk7XG5cblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSwgZUEpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoICogMjtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwLjQsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAzLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRcdGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcblx0XHRcdGNhcEJlemllclBvaW50czogdHJ1ZSxcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2xpbmUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHR2YXIgc3BhbkdhcHMgPSB2bS5zcGFuR2Fwcztcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XG5cdFx0dmFyIGluZGV4LCBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFZNO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRpZiAobWUuX2xvb3AgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmUgT3B0aW9uc1xuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdH1cblxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdGN0eC5saW5lSm9pbiA9IHZtLmJvcmRlckpvaW5TdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVySm9pblN0eWxlO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGgpO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblxuXHRcdC8vIFN0cm9rZSBMaW5lXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGxhc3REcmF3bkluZGV4ID0gLTE7XG5cblx0XHRmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG5cdFx0XHRjdXJyZW50ID0gcG9pbnRzW2luZGV4XTtcblx0XHRcdHByZXZpb3VzID0gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdGN1cnJlbnRWTSA9IGN1cnJlbnQuX3ZpZXc7XG5cblx0XHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRpZiAoKGxhc3REcmF3bkluZGV4ICE9PSAoaW5kZXggLSAxKSAmJiAhc3BhbkdhcHMpIHx8IGxhc3REcmF3bkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQyID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yJDEgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHBvaW50OiB7XG5cdFx0XHRyYWRpdXM6IDMsXG5cdFx0XHRwb2ludFN0eWxlOiAnY2lyY2xlJyxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdC8vIEhvdmVyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXG5cdFx0XHRob3ZlclJhZGl1czogNCxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiB4UmFuZ2UobW91c2VYKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VZIC0gdm0ueSkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbnZhciBlbGVtZW50X3BvaW50ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0gPyAoKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikpIDwgTWF0aC5wb3codm0uaGl0UmFkaXVzICsgdm0ucmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0aW5YUmFuZ2U6IHhSYW5nZSxcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRwYWRkaW5nOiB2bS5yYWRpdXMgKyB2bS5ib3JkZXJXaWR0aFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcblx0XHR2YXIgcmFkaXVzID0gdm0ucmFkaXVzO1xuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblxuXHRcdGlmICh2bS5za2lwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpcHBpbmcgZm9yIFBvaW50cy5cblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDIodm0uYm9yZGVyV2lkdGgsIGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBwb2ludFN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbG9yJDIgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKHZtKSB7XG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XG5cdHZhciB4MSwgeDIsIHkxLCB5MiwgaGFsZjtcblxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRoYWxmID0gdm0ud2lkdGggLyAyO1xuXHRcdHgxID0gdm0ueCAtIGhhbGY7XG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcblx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFsZiA9IHZtLmhlaWdodCAvIDI7XG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xuXHRcdHkxID0gdm0ueSAtIGhhbGY7XG5cdFx0eTIgPSB2bS55ICsgaGFsZjtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogeDEsXG5cdFx0dG9wOiB5MSxcblx0XHRyaWdodDogeDIsXG5cdFx0Ym90dG9tOiB5MlxuXHR9O1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuXHRyZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclNraXBwZWQodm0pIHtcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xuXHR2YXIgcmVzID0ge307XG5cblx0aWYgKCFlZGdlKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGlmICh2bS5ob3Jpem9udGFsKSB7XG5cdFx0aWYgKHZtLmJhc2UgPiB2bS54KSB7XG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh2bS5iYXNlIDwgdm0ueSkge1xuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XG5cdH1cblxuXHRyZXNbZWRnZV0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKHZtLCBtYXhXLCBtYXhIKSB7XG5cdHZhciB2YWx1ZSA9IHZtLmJvcmRlcldpZHRoO1xuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XG5cdHZhciB0LCByLCBiLCBsO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0fSBlbHNlIHtcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHQ6IHNraXAudG9wIHx8ICh0IDwgMCkgPyAwIDogdCA+IG1heEggPyBtYXhIIDogdCxcblx0XHRyOiBza2lwLnJpZ2h0IHx8IChyIDwgMCkgPyAwIDogciA+IG1heFcgPyBtYXhXIDogcixcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXG5cdFx0bDogc2tpcC5sZWZ0IHx8IChsIDwgMCkgPyAwIDogbCA+IG1heFcgPyBtYXhXIDogbFxuXHR9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKHZtKSB7XG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xuXHR2YXIgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcblx0dmFyIGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuXHRyZXR1cm4ge1xuXHRcdG91dGVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCxcblx0XHRcdHk6IGJvdW5kcy50b3AsXG5cdFx0XHR3OiB3aWR0aCxcblx0XHRcdGg6IGhlaWdodFxuXHRcdH0sXG5cdFx0aW5uZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG5cdFx0XHR5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG5cdFx0XHRoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iXG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XG5cdHZhciBza2lwWCA9IHggPT09IG51bGw7XG5cdHZhciBza2lwWSA9IHkgPT09IG51bGw7XG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcblxuXHRyZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXG5cdFx0JiYgKHNraXBZIHx8IHkgPj0gYm91bmRzLnRvcCAmJiB5IDw9IGJvdW5kcy5ib3R0b20pO1xufVxuXG52YXIgZWxlbWVudF9yZWN0YW5nbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xuXHRcdHZhciBvdXRlciA9IHJlY3RzLm91dGVyO1xuXHRcdHZhciBpbm5lciA9IHJlY3RzLmlubmVyO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguZmlsbFJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cblx0XHRpZiAob3V0ZXIudyA9PT0gaW5uZXIudyAmJiBvdXRlci5oID09PSBpbm5lci5oKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LnJlY3QoaW5uZXIueCwgaW5uZXIueSwgaW5uZXIudywgaW5uZXIuaCk7XG5cdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcblx0XHRcdDogaW5SYW5nZSh2bSwgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRpblhSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBudWxsKTtcblx0fSxcblxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgeCwgeTtcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRcdHggPSB2bS54O1xuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gKHZtLnggKyB2bS5iYXNlKSAvIDI7XG5cdFx0XHR5ID0gdm0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcblx0XHRcdDogdm0uaGVpZ2h0ICogTWF0aC5hYnModm0ueCAtIHZtLmJhc2UpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIGVsZW1lbnRzID0ge307XG52YXIgQXJjID0gZWxlbWVudF9hcmM7XG52YXIgTGluZSA9IGVsZW1lbnRfbGluZTtcbnZhciBQb2ludCA9IGVsZW1lbnRfcG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2JhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0fV1cblx0fVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XG5cdHZhciBtaW4gPSBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xuXHR2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuXHR2YXIgcHJldiwgY3VyciwgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMocGl4ZWxzW2ldIC0gcGl4ZWxzW2kgLSAxXSkpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG5cdFx0bWluID0gaSA+IDAgPyBNYXRoLm1pbihtaW4sIGN1cnIgLSBwcmV2KSA6IG1pbjtcblx0XHRwcmV2ID0gY3Vycjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XG5cdHZhciBjdXJyID0gcnVsZXIucGl4ZWxzW2luZGV4XTtcblx0dmFyIHNpemUsIHJhdGlvO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG5cdFx0c2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcblx0XHQvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcblx0XHRyYXRpbyA9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gY291bnQsXG5cdFx0cmF0aW86IHJhdGlvLFxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxuXHR9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuXHR2YXIgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHR2YXIgc3RhcnQsIHNpemU7XG5cblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHQvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG5cdH1cblxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG5cdH1cblxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXG5cdFx0cmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcblx0XHRzdGFydDogc3RhcnRcblx0fTtcbn1cblxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGE7XG5cblx0XHRjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuXHRcdG1ldGEuYmFyID0gdHJ1ZTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHJlY3RzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XG5cblx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXG5cdFx0fTtcblxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpO1xuXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCk7XG5cdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyKTtcblxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xuXHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBpbGVuID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggOiBsYXN0ICsgMTtcblx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0dmFyIGksIG1ldGE7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRpZiAobWV0YS5iYXIgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJlxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gZmFsc2UgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIChtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSkpKSB7XG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzdGFja3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIG5hbWUpIHtcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCk7XG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcblx0XHRcdD8gc3RhY2tzLmluZGV4T2YobmFtZSlcblx0XHRcdDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cblx0XHRyZXR1cm4gKGluZGV4ID09PSAtMSlcblx0XHRcdD8gc3RhY2tzLmxlbmd0aCAtIDFcblx0XHRcdDogaW5kZXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHN0YXJ0ID0gaXNIb3Jpem9udGFsID8gc2NhbGUubGVmdCA6IHNjYWxlLnRvcDtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaXNIb3Jpem9udGFsID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQpO1xuXHRcdHZhciBwaXhlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbWluO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBkYXRhc2V0SW5kZXgpKTtcblx0XHR9XG5cblx0XHRtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzY2FsZS5vcHRpb25zLmJhclRoaWNrbmVzcylcblx0XHRcdD8gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscylcblx0XHRcdDogLTE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiBtaW4sXG5cdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGVuZDogZW5kLFxuXHRcdFx0c3RhY2tDb3VudDogc3RhY2tDb3VudCxcblx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJWYWx1ZVBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgdmFsdWUgPSArc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgbWluQmFyTGVuZ3RoID0gc2NhbGUub3B0aW9ucy5taW5CYXJMZW5ndGg7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIHN0YWNrID0gbWV0YS5zdGFjaztcblx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdHZhciBpLCBpbWV0YSwgaXZhbHVlLCBiYXNlLCBoZWFkLCBzaXplO1xuXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRcdGltZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cblx0XHRcdFx0aWYgKGltZXRhLmJhciAmJlxuXHRcdFx0XHRcdGltZXRhLnN0YWNrID09PSBzdGFjayAmJlxuXHRcdFx0XHRcdGltZXRhLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBzY2FsZS5pZCAmJlxuXHRcdFx0XHRcdGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblxuXHRcdFx0XHRcdGl2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2ldLmRhdGFbaW5kZXhdKTtcblx0XHRcdFx0XHRpZiAoKHZhbHVlIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUgPj0gMCAmJiBpdmFsdWUgPiAwKSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XG5cblx0XHRpZiAobWluQmFyTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XG5cdFx0XHRpZiAodmFsdWUgPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IHZhbHVlIDwgMCAmJiBpc0hvcml6b250YWwpIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWFkID0gYmFzZSArIG1pbkJhckxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGJhc2U6IGJhc2UsXG5cdFx0XHRoZWFkOiBoZWFkLFxuXHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHJ1bGVyLnNjYWxlLm9wdGlvbnM7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcblx0XHRcdDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucyk7XG5cblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xuXHRcdHZhciBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcblx0XHRcdGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpLFxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG5cdFx0XHRoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0c2l6ZTogc2l6ZVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBpbGVuID0gcmVjdHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmICghaXNOYU4oc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0LmRhdGFbaV0pKSkge1xuXHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5yZWN0YW5nbGU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJTa2lwcGVkJyxcblx0XHRcdCdib3JkZXJXaWR0aCdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDEoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQyID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YXNldExhYmVsID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdHZhciBkYXRhUG9pbnQgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5kYXRhW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpbmRleCwgcmVzZXQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcblx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdH07XG5cblx0XHRwb2ludC5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdFx0J2hpdFJhZGl1cycsXG5cdFx0XHQncG9pbnRTdHlsZScsXG5cdFx0XHQncm90YXRpb24nXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQyKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG5cdFx0dmFsdWVzLnJhZGl1cyA9IHJlc29sdmUkMihbXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxuXHRcdFx0ZGF0YSA/IGRhdGEuciA6IHVuZGVmaW5lZCxcblx0XHRcdGRhdGFzZXQucmFkaXVzLFxuXHRcdFx0b3B0aW9ucy5yYWRpdXNcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdkb3VnaG51dCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0fSxcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjICYmIGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDMoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDMoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0aWYgKG1ldGEuZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHQvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuXHRyb3RhdGlvbjogTWF0aC5QSSAqIC0wLjUsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBNYXRoLlBJICogMi4wLFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFMYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9kb3VnaG51dCA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nSW5kZXggPSAwO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHQrK3JpbmdJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ0luZGV4O1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdHZhciBhdmFpbGFibGVIZWlnaHQgPSBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcDtcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuXHRcdHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH07XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGN1dG91dFBlcmNlbnRhZ2UgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2U7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgbWluU2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgTWF0aC5QSSAqIDIuMCkge1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyLjApO1xuXHRcdFx0c3RhcnRBbmdsZSArPSBNYXRoLlBJICogMi4wICogKHN0YXJ0QW5nbGUgPj0gTWF0aC5QSSA/IC0xIDogc3RhcnRBbmdsZSA8IC1NYXRoLlBJID8gMSA6IDApO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG5cdFx0XHR2YXIgc3RhcnQgPSB7eDogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpfTtcblx0XHRcdHZhciBlbmQgPSB7eDogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBNYXRoLnNpbihlbmRBbmdsZSl9O1xuXHRcdFx0dmFyIGNvbnRhaW5zMCA9IChzdGFydEFuZ2xlIDw9IDAgJiYgZW5kQW5nbGUgPj0gMCkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuMCAmJiBNYXRoLlBJICogMi4wIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDAuNSAmJiBNYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi41ICYmIE1hdGguUEkgKiAyLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgJiYgLU1hdGguUEkgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgJiYgTWF0aC5QSSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAqIDAuNSAmJiAtTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDEuNSAmJiBNYXRoLlBJICogMS41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjdXRvdXQgPSBjdXRvdXRQZXJjZW50YWdlIC8gMTAwLjA7XG5cdFx0XHR2YXIgbWluID0ge3g6IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydC54ICogKHN0YXJ0LnggPCAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54IDwgMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnkgKiAoc3RhcnQueSA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPCAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBtYXggPSB7eDogY29udGFpbnMwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnggKiAoc3RhcnQueCA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPiAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnkgKiAoc3RhcnQueSA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPiAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBzaXplID0ge3dpZHRoOiAobWF4LnggLSBtaW4ueCkgKiAwLjUsIGhlaWdodDogKG1heC55IC0gbWluLnkpICogMC41fTtcblx0XHRcdG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHNpemUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0XHRcdG9mZnNldCA9IHt4OiAobWF4LnggKyBtaW4ueCkgKiAtMC41LCB5OiAobWF4LnkgKyBtaW4ueSkgKiAtMC41fTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdH1cblxuXHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKTtcblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChjdXRvdXRQZXJjZW50YWdlKSA6IDAsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIChtZS5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHx8IDEpO1xuXHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXQueCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXQueSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXG5cdFx0bWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gTWF0aC5tYXgobWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gMCA6IGFyYy5oaWRkZW4gPyAwIDogbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKSAqIChvcHRzLmNpcmN1bWZlcmVuY2UgLyAoMi4wICogTWF0aC5QSSkpO1xuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuXHRcdHZhciBvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcblx0XHRcdFx0eTogY2VudGVyWSArIGNoYXJ0Lm9mZnNldFksXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcblx0XHRcdFx0Y2lyY3VtZmVyZW5jZTogY2lyY3VtZmVyZW5jZSxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQubGFiZWwsIGluZGV4LCBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXG5cdFx0Ly8gU2V0IGNvcnJlY3QgYW5nbGVzIGlmIG5vdCByZXNldHRpbmdcblx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcblx0XHR9XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0dmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIGlmICh0b3RhbCA9PT0gMCkge1xuXHRcdFx0dG90YWwgPSBOYU47XG5cdFx0fSovXG5cblx0XHRyZXR1cm4gdG90YWw7XG5cdH0sXG5cblx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcblx0XHRpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAoTWF0aC5QSSAqIDIuMCkgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXggPSAwO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhLCBhcmMsIGNvbnRyb2xsZXIsIG9wdGlvbnMsIGJvcmRlcldpZHRoLCBob3ZlcldpZHRoO1xuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmMgPSBhcmNzW2ldO1xuXHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjLCBpKSA6IGFyYy5fb3B0aW9ucztcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0aG92ZXJXaWR0aCA9IG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aDtcblxuXHRcdFx0XHRtYXggPSBib3JkZXJXaWR0aCA+IG1heCA/IGJvcmRlcldpZHRoIDogbWF4O1xuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1heDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJBbGlnbicsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMyhbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQkNCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YVNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XVxuXHR9LFxuXG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnbGVmdCdcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ1ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgaXNQb2ludEluQXJlYSA9IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWE7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucykge1xuXHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XG59XG5cbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNob3dMaW5lID0gbGluZUVuYWJsZWQoZGF0YXNldCwgbWUuY2hhcnQub3B0aW9ucyk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBVcGRhdGUgTGluZVxuXHRcdGlmIChzaG93TGluZSkge1xuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0Ly8gRGF0YVxuXHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0XHQvLyBNb2RlbFxuXHRcdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCwgeTtcblxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblxuXHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ1KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXHRcdFx0c3RlcHBlZExpbmU6IGxpbmVNb2RlbCA/IGxpbmVNb2RlbC5zdGVwcGVkTGluZSA6IGZhbHNlLFxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gb3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnLFxuXHRcdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0ZWxlbWVudE9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xuXHRcdC8vIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDM1I2lzc3VlY29tbWVudC0yMTY3MTgxNThcblx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LmxpbmVUZW5zaW9uLCBlbGVtZW50T3B0aW9ucy50ZW5zaW9uKTtcblx0XHR2YWx1ZXMuc3RlcHBlZExpbmUgPSByZXNvbHZlJDQoW2N1c3RvbS5zdGVwcGVkTGluZSwgZGF0YXNldC5zdGVwcGVkTGluZSwgZWxlbWVudE9wdGlvbnMuc3RlcHBlZF0pO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBzdW1Qb3MgPSAwO1xuXHRcdHZhciBzdW1OZWcgPSAwO1xuXHRcdHZhciBpLCBkcywgZHNNZXRhO1xuXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7IGkrKykge1xuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV07XG5cdFx0XHRcdGRzTWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHR2YXIgc3RhY2tlZFJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pKTtcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciByaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0aWYgKGxpbmVNb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGhhbGZCb3JkZXJXaWR0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobGluZUVuYWJsZWQobWUuZ2V0RGF0YXNldCgpLCBjaGFydC5vcHRpb25zKSkge1xuXHRcdFx0aGFsZkJvcmRlcldpZHRoID0gKG1ldGEuZGF0YXNldC5fbW9kZWwuYm9yZGVyV2lkdGggfHwgMCkgLyAyO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xuXHRcdFx0XHRsZWZ0OiBhcmVhLmxlZnQsXG5cdFx0XHRcdHJpZ2h0OiBhcmVhLnJpZ2h0LFxuXHRcdFx0XHR0b3A6IGFyZWEudG9wIC0gaGFsZkJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3R0b206IGFyZWEuYm90dG9tICsgaGFsZkJvcmRlcldpZHRoXG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblxuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB0aGUgcG9pbnRzXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9LFxufSk7XG5cbnZhciByZXNvbHZlJDUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BvbGFyQXJlYScsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRhbmdsZUxpbmVzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdH0sXG5cdFx0cG9pbnRMYWJlbHM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHR0aWNrczoge1xuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XG5cdGFuaW1hdGlvbjoge1xuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXG5cdH0sXG5cblx0c3RhcnRBbmdsZTogLTAuNSAqIE1hdGguUEksXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gcmVzb2x2ZSQ1KFtjdXN0b20uYmFja2dyb3VuZENvbG9yLCBkcy5iYWNrZ3JvdW5kQ29sb3IsIGFyY09wdHMuYmFja2dyb3VuZENvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJDb2xvciwgZHMuYm9yZGVyQ29sb3IsIGFyY09wdHMuYm9yZGVyQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gcmVzb2x2ZSQ1KFtjdXN0b20uYm9yZGVyV2lkdGgsIGRzLmJvcmRlcldpZHRoLCBhcmNPcHRzLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1tpdGVtLmluZGV4XSArICc6ICcgKyBpdGVtLnlMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9wb2xhckFyZWEgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IG1lLl9zdGFydHMgPSBbXTtcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuLCBhbmdsZTtcblxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcblxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXQuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xuXHRcdFx0YW5nbGVzW2ldID0gYW5nbGU7XG5cdFx0XHRzdGFydCArPSBhbmdsZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VwZGF0ZVJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGg7XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBzY2FsZSA9IGNoYXJ0LnNjYWxlO1xuXHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcblxuXHRcdHZhciBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcblx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG5cblx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XG5cdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBtZS5fc3RhcnRzW2luZGV4XTtcblx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogbWUuX2FuZ2xlc1tpbmRleF0pO1xuXG5cdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYLFxuXHRcdFx0XHR5OiBjZW50ZXJZLFxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IHJlc2V0ID8gcmVzZXRSYWRpdXMgOiBkaXN0YW5jZSxcblx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ1KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21wdXRlQW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY291bnQgPSB0aGlzLmdldE1ldGEoKS5jb3VudDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblxuXHRcdGlmIChpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogbWUuY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc29sdmUkNShbXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcblx0XHRcdCgyICogTWF0aC5QSSkgLyBjb3VudFxuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywgaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZG91Z2hudXQpKTtcbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywge1xuXHRjdXRvdXRQZXJjZW50YWdlOiAwXG59KTtcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbnZhciBjb250cm9sbGVyX3BpZSA9IGNvbnRyb2xsZXJfZG91Z2hudXQ7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcblx0fSxcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwIC8vIG5vIGJlemllciBpbiByYWRhclxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0fVxuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0Ly8gRGF0YVxuXHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xuXHRcdC8vIE1vZGVsXG5cdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0bGluZS5waXZvdCgpO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcblx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWUuZ2V0TWV0YSgpLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsIC8vIHZhbHVlIG5vdCB1c2VkIGluIGRhdGFzZXQgc2NhbGUsIGJ1dCB3ZSB3YW50IGEgY29uc2lzdGVudCBBUEkgYmV0d2VlbiBzY2FsZXNcblx0XHRcdHk6IHksXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNihjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcblxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJDYXBTdHlsZScsXG5cdFx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHRcdCdmaWxsJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ2KGRhdGFzZXQubGluZVRlbnNpb24sIG9wdGlvbnMudGVuc2lvbik7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdCk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJlemllciBnb2luZyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0c2hvd0xpbmVzOiBmYWxzZSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7ICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2UgZGF0YSBhcmUgZm9ybWF0dGVkIGFzIGEgcG9pbnRcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gJygnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcbnZhciBjb250cm9sbGVyX3NjYXR0ZXIgPSBjb250cm9sbGVyX2xpbmU7XG5cbi8vIE5PVEUgZXhwb3J0IGEgbWFwIGluIHdoaWNoIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgY29udHJvbGxlciB0eXBlLCBub3Rcbi8vIHRoZSBjbGFzcywgYW5kIHNvIG11c3QgYmUgQ2FtZWxDYXNlIGluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSByZXRyaWV2ZWRcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cblxudmFyIGNvbnRyb2xsZXJzID0ge1xuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxuXHRidWJibGU6IGNvbnRyb2xsZXJfYnViYmxlLFxuXHRkb3VnaG51dDogY29udHJvbGxlcl9kb3VnaG51dCxcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxuXHRsaW5lOiBjb250cm9sbGVyX2xpbmUsXG5cdHBvbGFyQXJlYTogY29udHJvbGxlcl9wb2xhckFyZWEsXG5cdHBpZTogY29udHJvbGxlcl9waWUsXG5cdHJhZGFyOiBjb250cm9sbGVyX3JhZGFyLFxuXHRzY2F0dGVyOiBjb250cm9sbGVyX3NjYXR0ZXJcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgYW4gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBldmVudCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG5cdGlmIChlLm5hdGl2ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBlLngsXG5cdFx0XHR5OiBlLnlcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcblx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmICghY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0RWxlbWVudFtdfSBpdGVtcyAtIGVsZW1lbnRzIHRvIGZpbHRlclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VNZXRyaWMgLSBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpIHtcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcblx0dmFyIHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0dmFyIGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG5cdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtpdGVtc1swXS5faW5kZXhdO1xuXG5cdFx0XHQvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBJSW50ZXJhY3Rpb25PcHRpb25zXG4gKi9cbi8qKlxuICogSWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9pbnRcbiAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbnZhciBjb3JlX2ludGVyYWN0aW9uID0ge1xuXHQvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuXHRtb2Rlczoge1xuXHRcdHNpbmdsZTogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmxhYmVsXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGxhYmVsOiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRpbmRleDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLngtYXhpc1xuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAuIFVzZSBpbmRleCBtb2RlIGFuZCBpbnRlcnNlY3QgPT0gdHJ1ZVxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0cmV0dXJuIGluZGV4TW9kZShjaGFydCwgZSwge2ludGVyc2VjdDogZmFsc2V9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5YUmFuZ2UocG9zaXRpb24ueCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR5OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pbllSYW5nZShwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcblx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG5cdFx0di5fdG1wSW5kZXhfID0gaTtcblx0XHRyZXR1cm4gdjtcblx0fSk7XG5cdGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cblx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcblx0fSk7XG5cdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdGRlbGV0ZSB2Ll90bXBJbmRleF87XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kTWF4UGFkZGluZyhib3hlcykge1xuXHR2YXIgdG9wID0gMDtcblx0dmFyIGxlZnQgPSAwO1xuXHR2YXIgYm90dG9tID0gMDtcblx0dmFyIHJpZ2h0ID0gMDtcblx0aGVscGVycyQxLmVhY2goYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdGlmIChib3guZ2V0UGFkZGluZykge1xuXHRcdFx0dmFyIGJveFBhZGRpbmcgPSBib3guZ2V0UGFkZGluZygpO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRsZWZ0ID0gTWF0aC5tYXgobGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcblx0XHRcdGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuXHRcdFx0cmlnaHQgPSBNYXRoLm1heChyaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHtcblx0XHR0b3A6IHRvcCxcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdGJvdHRvbTogYm90dG9tLFxuXHRcdHJpZ2h0OiByaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTaXplQnlQb3NpdGlvbihib3hlcywgc2l6ZSkge1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0c2l6ZVtib3gucG9zaXRpb25dICs9IGJveC5pc0hvcml6b250YWwoKSA/IGJveC5oZWlnaHQgOiBib3gud2lkdGg7XG5cdH0pO1xufVxuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbnZhciBjb3JlX2xheW91dHMgPSB7XG5cdGRlZmF1bHRzOiB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdCAqL1xuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG5cdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0Y2hhcnQuYm94ZXMucHVzaChpdGVtKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xuXHRcdHZhciBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG5cdGNvbmZpZ3VyZTogZnVuY3Rpb24oY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHByb3A7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0aXRlbVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoIWNoYXJ0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcblx0XHR2YXIgcGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhsYXlvdXRPcHRpb25zLnBhZGRpbmcpO1xuXHRcdHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmcubGVmdDtcblx0XHR2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZy5yaWdodDtcblx0XHR2YXIgdG9wUGFkZGluZyA9IHBhZGRpbmcudG9wO1xuXHRcdHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZy5ib3R0b207XG5cblx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHR2YXIgcmlnaHRCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdyaWdodCcpO1xuXHRcdHZhciB0b3BCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICd0b3AnKTtcblx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0dmFyIGNoYXJ0QXJlYUJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2NoYXJ0QXJlYScpO1xuXG5cdFx0Ly8gU29ydCBib3hlcyBieSB3ZWlnaHQuIEEgaGlnaGVyIHdlaWdodCBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChyaWdodEJveGVzLCBmYWxzZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHRvcEJveGVzLCB0cnVlKTtcblx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdHZhciB2ZXJ0aWNhbEJveGVzID0gbGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKTtcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gdG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKTtcblx0XHR2YXIgb3V0ZXJCb3hlcyA9IHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyk7XG5cblx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0Ly8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcblx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHQvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcblx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cblx0XHQvL1xuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vXG5cdFx0Ly8gV2hhdCB3ZSBkbyB0byBmaW5kIHRoZSBiZXN0IHNpemluZywgd2UgZG8gdGhlIGZvbGxvd2luZ1xuXHRcdC8vIDEuIERldGVybWluZSB0aGUgbWluaW11bSBzaXplIG9mIHRoZSBjaGFydCBhcmVhLlxuXHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdC8vIDMuIFNwbGl0IHRoZSByZW1haW5pbmcgaGVpZ2h0IGVxdWFsbHkgYmV0d2VlbiBlYWNoIGhvcml6b250YWwgYXhpc1xuXHRcdC8vIDQuIEdpdmUgZWFjaCBsYXlvdXQgdGhlIG1heGltdW0gc2l6ZSBpdCBjYW4gYmUuIFRoZSBsYXlvdXQgd2lsbCByZXR1cm4gaXQncyBtaW5pbXVtIHNpemVcblx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHQvLyA2LiBSZWZpdCBlYWNoIGF4aXNcblx0XHQvLyA3LiBQb3NpdGlvbiBlYWNoIGF4aXMgaW4gdGhlIGZpbmFsIGxvY2F0aW9uXG5cdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0Ly8gOS4gVGVsbCBhbnkgYXhlcyB0aGF0IG92ZXJsYXkgdGhlIGNoYXJ0IGFyZWEgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY2hhcnQgYXJlYVxuXG5cdFx0Ly8gU3RlcCAxXG5cdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdHZhciBjaGFydEhlaWdodCA9IGhlaWdodCAtIHRvcFBhZGRpbmcgLSBib3R0b21QYWRkaW5nO1xuXHRcdHZhciBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGggLyAyOyAvLyBtaW4gNTAlXG5cblx0XHQvLyBTdGVwIDJcblx0XHR2YXIgdmVydGljYWxCb3hXaWR0aCA9ICh3aWR0aCAtIGNoYXJ0QXJlYVdpZHRoKSAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCAzXG5cdFx0Ly8gVE9ETyByZS1saW1pdCBob3Jpem9udGFsIGF4aXMgaGVpZ2h0ICh0aGlzIGxpbWl0IGhhcyBhZmZlY3RlZCBvbmx5IHBhZGRpbmcgY2FsY3VsYXRpb24gc2luY2UgUFIgMTgzNylcblx0XHQvLyB2YXIgaG9yaXpvbnRhbEJveEhlaWdodCA9IChoZWlnaHQgLSBjaGFydEFyZWFIZWlnaHQpIC8gaG9yaXpvbnRhbEJveGVzLmxlbmd0aDtcblxuXHRcdC8vIFN0ZXAgNFxuXHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0dmFyIG1heENoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0O1xuXHRcdHZhciBvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0dmFyIG1pbkJveFNpemVzID0gW107XG5cdFx0dmFyIG1heFBhZGRpbmc7XG5cblx0XHRmdW5jdGlvbiBnZXRNaW5pbXVtQm94U2l6ZShib3gpIHtcblx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IGJveC5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZSh2ZXJ0aWNhbEJveFdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRtaW5Cb3hTaXplcy5wdXNoKHtcblx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHR3aWR0aDogbWluU2l6ZS53aWR0aCxcblx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChvdXRlckJveGVzLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHQvLyBJZiBhIGhvcml6b250YWwgYm94IGhhcyBwYWRkaW5nLCB3ZSBtb3ZlIHRoZSBsZWZ0IGJveGVzIG92ZXIgdG8gYXZvaWQgdWdseSBjaGFydHMgKHNlZSBpc3N1ZSAjMjQ3OClcblx0XHRtYXhQYWRkaW5nID0gZmluZE1heFBhZGRpbmcob3V0ZXJCb3hlcyk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdC8vIGJlIGlmIHRoZSBheGVzIGFyZSBkcmF3biBhdCB0aGVpciBtaW5pbXVtIHNpemVzLlxuXHRcdC8vIFN0ZXBzIDUgJiA2XG5cblx0XHQvLyBGdW5jdGlvbiB0byBmaXQgYSBib3hcblx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0cmV0dXJuIG1pbkJveC5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRpZiAobWluQm94U2l6ZS5ob3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5sZWZ0LCBtYXhQYWRkaW5nLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KG91dGVyQm94U2l6ZXMucmlnaHQsIG1heFBhZGRpbmcucmlnaHQpLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0Ym90dG9tOiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHQvLyBvbiB0aGUgbWFyZ2luLiBTb21ldGltZXMgdGhleSBuZWVkIHRvIGluY3JlYXNlIGluIHNpemUgc2xpZ2h0bHlcblx0XHRcdFx0XHRib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMiwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC51cGRhdGUobWluQm94U2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKHZlcnRpY2FsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZml0Qm94KTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbihob3Jpem9udGFsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0cmV0dXJuIG1pblNpemUuYm94ID09PSBib3g7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiBvdXRlckJveFNpemVzLnRvcCxcblx0XHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLmJvdHRvbVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQsIHNjYWxlTWFyZ2luKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMZXQgdGhlIGxlZnQgbGF5b3V0IGtub3cgdGhlIGZpbmFsIG1hcmdpblxuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpbmFsRml0VmVydGljYWxCb3gpO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgc2l6ZSBvZiBlYWNoIGxheW91dCBtaWdodCBoYXZlIGNoYW5nZWQgc2xpZ2h0bHkgZHVlIHRvIHRoZSBtYXJnaW5zIChsYWJlbCByb3RhdGlvbiBmb3IgaW5zdGFuY2UpXG5cdFx0b3V0ZXJCb3hTaXplcyA9IHt0b3A6IHRvcFBhZGRpbmcsIGxlZnQ6IGxlZnRQYWRkaW5nLCBib3R0b206IGJvdHRvbVBhZGRpbmcsIHJpZ2h0OiByaWdodFBhZGRpbmd9O1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKG91dGVyQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0dmFyIGxlZnRQYWRkaW5nQWRkaXRpb24gPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQgLSBvdXRlckJveFNpemVzLmxlZnQsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMubGVmdCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMucmlnaHQgKz0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCAtIG91dGVyQm94U2l6ZXMucmlnaHQsIDApO1xuXG5cdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wIC0gb3V0ZXJCb3hTaXplcy50b3AsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMudG9wICs9IHRvcFBhZGRpbmdBZGRpdGlvbjtcblx0XHRvdXRlckJveFNpemVzLmJvdHRvbSArPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSAtIG91dGVyQm94U2l6ZXMuYm90dG9tLCAwKTtcblxuXHRcdC8vIEZpZ3VyZSBvdXQgaWYgb3VyIGNoYXJ0IGFyZWEgY2hhbmdlZC4gVGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgZGF0YXNldCBsYXlvdXQgbGFiZWwgcm90YXRpb25cblx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHQvLyB3aXRob3V0IGNhbGxpbmcgYGZpdGAgYWdhaW5cblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ID0gaGVpZ2h0IC0gb3V0ZXJCb3hTaXplcy50b3AgLSBvdXRlckJveFNpemVzLmJvdHRvbTtcblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhV2lkdGggPSB3aWR0aCAtIG91dGVyQm94U2l6ZXMubGVmdCAtIG91dGVyQm94U2l6ZXMucmlnaHQ7XG5cblx0XHRpZiAobmV3TWF4Q2hhcnRBcmVhV2lkdGggIT09IG1heENoYXJ0QXJlYVdpZHRoIHx8IG5ld01heENoYXJ0QXJlYUhlaWdodCAhPT0gbWF4Q2hhcnRBcmVhSGVpZ2h0KSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChob3Jpem9udGFsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdG1heENoYXJ0QXJlYVdpZHRoID0gbmV3TWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0fVxuXG5cdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0dmFyIGxlZnQgPSBsZWZ0UGFkZGluZyArIGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0dmFyIHRvcCA9IHRvcFBhZGRpbmcgKyB0b3BQYWRkaW5nQWRkaXRpb247XG5cblx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gbGVmdFBhZGRpbmcgOiBvdXRlckJveFNpemVzLmxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyB3aWR0aCAtIHJpZ2h0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRib3gudG9wID0gdG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0dG9wID0gYm94LmJvdHRvbTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3gubGVmdCA9IGxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGxlZnQgKyBib3gud2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSBvdXRlckJveFNpemVzLnRvcDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRsZWZ0ID0gYm94LnJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKGxlZnRCb3hlcy5jb25jYXQodG9wQm94ZXMpLCBwbGFjZUJveCk7XG5cblx0XHQvLyBBY2NvdW50IGZvciBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHR0b3AgKz0gbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0aGVscGVycyQxLmVhY2gocmlnaHRCb3hlcywgcGxhY2VCb3gpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvdHRvbUJveGVzLCBwbGFjZUJveCk7XG5cblx0XHQvLyBTdGVwIDhcblx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRsZWZ0OiBvdXRlckJveFNpemVzLmxlZnQsXG5cdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0cmlnaHQ6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoLFxuXHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLnRvcCArIG1heENoYXJ0QXJlYUhlaWdodFxuXHRcdH07XG5cblx0XHQvLyBTdGVwIDlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3gubGVmdCA9IGNoYXJ0LmNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0LmNoYXJ0QXJlYS50b3A7XG5cdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRib3guYm90dG9tID0gY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTtcblxuXHRcdFx0Ym94LnVwZGF0ZShtYXhDaGFydEFyZWFXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcblx0fVxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxuICovXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxufVxcblxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxufVxcblxcbi8qXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXG4gKi9cXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxuXFx0cmlnaHQ6IDA7XFxuXFx0Ym90dG9tOiAwO1xcblxcdG92ZXJmbG93OiBoaWRkZW47XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcblxcdHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAyMDAlO1xcblxcdGhlaWdodDogMjAwJTtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbmRlZmF1bHQ6IHBsYXRmb3JtX2RvbVxufSk7XG5cbmZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcblx0cmV0dXJuIG4gJiYgbi5kZWZhdWx0IHx8IG47XG59XG5cbnZhciBzdHlsZXNoZWV0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShwbGF0Zm9ybV9kb20kMSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3JlbmRlci1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge1xuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcblx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcblx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuXHRwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN1cHBvcnRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuXHR9XG5cdHJldHVybiBzdXBwb3J0cztcbn0oKSk7XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xuXHRyZXR1cm4gZWw7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXG5cdC8vIE5PVEUoU0IpIERvbid0IHVzZSBpbm5lckhUTUwgYmVjYXVzZSBpdCBjb3VsZCBiZSBjb25zaWRlcmVkIHVuc2FmZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XG5cdHZhciBleHBhbmQgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctZXhwYW5kJyk7XG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XG5cblx0ZXhwYW5kLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblxuXHRyZXNpemVyLmFwcGVuZENoaWxkKGV4cGFuZCk7XG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRMaXN0ZW5lcihzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKHNocmluaywgJ3NocmluaycpKTtcblxuXHRyZXR1cm4gcmVzaXplcjtcbn1cblxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5mdW5jdGlvbiB3YXRjaEZvclJlbmRlcihub2RlLCBoYW5kbGVyKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IENTU19SRU5ERVJfQU5JTUFUSU9OKSB7XG5cdFx0XHRoYW5kbGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdH0pO1xuXG5cdC8vICM0NzM3OiBDaHJvbWUgbWlnaHQgc2tpcCB0aGUgQ1NTIGFuaW1hdGlvbiB3aGVuIHRoZSBDU1NfUkVOREVSX01PTklUT1IgY2xhc3Ncblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYSNib3gtbWV0cmljc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcblx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuXHRcdFx0XHQvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG5cdFx0XHRcdC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcblx0XHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbmplY3RDU1MocGxhdGZvcm0sIGNzcykge1xuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxuXHR2YXIgc3R5bGUgPSBwbGF0Zm9ybS5fc3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0aWYgKCFwbGF0Zm9ybS5fc3R5bGUpIHtcblx0XHRwbGF0Zm9ybS5fc3R5bGUgPSBzdHlsZTtcblx0XHRjc3MgPSAnLyogQ2hhcnQuanMgKi9cXG4nICsgY3NzO1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG59XG5cbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcblx0LyoqXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xuXHQgKiBzd2l0Y2ggaGFzIGJlZW4gYWRkZWQgdG8gYWxsb3cgZXh0ZXJuYWwgc3R5bGVzaGVldCAoYGRpc3QvQ2hhcnQoLm1pbik/LmpzYClcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHQgKi9cblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Vuc3VyZUxvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XG5cdFx0XHRpbmplY3RDU1ModGhpcywgc3R5bGVzaGVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG5cdFx0fSBlbHNlIGlmIChpdGVtLmxlbmd0aCkge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcblx0XHR9XG5cblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIHBvc3NpYmxlIHRvIGNoYW5nZVxuXHRcdC8vIHBsYXRmb3JtIG9wdGlvbnMgYWZ0ZXIgaW1wb3J0aW5nIHRoZSBsaWJyYXJ5IChlLmcuIGBkaXNhYmxlQ1NTSW5qZWN0aW9uYCkuXG5cdFx0dGhpcy5fZW5zdXJlTG9hZGVkKCk7XG5cblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG5cdFx0Ly8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3Ncblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xuXHRcdFx0aW5pdENhbnZhcyhpdGVtLCBjb25maWcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdGNhbnZhcy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcblx0XHQvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG5cdFx0ZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwgKGxpc3RlbmVyW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCAoZXhwYW5kby5wcm94aWVzID0ge30pO1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCB7fTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XG5cdFx0aWYgKCFwcm94eSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9XG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5hZGRFdmVudCA9IGFkZExpc3RlbmVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5yZW1vdmVFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHBsYXRmb3JtX2RvbSQyLl9lbmFibGVkID8gcGxhdGZvcm1fZG9tJDIgOiBwbGF0Zm9ybV9iYXNpYztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXG4gKiBAc2luY2UgMi40LjBcbiAqL1xudmFyIHBsYXRmb3JtID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdCAqL1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG5cbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHt9XG59KTtcblxuLyoqXG4gKiBUaGUgcGx1Z2luIHNlcnZpY2Ugc2luZ2xldG9uXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcbiAqIEBzaW5jZSAyLjEuMFxuICovXG52YXIgY29yZV9wbHVnaW5zID0ge1xuXHQvKipcblx0ICogR2xvYmFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BsdWdpbnM6IFtdLFxuXG5cdC8qKlxuXHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xuXHQgKiBpbmNyZW1lbnRlZCBhbmQgZGVzY3JpcHRvcnMgYXJlIHJlZ2VuZXJhdGVkIGR1cmluZyBmb2xsb3dpbmcgQVBJIGNhbGxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NhY2hlSWQ6IDAsXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0cC5wdXNoKHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgb25seSBpZiByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVnaXN0ZXJlZCBwbHVnaW5zP1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuXHRub3RpZnk6IGZ1bmN0aW9uKGNoYXJ0LCBob29rLCBhcmdzKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0dmFyIGksIGRlc2NyaXB0b3IsIHBsdWdpbiwgcGFyYW1zLCBtZXRob2Q7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG5cdFx0XHRwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBjYWNoZSA9IGNoYXJ0LiRwbHVnaW5zIHx8IChjaGFydC4kcGx1Z2lucyA9IHt9KTtcblx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcblx0XHR9XG5cblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuXHRcdHZhciBjb25maWcgPSAoY2hhcnQgJiYgY2hhcnQuY29uZmlnKSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcblxuXHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xuXHRcdFx0aWYgKG9wdHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0ZGVzY3JpcHRvcnMucHVzaCh7XG5cdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNhY2hlLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XG5cdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcblx0fSxcblxuXHQvKipcblx0ICogSW52YWxpZGF0ZXMgY2FjaGUgZm9yIHRoZSBnaXZlbiBjaGFydDogZGVzY3JpcHRvcnMgaG9sZCBhIHJlZmVyZW5jZSBvbiBwbHVnaW4gb3B0aW9uLFxuXHQgKiBidXQgaW4gc29tZSBjYXNlcywgdGhpcyByZWZlcmVuY2UgY2FuIGJlIGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiB1cGRhdGluZyBvcHRpb25zLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRkZWxldGUgY2hhcnQuJHBsdWdpbnM7XG5cdH1cbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcblx0Ly8gU2NhbGUgcmVnaXN0cmF0aW9uIG9iamVjdC4gRXh0ZW5zaW9ucyBjYW4gcmVnaXN0ZXIgbmV3IHNjYWxlIHR5cGVzIChzdWNoIGFzIGxvZyBvciBEQiBzY2FsZXMpIGFuZCB0aGVuXG5cdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxuXHQvLyBVc2UgYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gbW92ZSB0byBhbiBFUzYgbWFwIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gc3VwcG9ydFxuXHQvLyBvbGQgYnJvd3NlcnNcblxuXHQvLyBTY2FsZSBjb25maWcgZGVmYXVsdHNcblx0ZGVmYXVsdHM6IHt9LFxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xuXHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xuXHR9LFxuXHRnZXRTY2FsZUNvbnN0cnVjdG9yOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XG5cdH0sXG5cdGdldFNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKHt9LCBbY29yZV9kZWZhdWx0cy5zY2FsZSwgdGhpcy5kZWZhdWx0c1t0eXBlXV0pIDoge307XG5cdH0sXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0fVxuXHR9LFxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHQvLyBBZGRzIGVhY2ggc2NhbGUgdG8gdGhlIGNoYXJ0LmJveGVzIGFycmF5IHRvIGJlIHNpemVkIGFjY29yZGluZ2x5XG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgc2NhbGUpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRvb2x0aXBzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycyQxLm5vb3AsXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cdFx0XHRcdFx0aWYgKGl0ZW0ubGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS5sYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ueExhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRvb2x0aXBJdGVtLnZhbHVlKSkge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxDb2xvcjogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGFjdGl2ZUVsZW1lbnQgPSBtZXRhLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmlldyA9IGFjdGl2ZUVsZW1lbnQuX3ZpZXc7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IHZpZXcuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiB2aWV3LmJhY2tncm91bmRDb2xvclxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsVGV4dENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcblx0XHRcdH0sXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0YWZ0ZXJGb290ZXI6IGhlbHBlcnMkMS5ub29wXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIHBvc2l0aW9uZXJzID0ge1xuXHQvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0RWxlbWVudFtdfSB0aGUgZWxlbWVudHMgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaSwgbGVuO1xuXHRcdHZhciB4ID0gMDtcblx0XHR2YXIgeSA9IDA7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0eSArPSBwb3MueTtcblx0XHRcdFx0Kytjb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCAvIGNvdW50LFxuXHRcdFx0eTogeSAvIGNvdW50XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSBldmVudFBvc2l0aW9uIHtvYmplY3R9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0b29sdGlwIHBvc2l0aW9uXG5cdCAqL1xuXHRuZWFyZXN0OiBmdW5jdGlvbihlbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuXHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0XHR2YXIgZCA9IGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdFx0XHRpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmVhcmVzdEVsZW1lbnQpIHtcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0eCA9IHRwLng7XG5cdFx0XHR5ID0gdHAueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG5cdGlmICh0b1B1c2gpIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xuXHRcdFx0Ly8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiYXNlLnB1c2godG9QdXNoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XG5cdHZhciB4U2NhbGUgPSBlbGVtZW50Ll94U2NhbGU7XG5cdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHR2YXIgZGF0YXNldEluZGV4ID0gZWxlbWVudC5fZGF0YXNldEluZGV4O1xuXHR2YXIgY29udHJvbGxlciA9IGVsZW1lbnQuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XG5cdHZhciB2YWx1ZVNjYWxlID0gY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZSgpO1xuXG5cdHJldHVybiB7XG5cdFx0eExhYmVsOiB4U2NhbGUgPyB4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdHlMYWJlbDogeVNjYWxlID8geVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0dmFsdWU6IHZhbHVlU2NhbGUgPyAnJyArIHZhbHVlU2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGluZGV4OiBpbmRleCxcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHR4OiBlbGVtZW50Ll9tb2RlbC54LFxuXHRcdHk6IGVsZW1lbnQuX21vZGVsLnlcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB0b29sdGlwT3B0cyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxuXHRcdHlQYWRkaW5nOiB0b29sdGlwT3B0cy55UGFkZGluZyxcblx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcblxuXHRcdC8vIEJvZHlcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRib2R5Rm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcblxuXHRcdC8vIFRpdGxlXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X3RpdGxlRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXG5cdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdGZvb3RlclNwYWNpbmc6IHRvb2x0aXBPcHRzLmZvb3RlclNwYWNpbmcsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0b3BhY2l0eTogMCxcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHR2YXIgaGVpZ2h0ID0gbW9kZWwueVBhZGRpbmcgKiAyOyAvLyBUb29sdGlwIFBhZGRpbmdcblx0dmFyIHdpZHRoID0gMDtcblxuXHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0fSwgMCk7XG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcblx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0Ly8gVGl0bGUgd2lkdGhcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0fTtcblxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdH0pO1xuXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdC8vIEZvb3RlciB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBBZGQgcGFkZGluZ1xuXHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0cmV0dXJuIHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdHlBbGlnbiA9ICd0b3AnO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdH1cblxuXHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0fTtcblx0fVxuXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcblx0fTtcblx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XG5cdH07XG5cdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHR9O1xuXG5cdGlmIChsZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRyZXR1cm4ge1xuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHR2YXIgeCA9IHZtLng7XG5cdHZhciB5ID0gdm0ueTtcblxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggLT0gc2l6ZS53aWR0aDtcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XG5cdFx0XHR4ID0gY2hhcnQud2lkdGggLSBzaXplLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoeCA8IDApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR4OiB4LFxuXHRcdHk6IHlcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodm0sIGFsaWduKSB7XG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcblx0XHQ6IGFsaWduID09PSAncmlnaHQnXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG5cdHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxudmFyIGV4cG9ydHMkMyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9sYXN0QWN0aXZlID0gW107XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSB0aXRsZVxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0bGluZXM6IFtdLFxuXHRcdFx0XHRhZnRlcjogW11cblx0XHRcdH07XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBib2R5SXRlbXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHQvLyB3aGljaCBicmVha3MgYW55IGFuaW1hdGlvbnMuXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdHZhciBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcblx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0fTtcblx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcblx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0fTtcblxuXHRcdHZhciBpLCBsZW47XG5cblx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XG5cblx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwueSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0bW9kZWwubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXG5cdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxuXHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50LCBtZS5fY2hhcnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHR9XG5cblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblxuXHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcblxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XG5cblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcblx0fSxcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0fSxcblxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cblx0XHRpZiAodGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl90aXRsZUFsaWduO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHR2YXIgdGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XG5cdFx0XHR2YXIgdGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0udGl0bGVGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIHZtLl90aXRsZUZvbnRTdHlsZSwgdm0uX3RpdGxlRm9udEZhbWlseSk7XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aXRsZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGl0bGVbaV0sIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0aWYgKGkgKyAxID09PSB0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBib2R5Rm9udFNpemUgPSB2bS5ib2R5Rm9udFNpemU7XG5cdFx0dmFyIGJvZHlTcGFjaW5nID0gdm0uYm9keVNwYWNpbmc7XG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XG5cdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XG5cdFx0dmFyIGxhYmVsQ29sb3JzID0gdm0ubGFiZWxDb2xvcnM7XG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0dmFyIGNvbG9yWCA9IGRyYXdDb2xvckJveGVzID8gZ2V0QWxpZ25lZFgodm0sICdsZWZ0JykgOiAwO1xuXHRcdHZhciB0ZXh0Q29sb3I7XG5cblx0XHRjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XG5cblx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIGJvZHlBbGlnbik7XG5cblx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdHB0LnkgKz0gYm9keUZvbnRTaXplICsgYm9keVNwYWNpbmc7XG5cdFx0fTtcblxuXHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvZHlGb250Q29sb3I7XG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgJiYgYm9keUFsaWduICE9PSAncmlnaHQnXG5cdFx0XHQ/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm9keUZvbnRTaXplIC8gMiArIDEpIDogKGJvZHlGb250U2l6ZSArIDIpXG5cdFx0XHQ6IDA7XG5cblx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0Ly8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdm0ubGVnZW5kQ29sb3JCYWNrZ3JvdW5kO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclgsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIEJvcmRlclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gSW5uZXIgc3F1YXJlXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29sb3JYICsgMSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG5cdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcblx0fSxcblxuXHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRpZiAoZm9vdGVyLmxlbmd0aCkge1xuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xuXHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpIHtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHggPSBwdC54O1xuXHRcdHZhciB5ID0gcHQueTtcblx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHZtLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHB0ID0ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXG5cdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHQvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcblx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKTtcblxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxuXHRcdFx0cHQueSArPSB2bS55UGFkZGluZztcblxuXHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEJvZHlcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBGb290ZXJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuX2FjdGl2ZSwgbWUuX2xhc3RBY3RpdmUpO1xuXG5cdFx0Ly8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG5cdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBlLngsXG5cdFx0XHRcdFx0eTogZS55XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG59KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAqL1xudmFyIHBvc2l0aW9uZXJzXzEgPSBwb3NpdGlvbmVycztcblxudmFyIGNvcmVfdG9vbHRpcCA9IGV4cG9ydHMkMztcbmNvcmVfdG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzXzE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHt9LFxuXHRldmVudHM6IFtcblx0XHQnbW91c2Vtb3ZlJyxcblx0XHQnbW91c2VvdXQnLFxuXHRcdCdjbGljaycsXG5cdFx0J3RvdWNoc3RhcnQnLFxuXHRcdCd0b3VjaG1vdmUnXG5cdF0sXG5cdGhvdmVyOiB7XG5cdFx0b25Ib3ZlcjogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA0MDBcblx0fSxcblx0b25DbGljazogbnVsbCxcblx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0cmVzcG9uc2l2ZTogdHJ1ZSxcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXG59KTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVzYCBvcHRpb25cbiAqIGJ5IGluY29ycG9yYXRpbmcgc2NhbGUgZGVmYXVsdHMgaW4gYHhBeGVzYCBhbmQgYHlBeGVzYCBhcnJheSBpdGVtcywgdGhlblxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XG5cdFx0XHRcdHZhciBzbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuXHRcdFx0XHR2YXIgaSwgdHlwZSwgc2NhbGU7XG5cblx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcblx0XHRcdFx0XHR0eXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZS50eXBlLCBrZXkgPT09ICd4QXhlcycgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcicpO1xuXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XS5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldW2ldLnR5cGUgfHwgKHNjYWxlLnR5cGUgJiYgc2NhbGUudHlwZSAhPT0gdGFyZ2V0W2tleV1baV0udHlwZSkpIHtcblx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHR5cGUpLCBzY2FsZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgc2NhbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xuICogZGVmYXVsdCBzY2FsZSBvcHRpb25zIGZvciB0aGUgYHNjYWxlc2AgYW5kIGBzY2FsZWAgcHJvcGVydGllcywgdGhlbiByZXR1cm5zXG4gKiBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcblx0XHRcdFx0Ly8gc2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlU2NhbGVDb25maWcodHZhbCwgc3ZhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuXHRcdFx0XHQvLyB1c2VkIGluIHBvbGFyIGFyZWEgJiByYWRhciBjaGFydHMgc2luY2UgdGhlcmUgaXMgb25seSBvbmUgc2NhbGVcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzJDEubWVyZ2UodHZhbCwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIERvIE5PVCB1c2UgbWVyZ2VDb25maWcgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxuXHR2YXIgZGF0YSA9IGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdGNvbmZpZy5vcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjb25maWcudHlwZV0sXG5cdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xuXG5cdHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhjaGFydCkge1xuXHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cblx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHNjYWxlKTtcblx0fSk7XG5cblx0bmV3T3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY2hhcnQuY29uZmlnLnR5cGVdLFxuXHRcdG5ld09wdGlvbnMpO1xuXG5cdGNoYXJ0Lm9wdGlvbnMgPSBjaGFydC5jb25maWcub3B0aW9ucyA9IG5ld09wdGlvbnM7XG5cdGNoYXJ0LmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXG5cdC8vIFRvb2x0aXBcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XG5cdGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbn1cblxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdG1lLmlkID0gaGVscGVycyQxLnVpZCgpO1xuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcblx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdCAqIEBwcm9wIENoYXJ0I2NoYXJ0XG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0bWUuY29udHJvbGxlciA9IG1lOyAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cblxuXHRcdC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XG5cblx0XHQvLyBEZWZpbmUgYWxpYXMgdG8gdGhlIGNvbmZpZyBkYXRhOiBgY2hhcnQuZGF0YSA9PT0gY2hhcnQuY29uZmlnLmRhdGFgXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtZS5jb25maWcuZGF0YTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdG1lLmNvbmZpZy5kYXRhID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG5cdFx0XHQvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuXHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5pbml0aWFsaXplKCk7XG5cdFx0bWUudXBkYXRlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVJbml0Jyk7XG5cblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRtZS5iaW5kRXZlbnRzKCk7XG5cblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0bWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRcdG1lLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblx0XHRtZS5pbml0VG9vbFRpcCgpO1xuXG5cdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFN0b3BzIGFueSBjdXJyZW50IGFuaW1hdGlvbiBsb29wIG9jY3VycmluZ1xuXHRcdGNvcmVfYW5pbWF0aW9ucy5jYW5jZWxBbmltYXRpb24odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBhc3BlY3RSYXRpbyA9IChvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbWUuYXNwZWN0UmF0aW8pIHx8IG51bGw7XG5cblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XG5cdFx0Ly8gdGhlIGNhbnZhcyBkaXNwbGF5IHN0eWxlIHVzZXMgdGhlIHNhbWUgaW50ZWdlciB2YWx1ZXMgdG8gYXZvaWQgYmx1cnJpbmcgZWZmZWN0LlxuXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXG5cdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoKGNhbnZhcykpKTtcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XG5cblx0XHRpZiAobWUud2lkdGggPT09IG5ld1dpZHRoICYmIG1lLmhlaWdodCA9PT0gbmV3SGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdGlmICghc2lsZW50KSB7XG5cdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcblxuXHRcdFx0Ly8gTm90aWZ5IG9mIHJlc2l6ZVxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0b3B0aW9ucy5vblJlc2l6ZShtZSwgbmV3U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdG1lLnVwZGF0ZSh7XG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnhBeGVzLCBmdW5jdGlvbih4QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHR4QXhpc09wdGlvbnMuaWQgPSB4QXhpc09wdGlvbnMuaWQgfHwgKCd4LWF4aXMtJyArIGluZGV4KTtcblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IHlBeGlzT3B0aW9ucy5pZCB8fCAoJ3ktYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHR2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgaWQpIHtcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSwge30pO1xuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGVzKSB7XG5cdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB4QXhpc09wdGlvbnMsIGR0eXBlOiAnY2F0ZWdvcnknLCBkcG9zaXRpb246ICdib3R0b20nfTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeUF4aXNPcHRpb25zLCBkdHlwZTogJ2xpbmVhcicsIGRwb3NpdGlvbjogJ2xlZnQnfTtcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLnNjYWxlLFxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdGlzRGVmYXVsdDogdHJ1ZSxcblx0XHRcdFx0ZHBvc2l0aW9uOiAnY2hhcnRBcmVhJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG5cdFx0XHR2YXIgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cblx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcblx0XHRcdHZhciBzY2FsZSA9IG51bGw7XG5cdFx0XHRpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcblx0XHRcdFx0c2NhbGUub3B0aW9ucyA9IHNjYWxlT3B0aW9ucztcblx0XHRcdFx0c2NhbGUuY3R4ID0gbWUuY3R4O1xuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlQ2xhc3MgPSBjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdFx0dHlwZTogc2NhbGVUeXBlLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcblx0XHRcdFx0XHRjdHg6IG1lLmN0eCxcblx0XHRcdFx0XHRjaGFydDogbWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcblx0XHRcdH1cblxuXHRcdFx0c2NhbGUubWVyZ2VUaWNrc09wdGlvbnMoKTtcblxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHQvLyBhbmQgY29uc2lkZXIgaXQgYXMgYSByZWd1bGFyIHNjYWxlIHBhcnQgb2YgdGhlIFwic2NhbGVzXCJcIiBtYXAgb25seSEgVGhpcyB3b3VsZFxuXHRcdFx0Ly8gbWFrZSB0aGUgbG9naWMgZWFzaWVyIGFuZCByZW1vdmUgc29tZSB1c2VsZXNzPyBjdXN0b20gY29kZS5cblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRtZS5zY2FsZSA9IHNjYWxlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh1cGRhdGVkLCBmdW5jdGlvbihoYXNVcGRhdGVkLCBpZCkge1xuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBzY2FsZXNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bWUuc2NhbGVzID0gc2NhbGVzO1xuXG5cdFx0Y29yZV9zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcblxuXHRcdFx0aWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblxuXHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBDb250cm9sbGVyQ2xhc3MgPSBjb250cm9sbGVyc1ttZXRhLnR5cGVdO1xuXHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuXHRcdFx0fVxuXHRcdH0sIG1lKTtcblxuXHRcdHJldHVybiBuZXdDb250cm9sbGVycztcblx0fSxcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuXHRcdH0sIG1lKTtcblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXQncyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlc2V0RWxlbWVudHMoKTtcblx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dXBkYXRlQ29uZmlnKG1lKTtcblxuXHRcdC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdG1lLnRvb2x0aXAuX2RhdGEgPSBtZS5kYXRhO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcblx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLnVwZGF0ZUxheW91dCgpO1xuXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0aWYgKG1lLm9wdGlvbnMuYW5pbWF0aW9uICYmIG1lLm9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxuXHRcdC8vIGFmdGVyIHVwZGF0ZS5cblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcblxuXHRcdC8vIExhc3QgYWN0aXZlIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluIHRoZSB0b29sdGlwLlxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XG5cblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXG5cdFx0XHRcdGxhenk6IGNvbmZpZy5sYXp5XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5yZW5kZXIoY29uZmlnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGF5b3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb3JlX2xheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxuXHRcdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclNjYWxlVXBkYXRlXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1ldGEuY29udHJvbGxlci51cGRhdGUoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ4KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyUmVuZGVyJyk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XG5cdFx0fTtcblxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcblx0XHRcdFx0bnVtU3RlcHM6IGR1cmF0aW9uIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHR2YXIgc3RlcERlY2ltYWwgPSBjdXJyZW50U3RlcCAvIGFuaW1hdGlvbk9iamVjdC5udW1TdGVwcztcblxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcblx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvcmVfYW5pbWF0aW9ucy5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmNsZWFyKCk7XG5cblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoZWFzaW5nVmFsdWUpKSB7XG5cdFx0XHRlYXNpbmdWYWx1ZSA9IDE7XG5cdFx0fVxuXG5cdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRpZiAobWUud2lkdGggPD0gMCB8fCBtZS5oZWlnaHQgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgYWxsIHRoZSBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cdFx0bWUuX2RyYXdUb29sdGlwKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRmb3IgKHZhciBpID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5kcmF3RGF0YXNldChpLCBlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmF3RGF0YXNldDogZnVuY3Rpb24oaW5kZXgsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLmRyYXcoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyB0b29sdGlwIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVUb29sdGlwRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyVG9vbHRpcERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RyYXdUb29sdGlwOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVRvb2x0aXBEcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b29sdGlwLmRyYXcoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclRvb2x0aXBEcmF3JywgW2FyZ3NdKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XG5cdCAqL1xuXHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdFhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XG5cdFx0XHRkYXRhc2V0Ll9tZXRhID0ge307XG5cdFx0fVxuXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXTtcblx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXG5cdFx0XHRcdGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcblx0XHRcdFx0eUF4aXNJRDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YTtcblx0fSxcblxuXHRnZXRWaXNpYmxlRGF0YXNldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0aXNEYXRhc2V0VmlzaWJsZTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuXHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICF0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5oaWRkZW47XG5cdH0sXG5cblx0Z2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGEgJiYgZGF0YXNldC5fbWV0YVtpZF07XG5cblx0XHRpZiAobWV0YSkge1xuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuc3RvcCgpO1xuXG5cdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoaSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhbnZhcykge1xuXHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcblx0XHRcdHBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KG1lLmN0eCk7XG5cdFx0XHRtZS5jYW52YXMgPSBudWxsO1xuXHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xuXG5cdFx0ZGVsZXRlIENoYXJ0Lmluc3RhbmNlc1ttZS5pZF07XG5cdH0sXG5cblx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS50b29sdGlwID0gbmV3IGNvcmVfdG9vbHRpcCh7XG5cdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0X2NoYXJ0SW5zdGFuY2U6IG1lLCAvLyBkZXByZWNhdGVkLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRfZGF0YTogbWUuZGF0YSxcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xuXHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0fSk7XG5cblx0XHQvLyBFbGVtZW50cyB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZSBzaG91bGQgbm90IGJlIGluamVjdGVkIGZvciBub24gcmVzcG9uc2l2ZSBjaGFydHMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0bGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcblx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50cywgbW9kZSwgZW5hYmxlZCkge1xuXHRcdHZhciBtZXRob2QgPSBlbmFibGVkID8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbbWV0aG9kXShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBhbnkgdXBkYXRlIGNhbGxzIHNvIHRoYXQgcmVuZGVycyBkbyBub3Qgb2NjdXJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxuXHRcdC8vIHRoZSB0b29sdGlwIHNob3VsZCBiZSB0aGUgc291cmNlIG9mIGNoYW5nZVxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcblx0XHRcdFx0OiBjaGFuZ2VkIHwgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcblx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcblx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRtZS5yZW5kZXIoe1xuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0bGF6eTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0dmFyIGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIEludm9rZSBvbkhvdmVyIGhvb2tcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdH1cblxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxuICogd291bGQgbmVlZCB0byB3b3JrIG9uIG11bHRpcGxlIGNoYXJ0cz8hXG4gKi9cbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuY29uZmlnTWVyZ2UgPSBtZXJnZUNvbmZpZztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5zY2FsZU1lcmdlID0gbWVyZ2VTY2FsZUNvbmZpZztcblxudmFyIGNvcmVfaGVscGVycyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xuXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgYXJyYXlUb1NlYXJjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycyQxLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgoKHJvdW5kZWQgLSBlcHNpbG9uKSA8IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID4geCkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLmxvZzEwID0gTWF0aC5sb2cxMCA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTsgLy8gTWF0aC5MT0cxMEUgPSAxIC8gTWF0aC5MTjEwLlxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHdob2xlIHBvd2VycyBvZiAxMCxcblx0XHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxuXHRcdFx0dmFyIHBvd2VyT2YxMCA9IE1hdGgucm91bmQoZXhwb25lbnQpO1xuXHRcdFx0dmFyIGlzUG93ZXJPZjEwID0geCA9PT0gTWF0aC5wb3coMTAsIHBvd2VyT2YxMCk7XG5cblx0XHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xuXHRcdH07XG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdH07XG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQSBudW1iZXIuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGUgPSAxO1xuXHRcdHZhciBwID0gMDtcblx0XHR3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG5cdFx0XHRlICo9IDEwO1xuXHRcdFx0cCsrO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fTtcblxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuXHRoZWxwZXJzJDEuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG5cdFx0dmFyIHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbmdsZTogYW5nbGUsXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hbGlhc1BpeGVsXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XG5cdFx0cmV0dXJuIChwaXhlbFdpZHRoICUgMiA9PT0gMCkgPyAwIDogMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcblx0XHR2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuXHRcdHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcblx0fTtcblxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuXHRcdC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcblx0XHR2YXIgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuXG5cdFx0dmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50LnggLSBwcmV2aW91cy54LCAyKSArIE1hdGgucG93KGN1cnJlbnQueSAtIHByZXZpb3VzLnksIDIpKTtcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcblxuXHRcdHZhciBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cblx0XHQvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcblx0XHR2YXIgZmIgPSB0ICogczEyO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZXZpb3VzOiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHtcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLkVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRBZnRlci5tSyA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG5cdFx0XHRwb2ludEN1cnJlbnQubUsgPSBhbHBoYUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcblx0XHR2YXIgZGVsdGFYO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRDdXJyZW50Lm1vZGVsLnggLSBwb2ludEJlZm9yZS5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggKyBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcblx0XHRpZiAobG9vcCkge1xuXHRcdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdH07XG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzJDEubmljZU51bSA9IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHJhbmdlKSk7XG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHRcdHZhciBuaWNlRnJhY3Rpb247XG5cblx0XHRpZiAocm91bmQpIHtcblx0XHRcdGlmIChmcmFjdGlvbiA8IDEuNSkge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCA3KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDEuMCkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmljZUZyYWN0aW9uICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0fTtcblx0Ly8gUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGwgLSBodHRwczovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSgpKTtcblx0Ly8gLS0gRE9NIG1ldGhvZHNcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XG5cdFx0dmFyIG1vdXNlWCwgbW91c2VZO1xuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xuXHRcdHZhciBib3VuZGluZ1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcblx0XHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSBlLmNsaWVudFk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgbW91c2UgY29vcmRpbmF0ZXMgaW50byBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWxlZnQnKSk7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXRvcCcpKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctYm90dG9tJykpO1xuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcblx0XHRtb3VzZVggPSBNYXRoLnJvdW5kKChtb3VzZVggLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0KSAvICh3aWR0aCkgKiBjYW52YXMud2lkdGggLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IG1vdXNlWCxcblx0XHRcdHk6IG1vdXNlWVxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcblx0XHR2YXIgdmFsdWVJblBpeGVscztcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuXHRcdFx0XHR2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZUluUGl4ZWxzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXggd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBnaXZlbiBET00gbm9kZSBpbiBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSBmYXNoaW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbU5vZGUgLSB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwZXJjZW50YWdlUHJvcGVydHkgLSBwcm9wZXJ0eSBvZiBwYXJlbnQgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgd2lkdGggYXMgYSBwZXJjZW50YWdlXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3Nlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgbWF4U3R5bGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkge1xuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0dmFyIGNvbnN0cmFpbmVkTm9kZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcblx0XHR2YXIgaGFzQ0NvbnRhaW5lciA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZENvbnRhaW5lcik7XG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc0NOb2RlIHx8IGhhc0NDb250YWluZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbihcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxuXHRcdFx0XHRoYXNDQ29udGFpbmVyID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC13aWR0aCcsICdjbGllbnRXaWR0aCcpO1xuXHR9O1xuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG4gXHQgKi9cblx0aGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYWRkaW5nLCBwYXJlbnREaW1lbnNpb24pIHtcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XG5cblx0XHRyZXR1cm4gcGFkZGluZy5pbmRleE9mKCclJykgPiAtMSA/IHBhcmVudERpbWVuc2lvbiAqIHBhcnNlSW50KHBhZGRpbmcsIDEwKSAvIDEwMCA6IHBhcnNlSW50KHBhZGRpbmcsIDEwKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5ob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyZW50O1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1yaWdodCcsIGNsaWVudFdpZHRoKTtcblxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgY3cgPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoKGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjdykgPyB3IDogTWF0aC5taW4odywgY3cpO1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy10b3AnLCBjbGllbnRIZWlnaHQpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcblxuXHRcdHZhciBoID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGNoKSA/IGggOiBNYXRoLm1pbihoLCBjaCk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycyQxLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG5cdFx0aWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2hhcnQud2lkdGg7XG5cblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuXHRcdGlmICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSB7XG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHR9XG5cdH07XG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXG5cdGhlbHBlcnMkMS5mb250U3RyaW5nID0gZnVuY3Rpb24ocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXHR9O1xuXHRoZWxwZXJzJDEubG9uZ2VzdFRleHQgPSBmdW5jdGlvbihjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuXHRcdHZhciBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuXHRcdFx0ZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xuXHRcdH1cblxuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHR2YXIgbG9uZ2VzdCA9IDA7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0XHQvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKHRoaW5nLCBmdW5jdGlvbihuZXN0ZWRUaGluZykge1xuXHRcdFx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzJDEuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xuXHRcdFx0fVxuXHRcdFx0Z2Muc3BsaWNlKDAsIGdjTGVuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG5cdFx0aWYgKCF0ZXh0V2lkdGgpIHtcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5jb2xvciA9ICFjaGFydGpzQ29sb3IgP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xuXHRcdFx0Y29sb3JWYWx1ZSA6XG5cdFx0XHRoZWxwZXJzJDEuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXG5cdCk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxuICogQHR5cGVkZWYgeygnbWlsbGlzZWNvbmQnfCdzZWNvbmQnfCdtaW51dGUnfCdob3VyJ3wnZGF5J3wnd2Vlayd8J21vbnRoJ3wncXVhcnRlcid8J3llYXInKX1cbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBuYW1lIFVuaXRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIERhdGVBZGFwdGVyICovIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuXHQgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cblx0ICovXG5cdGZvcm1hdHM6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcblx0ICogQHJldHVybnMgeyhudW1iZXJ8bnVsbCl9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0cGFyc2U6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGZvcm1hdDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRhZGQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSB0aGUgdGltZXN0YW1wIHRvIHN1YnN0cmFjdFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGRpZmY6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcblx0ICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRzdGFydE9mOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGVuZE9mOiBhYnN0cmFjdCxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcblxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xudmFyIGNvcmVfdGlja3MgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3Ncblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHR2YXIgdGlja1N0cmluZyA9ICcnO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHZhciBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0pLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChNYXRoLmZsb29yKGxvZ1RpY2spIC0gTWF0aC5mbG9vcihsb2dEZWx0YSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2tTdHJpbmcgPSAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XG5cdFx0fSxcblxuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJzAnO1xuXHRcdFx0fSBlbHNlIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ5ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhbGUnLCB7XG5cdGRpc3BsYXk6IHRydWUsXG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cdG9mZnNldDogZmFsc2UsXG5cblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXG5cdGdyaWRMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcblx0XHRkcmF3VGlja3M6IHRydWUsXG5cdFx0dGlja01hcmtMZW5ndGg6IDEwLFxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXG5cdFx0emVyb0xpbmVDb2xvcjogJ3JnYmEoMCwwLDAsMC4yNSknLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0b2Zmc2V0R3JpZExpbmVzOiBmYWxzZSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHQvLyBzY2FsZSBsYWJlbFxuXHRzY2FsZUxhYmVsOiB7XG5cdFx0Ly8gZGlzcGxheSBwcm9wZXJ0eVxuXHRcdGRpc3BsYXk6IGZhbHNlLFxuXG5cdFx0Ly8gYWN0dWFsIGxhYmVsXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxuXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiA0LFxuXHRcdFx0Ym90dG9tOiA0XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxuXHRcdG1pblJvdGF0aW9uOiAwLFxuXHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRtaXJyb3I6IGZhbHNlLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRhdXRvU2tpcDogdHJ1ZSxcblx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG5cdFx0bWlub3I6IHt9LFxuXHRcdG1ham9yOiB7fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGFiZWxzRnJvbVRpY2tzKHRpY2tzKSB7XG5cdHZhciBsYWJlbHMgPSBbXTtcblx0dmFyIGksIGlsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxhYmVscy5wdXNoKHRpY2tzW2ldLmxhYmVsKTtcblx0fVxuXG5cdHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCk7XG5cblx0aWYgKG9mZnNldEdyaWRMaW5lcykge1xuXHRcdGlmIChzY2FsZS5nZXRUaWNrcygpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGluZVZhbHVlIC09IHNjYWxlLmlzSG9yaXpvbnRhbCgpID9cblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUubGVmdCwgc2NhbGUucmlnaHQgLSBsaW5lVmFsdWUpIDpcblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUudG9wLCBzY2FsZS5ib3R0b20gLSBsaW5lVmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4IC0gMSkpIC8gMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRleHRTaXplKGNvbnRleHQsIHRpY2ssIGZvbnQpIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHRpY2spID9cblx0XHRoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgZm9udCwgdGljaykgOlxuXHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG59XG5cbnZhciBjb3JlX3NjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtQYWRkaW5nfSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICovXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXG5cdFx0XHR0b3A6IG1lLnBhZGRpbmdUb3AgfHwgMCxcblx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cblx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90aWNrcztcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWxlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0aWYgKHRpY2tzLm1pbm9yID09PSBmYWxzZSkge1xuXHRcdFx0dGlja3MubWlub3IgPSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAodGlja3MubWFqb3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5tYWpvciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiB0aWNrcykge1xuXHRcdFx0aWYgKGtleSAhPT0gJ21ham9yJyAmJiBrZXkgIT09ICdtaW5vcicpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5taW5vcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1pbm9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWFqb3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aWNrcy5tYWpvcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBpbGVuLCBsYWJlbHMsIGxhYmVsLCB0aWNrcywgdGljaztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRib3R0b206IDBcblx0XHR9LCBtYXJnaW5zKTtcblxuXHRcdG1lLl9tYXhMYWJlbExpbmVzID0gMDtcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XG5cdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdC8vIERhdGEgbWluL21heFxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG5cblx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcblx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXG5cblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcblxuXHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxuXHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xuXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcblxuXHRcdC8vIElNUE9SVEFOVDogZnJvbSB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuXHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHR0aWNrID0gdGlja3NbaV07XG5cdFx0XHRpZiAoIXRpY2spIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aWNrID0ge1xuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRtYWpvcjogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuX3RpY2tzID0gdGlja3M7XG5cblx0XHQvLyBUaWNrIFJvdGF0aW9uXG5cdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBEYXRhIGxpbWl0c1xuXHRiZWZvcmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckRhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cdGJlZm9yZUJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQnVpbGRUaWNrcywgW3RoaXNdKTtcblx0fSxcblx0YnVpbGRUaWNrczogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIHRpY2tzIGlzIGVtcHR5IGZvciBvbGQgYXhpcyBpbXBsZW1lbnRhdGlvbnMgaGVyZVxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIHRpY2tzXSk7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcblx0XHRtZS50aWNrcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCBtZS50aWNrc10pIHx8IG1lLnRpY2tzO1xuXHRcdHJldHVybiB0aWNrcztcblx0fSxcblxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XG5cdH0sXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2Vcblx0XHQvLyBiZXR3ZWVuIHggb2Zmc2V0cyBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0Y29udGV4dC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGggJiYgbWUub3B0aW9ucy5kaXNwbGF5ICYmIG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxMYWJlbFdpZHRoID0gaGVscGVycyQxLmxvbmdlc3RUZXh0KGNvbnRleHQsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciBsYWJlbFdpZHRoID0gb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uLCBzaW5Sb3RhdGlvbjtcblxuXHRcdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcblx0XHRcdHZhciB0aWNrV2lkdGggPSBtZS5nZXRQaXhlbEZvclRpY2soMSkgLSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSA2O1xuXG5cdFx0XHQvLyBNYXggbGFiZWwgcm90YXRpb24gY2FuIGJlIHNldCBvciBkZWZhdWx0IHRvIDkwIC0gYWxzbyBhY3QgYXMgYSBsb29wIGNvdW50ZXJcblx0XHRcdHdoaWxlIChsYWJlbFdpZHRoID4gdGlja1dpZHRoICYmIGxhYmVsUm90YXRpb24gPCB0aWNrT3B0cy5tYXhSb3RhdGlvbikge1xuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhsYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0Y29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0aWYgKHNpblJvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoID4gbWUubWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0Ly8gZ28gYmFjayBvbmUgc3RlcFxuXHRcdFx0XHRcdGxhYmVsUm90YXRpb24tLTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxhYmVsUm90YXRpb24rKztcblx0XHRcdFx0bGFiZWxXaWR0aCA9IGNvc1JvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuXHR9LFxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG5cdH0sXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBSZXNldFxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblxuXHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5faXNWaXNpYmxlKCk7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbjtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgcGFyc2VGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udDtcblx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnQodGlja09wdHMpO1xuXHRcdHZhciB0aWNrTWFya0xlbmd0aCA9IG9wdHMuZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoO1xuXG5cdFx0Ly8gV2lkdGhcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgbWFyZ2lucyB0byBsaW5lIHVwIHdpdGggdGhlIGNoYXJ0QXJlYSBpZiB3ZSBhcmUgYSBmdWxsIHdpZHRoIHNjYWxlXG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1heFdpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodCA6IG1lLm1heFdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH1cblxuXHRcdC8vIGhlaWdodFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEFyZSB3ZSBzaG93aW5nIGEgdGl0bGUgZm9yIHRoZSBzY2FsZT9cblx0XHRpZiAoc2NhbGVMYWJlbE9wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnQoc2NhbGVMYWJlbE9wdHMpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0dmFyIGRlbHRhSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLmhlaWdodDtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG5cdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0dmFyIGxhcmdlc3RUZXh0V2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5zdHJpbmcsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHR2YXIgdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyA9IGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMobGFiZWxzKTtcblx0XHRcdHZhciBsaW5lU3BhY2UgPSB0aWNrRm9udC5zaXplICogMC41O1xuXHRcdFx0dmFyIHRpY2tQYWRkaW5nID0gbWUub3B0aW9ucy50aWNrcy5wYWRkaW5nO1xuXG5cdFx0XHQvLyBTdG9yZSBtYXggbnVtYmVyIG9mIGxpbmVzIGFuZCB3aWRlc3QgbGFiZWwgZm9yIF9hdXRvU2tpcFxuXHRcdFx0bWUuX21heExhYmVsTGluZXMgPSB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzO1xuXHRcdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSBsYXJnZXN0VGV4dFdpZHRoO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdC8vIFRPRE8gLSBpbXByb3ZlIHRoaXMgY2FsY3VsYXRpb25cblx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHQrICh0aWNrRm9udC5saW5lSGVpZ2h0ICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcylcblx0XHRcdFx0XHQrIGxpbmVTcGFjZTsgLy8gcGFkZGluZ1xuXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuXG5cdFx0XHRcdG1lLmN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXHRcdFx0XHR2YXIgZmlyc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzWzBdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgbGFzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGxhYmVscy5sZW5ndGggLSAxKTtcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG5cdFx0XHRcdGlmIChtZS5sYWJlbFJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBmaXJzdExhYmVsV2lkdGgpIDogKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKTtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpIDogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gZmlyc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQsIDApICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0LCAwKSArIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcblx0XHRcdFx0aWYgKHRpY2tPcHRzLm1pcnJvcikge1xuXHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVzZSBsaW5lU3BhY2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCArPSB0aWNrUGFkZGluZyArIGxpbmVTcGFjZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5tYXJnaW5zKSB7XG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0IC0gbWUubWFyZ2lucy5sZWZ0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wIC0gbWUubWFyZ2lucy50b3AsIDApO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0IC0gbWUubWFyZ2lucy5yaWdodCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSAtIG1lLm1hcmdpbnMuYm90dG9tLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3Rcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHQvLyBOdWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZpcnN0XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdGlmICgodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyB8fCByYXdWYWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRpZiAocmF3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLngpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFZhbHVlIGlzIGdvb2QsIHJldHVybiBpdFxuXHRcdHJldHVybiByYXdWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldFBpeGVsRm9yVmFsdWU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHBpeGVsXG5cdCAqL1xuXHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdFx0dmFyIHBpeGVsID0gKHRpY2tXaWR0aCAqIGluZGV4KSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHBpeGVsICs9IHRpY2tXaWR0aCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBwaXhlbDtcblx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdH1cblx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xuXHRcdHJldHVybiBtZS50b3AgKyAoaW5kZXggKiAoaW5uZXJIZWlnaHQgLyAobWUuX3RpY2tzLmxlbmd0aCAtIDEpKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yRGVjaW1hbDogZnVuY3Rpb24oZGVjaW1hbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChpbm5lcldpZHRoICogZGVjaW1hbCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHZhbHVlT2Zmc2V0O1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHJldHVybiBtZS50b3AgKyAoZGVjaW1hbCAqIG1lLmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcblx0fSxcblxuXHRnZXRCYXNlVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYXV0b1NraXA6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgdGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuXHRcdHZhciBza2lwUmF0aW8gPSBmYWxzZTtcblx0XHR2YXIgbWF4VGlja3MgPSBvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0O1xuXG5cdFx0Ly8gVG90YWwgc3BhY2UgbmVlZGVkIHRvIGRpc3BsYXkgYWxsIHRpY2tzLiBGaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmVcblx0XHQvLyBkcmF3biBhcyB0aGVpciBjZW50ZXIgYXQgZW5kIG9mIGF4aXMsIHNvIHRpY2tDb3VudC0xXG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gbWUuX3RpY2tTaXplKCkgKiAodGlja0NvdW50IC0gMSk7XG5cblx0XHQvLyBBeGlzIGxlbmd0aFxuXHRcdHZhciBheGlzTGVuZ3RoID0gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KVxuXHRcdFx0OiBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLlBhZGRpbmdCb3R0b20pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpLCB0aWNrO1xuXG5cdFx0aWYgKHRpY2tzTGVuZ3RoID4gYXhpc0xlbmd0aCkge1xuXHRcdFx0c2tpcFJhdGlvID0gMSArIE1hdGguZmxvb3IodGlja3NMZW5ndGggLyBheGlzTGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGV5IGRlZmluZWQgYSBtYXggbnVtYmVyIG9mIG9wdGlvblRpY2tzLFxuXHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRpZiAodGlja0NvdW50ID4gbWF4VGlja3MpIHtcblx0XHRcdHNraXBSYXRpbyA9IE1hdGgubWF4KHNraXBSYXRpbywgMSArIE1hdGguZmxvb3IodGlja0NvdW50IC8gbWF4VGlja3MpKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblxuXHRcdFx0aWYgKHNraXBSYXRpbyA+IDEgJiYgaSAlIHNraXBSYXRpbyA+IDApIHtcblx0XHRcdFx0Ly8gbGVhdmUgdGljayBpbiBwbGFjZSBidXQgbWFrZSBzdXJlIGl0J3Mgbm90IGRpc3BsYXllZCAoIzQ2MzUpXG5cdFx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2godGljayk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdGlja1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHZhciByb3QgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdHZhciBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuXHRcdHZhciB3ID0gKG1lLmxvbmdlc3RMYWJlbFdpZHRoICsgcGFkZGluZykgfHwgMDtcblxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9uVGlja3MpO1xuXHRcdHZhciBoID0gKG1lLl9tYXhMYWJlbExpbmVzICogdGlja0ZvbnQubGluZUhlaWdodCArIHBhZGRpbmcpIHx8IDA7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0cmV0dXJuIGlzSG9yaXpvbnRhbFxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuXHRcdFx0cmV0dXJuICEhZGlzcGxheTtcblx0XHR9XG5cblx0XHQvLyBXaGVuICdhdXRvJywgdGhlIHNjYWxlIGlzIHZpc2libGUgaWYgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgZGF0YXNldCBpcyB2aXNpYmxlLlxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFjdHVhbGx5IGRyYXcgdGhlIHNjYWxlIG9uIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYSAtIHRoZSBhcmVhIG9mIHRoZSBjaGFydCB0byBkcmF3IGZ1bGwgZ3JpZCBsaW5lcyBvblxuXHQgKi9cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Rm9udENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcjtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBvcHRpb25NYWpvclRpY2tzID0gb3B0aW9ucy50aWNrcy5tYWpvciB8fCBvcHRpb25UaWNrcztcblx0XHR2YXIgZ3JpZExpbmVzID0gb3B0aW9ucy5ncmlkTGluZXM7XG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuXHRcdHZhciBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrcyA9IG9wdGlvblRpY2tzLmRpc3BsYXkgJiYgb3B0aW9uVGlja3MuYXV0b1NraXAgPyBtZS5fYXV0b1NraXAobWUuZ2V0VGlja3MoKSkgOiBtZS5nZXRUaWNrcygpO1xuXHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShvcHRpb25UaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuXHRcdHZhciBtYWpvclRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvbk1ham9yVGlja3MuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgbWFqb3JUaWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25NYWpvclRpY2tzKTtcblx0XHR2YXIgdGlja1BhZGRpbmcgPSBvcHRpb25UaWNrcy5wYWRkaW5nO1xuXHRcdHZhciBsYWJlbE9mZnNldCA9IG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuXG5cdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHR2YXIgc2NhbGVMYWJlbEZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGVMYWJlbC5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsKTtcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHR2YXIgbGFiZWxSb3RhdGlvblJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0dmFyIGl0ZW1zVG9EcmF3ID0gW107XG5cblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xuXHRcdHZhciBib3JkZXJWYWx1ZSwgdGlja1N0YXJ0LCB0aWNrRW5kO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gYm9yZGVyVmFsdWUgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0dGlja0VuZCA9IG1lLnRvcCArIHRsO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR0aWNrRW5kID0gYm9yZGVyVmFsdWUgLSBheGlzV2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUubGVmdCArIHRsO1xuXHRcdH1cblxuXHRcdHZhciBlcHNpbG9uID0gMC4wMDAwMDAxOyAvLyAwLjAwMDAwMDEgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgQWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRoZWxwZXJzJDEuZWFjaCh0aWNrcywgZnVuY3Rpb24odGljaywgaW5kZXgpIHtcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aWNrLmxhYmVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYWJlbCA9IHRpY2subGFiZWw7XG5cdFx0XHR2YXIgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRpZiAoaW5kZXggPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIGluZGV4KTtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoIHx8IFtdO1xuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gcHJvcGVydGllc1xuXHRcdFx0dmFyIHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTIsIGxhYmVsWCwgbGFiZWxZLCB0ZXh0T2Zmc2V0LCB0ZXh0QWxpZ247XG5cdFx0XHR2YXIgbGFiZWxDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG5cdFx0XHR2YXIgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBsYWJlbFlPZmZzZXQgPSB0bCArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS5sZWZ0IC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cdFx0XHRcdHR5MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHkyID0gdGlja0VuZDtcblx0XHRcdFx0bGFiZWxYID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0OyAvLyB4IHZhbHVlcyBmb3Igb3B0aW9uVGlja3MgKG5lZWQgdG8gY29uc2lkZXIgb2Zmc2V0TGFiZWwgb3B0aW9uKVxuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHR5MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS50b3AsIGF4aXNXaWR0aCkgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCghaXNSb3RhdGVkID8gMC41IDogMSkgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ2xlZnQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLmJvdHRvbSAtIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5MSA9IGNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEuYm90dG9tLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCFpc1JvdGF0ZWQgPyAwLjUgOiAwKSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsYWJlbFhPZmZzZXQgPSAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRpZiAobGluZVZhbHVlIDwgbWUudG9wIC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHgyID0gdGlja0VuZDtcblx0XHRcdFx0dHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0bGFiZWxZID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0O1xuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEubGVmdCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eDIgPSBjaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcblx0XHRcdFx0XHR4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5yaWdodCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUubGVmdCArIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpdGVtc1RvRHJhdy5wdXNoKHtcblx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0bGFiZWxYOiBsYWJlbFgsXG5cdFx0XHRcdGxhYmVsWTogbGFiZWxZLFxuXHRcdFx0XHRnbFdpZHRoOiBsaW5lV2lkdGgsXG5cdFx0XHRcdGdsQ29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0Z2xCb3JkZXJEYXNoOiBib3JkZXJEYXNoLFxuXHRcdFx0XHRnbEJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdHJvdGF0aW9uOiAtMSAqIGxhYmVsUm90YXRpb25SYWRpYW5zLFxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdG1ham9yOiB0aWNrLm1ham9yLFxuXHRcdFx0XHR0ZXh0T2Zmc2V0OiB0ZXh0T2Zmc2V0LFxuXHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGljayBsYWJlbHMsIHRpY2sgbWFya3MsIGFuZCBncmlkIGxpbmVzIGF0IHRoZSBjb3JyZWN0IHBsYWNlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGl0ZW1zVG9EcmF3LCBmdW5jdGlvbihpdGVtVG9EcmF3KSB7XG5cdFx0XHR2YXIgZ2xXaWR0aCA9IGl0ZW1Ub0RyYXcuZ2xXaWR0aDtcblx0XHRcdHZhciBnbENvbG9yID0gaXRlbVRvRHJhdy5nbENvbG9yO1xuXG5cdFx0XHRpZiAoZ3JpZExpbmVzLmRpc3BsYXkgJiYgZ2xXaWR0aCAmJiBnbENvbG9yKSB7XG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGdsV2lkdGg7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnbENvbG9yO1xuXHRcdFx0XHRpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0TGluZURhc2goaXRlbVRvRHJhdy5nbEJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LnR4MSwgaXRlbVRvRHJhdy50eTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcudHgyLCBpdGVtVG9EcmF3LnR5Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcueDEsIGl0ZW1Ub0RyYXcueTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcueDIsIGl0ZW1Ub0RyYXcueTIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdGNvbnRleHQucm90YXRlKGl0ZW1Ub0RyYXcucm90YXRpb24pO1xuXHRcdFx0XHRjb250ZXh0LmZvbnQgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udC5zdHJpbmcgOiB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnRDb2xvciA6IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0dmFyIGxhYmVsID0gaXRlbVRvRHJhdy5sYWJlbDtcblx0XHRcdFx0dmFyIHkgPSBpdGVtVG9EcmF3LnRleHRPZmZzZXQ7XG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KCcnICsgbGFiZWxbaV0sIDAsIHkpO1xuXHRcdFx0XHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCB5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChzY2FsZUxhYmVsLmRpc3BsYXkpIHtcblx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHR2YXIgc2NhbGVMYWJlbFg7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFk7XG5cdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0dmFyIGhhbGZMaW5lSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCAvIDI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgKChtZS5yaWdodCAtIG1lLmxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHRzY2FsZUxhYmVsWSA9IHBvc2l0aW9uID09PSAnYm90dG9tJ1xuXHRcdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cblx0XHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XG5cdFx0XHRcdFx0PyBtZS5sZWZ0ICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3Bcblx0XHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgKChtZS5ib3R0b20gLSBtZS50b3ApIC8gMik7XG5cdFx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XG5cdFx0XHRjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gc2NhbGVMYWJlbEZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjb250ZXh0LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5zdHJpbmc7XG5cdFx0XHRjb250ZXh0LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xuXHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZSBhdCB0aGUgZWRnZSBvZiB0aGUgYXhpc1xuXHRcdFx0dmFyIGZpcnN0TGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgdGlja3MubGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkxID0geTIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkyID0gYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG5cdFx0XHRjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0cG9zaXRpb246ICdib3R0b20nXG59O1xuXG52YXIgc2NhbGVfY2F0ZWdvcnkgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdC8qKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHQqIGVsc2UgZmFsbCBiYWNrIHRvIGRhdGEubGFiZWxzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0bWUubWluSW5kZXggPSAwO1xuXHRcdG1lLm1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG5cdFx0dmFyIGZpbmRJbmRleDtcblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWluKTtcblx0XHRcdG1lLm1pbkluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1pbkluZGV4O1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtYXggdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWF4KTtcblx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGxhYmVsc1ttZS5taW5JbmRleF07XG5cdFx0bWUubWF4ID0gbGFiZWxzW21lLm1heEluZGV4XTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuXHRcdG1lLnRpY2tzID0gKG1lLm1pbkluZGV4ID09PSAwICYmIG1lLm1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWUubWluSW5kZXgsIG1lLm1heEluZGV4ICsgMSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cblx0XHRpZiAoY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gbWUuaWQpIHtcblx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lLnRpY2tzW2luZGV4IC0gbWUubWluSW5kZXhdO1xuXHR9LFxuXG5cdC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiAgVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHQvLyAxIGlzIGFkZGVkIGJlY2F1c2Ugd2UgbmVlZCB0aGUgbGVuZ3RoIGJ1dCB3ZSBoYXZlIHRoZSBpbmRleGVzXG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblxuXHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxuXHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHR2YWx1ZUNhdGVnb3J5ID0gbWUuaXNIb3Jpem9udGFsKCkgPyB2YWx1ZS54IDogdmFsdWUueTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHR2YXIgaWR4ID0gbGFiZWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgdmFsdWVXaWR0aCA9IG1lLndpZHRoIC8gb2Zmc2V0QW10O1xuXHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHdpZHRoT2Zmc2V0ICs9ICh2YWx1ZVdpZHRoIC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS5sZWZ0ICsgd2lkdGhPZmZzZXQ7XG5cdFx0fVxuXHRcdHZhciB2YWx1ZUhlaWdodCA9IG1lLmhlaWdodCAvIG9mZnNldEFtdDtcblx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKHZhbHVlSGVpZ2h0ICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdGhlaWdodE9mZnNldCArPSAodmFsdWVIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudG9wICsgaGVpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwpO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHR2YXIgaG9yeiA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciB2YWx1ZURpbWVuc2lvbiA9IChob3J6ID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gb2Zmc2V0QW10O1xuXG5cdFx0cGl4ZWwgLT0gaG9yeiA/IG1lLmxlZnQgOiBtZS50b3A7XG5cblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRwaXhlbCAtPSAodmFsdWVEaW1lbnNpb24gLyAyKTtcblx0XHR9XG5cblx0XHRpZiAocGl4ZWwgPD0gMCkge1xuXHRcdFx0dmFsdWUgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlICsgbWUubWluSW5kZXg7XG5cdH0sXG5cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMgPSBkZWZhdWx0Q29uZmlnO1xuc2NhbGVfY2F0ZWdvcnkuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuXG52YXIgbm9vcCA9IGhlbHBlcnMkMS5ub29wO1xudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3Ncblx0Ly8gZm9yIGRldGFpbHMuXG5cblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XG5cdHZhciBzdGVwU2l6ZSA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XG5cdHZhciBtaW4gPSBnZW5lcmF0aW9uT3B0aW9ucy5taW47XG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XG5cdHZhciBybWluID0gZGF0YVJhbmdlLm1pbjtcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdHZhciBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuXHQvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZihtaW4pICYmIGlzTnVsbE9yVW5kZWYobWF4KSkge1xuXHRcdHJldHVybiBbcm1pbiwgcm1heF07XG5cdH1cblxuXHRudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcblx0XHQvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuXHRcdHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuXHR9XG5cblx0aWYgKHN0ZXBTaXplIHx8IGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuXHRcdC8vIElmIGEgcHJlY2lzaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmYWN0b3IgYmFzZWQgb24gc3BhY2luZ1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0bmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1pbikgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1pbiAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1pbiA9IG1pbjtcblx0XHR9XG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1heCkgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1heCAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1heCA9IG1heDtcblx0XHR9XG5cdH1cblxuXHRudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuXHR9IGVsc2Uge1xuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xuXHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XG5cdH1cblx0dGlja3MucHVzaChpc051bGxPclVuZGVmKG1heCkgPyBuaWNlTWF4IDogbWF4KTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBzY2FsZV9saW5lYXJiYXNlID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XG5cdFx0Ly8gYXhpcywgdGhleSBjYW4gbWFudWFsbHkgb3ZlcnJpZGUgaXRcblx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcblx0XHRcdHZhciBtYXhTaWduID0gaGVscGVycyQxLnNpZ24obWUubWF4KTtcblxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIHRvcCB1cCB0byAwXG5cdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIGJvdHRvbSBkb3duIHRvIDBcblx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHNldE1heCA9IHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5taW47XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5zdWdnZXN0ZWRNaW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIHRpY2tPcHRzLnN1Z2dlc3RlZE1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNldE1pbiAhPT0gc2V0TWF4KSB7XG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cblx0XHRcdC8vIFNvIGVuc3VyZSB0aGF0IG91ciByYW5nZSBpcyBnb29kXG5cdFx0XHQvLyBJbnZlcnRlZCBvciAwIGxlbmd0aCByYW5nZSBjYW4gaGFwcGVuIHdoZW5cblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxuXHRcdFx0aWYgKG1lLm1pbiA+PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKHNldE1pbikge1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWF4IC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdGlmICghdGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0bWUubWluLS07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBzdGVwU2l6ZSA9IHRpY2tPcHRzLnN0ZXBTaXplO1xuXHRcdHZhciBtYXhUaWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdDtcblx0XHR2YXIgbWF4VGlja3M7XG5cblx0XHRpZiAoc3RlcFNpemUpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF4VGlja3MgPSBtZS5fY29tcHV0ZVRpY2tMaW1pdCgpO1xuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXhUaWNrcztcblx0fSxcblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0fSxcblxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuXHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuXHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuXHRcdHZhciBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuXHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0dmFyIG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuXHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRtYXg6IHRpY2tPcHRzLm1heCxcblx0XHRcdHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgbWUpO1xuXG5cdFx0bWUuaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzKCk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRtZS56ZXJvTGluZUluZGV4ID0gbWUudGlja3MuaW5kZXhPZigwKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9XG59O1xuXG52YXIgc2NhbGVfbGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxO1xuXG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBGaXJzdCBDYWxjdWxhdGUgdGhlIHJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlczogW10sXG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlc2UgcGVyIHR5cGVcblx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0dmFyIG5lZ2F0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5uZWdhdGl2ZVZhbHVlcztcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gcG9zaXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gPSBuZWdhdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gMTAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc0ZvclR5cGUucG9zaXRpdmVWYWx1ZXMuY29uY2F0KHZhbHVlc0ZvclR5cGUubmVnYXRpdmVWYWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycyQxLm1heCh2YWx1ZXMpO1xuXHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5taW4gPSBpc0Zpbml0ZShtZS5taW4pICYmICFpc05hTihtZS5taW4pID8gbWUubWluIDogREVGQVVMVF9NSU47XG5cdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tGb250O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xuXHRcdH1cblx0XHR0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobWUub3B0aW9ucy50aWNrcyk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcblx0fSxcblxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHQvLyBVdGlsc1xuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0Ly8gdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5yaWdodCwgYW5kIHRoaXMuYm90dG9tIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdHZhciByaWdodFZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdHZhciBwaXhlbDtcblx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKG1lLndpZHRoIC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgb2Zmc2V0ID0gKGlzSG9yaXpvbnRhbCA/IHBpeGVsIC0gbWUubGVmdCA6IG1lLmJvdHRvbSAtIHBpeGVsKSAvIGlubmVyRGltZW5zaW9uO1xuXHRcdHJldHVybiBtZS5zdGFydCArICgobWUuZW5kIC0gbWUuc3RhcnQpICogb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMSA9IGRlZmF1bHRDb25maWckMTtcbnNjYWxlX2xpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cblx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWF4KSk7XG5cdHZhciBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuXHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcblxuXHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW5Ob3RaZXJvIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSBlbHNlIHtcblx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdH1cblx0dmFyIHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuXG5cdGRvIHtcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0KytzaWduaWZpY2FuZDtcblx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHQrK2V4cDtcblx0XHRcdHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcblx0XHR9XG5cblx0XHR0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQkYShnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDIgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdH1cbn07XG5cbi8vIFRPRE8odjMpOiBjaGFuZ2UgdGhpcyB0byBwb3NpdGl2ZU9yRGVmYXVsdFxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gfHwgdmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc0ZvclR5cGUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gMCAmJiAobWUubWluTm90WmVybyA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1lLm1pbk5vdFplcm8pKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4XG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBERUZBVUxUX01JTiA9IDE7XG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XG5cblx0XHRtZS5taW4gPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4sIG1lLm1pbik7XG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgLSAxKTtcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcblx0XHRcdFx0bWUubWF4ID0gREVGQVVMVF9NQVg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSAtIDEpO1xuXHRcdH1cblx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcblx0XHRcdFx0PyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgKyAxKVxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xuXHRcdH1cblx0XHRpZiAobWUubWluTm90WmVybyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSBpZiAobWUubWF4IDwgMSkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIGdlbmVyYXRpb25PcHRpb25zID0ge1xuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHJldmVyc2UgPSAhcmV2ZXJzZTtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tWYWx1ZXNbaW5kZXhdKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRpY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIG5vdCB6ZXJvIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh2YWx1ZSkpO1xuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHRyZXR1cm4gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHBpeGVsLCBzdGFydCwgZW5kLCBzaWduO1xuXG5cdFx0dmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0XHRzaWduID0gMTtcblx0XHR9XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0cGl4ZWwgPSByZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHNpZ24gKj0gLTE7IC8vIGludmVydCwgc2luY2UgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMgaXMgYXQgcGl4ZWwgKDAsIDApXG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS50b3AgOiBtZS5ib3R0b207XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHRvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyRGltZW5zaW9uIC8gKGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCkpICogKGxvZzEwKHZhbHVlKSAtIGxvZzEwKHN0YXJ0KSk7XG5cdFx0XHR9XG5cdFx0XHRwaXhlbCArPSBzaWduICogb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHRcdHZhciBsb2cxMCA9IGhlbHBlcnMkMS5sb2cxMDtcblx0XHR2YXIgZmlyc3RUaWNrVmFsdWUgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uLCBzdGFydCwgZW5kLCB2YWx1ZTtcblxuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRzdGFydCA9IG1lLmVuZDtcblx0XHRcdGVuZCA9IG1lLnN0YXJ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0ZW5kID0gbWUuZW5kO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHR2YWx1ZSA9IHJldmVyc2UgPyBtZS5yaWdodCAtIHBpeGVsIDogcGl4ZWwgLSBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IHBpeGVsIC0gbWUudG9wIDogbWUuYm90dG9tIC0gcGl4ZWw7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYSh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFsdWUgLT0gb2Zmc2V0O1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSAqPSBsb2cxMChlbmQpIC0gbG9nMTAoc3RhcnQpO1xuXHRcdFx0dmFsdWUgLz0gaW5uZXJEaW1lbnNpb247XG5cdFx0XHR2YWx1ZSA9IE1hdGgucG93KDEwLCBsb2cxMChzdGFydCkgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQyID0gZGVmYXVsdENvbmZpZyQyO1xuc2NhbGVfbG9nYXJpdGhtaWMuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDI7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRiID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDcgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xuXHRkaXNwbGF5OiB0cnVlLFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG5cdGFuaW1hdGU6IHRydWUsXG5cdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuXHRhbmdsZUxpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdGdyaWRMaW5lczoge1xuXHRcdGNpcmN1bGFyOiBmYWxzZVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcblx0XHRzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXG5cdFx0YmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC43NSknLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWTogMixcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdYOiAyLFxuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0fSxcblxuXHRwb2ludExhYmVsczoge1xuXHRcdC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHQvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG5cdFx0Zm9udFNpemU6IDEwLFxuXG5cdFx0Ly8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUNvdW50KHNjYWxlKSB7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0cmV0dXJuIG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSA/IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG5cdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG5cdFx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSkgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMjtcblx0fVxuXHRyZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGxpbmVIZWlnaHQsIGxhYmVsKSB7XG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogaGVscGVycyQxLmxvbmdlc3RUZXh0KGN0eCwgY3R4LmZvbnQsIGxhYmVsKSxcblx0XHRcdGg6IGxhYmVsLmxlbmd0aCAqIGxpbmVIZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR3OiBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxuXHRcdGg6IGxpbmVIZWlnaHRcblx0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG5cdGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG5cdFx0XHRlbmQ6IHBvcyArIChzaXplIC8gMilcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplLFxuXHRcdFx0ZW5kOiBwb3Ncblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdGFydDogcG9zLFxuXHRcdGVuZDogcG9zICsgc2l6ZVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcblx0Ly8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG5cdC8vXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcblx0Ly9cblx0Ly8gU29sdXRpb246XG5cdC8vXG5cdC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuXHQvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuXHQvL1xuXHQvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuXHQvL1xuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcblx0Ly8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuXHQvL1xuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuXHQvLyBhbG9uZyB3aXRoIGxhYmVscy5cblx0Ly9cblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuXHQvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cblx0Ly9cblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG5cdC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG5cdC8vXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMpO1xuXG5cdC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuXHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xuXHRcdGw6IDAsXG5cdFx0cjogc2NhbGUud2lkdGgsXG5cdFx0dDogMCxcblx0XHRiOiBzY2FsZS5oZWlnaHQgLSBzY2FsZS5wYWRkaW5nVG9wXG5cdH07XG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuXHR2YXIgaSwgdGV4dFNpemUsIHBvaW50UG9zaXRpb247XG5cblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xuXHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzID0gW107XG5cblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgNSk7XG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnKTtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cdH1cblxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdHJldHVybiAnY2VudGVyJztcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdHJldHVybiAnbGVmdCc7XG5cdH1cblxuXHRyZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xuXHR2YXIgeSA9IHBvc2l0aW9uLnkgKyBsaW5lSGVpZ2h0IC8gMjtcblx0dmFyIGksIGlsZW47XG5cblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCB5KTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRwb3NpdGlvbi55IC09ICh0ZXh0U2l6ZS5oIC8gMik7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0fVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgYW5nbGVMaW5lT3B0cyA9IG9wdHMuYW5nbGVMaW5lcztcblx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHR2YXIgcG9pbnRMYWJlbE9wdHMgPSBvcHRzLnBvaW50TGFiZWxzO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkYihhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aCwgZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCk7XG5cdHZhciBsaW5lQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMuY29sb3IsIGdyaWRMaW5lT3B0cy5jb2xvcik7XG5cdHZhciB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG5cblx0Y3R4LnNhdmUoKTtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKHJlc29sdmUkNyhbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoLCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaCwgW11dKSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcblx0fVxuXG5cdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHQvLyBQb2ludCBMYWJlbCBGb250XG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHBvaW50TGFiZWxPcHRzKTtcblxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRmb3IgKHZhciBpID0gZ2V0VmFsdWVDb3VudChzY2FsZSkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmIChhbmdsZUxpbmVPcHRzLmRpc3BsYXkgJiYgbGluZVdpZHRoICYmIGxpbmVDb2xvcikge1xuXHRcdFx0dmFyIG91dGVyUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyKTtcblx0XHRcdGN0eC5saW5lVG8ob3V0ZXJQb3NpdGlvbi54LCBvdXRlclBvc2l0aW9uLnkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHQvLyBFeHRyYSBwaXhlbHMgb3V0IGZvciBzb21lIGxhYmVsIHNwYWNpbmdcblx0XHRcdHZhciBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuXHRcdFx0dmFyIHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgNSk7XG5cblx0XHRcdC8vIEtlZXAgdGhpcyBpbiBsb29wIHNpbmNlIHdlIG1heSBzdXBwb3J0IGFycmF5IHByb3BlcnRpZXMgaGVyZVxuXHRcdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcblx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycsIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xuXHRcdH1cblx0fVxuXHRjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdHZhciBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cdHZhciBwb2ludFBvc2l0aW9uO1xuXG5cdGlmICgoIWNpcmN1bGFyICYmICF2YWx1ZUNvdW50KSB8fCAhbGluZUNvbG9yIHx8ICFsaW5lV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHguc2F2ZSgpO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYgKGNpcmN1bGFyKSB7XG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuXHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cblxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cdFx0bWUucGFkZGluZ1RvcCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChtZS5vcHRpb25zKSAvIDI7XG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3AsIG1lLndpZHRoKSAvIDI7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBtZSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0fSxcblxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG5cdH0sXG5cblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gKE1hdGguUEkgKiAyKSAvIGdldFZhbHVlQ291bnQodGhpcyk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgdGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgP1xuXHRcdFx0dGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgOlxuXHRcdFx0MDtcblxuXHRcdHZhciBzdGFydEFuZ2xlUmFkaWFucyA9IHN0YXJ0QW5nbGUgKiBNYXRoLlBJICogMiAvIDM2MDtcblxuXHRcdC8vIFN0YXJ0IGZyb20gdGhlIHRvcCBpbnN0ZWFkIG9mIHJpZ2h0LCBzbyByZW1vdmUgYSBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblx0XHRyZXR1cm4gaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlUmFkaWFucztcblx0fSxcblxuXHRnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gMDsgLy8gbnVsbCBhbHdheXMgaW4gY2VudGVyXG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fVxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcblx0XHRcdHk6IE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0fSxcblxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLFxuXHRcdFx0bWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MCk7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblxuXHRcdFx0aWYgKG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdC8vIERvbid0IGRyYXcgYSBjZW50cmUgdmFsdWUgKGlmIGl0IGlzIG1pbmltdW0pXG5cdFx0XHRcdGlmIChpbmRleCA+IDAgfHwgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHZhciB5Q2VudGVyT2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0XHRcdC8vIERyYXcgY2lyY3VsYXIgbGluZXMgYXJvdW5kIHRoZSBzY2FsZVxuXHRcdFx0XHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSAmJiBpbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG5cblx0XHRcdFx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrT3B0cy5iYWNrZHJvcENvbG9yO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoXG5cdFx0XHRcdFx0XHRcdFx0LWxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHQteUNlbnRlck9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFdpZHRoICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCAqIDIsXG5cdFx0XHRcdFx0XHRcdFx0dGlja0ZvbnQuc2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCAwLCAteUNlbnRlck9mZnNldCk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDMgPSBkZWZhdWx0Q29uZmlnJDM7XG5zY2FsZV9yYWRpYWxMaW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRjID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbnZhciBJTlRFUlZBTFMgPSB7XG5cdG1pbGxpc2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIDI1MCwgNTAwXVxuXHR9LFxuXHRzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMTAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdG1pbnV0ZToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdGhvdXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMzYwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDYsIDEyXVxuXHR9LFxuXHRkYXk6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHR9LFxuXHR3ZWVrOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA2MDQ4MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHRtb250aDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAyLjYyOGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgM11cblx0fSxcblx0cXVhcnRlcjoge1xuXHRcdGNvbW1vbjogZmFsc2UsXG5cdFx0c2l6ZTogNy44ODRlOSxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdHllYXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcbiAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cbiAqIGFuZCBtYXggcmFuZ2UsIHNvIGJhc2ljYWxseSwgdGhlIHRhYmxlIHdpbGwgY29udGFpbnMgb25seSB0d28gaXRlbXM6IHttaW4sIDB9IGFuZCB7bWF4LCAxfS5cbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxuICogYmVzdCBjYXNlLCBhbGwgdGltZXN0YW1wcyBhcmUgbGluZWFyLCB0aGUgdGFibGUgY29udGFpbnMgb25seSBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XG5cdGlmIChkaXN0cmlidXRpb24gPT09ICdsaW5lYXInIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxuXHRcdFx0e3RpbWU6IG1heCwgcG9zOiAxfVxuXHRcdF07XG5cdH1cblxuXHR2YXIgdGFibGUgPSBbXTtcblx0dmFyIGl0ZW1zID0gW21pbl07XG5cdHZhciBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XG5cdFx0fVxuXHR9XG5cblx0aXRlbXMucHVzaChtYXgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRuZXh0ID0gaXRlbXNbaSArIDFdO1xuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xuXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuXHRcdFx0dGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWJsZTtcbn1cblxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuYW51amdha2hhci5jb20vMjAxNC8wMy8wMS9iaW5hcnktc2VhcmNoLWluLWphdmFzY3JpcHQvXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcblx0dmFyIGxvID0gMDtcblx0dmFyIGhpID0gdGFibGUubGVuZ3RoIC0gMTtcblx0dmFyIG1pZCwgaTAsIGkxO1xuXG5cdHdoaWxlIChsbyA+PSAwICYmIGxvIDw9IGhpKSB7XG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XG5cdFx0aTAgPSB0YWJsZVttaWQgLSAxXSB8fCBudWxsO1xuXHRcdGkxID0gdGFibGVbbWlkXTtcblxuXHRcdGlmICghaTApIHtcblx0XHRcdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGJlZm9yZSBmaXJzdCBpdGVtKVxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcblx0XHR9IGVsc2UgaWYgKGkxW2tleV0gPCB2YWx1ZSkge1xuXHRcdFx0bG8gPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XG5cdFx0XHRoaSA9IG1pZCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xuXHRcdH1cblx0fVxuXG5cdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGFmdGVyIGxhc3QgaXRlbSlcblx0cmV0dXJuIHtsbzogaTEsIGhpOiBudWxsfTtcbn1cblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxuICogcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBgdGtleWAgdmFsdWUuIEZvciBleGFtcGxlLCBpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCA0MiwgJ3BvcycpXG4gKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBmb3IgYSB0aW1lc3RhbXAgZXF1YWwgdG8gNDIuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlcyBhdFxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XG5cblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xuXHR2YXIgbmV4dCA9ICFyYW5nZS5sbyA/IHRhYmxlWzFdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMV0gOiByYW5nZS5oaTtcblxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xuXHR2YXIgcmF0aW8gPSBzcGFuID8gKHN2YWwgLSBwcmV2W3NrZXldKSAvIHNwYW4gOiAwO1xuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xuXG5cdHJldHVybiBwcmV2W3RrZXldICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzY2FsZSwgaW5wdXQpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciBwYXJzZXIgPSBvcHRpb25zLnBhcnNlcjtcblx0dmFyIGZvcm1hdCA9IHBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcblx0dmFyIHZhbHVlID0gaW5wdXQ7XG5cblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG5cdH1cblxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuXHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHR2YWx1ZSA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcblx0XHRcdDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAodmFsdWUgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gK3ZhbHVlO1xuXHR9XG5cblx0Ly8gTGFiZWxzIGFyZSBpbiBhbiBpbmNvbXBhdGlibGUgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cblx0aWYgKCFwYXJzZXIgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gZm9ybWF0KGlucHV0KTtcblxuXHRcdC8vIGBmb3JtYXRgIGNvdWxkIHJldHVybiBzb21ldGhpbmcgZWxzZSB0aGFuIGEgdGltZXN0YW1wLCBpZiBzbywgcGFyc2UgaXRcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGlucHV0KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciB2YWx1ZSA9IHRvVGltZXN0YW1wKHNjYWxlLCBzY2FsZS5nZXRSaWdodFZhbHVlKGlucHV0KSk7XG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XG5cdFx0dmFsdWUgPSArc2NhbGUuX2FkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgb3B0aW9ucy5yb3VuZCk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXQgdG8gc2tpcCB0byBiZSBhYmxlIHRvIGRpc3BsYXkgdXAgdG8gYGNhcGFjaXR5YCBudW1iZXIgb2YgdGlja3NcbiAqIGluIGB1bml0YCBmb3IgdGhlIGdpdmVuIGBtaW5gIC8gYG1heGAgcmFuZ2UgYW5kIHJlc3BlY3RpbmcgdGhlIGludGVydmFsIHN0ZXBzIGNvbnN0cmFpbnRzLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgY2FwYWNpdHkpIHtcblx0dmFyIHJhbmdlID0gbWF4IC0gbWluO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbdW5pdF07XG5cdHZhciBtaWxsaXNlY29uZHMgPSBpbnRlcnZhbC5zaXplO1xuXHR2YXIgc3RlcHMgPSBpbnRlcnZhbC5zdGVwcztcblx0dmFyIGksIGlsZW4sIGZhY3RvcjtcblxuXHRpZiAoIXN0ZXBzKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChyYW5nZSAvIChjYXBhY2l0eSAqIG1pbGxpc2Vjb25kcykpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHN0ZXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGZhY3RvciA9IHN0ZXBzW2ldO1xuXHRcdGlmIChNYXRoLmNlaWwocmFuZ2UgLyAobWlsbGlzZWNvbmRzICogZmFjdG9yKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWN0b3I7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcblxuXHRmb3IgKGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcblx0XHRmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzW2ludGVydmFsLnN0ZXBzLmxlbmd0aCAtIDFdIDogTUFYX0lOVEVHRVI7XG5cblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgdGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgdW5pdDtcblxuXHRmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcblx0XHR1bml0ID0gVU5JVFNbaV07XG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcbiAqIGBtaW5vcmAgdW5pdCwgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0IGFuZCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG4gKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHNjYWxlLCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xuXHR2YXIgbWFqb3IgPSBkZXRlcm1pbmVNYWpvclVuaXQobWlub3IpO1xuXHR2YXIgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUpO1xuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG5cdHZhciBtYWpvclRpY2tzRW5hYmxlZCA9IG9wdGlvbnMudGlja3MubWFqb3IuZW5hYmxlZDtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW21pbm9yXTtcblx0dmFyIGZpcnN0ID0gbWluO1xuXHR2YXIgbGFzdCA9IG1heDtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciB0aW1lO1xuXG5cdGlmICghc3RlcFNpemUpIHtcblx0XHRzdGVwU2l6ZSA9IGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCBtaW5vciwgY2FwYWNpdHkpO1xuXHR9XG5cblx0Ly8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuXHRpZiAod2Vla2RheSkge1xuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcblx0XHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QvbGFzdCB0aWNrcyBvbiB1bml0XG5cdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhc3QgdGljayBpbmNsdWRlIG1heFxuXHRpZiAobGFzdCA8IG1heCkge1xuXHRcdGxhc3QgPSArYWRhcHRlci5hZGQobGFzdCwgMSwgbWlub3IpO1xuXHR9XG5cblx0dGltZSA9IGZpcnN0O1xuXG5cdGlmIChtYWpvclRpY2tzRW5hYmxlZCAmJiBtYWpvciAmJiAhd2Vla2RheSAmJiAhdGltZU9wdHMucm91bmQpIHtcblx0XHQvLyBBbGlnbiB0aGUgZmlyc3QgdGljayBvbiB0aGUgcHJldmlvdXMgYG1pbm9yYCB1bml0IGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdDpcblx0XHQvLyB3ZSBmaXJzdCBhbGlnbmVkIHRpbWUgb24gdGhlIHByZXZpb3VzIGBtYWpvcmAgdW5pdCB0aGVuIGFkZCB0aGUgbnVtYmVyIG9mIGZ1bGxcblx0XHQvLyBzdGVwU2l6ZSB0aGVyZSBpcyBiZXR3ZWVuIGZpcnN0IGFuZCB0aGUgcHJldmlvdXMgbWFqb3IgdGltZS5cblx0XHR0aW1lID0gK2FkYXB0ZXIuc3RhcnRPZih0aW1lLCBtYWpvcik7XG5cdFx0dGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCB+figoZmlyc3QgLSB0aW1lKSAvIChpbnRlcnZhbC5zaXplICogc3RlcFNpemUpKSAqIHN0ZXBTaXplLCBtaW5vcik7XG5cdH1cblxuXHRmb3IgKDsgdGltZSA8IGxhc3Q7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSkge1xuXHRcdHRpY2tzLnB1c2goK3RpbWUpO1xuXHR9XG5cblx0dGlja3MucHVzaCgrdGltZSk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBlbmQgPSAwO1xuXHR2YXIgZmlyc3QsIGxhc3Q7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGlmICghb3B0aW9ucy50aW1lLm1pbikge1xuXHRcdFx0Zmlyc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzBdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhcnQgPSAoaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1sxXSwgJ3BvcycpIC0gZmlyc3QpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWF4KSB7XG5cdFx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xuXHRcdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRlbmQgPSBsYXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xufVxuXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIGksIGlsZW4sIHZhbHVlLCBtYWpvcjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdG1ham9yID0gbWFqb3JVbml0ID8gdmFsdWUgPT09ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBtYWpvclVuaXQpIDogZmFsc2U7XG5cblx0XHR0aWNrcy5wdXNoKHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdG1ham9yOiBtYWpvclxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyQ0ID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0LyoqXG5cdCAqIERhdGEgZGlzdHJpYnV0aW9uIGFsb25nIHRoZSBzY2FsZTpcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxuXHQgKiAtICdzZXJpZXMnOiBkYXRhIGFyZSBzcHJlYWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGRpc3RyaWJ1dGlvbjogJ2xpbmVhcicsXG5cblx0LyoqXG5cdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG5cdCAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGJvdW5kczogJ2RhdGEnLFxuXG5cdGFkYXB0ZXJzOiB7fSxcblx0dGltZToge1xuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdGZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURUQgZmFsc2UgPT0gZGF0ZSBvYmplY3RzLCBtb21lbnQgb2JqZWN0LCBjYWxsYmFjayBvciBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRkaXNwbGF5Rm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuXHRcdGRpc3BsYXlGb3JtYXRzOiB7fVxuXHR9LFxuXHR0aWNrczoge1xuXHRcdGF1dG9Ta2lwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdHNvdXJjZTogJ2F1dG8nLFxuXG5cdFx0bWFqb3I6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fVxuXHR9XG59O1xuXG52YXIgc2NhbGVfdGltZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lID0gb3B0aW9ucy50aW1lIHx8IChvcHRpb25zLnRpbWUgPSB7fSk7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XG5cblx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0aWYgKHRpbWUuZm9ybWF0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ29wdGlvbnMudGltZS5mb3JtYXQgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgb3B0aW9ucy50aW1lLnBhcnNlci4nKTtcblx0XHR9XG5cblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcblx0XHQvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuXHRcdC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcblx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXG5cdCAqL1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCByYXdWYWx1ZSk7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHR2YXIgdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgJ2RheSc7XG5cdFx0dmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciBkYXRhc2V0cyA9IFtdO1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wO1xuXHRcdHZhciBkYXRhTGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG5cblx0XHQvLyBDb252ZXJ0IGxhYmVscyB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFMYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGRhdGEgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGE7XG5cblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdChkYXRhWzBdKSkge1xuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKG1lLCBkYXRhW2pdKTtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV1bal0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2gobGFiZWxzW2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGgpIHtcblx0XHRcdC8vIFNvcnQgbGFiZWxzICoqYWZ0ZXIqKiBkYXRhIGhhdmUgYmVlbiBjb252ZXJ0ZWRcblx0XHRcdGxhYmVscyA9IGFycmF5VW5pcXVlKGxhYmVscykuc29ydChzb3J0ZXIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4obWluLCBsYWJlbHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcblx0XHR9XG5cblx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdHRpbWVzdGFtcHMgPSBhcnJheVVuaXF1ZSh0aW1lc3RhbXBzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdG1pbiA9IHBhcnNlKG1lLCB0aW1lT3B0cy5taW4pIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgdGltZU9wdHMubWF4KSB8fCBtYXg7XG5cblx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIHNldCBsaW1pdHMgYmFzZWQgb24gdW5pdCB0aW1lIG9wdGlvblxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcblx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl9ob3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0bWUuX3RhYmxlID0gW107XG5cdFx0bWUuX3RpbWVzdGFtcHMgPSB7XG5cdFx0XHRkYXRhOiB0aW1lc3RhbXBzLFxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxuXHRcdFx0bGFiZWxzOiBsYWJlbHNcblx0XHR9O1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xuXG5cdFx0c3dpdGNoIChvcHRpb25zLnRpY2tzLnNvdXJjZSkge1xuXHRcdGNhc2UgJ2RhdGEnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmRhdGE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbHMnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmxhYmVscztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2F1dG8nOlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWUsIG1pbiwgbWF4LCBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbiksIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0bWluID0gdGltZXN0YW1wc1swXTtcblx0XHRcdG1heCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcblx0XHR9XG5cblx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbWluO1xuXHRcdG1lLm1heCA9IG1heDtcblxuXHRcdC8vIFBSSVZBVEVcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCk7XG5cdFx0bWUuX21ham9yVW5pdCA9IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgb3B0aW9ucy5kaXN0cmlidXRpb24pO1xuXHRcdG1lLl9vZmZzZXRzID0gY29tcHV0ZU9mZnNldHMobWUuX3RhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpO1xuXG5cdFx0aWYgKG9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCB0aWNrcywgbWUuX21ham9yVW5pdCk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XG5cdFx0dmFyIHZhbHVlID0gZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5mb3JtYXQodG9UaW1lc3RhbXAobWUsIGxhYmVsKSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja0Zvcm1hdEZ1bmN0aW9uOiBmdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XG5cdFx0dmFyIG1ham9yVW5pdCA9IG1lLl9tYWpvclVuaXQ7XG5cdFx0dmFyIG1ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xuXHRcdHZhciBtYWpvclRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yVW5pdCk7XG5cdFx0dmFyIG1ham9yVGlja09wdHMgPSBvcHRpb25zLnRpY2tzLm1ham9yO1xuXHRcdHZhciBtYWpvciA9IG1ham9yVGlja09wdHMuZW5hYmxlZCAmJiBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGltZSA9PT0gbWFqb3JUaW1lO1xuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWFqb3IgPyBtYWpvclRpY2tPcHRzIDogb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgZm9ybWF0dGVyID0gdmFsdWVPckRlZmF1bHQkYyh0aWNrT3B0cy5jYWxsYmFjaywgdGlja09wdHMudXNlckNhbGxiYWNrKTtcblxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbih0aWNrc1tpXS52YWx1ZSwgaSwgdGlja3MpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc1JldmVyc2UgPSBtZS5vcHRpb25zLnRpY2tzLnJldmVyc2U7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gaXNSZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0IDogaXNSZXZlcnNlID8gbWUuYm90dG9tIDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XG5cdFx0dmFyIG9mZnNldCA9IHNpemUgKiAobWUuX29mZnNldHMuc3RhcnQgKyBwb3MpIC8gKG1lLl9vZmZzZXRzLnN0YXJ0ICsgMSArIG1lLl9vZmZzZXRzLmVuZCk7XG5cblx0XHRyZXR1cm4gaXNSZXZlcnNlID8gc3RhcnQgLSBvZmZzZXQgOiBzdGFydCArIG9mZnNldDtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHR9XG5cblx0XHRpZiAodGltZSA9PT0gbnVsbCkge1xuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldCh0aW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblx0XHRyZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCA/XG5cdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxuXHRcdFx0bnVsbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gbWUubGVmdCA6IG1lLnRvcDtcblx0XHR2YXIgcG9zID0gKHNpemUgPyAocGl4ZWwgLSBzdGFydCkgLyBzaXplIDogMCkgKiAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuc3RhcnQpIC0gbWUuX29mZnNldHMuZW5kO1xuXHRcdHZhciB0aW1lID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XG5cblx0XHQvLyBERVBSRUNBVElPTiwgd2Ugc2hvdWxkIHJldHVybiB0aW1lIGRpcmVjdGx5XG5cdFx0cmV0dXJuIG1lLl9hZGFwdGVyLl9jcmVhdGUodGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b1JhZGlhbnModGlja3NPcHRzLm1heFJvdGF0aW9uKTtcblx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblxuXHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXN0aW1hdGlvblxuXHRcdHZhciBmb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG5cdFx0dmFyIGV4YW1wbGVMYWJlbCA9IG1lLnRpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgW10sIGZvcm1hdCk7XG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuZ2V0TGFiZWxXaWR0aChleGFtcGxlTGFiZWwpO1xuXHRcdHZhciBpbm5lcldpZHRoID0gbWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKGlubmVyV2lkdGggLyB0aWNrTGFiZWxXaWR0aCk7XG5cblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDQgPSBkZWZhdWx0Q29uZmlnJDQ7XG5zY2FsZV90aW1lLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQ0O1xuXG52YXIgc2NhbGVzID0ge1xuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXG5cdGxpbmVhcjogc2NhbGVfbGluZWFyLFxuXHRsb2dhcml0aG1pYzogc2NhbGVfbG9nYXJpdGhtaWMsXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxuXHR0aW1lOiBzY2FsZV90aW1lXG59O1xuXG52YXIgRk9STUFUUyA9IHtcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcblx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJyxcblx0c2Vjb25kOiAnaDptbTpzcyBhJyxcblx0bWludXRlOiAnaDptbSBhJyxcblx0aG91cjogJ2hBJyxcblx0ZGF5OiAnTU1NIEQnLFxuXHR3ZWVrOiAnbGwnLFxuXHRtb250aDogJ01NTSBZWVlZJyxcblx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJyxcblx0eWVhcjogJ1lZWVknXG59O1xuXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG5cdF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRk9STUFUUztcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcblx0XHR9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuXHR9LFxuXG5cdGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihtb21lbnQobWF4KS5kaWZmKG1vbWVudChtaW4pKSkuYXModW5pdCk7XG5cdH0sXG5cblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xuXHRcdHRpbWUgPSBtb21lbnQodGltZSk7XG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xuXHR9LFxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBtYXBwZXJzID0ge1xuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0fTtcblx0fSxcblxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGJvdW5kYXJ5ID0gc291cmNlLmJvdW5kYXJ5O1xuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHR9XG5cblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdHN3aXRjaCAoZmlsbCkge1xuXHQvLyBjb21wYXRpYmlsaXR5XG5cdGNhc2UgJ2JvdHRvbSc6XG5cdFx0cmV0dXJuICdzdGFydCc7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0cmV0dXJuICdlbmQnO1xuXHRjYXNlICd6ZXJvJzpcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdGNhc2UgJ29yaWdpbic6XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0Y2FzZSAnZW5kJzpcblx0XHRyZXR1cm4gZmlsbDtcblx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0YXJnZXQgPSBudWxsO1xuXHR2YXIgaG9yaXpvbnRhbDtcblxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKCk7XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdH1cblxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmICghcHJvcGFnYXRlKSB7XG5cdFx0cmV0dXJuIGZpbGw7XG5cdH1cblxuXHR3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRmaWxsID0gdGFyZ2V0LmZpbGw7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpc0RyYXdhYmxlKHBvaW50KSB7XG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xuXHR2YXIgaTtcblxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdGN0eC5tb3ZlVG8oY3VydmUwWzBdLngsIGN1cnZlMFswXS55KTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2kgLSAxXSwgY3VydmUwW2ldKTtcblx0fVxuXG5cdC8vIGpvaW5pbmcgdGhlIHR3byBhcmVhIGN1cnZlc1xuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGxvb3ApIHtcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHR2YXIgY3VydmUwID0gW107XG5cdHZhciBjdXJ2ZTEgPSBbXTtcblx0dmFyIGxlbjAgPSAwO1xuXHR2YXIgbGVuMSA9IDA7XG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDE7XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoY291bnQgKyAhIWxvb3ApOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aW5kZXggPSBpICUgY291bnQ7XG5cdFx0cDAgPSBwb2ludHNbaW5kZXhdLl92aWV3O1xuXHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcblx0XHRkMSA9IGlzRHJhd2FibGUocDEpO1xuXG5cdFx0aWYgKGQwICYmIGQxKSB7XG5cdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcblx0XHR9IGVsc2UgaWYgKGxlbjAgJiYgbGVuMSkge1xuXHRcdFx0aWYgKCFzcGFuKSB7XG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXHRcdFx0XHRsZW4wID0gbGVuMSA9IDA7XG5cdFx0XHRcdGN1cnZlMCA9IFtdO1xuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkMCkge1xuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZDEpIHtcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0Y3R4LmZpbGwoKTtcbn1cblxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG5cdGlkOiAnZmlsbGVyJyxcblxuXHRhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xuXHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHRzb3VyY2UgPSBudWxsO1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xuXHRcdFx0XHRzb3VyY2UgPSB7XG5cdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXG5cdFx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRcdGVsOiBlbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG5cdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgcHJvcGFnYXRlKTtcblx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVEYXRhc2V0RHJhdzogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcblx0XHR2YXIgbWV0YSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIGVsID0gbWV0YS5lbDtcblx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdHZhciBwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0dmFyIG1hcHBlciA9IG1ldGEubWFwcGVyO1xuXHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuXHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMSA9IGhlbHBlcnMkMS5ub29wO1xudmFyIHZhbHVlT3JEZWZhdWx0JGQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsZWdlbmQ6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0d2VpZ2h0OiAxMDAwLFxuXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxuXHRcdFx0bWV0YS5oaWRkZW4gPSBtZXRhLmhpZGRlbiA9PT0gbnVsbCA/ICFjaS5kYXRhLmRhdGFzZXRzW2luZGV4XS5oaWRkZW4gOiBudWxsO1xuXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcblx0XHRcdGNpLnVwZGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG9uTGVhdmU6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkoZGF0YS5kYXRhc2V0cykgPyBkYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbihkYXRhc2V0LCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6ICghaGVscGVycyQxLmlzQXJyYXkoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IpID8gZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgOiBkYXRhc2V0LmJhY2tncm91bmRDb2xvclswXSksXG5cdFx0XHRcdFx0XHRoaWRkZW46ICFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdFx0bGluZUNhcDogZGF0YXNldC5ib3JkZXJDYXBTdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBkYXRhc2V0LmJvcmRlckRhc2gsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogZGF0YXNldC5ib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRcdFx0bGluZUpvaW46IGRhdGFzZXQuYm9yZGVySm9pblN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBkYXRhc2V0LmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IGRhdGFzZXQuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBkYXRhc2V0LnBvaW50U3R5bGUsXG5cblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IGlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LCB0aGlzKSA6IFtdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3IgKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0aWYgKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpIHtcblx0XHRcdFx0dGV4dC5wdXNoKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdH1cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSB0aGUgbGFiZWwgZm9udCBzaXplXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxuICovXG5mdW5jdGlvbiBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKSB7XG5cdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSAmJiBsYWJlbE9wdHMuYm94V2lkdGggPiBmb250U2l6ZSA/XG5cdFx0Zm9udFNpemUgOlxuXHRcdGxhYmVsT3B0cy5ib3hXaWR0aDtcbn1cblxuLyoqXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXG4gKi9cbnZhciBMZWdlbmQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHR0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHQvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG5cdFx0dGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG5cdFx0Ly8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuXHRcdHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMSxcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXHR9LFxuXHRhZnRlclVwZGF0ZTogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXG5cdGJ1aWxkTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcblx0XHR2YXIgbGVnZW5kSXRlbXMgPSBoZWxwZXJzJDEuY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG5cblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuXHRcdFx0bGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuXHR9LFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXG5cdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblxuXHRcdC8vIFJlc2V0IGhpdCBib3hlc1xuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuXHRcdFx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG5cdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IDA7XG5cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0aWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gdG90YWxIZWlnaHQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgY29sdW1uV2lkdGhzID0gbWUuY29sdW1uV2lkdGhzID0gW107XG5cdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHR2YXIgY3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdHZhciBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCA+IG1pblNpemUuaGVpZ2h0IC0gdlBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcblxuXHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuXHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQxLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSBsZWdlbmQgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZChsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblx0XHRcdHZhciBjdXJzb3I7XG5cblx0XHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBmb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG5cdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5sYWJlbHMgJiYgb3B0cy5sYWJlbHMudXNlUG9pbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHR2YXIgcmFkaXVzID0gYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBib3hXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dmFyIGNlbnRlclkgPSB5ICsgZm9udFNpemUgLyAyO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0XHR2YXIgeExlZnQgPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHg7XG5cdFx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0XHRjdHguZmlsbFRleHQobGVnZW5kSXRlbS50ZXh0LCB4TGVmdCwgeU1pZGRsZSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZEl0ZW0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4TGVmdCArIHRleHRXaWR0aCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbMF0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xuXHRcdFx0XHR2YXIgeCA9IGN1cnNvci54O1xuXHRcdFx0XHR2YXIgeSA9IGN1cnNvci55O1xuXG5cdFx0XHRcdC8vIFVzZSAobWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIGFuZCAobWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgbWUucmlnaHQgYW5kIG1lLmJvdHRvbSBiZWNhdXNlIG1lLndpZHRoIGFuZCBtZS5oZWlnaHRcblx0XHRcdFx0Ly8gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIHNpbmNlIG1lLm1pblNpemUgd2FzIGNhbGN1bGF0ZWRcblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBpdGVtSGVpZ2h0ID4gbWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSB4ICsgbWUuY29sdW1uV2lkdGhzW2N1cnNvci5saW5lXSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3TGVnZW5kQm94KHgsIHksIGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRoaXRib3hlc1tpXS50b3AgPSB5O1xuXG5cdFx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuXHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XG5cblx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdHZhciBob3ZlcmVkSXRlbTtcblxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0cy5vbkxlYXZlICYmIGhvdmVyZWRJdGVtICE9PSBtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xufVxuXG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcblx0aWQ6ICdsZWdlbmQnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBMZWdlbmQsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcblxuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDIgPSBoZWxwZXJzJDEubm9vcDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDIsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDIsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xuXHRcdHZhciBsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHR2YXIgdGV4dFNpemUgPSBkaXNwbGF5ID8gKGxpbmVDb3VudCAqIGZvbnRPcHRzLmxpbmVIZWlnaHQpICsgKG9wdHMucGFkZGluZyAqIDIpIDogMDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gdGV4dFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSB0ZXh0U2l6ZTtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDIsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgdG9wID0gbWUudG9wO1xuXHRcdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xuXHRcdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcblx0XHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xuXHRcdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR0aXRsZVggPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG5cdFx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGl0bGVYID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gbGVmdCArIG9mZnNldCA6IHJpZ2h0IC0gb2Zmc2V0O1xuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdFx0bWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG5cdFx0XHRcdHJvdGF0aW9uID0gTWF0aC5QSSAqIChvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyAtMC41IDogMC41KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xuXHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHRcdHZhciB5ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcblx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdHZhciB0aXRsZSA9IG5ldyBUaXRsZSh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG5cdGlkOiAndGl0bGUnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIHRpdGxlIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBUaXRsZSxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpdGxlT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBwbHVnaW5zID0ge307XG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcbnZhciBsZWdlbmQgPSBwbHVnaW5fbGVnZW5kO1xudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cblxuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycyA9IGhlbHBlcnMkMTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxuY29yZV9oZWxwZXJzKGNvcmVfY29udHJvbGxlcik7XG5cbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xuY29yZV9jb250cm9sbGVyLkFuaW1hdGlvbiA9IGNvcmVfYW5pbWF0aW9uO1xuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmNvcmVfY29udHJvbGxlci5EYXRhc2V0Q29udHJvbGxlciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXI7XG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XG5jb3JlX2NvbnRyb2xsZXIuZWxlbWVudHMgPSBlbGVtZW50cztcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xuY29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZSA9IGNvcmVfc2NhbGVTZXJ2aWNlO1xuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xuXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlLCB0eXBlKSB7XG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XG59KTtcblxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxuXG5cbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xuXG5mb3IgKHZhciBrIGluIHBsdWdpbnMpIHtcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcblx0fVxufVxuXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcbn1cblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5sYXlvdXRTZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxpbmVhclNjYWxlQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcbiAqIGJ5IHNldHRpbmcgdGhlIHR5cGUgaW4gdGhlIGNvbmZpZyAoYG5ldyBDaGFydChpZCwge3R5cGU6ICd7Y2hhcnQtdHlwZX0nfWApLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxuXHRbXG5cdFx0J0JhcicsXG5cdFx0J0J1YmJsZScsXG5cdFx0J0RvdWdobnV0Jyxcblx0XHQnTGluZScsXG5cdFx0J1BvbGFyQXJlYScsXG5cdFx0J1JhZGFyJyxcblx0XHQnU2NhdHRlcidcblx0XSxcblx0ZnVuY3Rpb24oa2xhc3MpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXJba2xhc3NdID0gZnVuY3Rpb24oY3R4LCBjZmcpIHtcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcblx0XHRcdH0pKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5yZXR1cm4gc3JjO1xuXG59KSkpO1xuIiwiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJ0KGNoYXJ0SWQsIGNoYXJ0VHlwZSkge1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgY2xhc3M6IHRoaXMuY3NzQ2xhc3Nlc1xuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5jaGFydElkLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnY2FudmFzJ1xuICAgICAgfSldKTtcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGFydElkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGNoYXJ0SWQsXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgY3NzQ2xhc3Nlczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9jaGFydDogbnVsbCxcbiAgICAgICAgX3BsdWdpbnM6IHRoaXMucGx1Z2luc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGFkZFBsdWdpbjogZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgICB0aGlzLiRkYXRhLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24gZ2VuZXJhdGVMZWdlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRkYXRhLl9jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uIHJlbmRlckNoYXJ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuJHJlZnMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHtcbiAgICAgICAgICB0eXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgIHBsdWdpbnM6IHRoaXMuJGRhdGEuX3BsdWdpbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgdmFyIEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2Jhci1jaGFydCcsICdiYXInKTtcbmV4cG9ydCB2YXIgSG9yaXpvbnRhbEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2hvcml6b250YWxiYXItY2hhcnQnLCAnaG9yaXpvbnRhbEJhcicpO1xuZXhwb3J0IHZhciBEb3VnaG51dCA9IGdlbmVyYXRlQ2hhcnQoJ2RvdWdobnV0LWNoYXJ0JywgJ2RvdWdobnV0Jyk7XG5leHBvcnQgdmFyIExpbmUgPSBnZW5lcmF0ZUNoYXJ0KCdsaW5lLWNoYXJ0JywgJ2xpbmUnKTtcbmV4cG9ydCB2YXIgUGllID0gZ2VuZXJhdGVDaGFydCgncGllLWNoYXJ0JywgJ3BpZScpO1xuZXhwb3J0IHZhciBQb2xhckFyZWEgPSBnZW5lcmF0ZUNoYXJ0KCdwb2xhci1jaGFydCcsICdwb2xhckFyZWEnKTtcbmV4cG9ydCB2YXIgUmFkYXIgPSBnZW5lcmF0ZUNoYXJ0KCdyYWRhci1jaGFydCcsICdyYWRhcicpO1xuZXhwb3J0IHZhciBCdWJibGUgPSBnZW5lcmF0ZUNoYXJ0KCdidWJibGUtY2hhcnQnLCAnYnViYmxlJyk7XG5leHBvcnQgdmFyIFNjYXR0ZXIgPSBnZW5lcmF0ZUNoYXJ0KCdzY2F0dGVyLWNoYXJ0JywgJ3NjYXR0ZXInKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmFyOiBCYXIsXG4gIEhvcml6b250YWxCYXI6IEhvcml6b250YWxCYXIsXG4gIERvdWdobnV0OiBEb3VnaG51dCxcbiAgTGluZTogTGluZSxcbiAgUGllOiBQaWUsXG4gIFBvbGFyQXJlYTogUG9sYXJBcmVhLFxuICBSYWRhcjogUmFkYXIsXG4gIEJ1YmJsZTogQnViYmxlLFxuICBTY2F0dGVyOiBTY2F0dGVyXG59OyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjaGFydExhYmVscyA9IFsnMTk4MCcsICcxOTkwJywgJzIwMDAnLCAnMjAxMCcsICcyMDIwJ107XG5cbmNvbnN0IGNoYXJ0RGF0YUxpc3QgPSBbNjU0MjU2NCwgNzMyMjU2NCwgODAwODI3OCwgODE3NTEzMywgNTQ3NTEzM107XG5cbmNvbnN0IENoYXJ0RGF0YSA9IHtcbiAgZGF0YToge1xuICAgIGxhYmVsczogY2hhcnRMYWJlbHMsXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtcbiAgICAgICAgZGF0YTogY2hhcnREYXRhTGlzdCxcbiAgICAgICAgZmlsbDogZmFsc2UsIC8vIHVzZWQgYnkgbGluZSBjaGFydFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAnIzJGMzM0RicsXG4gICAgICAgICAgJyMzMTU1QTYnLFxuICAgICAgICAgICcjRjI2OTVEJyxcbiAgICAgICAgICAnI0VCQkNEOCcsXG4gICAgICAgICAgJyNGOUExMzcnLFxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgICcjQUNBRUI5J1xuICAgICAgICBdLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSxcbiAgICBdXG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWxCYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1llYXJzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAyNSxcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2Jhcic7XG5cbmNsYXNzIENoYXJ0QmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSG9yaXpvbnRhbEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogSG9yaXpvbnRhbEJhcixcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWhvcml6b250YWwtYmFyLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdob3Jpem9udGFsLWJhcic7XG5cbmNsYXNzIENoYXJ0SG9yaXpvbnRhbEJhciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5ob3Jpem9udGFsQmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEhvcml6b250YWxCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgTGluZSwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogTGluZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWxpbmUudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2xpbmUnO1xuXG5jbGFzcyBDaGFydExpbmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydExpbmU7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgUGllLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBQaWUsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLXBpZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAncGllJztcblxuY2xhc3MgQ2hhcnRQaWUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEucGllLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydFBpZTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBJY29ucyBmcm9tICcuLi9lbGVtZW50cy9pY29ucy9JY29ucyc7XG5pbXBvcnQgRmVlZCBmcm9tICcuLi9vYmplY3RzL2ZlZWQvRmVlZCc7XG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlJztcbmltcG9ydCBUcmFjayBmcm9tICcuLi91dGlsaXRpZXMvdHJhY2svVHJhY2snO1xuaW1wb3J0IFNlbGVjdCBmcm9tICcuLi9lbGVtZW50cy9zZWxlY3Qvc2VsZWN0JztcbmltcG9ydCBDaGFydEJhciBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tYmFyJztcbmltcG9ydCBDaGFydEhvcml6b250YWxCYXIgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWhvcml6b250YWwtYmFyJztcbmltcG9ydCBDaGFydExpbmUgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUnO1xuaW1wb3J0IENoYXJ0UGllIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1waWUnO1xuLyoqIGltcG9ydCBtb2R1bGVzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIHRoZSBnbG9iYWwgTnljb1BhdHRlcm5zIGluc3RhbmNlXG4gKi9cbmNsYXNzIG55Y28ge1xuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgSWNvbnMgRWxlbWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBJY29ucyBpbnN0YW5jZVxuICAgKi9cbiAgaWNvbnMocGF0aCkge1xuICAgIHJldHVybiBuZXcgSWNvbnMocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgRmVlZCBPYmplY3RcbiAgICogQHBhcmFtICAge09iamVjdH0gIHNldHRpbmdzICBTZXR0aW5nIGZvciB0aGUgZmVlZFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgICAgICAgIEZlZWQgaW5zdGFuY2VcbiAgICovXG4gIGZlZWQoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZlZWQoc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIFRvZ2dsZSBVdGlsaXR5XG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRvZ2dsZSBpbnN0YW5jZVxuICAgKi9cbiAgdG9nZ2xlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUb2dnbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUcmFjayBNb2R1bGVcbiAgICogQHJldHVybiAge09iamVjdH0gVHJhY2sgTW9kdWxlXG4gICAqL1xuICB0cmFjayhzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVHJhY2soKTtcbiAgfVxuXG4gIHNlbGVjdCgpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBDaGFydCBPYmplY3RzXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IENoYXJ0IGluc3RhbmNlXG4gICAqL1xuICBjaGFydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdiYXInKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdob3Jpem9udGFsQmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRIb3Jpem9udGFsQmFyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydExpbmUoKTtcblxuICAgIGlmICh0eXBlID09PSAncGllJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRQaWUoKTtcbiAgfVxuICAvKiogYWRkIEFQSXMgaGVyZSBhcyB0aGV5IGFyZSB3cml0dGVuICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IG55Y287XG4iXSwibmFtZXMiOlsiVXRpbGl0eSIsImRlYnVnIiwiZ2V0VXJsUGFyYW1ldGVyIiwiUEFSQU1TIiwiREVCVUciLCJuYW1lIiwicXVlcnlTdHJpbmciLCJjb25zdCIsInF1ZXJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJzZWFyY2giLCJwYXJhbSIsInJlcGxhY2UiLCJyZWdleCIsIlJlZ0V4cCIsInJlc3VsdHMiLCJleGVjIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibG9jYWxpemUiLCJzbHVnIiwibGV0IiwidGV4dCIsInN0cmluZ3MiLCJMT0NBTElaRURfU1RSSU5HUyIsIm1hdGNoIiwiZmlsdGVyIiwicyIsImhhc093blByb3BlcnR5IiwibGFiZWwiLCJTRUxFQ1RPUlMiLCJwYXJzZU1hcmtkb3duIiwiSWNvbnMiLCJwYXRoIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsImNvbnNvbGUiLCJkaXIiLCJlcnJvciIsImRhdGEiLCJzcHJpdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiT2JqZWN0IiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJwcm90b3R5cGUiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImdldFJhd1RhZyIsInZhbHVlIiwiaXNPd24iLCJjYWxsIiwidGFnIiwidW5tYXNrZWQiLCJlIiwicmVzdWx0Iiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwidHlwZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwia2V5cyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsInRlc3QiLCJnZXRWYWx1ZSIsIm9iamVjdCIsImtleSIsImdldE5hdGl2ZSIsImRlZmluZVByb3BlcnR5IiwiYmFzZUFzc2lnblZhbHVlIiwiZXEiLCJvdGhlciIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJjb3B5T2JqZWN0Iiwic291cmNlIiwicHJvcHMiLCJjdXN0b21pemVyIiwiaXNOZXciLCJpbmRleCIsImxlbmd0aCIsIm5ld1ZhbHVlIiwiaWRlbnRpdHkiLCJhcHBseSIsInRoaXNBcmciLCJhcmdzIiwibmF0aXZlTWF4IiwiTWF0aCIsIm1heCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJhcmd1bWVudHMiLCJhcnJheSIsIkFycmF5Iiwib3RoZXJBcmdzIiwiY29uc3RhbnQiLCJiYXNlU2V0VG9TdHJpbmciLCJzdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIkRhdGUiLCJub3ciLCJzaG9ydE91dCIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwic2V0VG9TdHJpbmciLCJiYXNlUmVzdCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwicmVJc1VpbnQiLCJpc0luZGV4IiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwiYmFzZVRpbWVzIiwibiIsIml0ZXJhdGVlIiwiaXNPYmplY3RMaWtlIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJpc0FycmF5Iiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwicHVzaCIsImlzUHJvdG90eXBlIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImtleXNJbiIsImFzc2lnbkluV2l0aCIsInNyY0luZGV4Iiwib3ZlckFyZyIsImFyZyIsImdldFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0Q3RvclN0cmluZyIsImlzUGxhaW5PYmplY3QiLCJkb21FeGNUYWciLCJpc0Vycm9yIiwibWVzc2FnZSIsImF0dGVtcHQiLCJFcnJvciIsImFycmF5TWFwIiwiYmFzZVZhbHVlcyIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJzcmNWYWx1ZSIsInN0cmluZ0VzY2FwZXMiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwibmF0aXZlS2V5cyIsImJhc2VLZXlzIiwicmVJbnRlcnBvbGF0ZSIsImJhc2VQcm9wZXJ0eU9mIiwiaHRtbEVzY2FwZXMiLCJlc2NhcGVIdG1sQ2hhciIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlIiwicmVFc2NhcGUiLCJyZUV2YWx1YXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNUZW1wbGF0ZSIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwidGVtcGxhdGUiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiXyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsIm9mZnNldCIsInNsaWNlIiwidmFyaWFibGUiLCJhcnJheUVhY2giLCJjcmVhdGVCYXNlRm9yIiwiZnJvbVJpZ2h0Iiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsImJhc2VGb3IiLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJlYWNoRnVuYyIsImNvbGxlY3Rpb24iLCJiYXNlRWFjaCIsImNhc3RGdW5jdGlvbiIsImZvckVhY2giLCJsaXN0Q2FjaGVDbGVhciIsIl9fZGF0YV9fIiwic2l6ZSIsImFzc29jSW5kZXhPZiIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJsaXN0Q2FjaGVEZWxldGUiLCJsYXN0SW5kZXgiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsInNldCIsImdldCIsImhhcyIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJNYXAiLCJuYXRpdmVDcmVhdGUiLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiSEFTSF9VTkRFRklORUQiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwibWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJtYXAiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiTEFSR0VfQVJSQVlfU0laRSIsInN0YWNrU2V0IiwicGFpcnMiLCJTdGFjayIsImFzc2lnbk1lcmdlVmFsdWUiLCJhbGxvY1Vuc2FmZSIsImNsb25lQnVmZmVyIiwiYnVmZmVyIiwiaXNEZWVwIiwiY29weSIsIlVpbnQ4QXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsImJ5dGVPZmZzZXQiLCJjb3B5QXJyYXkiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJiYXNlQ3JlYXRlIiwiaW5pdENsb25lT2JqZWN0IiwiaXNBcnJheUxpa2VPYmplY3QiLCJzYWZlR2V0IiwidG9QbGFpbk9iamVjdCIsImJhc2VNZXJnZURlZXAiLCJtZXJnZUZ1bmMiLCJzdGFjayIsInN0YWNrZWQiLCJpc0NvbW1vbiIsImlzVHlwZWQiLCJiYXNlTWVyZ2UiLCJtZXJnZSIsInZhbHVlcyIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSIsImFkZCIsImFycmF5U29tZSIsInByZWRpY2F0ZSIsImNhY2hlSGFzIiwiY2FjaGUiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImJpdG1hc2siLCJlcXVhbEZ1bmMiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiZXF1YWxCeVRhZyIsImNvbnZlcnQiLCJhcnJheVB1c2giLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYXJyYXlGaWx0ZXIiLCJyZXNJbmRleCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRTeW1ib2xzIiwic3ltYm9sIiwiZ2V0QWxsS2V5cyIsImVxdWFsT2JqZWN0cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiRGF0YVZpZXciLCJQcm9taXNlIiwiU2V0IiwiV2Vha01hcCIsInByb21pc2VUYWciLCJkYXRhVmlld0N0b3JTdHJpbmciLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJnZXRUYWciLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwiYmFzZUlzRXF1YWxEZWVwIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJiYXNlSXNFcXVhbCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJiYXNlTWF0Y2hlcyIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJpc0tleSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemUiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldCIsImRlZmF1bHRWYWx1ZSIsImJhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaGFzSW4iLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsInByb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiYmFzZU1hcCIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsInNvcnQiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNOdWxsIiwidmFsSXNSZWZsZXhpdmUiLCJ2YWxJc1N5bWJvbCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJjb21wYXJlTXVsdGlwbGUiLCJvcmRlcnMiLCJvYmpDcml0ZXJpYSIsImNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsImJhc2VPcmRlckJ5IiwiaXRlcmF0ZWVzIiwib3JkZXJCeSIsIm5vb3AiLCJjcmVhdGVTZXQiLCJGZWVkIiwiY29uZmlnIiwiX3NldHRpbmdzIiwiX21lcmdlIiwiaW5pdCIsImZlZWQiLCJyc3NUb0pzb24iLCJyc3NVcmwiLCJfZm9yRWFjaCIsInVybCIsInRoaXMiLCJfcmVxdWVzdCIsIl9wcm9jZXNzIiwiSlNPTiIsInBhcnNlIiwidGhpcyQxIiwiY29tcGlsZWQiLCJfcmVuZGVyIiwiZWwiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0b3IiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImV2ZW50IiwiX3hociIsInRhcmdldCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJvbnRpbWVvdXQiLCJvcGVuIiwic2VuZCIsImxvZyIsIl92YWx1ZXMiLCJ0ZW1wbGF0ZXMiLCJqb2luIiwiX3RlbXBsYXRlIiwibWVkaXVtIiwib3BlbmVyIiwiaGVhZGVyIiwicG9zdHMiLCJjbG9zZXIiLCJwb3N0RXhjZXJwdExlbmd0aCIsIml0ZW1zIiwicG9zdCIsImV4Y2VycHQiLCJkYXRlIiwiZGVzY3JpcHRpb24iLCJzdWJzdHIiLCJtaW4iLCJsYXN0SW5kZXhPZiIsInB1YkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJwb3N0RGF0ZUxvY2FsIiwicG9zdERhdGVGb3JtYXQiLCJtZXJnZWQiLCJjb25jYXQiLCJfb3JkZXJCeSIsInRpdGxlIiwidGl0bGVVcmwiLCJwcm9maWxlSW1nIiwiZm9udFNpemUiLCJyYXRpb1Byb2ZpbGUiLCJwb3N0Qm9yZGVyQ29sb3IiLCJwb3N0SW1nSGVpZ2h0IiwicG9zdEV4Y2VycHRUcmFpbCIsInBvc3RDdGFUZXh0IiwieWVhciIsIm1vbnRoIiwiZGF5IiwicG9zdERhdGVUaXRsZSIsImNsYXNzZXMiLCJ3cmFwcGVyIiwiZmVlZEl0ZW0iLCJsaW5rIiwidGh1bWJuYWlsIiwiaXRlbUZvb3RlciIsImN0YSIsInVuaXF1ZSIsIlRvZ2dsZSIsIm5hbWVzcGFjZSIsImluYWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJtYXRjaGVzIiwicHJldmVudERlZmF1bHQiLCJfdG9nZ2xlIiwiZ2V0QXR0cmlidXRlIiwiZWxlbWVudFRvZ2dsZSIsImRhdGFzZXQiLCJ1bmRvIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsYXNzTGlzdCIsInRvZ2dsZSIsImkiLCJlbEFyaWFSb2xlcyIsInRhcmdldEFyaWFSb2xlcyIsImNvbnRhaW5zIiwiaGFzaCIsIlRyYWNrIiwidHJhY2tLZXkiLCJ0cmFja0RhdGEiLCJjbGljayIsImQiLCJwYXRobmFtZSIsInd0Iiwid2VidHJlbmRzIiwiZ2EiLCJndGFnIiwidmlldyIsImFwcCIsImd0YWdWaWV3IiwiYXNzaWduIiwid3RkIiwiYXJnc2EiLCJmbGF0TWFwIiwiayIsIldlYnRyZW5kcyIsIm11bHRpVHJhY2siLCJ1cmkiLCJmaW5kIiwiZWxlbWVudCIsImFwcF9uYW1lIiwic2NyZWVuX25hbWUiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJvYmoiLCJfdG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwicGFyc2VGbG9hdCIsImZsb29yIiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJjYXRjaCIsInN0cmluZ2lmeSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImxpc3QiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleE9mIiwiaGFzT3duIiwiY2FjaGVkIiwiZm4iLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsInRvQXJyYXkiLCJyZXQiLCJleHRlbmQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJyZXMiLCJiIiwibm8iLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJzdGF0aWNLZXlzIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZUxldHRlcnMiLCJpc1Jlc2VydmVkIiwiZGVmIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwiaXNGRiIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiaGFzU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0Iiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwidHJhY2UiLCJpbmNsdWRlRmlsZSIsIiRyb290IiwiY2lkIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsIlZOb2RlIiwiY2hpbGRyZW4iLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwiZGVsIiwic3RyYXRzIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsIkJvb2xlYW4iLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsImxlbiIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsIk51bWJlciIsImV4cGxpY2l0VHlwZXMiLCJzb21lIiwiZWxlbSIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsImhhbmRsZXIiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJwIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiX25vcm1hbGl6ZWQiLCIkc3RhYmxlIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJiaW5kRHluYW1pY0tleXMiLCJiYXNlT2JqIiwicHJlcGVuZE1vZGlmaWVyIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJfZCIsIl9wIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJsaXN0ZW5lcnMiLCJpbmplY3Rpb25zIiwic2NvcGVkU2xvdHMiLCJfc2NvcGVJZCIsIl9jIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiaW5zZXJ0IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGVzdHJveSIsIiRkZXN0cm95IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsIl9wYXJlbnRWbm9kZSIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiJHZub2RlIiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImNsYXNzIiwiaW5pdFJlbmRlciIsIl92bm9kZSIsInBhcmVudFZub2RlIiwiX3JlbmRlckNoaWxkcmVuIiwicGFyZW50RGF0YSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIlZ1ZSIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsIm93bmVyIiwib3duZXJzIiwic3luYyIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNyZWF0ZUdldHRlckludm9rZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJ1aWQkMyIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInNlbGVjdGVkIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWYiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJyYW5nZSIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiZHluYW1pYyIsInJhbmdlU2V0SXRlbSIsInBsYWluIiwiYWRkQXR0ciIsImR5bmFtaWNBdHRycyIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImlzRHluYW1pY0FyZyIsInByZXBlbmRNb2RpZmllck1hcmtlciIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwicmlnaHQiLCJtaWRkbGUiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0UmF3QmluZGluZ0F0dHIiLCJyYXdBdHRyc01hcCIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ0eXBlQmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsImVuZGVkIiwib25FbmQiLCJwcm9wQ291bnQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwiYXBwZWFyIiwic3RhcnRDbGFzcyIsImFwcGVhckNsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImJlZm9yZUFwcGVhciIsImJlZm9yZUVudGVyIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJhZnRlckFwcGVhciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZEhvb2siLCJhcHBlYXJDYW5jZWxsZWQiLCJlbnRlckNhbmNlbGxlZCIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJsZWF2ZUNhbmNlbGxlZCIsImFmdGVyTGVhdmUiLCJkZWxheUxlYXZlIiwicGVyZm9ybUxlYXZlIiwiYmVmb3JlTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJvdXRwdXRTb3VyY2VSYW5nZSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImR5bmFtaWNBcmdSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsInNsb3RSRSIsImxpbmVCcmVha1JFIiwid2hpdGVzcGFjZVJFJDEiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwid2hpdGVzcGFjZU9wdGlvbiIsIndoaXRlc3BhY2UiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJmb3IiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdFRhcmdldER5bmFtaWMiLCJzbG90QmluZGluZyIsImdldFNsb3ROYW1lIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwiZm5JbnZva2VSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwicHJlZml4Iiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiY29udGFpbnNTbG90Q2hpbGQiLCJnZW5TY29wZWRTbG90IiwiaXNMZWdhY3lTeW50YXgiLCJyZXZlcnNlUHJveHkiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJsaW5lTGVuZ3RoIiwicGFkIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiU2VsZWN0RGF0YSIsIlNlbGVjdCIsIlNlbGVjdENvbXBvbmVudCIsIl9jb25zdGFudHMiLCJkYXRhSGFuZGxlciIsIm5ld0RhdGEiLCJjaGFydCIsIl9jaGFydCIsIm5ld0RhdGFzZXRMYWJlbHMiLCJkYXRhc2V0cyIsIm9sZERhdGFzZXRMYWJlbHMiLCJvbGRMYWJlbHMiLCJuZXdMYWJlbHMiLCJvbGREYXRhc2V0S2V5cyIsIm5ld0RhdGFzZXRLZXlzIiwiZGVsZXRpb25LZXlzIiwiZGVsZXRpb25LZXkiLCJsYWJlbHMiLCJ4TGFiZWxzIiwieUxhYmVscyIsInJlbmRlckNoYXJ0IiwiY2hhcnREYXRhIiwicmVhY3RpdmVEYXRhIiwicmVhY3RpdmVQcm9wIiwiaG9va0NhbGxiYWNrIiwic2V0SG9va0NhbGxiYWNrIiwiaW5wdXQiLCJpc09iamVjdEVtcHR5IiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsImhhc093blByb3AiLCJjcmVhdGVVVEMiLCJmb3JtYXQiLCJsb2NhbGUiLCJzdHJpY3QiLCJjcmVhdGVMb2NhbE9yVVRDIiwidXRjIiwiZGVmYXVsdFBhcnNpbmdGbGFncyIsImVtcHR5IiwidW51c2VkVG9rZW5zIiwidW51c2VkSW5wdXQiLCJvdmVyZmxvdyIsImNoYXJzTGVmdE92ZXIiLCJudWxsSW5wdXQiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwiX3BmIiwiZnVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpbnZhbGlkV2Vla2RheSIsIl9zdHJpY3QiLCJiaWdIb3VyIiwiY3JlYXRlSW52YWxpZCIsIk5hTiIsIm1vbWVudFByb3BlcnRpZXMiLCJjb3B5Q29uZmlnIiwiX2lzQU1vbWVudE9iamVjdCIsIl90em0iLCJfaXNVVEMiLCJfb2Zmc2V0IiwiX2xvY2FsZSIsInVwZGF0ZUluUHJvZ3Jlc3MiLCJNb21lbnQiLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsImFic0Zsb29yIiwiY2VpbCIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJjb21wYXJlQXJyYXlzIiwiYXJyYXkxIiwiYXJyYXkyIiwiZG9udENvbnZlcnQiLCJsZW5ndGhEaWZmIiwiYWJzIiwiZGlmZnMiLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGUiLCJmaXJzdFRpbWUiLCJkZXByZWNhdGlvbkhhbmRsZXIiLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJfY29uZmlnIiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50IiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbFBhcnNlIiwibWVyZ2VDb25maWdzIiwicGFyZW50Q29uZmlnIiwiY2hpbGRDb25maWciLCJMb2NhbGUiLCJkZWZhdWx0Q2FsZW5kYXIiLCJzYW1lRGF5IiwibmV4dERheSIsIm5leHRXZWVrIiwibGFzdERheSIsImxhc3RXZWVrIiwic2FtZUVsc2UiLCJjYWxlbmRhciIsIm1vbSIsIm91dHB1dCIsIl9jYWxlbmRhciIsImRlZmF1bHRMb25nRGF0ZUZvcm1hdCIsIkxUUyIsIkxUIiwiTCIsIkxMIiwiTExMIiwiTExMTCIsImxvbmdEYXRlRm9ybWF0IiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJkZWZhdWx0SW52YWxpZERhdGUiLCJpbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJvcmRpbmFsIiwiX29yZGluYWwiLCJkZWZhdWx0UmVsYXRpdmVUaW1lIiwiZnV0dXJlIiwicGFzdCIsInNzIiwibW0iLCJoaCIsImRkIiwiTSIsIk1NIiwieSIsInl5IiwicmVsYXRpdmVUaW1lIiwid2l0aG91dFN1ZmZpeCIsImlzRnV0dXJlIiwiX3JlbGF0aXZlVGltZSIsInBhc3RGdXR1cmUiLCJkaWZmIiwiYWxpYXNlcyIsImFkZFVuaXRBbGlhcyIsInVuaXQiLCJzaG9ydGhhbmQiLCJsb3dlckNhc2UiLCJub3JtYWxpemVVbml0cyIsInVuaXRzIiwibm9ybWFsaXplT2JqZWN0VW5pdHMiLCJpbnB1dE9iamVjdCIsIm5vcm1hbGl6ZWRJbnB1dCIsIm5vcm1hbGl6ZWRQcm9wIiwicHJpb3JpdGllcyIsImFkZFVuaXRQcmlvcml0eSIsInByaW9yaXR5IiwiZ2V0UHJpb3JpdGl6ZWRVbml0cyIsInVuaXRzT2JqIiwidSIsInplcm9GaWxsIiwidGFyZ2V0TGVuZ3RoIiwiZm9yY2VTaWduIiwiYWJzTnVtYmVyIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsImxvY2FsZURhdGEiLCJyZW1vdmVGb3JtYXR0aW5nVG9rZW5zIiwibWFrZUZvcm1hdEZ1bmN0aW9uIiwiZm9ybWF0TW9tZW50IiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibWF0Y2gxIiwibWF0Y2gyIiwibWF0Y2gzIiwibWF0Y2g0IiwibWF0Y2g2IiwibWF0Y2gxdG8yIiwibWF0Y2gzdG80IiwibWF0Y2g1dG82IiwibWF0Y2gxdG8zIiwibWF0Y2gxdG80IiwibWF0Y2gxdG82IiwibWF0Y2hVbnNpZ25lZCIsIm1hdGNoU2lnbmVkIiwibWF0Y2hPZmZzZXQiLCJtYXRjaFNob3J0T2Zmc2V0IiwibWF0Y2hUaW1lc3RhbXAiLCJtYXRjaFdvcmQiLCJyZWdleGVzIiwiYWRkUmVnZXhUb2tlbiIsInN0cmljdFJlZ2V4IiwiaXNTdHJpY3QiLCJnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4iLCJ1bmVzY2FwZUZvcm1hdCIsInJlZ2V4RXNjYXBlIiwibWF0Y2hlZCIsInAxIiwicDIiLCJwMyIsInA0IiwiYWRkUGFyc2VUb2tlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwicGFyc2VUd29EaWdpdFllYXIiLCJkYXlzSW5ZZWFyIiwiaXNMZWFwWWVhciIsImdldFNldFllYXIiLCJtYWtlR2V0U2V0IiwiZ2V0SXNMZWFwWWVhciIsImtlZXBUaW1lIiwic2V0JDEiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwibW9kIiwieCIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TG9jYWxlTW9udGhzIiwibG9jYWxlTW9udGhzIiwiX21vbnRocyIsImlzRm9ybWF0IiwiZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0IiwibG9jYWxlTW9udGhzU2hvcnQiLCJfbW9udGhzU2hvcnQiLCJoYW5kbGVTdHJpY3RQYXJzZSIsIm1vbnRoTmFtZSIsImlpIiwibGxjIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJfbW9udGhzUGFyc2UiLCJfbG9uZ01vbnRoc1BhcnNlIiwiX3Nob3J0TW9udGhzUGFyc2UiLCJsb2NhbGVNb250aHNQYXJzZSIsIl9tb250aHNQYXJzZUV4YWN0Iiwic2V0TW9udGgiLCJkYXlPZk1vbnRoIiwiZ2V0U2V0TW9udGgiLCJnZXREYXlzSW5Nb250aCIsImRlZmF1bHRNb250aHNTaG9ydFJlZ2V4IiwiY29tcHV0ZU1vbnRoc1BhcnNlIiwiX21vbnRoc1Nob3J0U3RyaWN0UmVnZXgiLCJfbW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsIl9tb250aHNTdHJpY3RSZWdleCIsIl9tb250aHNSZWdleCIsImNtcExlblJldiIsInNob3J0UGllY2VzIiwibG9uZ1BpZWNlcyIsIm1peGVkUGllY2VzIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImxvY2FsZVdlZWtkYXlzIiwiX3dlZWtkYXlzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQiLCJsb2NhbGVXZWVrZGF5c1Nob3J0IiwiX3dlZWtkYXlzU2hvcnQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4iLCJsb2NhbGVXZWVrZGF5c01pbiIsIl93ZWVrZGF5c01pbiIsImhhbmRsZVN0cmljdFBhcnNlJDEiLCJ3ZWVrZGF5TmFtZSIsIl93ZWVrZGF5c1BhcnNlIiwiX3Nob3J0V2Vla2RheXNQYXJzZSIsIl9taW5XZWVrZGF5c1BhcnNlIiwibG9jYWxlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1BhcnNlRXhhY3QiLCJfZnVsbFdlZWtkYXlzUGFyc2UiLCJnZXRTZXREYXlPZldlZWsiLCJnZXREYXkiLCJnZXRTZXRMb2NhbGVEYXlPZldlZWsiLCJnZXRTZXRJU09EYXlPZldlZWsiLCJkZWZhdWx0V2Vla2RheXNSZWdleCIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsImRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRSZWdleCIsImRlZmF1bHRXZWVrZGF5c01pblJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwibG9jYWxlTWVyaWRpZW0iLCJpc0xvd2VyIiwiZ2V0U2V0SG91ciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwibG9hZExvY2FsZSIsIm9sZExvY2FsZSIsIl9hYmJyIiwiYWxpYXNlZFJlcXVpcmUiLCJnZXRTZXRHbG9iYWxMb2NhbGUiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwidXBkYXRlTG9jYWxlIiwidG1wTG9jYWxlIiwibGlzdExvY2FsZXMiLCJjaGVja092ZXJmbG93IiwiX292ZXJmbG93RGF5T2ZZZWFyIiwiX292ZXJmbG93V2Vla3MiLCJfb3ZlcmZsb3dXZWVrZGF5IiwiZGVmYXVsdHMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJfdXNlVVRDIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiY29uZmlnRnJvbUFycmF5IiwiY3VycmVudERhdGUiLCJleHBlY3RlZFdlZWtkYXkiLCJ5ZWFyVG9Vc2UiLCJkYXlPZlllYXJGcm9tV2Vla0luZm8iLCJfZGF5T2ZZZWFyIiwiX25leHREYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsInciLCJ3ZWVrWWVhciIsInRlbXAiLCJ3ZWVrZGF5T3ZlcmZsb3ciLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJjdXJXZWVrIiwiZ2ciLCJleHRlbmRlZElzb1JlZ2V4IiwiYmFzaWNJc29SZWdleCIsInR6UmVnZXgiLCJpc29EYXRlcyIsImlzb1RpbWVzIiwiYXNwTmV0SnNvblJlZ2V4IiwiY29uZmlnRnJvbUlTTyIsImFsbG93VGltZSIsImRhdGVGb3JtYXQiLCJ0aW1lRm9ybWF0IiwidHpGb3JtYXQiLCJjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IiwiZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyIsInllYXJTdHIiLCJtb250aFN0ciIsImRheVN0ciIsImhvdXJTdHIiLCJtaW51dGVTdHIiLCJzZWNvbmRTdHIiLCJ1bnRydW5jYXRlWWVhciIsInByZXByb2Nlc3NSRkMyODIyIiwiY2hlY2tXZWVrZGF5Iiwid2Vla2RheVN0ciIsInBhcnNlZElucHV0Iiwid2Vla2RheVByb3ZpZGVkIiwid2Vla2RheUFjdHVhbCIsIm9ic09mZnNldHMiLCJVVCIsIkdNVCIsIkVEVCIsIkVTVCIsIkNEVCIsIkNTVCIsIk1EVCIsIk1TVCIsIlBEVCIsIlBTVCIsImNhbGN1bGF0ZU9mZnNldCIsIm9ic09mZnNldCIsIm1pbGl0YXJ5T2Zmc2V0IiwibnVtT2Zmc2V0IiwiaG0iLCJjb25maWdGcm9tUkZDMjgyMiIsInBhcnNlZEFycmF5IiwiY29uZmlnRnJvbVN0cmluZyIsImNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrIiwiSVNPXzg2MDEiLCJSRkNfMjgyMiIsInNraXBwZWQiLCJzdHJpbmdMZW5ndGgiLCJ0b3RhbFBhcnNlZElucHV0TGVuZ3RoIiwibWVyaWRpZW1GaXhXcmFwIiwiaG91ciIsImlzUG0iLCJtZXJpZGllbUhvdXIiLCJjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkiLCJ0ZW1wQ29uZmlnIiwiYmVzdE1vbWVudCIsInNjb3JlVG9CZWF0IiwiY3VycmVudFNjb3JlIiwic2NvcmUiLCJjb25maWdGcm9tT2JqZWN0IiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJjcmVhdGVGcm9tQ29uZmlnIiwicHJlcGFyZUNvbmZpZyIsInByZXBhcnNlIiwiY29uZmlnRnJvbUlucHV0IiwiaXNVVEMiLCJwcm90b3R5cGVNaW4iLCJwcm90b3R5cGVNYXgiLCJwaWNrQnkiLCJtb21lbnRzIiwib3JkZXJpbmciLCJpc0R1cmF0aW9uVmFsaWQiLCJ1bml0SGFzRGVjaW1hbCIsImlzVmFsaWQkMSIsImNyZWF0ZUludmFsaWQkMSIsImNyZWF0ZUR1cmF0aW9uIiwiRHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfYnViYmxlIiwiaXNEdXJhdGlvbiIsImFic1JvdW5kIiwicm91bmQiLCJzZXBhcmF0b3IiLCJ1dGNPZmZzZXQiLCJvZmZzZXRGcm9tU3RyaW5nIiwiY2h1bmtPZmZzZXQiLCJtYXRjaGVyIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsInNldFRpbWUiLCJsb2NhbCIsImdldERhdGVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImdldFNldE9mZnNldCIsImtlZXBMb2NhbFRpbWUiLCJrZWVwTWludXRlcyIsImxvY2FsQWRqdXN0IiwiX2NoYW5nZUluUHJvZ3Jlc3MiLCJhZGRTdWJ0cmFjdCIsImdldFNldFpvbmUiLCJzZXRPZmZzZXRUb1VUQyIsInNldE9mZnNldFRvTG9jYWwiLCJzdWJ0cmFjdCIsInNldE9mZnNldFRvUGFyc2VkT2Zmc2V0IiwidFpvbmUiLCJoYXNBbGlnbmVkSG91ck9mZnNldCIsImlzRGF5bGlnaHRTYXZpbmdUaW1lIiwiaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkIiwiX2lzRFNUU2hpZnRlZCIsImlzTG9jYWwiLCJpc1V0Y09mZnNldCIsImlzVXRjIiwiYXNwTmV0UmVnZXgiLCJpc29SZWdleCIsImRpZmZSZXMiLCJwYXJzZUlzbyIsIm1vbWVudHNEaWZmZXJlbmNlIiwiaW52YWxpZCIsImlucCIsInBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsImlzQWRkaW5nIiwiZ2V0Q2FsZW5kYXJGb3JtYXQiLCJteU1vbWVudCIsImNhbGVuZGFyJDEiLCJ0aW1lIiwiZm9ybWF0cyIsInNvZCIsInN0YXJ0T2YiLCJjYWxlbmRhckZvcm1hdCIsImxvY2FsSW5wdXQiLCJlbmRPZiIsImlzQmV0d2VlbiIsImluY2x1c2l2aXR5IiwibG9jYWxGcm9tIiwibG9jYWxUbyIsImlzU2FtZSIsImlucHV0TXMiLCJpc1NhbWVPckFmdGVyIiwiaXNTYW1lT3JCZWZvcmUiLCJhc0Zsb2F0IiwidGhhdCIsInpvbmVEZWx0YSIsIm1vbnRoRGlmZiIsIndob2xlTW9udGhEaWZmIiwiYW5jaG9yIiwiYW5jaG9yMiIsImFkanVzdCIsImRlZmF1bHRGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0VXRjIiwidG9JU09TdHJpbmciLCJrZWVwT2Zmc2V0IiwidG9EYXRlIiwiaW5zcGVjdCIsInpvbmUiLCJkYXRldGltZSIsInN1ZmZpeCIsImlucHV0U3RyaW5nIiwicG9zdGZvcm1hdCIsImh1bWFuaXplIiwiZnJvbU5vdyIsInRvTm93IiwibmV3TG9jYWxlRGF0YSIsImxhbmciLCJNU19QRVJfU0VDT05EIiwiTVNfUEVSX01JTlVURSIsIk1TX1BFUl9IT1VSIiwiTVNfUEVSXzQwMF9ZRUFSUyIsIm1vZCQxIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibG9jYWxTdGFydE9mRGF0ZSIsInV0Y1N0YXJ0T2ZEYXRlIiwic3RhcnRPZkRhdGUiLCJpc29XZWVrZGF5IiwidW5peCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsImlzb1dlZWtZZWFyIiwiYWRkV2Vla1llYXJGb3JtYXRUb2tlbiIsImdldFNldFdlZWtZZWFyIiwiZ2V0U2V0V2Vla1llYXJIZWxwZXIiLCJnZXRTZXRJU09XZWVrWWVhciIsImdldElTT1dlZWtzSW5ZZWFyIiwiZ2V0V2Vla3NJblllYXIiLCJ3ZWVrSW5mbyIsIndlZWtzVGFyZ2V0Iiwic2V0V2Vla0FsbCIsImRheU9mWWVhckRhdGEiLCJnZXRTZXRRdWFydGVyIiwiZ2V0U2V0RGF5T2ZNb250aCIsImdldFNldERheU9mWWVhciIsImdldFNldE1pbnV0ZSIsImdldFNldFNlY29uZCIsInBhcnNlTXMiLCJnZXRTZXRNaWxsaXNlY29uZCIsImdldFpvbmVBYmJyIiwiZ2V0Wm9uZU5hbWUiLCJpc29XZWVrcyIsImlzb1dlZWtzSW5ZZWFyIiwicGFyc2Vab25lIiwiaXNEU1QiLCJ6b25lQWJiciIsInpvbmVOYW1lIiwiZGF0ZXMiLCJpc0RTVFNoaWZ0ZWQiLCJjcmVhdGVVbml4IiwiY3JlYXRlSW5ab25lIiwicHJlUGFyc2VQb3N0Rm9ybWF0IiwicHJvdG8kMSIsImZpcnN0RGF5T2ZZZWFyIiwiZmlyc3REYXlPZldlZWsiLCJnZXQkMSIsImZpZWxkIiwibGlzdE1vbnRoc0ltcGwiLCJvdXQiLCJsaXN0V2Vla2RheXNJbXBsIiwibG9jYWxlU29ydGVkIiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsInN1YnRyYWN0JDEiLCJhYnNDZWlsIiwiYnViYmxlIiwibW9udGhzRnJvbURheXMiLCJtb250aHNUb0RheXMiLCJkYXlzVG9Nb250aHMiLCJhcyIsInZhbHVlT2YkMSIsIm1ha2VBcyIsImFzTWlsbGlzZWNvbmRzIiwiYXNTZWNvbmRzIiwiYXNNaW51dGVzIiwiYXNIb3VycyIsImFzRGF5cyIsImFzV2Vla3MiLCJhc01vbnRocyIsImFzUXVhcnRlcnMiLCJhc1llYXJzIiwiY2xvbmUkMSIsImdldCQyIiwibWFrZUdldHRlciIsInRocmVzaG9sZHMiLCJzdWJzdGl0dXRlVGltZUFnbyIsInJlbGF0aXZlVGltZSQxIiwicG9zTmVnRHVyYXRpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJvdW5kaW5nRnVuY3Rpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndpdGhTdWZmaXgiLCJhYnMkMSIsInRvSVNPU3RyaW5nJDEiLCJZIiwiRCIsInRvRml4ZWQiLCJ0b3RhbCIsInRvdGFsU2lnbiIsInltU2lnbiIsImRheXNTaWduIiwiaG1zU2lnbiIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInJlbGF0aXZlVGltZVJvdW5kaW5nIiwicmVsYXRpdmVUaW1lVGhyZXNob2xkIiwiSFRNTDVfRk1UIiwiREFURVRJTUVfTE9DQUwiLCJEQVRFVElNRV9MT0NBTF9TRUNPTkRTIiwiREFURVRJTUVfTE9DQUxfTVMiLCJUSU1FIiwiVElNRV9TRUNPTkRTIiwiVElNRV9NUyIsInJlcXVpcmUkJDAiLCJtb21lbnQiLCJjb252ZXJzaW9ucyIsInJnYjJoc2wiLCJyZ2IyaHN2IiwicmdiMmh3YiIsInJnYjJjbXlrIiwicmdiMmtleXdvcmQiLCJyZ2IyeHl6IiwicmdiMmxhYiIsInJnYjJsY2giLCJoc2wycmdiIiwiaHNsMmhzdiIsImhzbDJod2IiLCJoc2wyY215ayIsImhzbDJrZXl3b3JkIiwiaHN2MnJnYiIsImhzdjJoc2wiLCJoc3YyaHdiIiwiaHN2MmNteWsiLCJoc3Yya2V5d29yZCIsImh3YjJyZ2IiLCJod2IyaHNsIiwiaHdiMmhzdiIsImh3YjJjbXlrIiwiaHdiMmtleXdvcmQiLCJjbXlrMnJnYiIsImNteWsyaHNsIiwiY215azJoc3YiLCJjbXlrMmh3YiIsImNteWsya2V5d29yZCIsImtleXdvcmQycmdiIiwia2V5d29yZDJoc2wiLCJrZXl3b3JkMmhzdiIsImtleXdvcmQyaHdiIiwia2V5d29yZDJjbXlrIiwia2V5d29yZDJsYWIiLCJrZXl3b3JkMnh5eiIsInh5ejJyZ2IiLCJ4eXoybGFiIiwieHl6MmxjaCIsImxhYjJ4eXoiLCJsYWIycmdiIiwibGFiMmxjaCIsImxjaDJsYWIiLCJsY2gyeHl6IiwibGNoMnJnYiIsInJnYiIsInIiLCJnIiwiZGVsdGEiLCJyZXZlcnNlS2V5d29yZHMiLCJ6IiwieHl6IiwiaHNsIiwidDEiLCJ0MiIsInQzIiwic3YiLCJoc3YiLCJoaSIsImYiLCJxIiwic2wiLCJod2IiLCJ3aCIsImJsIiwicmF0aW8iLCJjbXlrIiwibGFiIiwieTIiLCJociIsImF0YW4yIiwiUEkiLCJzcXJ0IiwibGNoIiwiY29zIiwic2luIiwia2V5d29yZCIsImNzc0tleXdvcmRzIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJDb252ZXJ0ZXIiLCJwYWlyIiwiY29udnMiLCJyb3V0ZVNwYWNlIiwiZ2V0VmFsdWVzIiwic2V0VmFsdWVzIiwidmFscyIsImZzcGFjZSIsImNvbG9yQ29udmVydCIsImNvbG9yTmFtZSIsImNvbG9yU3RyaW5nIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwiaGV4IiwicmdiYSIsInBlciIsImhleEFscGhhIiwic2NhbGUiLCJhbHBoYSIsImhzbGEiLCJoZXhEb3VibGUiLCJyZXZlcnNlTmFtZXMiLCJudW0iLCJDb2xvciIsImxpZ2h0bmVzcyIsIndoaXRlbmVzcyIsInNldFNwYWNlIiwicmdiQXJyYXkiLCJoc2xBcnJheSIsImhzdkFycmF5IiwiaHdiQXJyYXkiLCJjbXlrQXJyYXkiLCJyZ2JhQXJyYXkiLCJoc2xhQXJyYXkiLCJzZXRDaGFubmVsIiwiaHVlIiwic2F0dXJhdGlvbiIsInNhdHVyYXRpb252IiwiYmxhY2tuZXNzIiwicmdiTnVtYmVyIiwibHVtaW5vc2l0eSIsImx1bSIsImNoYW4iLCJjb250cmFzdCIsImNvbG9yMiIsImx1bTEiLCJsdW0yIiwibGV2ZWwiLCJjb250cmFzdFJhdGlvIiwiZGFyayIsInlpcSIsImxpZ2h0IiwibmVnYXRlIiwibGlnaHRlbiIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImJsYWNrZW4iLCJncmV5c2NhbGUiLCJjbGVhcmVyIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwidzEiLCJ3MiIsInNwYWNlcyIsIm1heGVzIiwiY2hhbnMiLCJjYXBwZWQiLCJzbmFtZSIsInN2YWx1ZXMiLCJjaGFydGpzQ29sb3IiLCJoZWxwZXJzIiwiaXNOdWxsT3JVbmRlZiIsInZhbHVlT3JEZWZhdWx0IiwidmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWFjaCIsImxvb3BhYmxlIiwicmV2ZXJzZSIsImFycmF5RXF1YWxzIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwia2xlbiIsIl9tZXJnZXIiLCJ0dmFsIiwic3ZhbCIsIl9tZXJnZXJJZiIsIm1lcmdlSWYiLCJtZXJnZXIiLCJzZXRGbiIsImluaGVyaXRzIiwiZXh0ZW5zaW9ucyIsIm1lIiwiQ2hhcnRFbGVtZW50IiwiU3Vycm9nYXRlIiwiX19zdXBlcl9fIiwiaGVscGVyc19jb3JlIiwiY2FsbENhbGxiYWNrIiwiZnJvbUluZGV4IiwiZ2V0VmFsdWVPckRlZmF1bHQiLCJnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJoZWxwZXJzX2Vhc2luZyIsImVhc2luZ0VmZmVjdHMiLCJSQURfUEVSX0RFRyIsIkRPVUJMRV9QSSIsIkhBTEZfUEkiLCJRVUFSVEVSX1BJIiwiVFdPX1RISVJEU19QSSIsImV4cG9ydHMkMSIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmRlZFJlY3QiLCJyYWRpdXMiLCJib3R0b20iLCJtb3ZlVG8iLCJhcmMiLCJjbG9zZVBhdGgiLCJyZWN0IiwiZHJhd1BvaW50Iiwicm90YXRpb24iLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInJhZCIsImRyYXdJbWFnZSIsImJlZ2luUGF0aCIsImxpbmVUbyIsIlNRUlQxXzIiLCJmaWxsIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJwb2ludCIsImFyZWEiLCJlcHNpbG9uIiwiY2xpcEFyZWEiLCJzYXZlIiwiY2xpcCIsInVuY2xpcEFyZWEiLCJyZXN0b3JlIiwicHJldmlvdXMiLCJmbGlwIiwic3RlcHBlZCIsInN0ZXBwZWRMaW5lIiwibWlkcG9pbnQiLCJ0ZW5zaW9uIiwiYmV6aWVyQ3VydmVUbyIsImNvbnRyb2xQb2ludFByZXZpb3VzWCIsImNvbnRyb2xQb2ludE5leHRYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFkiLCJoZWxwZXJzX2NhbnZhcyIsImRyYXdSb3VuZGVkUmVjdGFuZ2xlIiwiX3NldCIsInNjb3BlIiwiZGVmYXVsdENvbG9yIiwiZGVmYXVsdEZvbnRDb2xvciIsImRlZmF1bHRGb250RmFtaWx5IiwiZGVmYXVsdEZvbnRTaXplIiwiZGVmYXVsdEZvbnRTdHlsZSIsImRlZmF1bHRMaW5lSGVpZ2h0Iiwic2hvd0xpbmVzIiwiY29yZV9kZWZhdWx0cyIsInRvRm9udFN0cmluZyIsImZvbnQiLCJmYW1pbHkiLCJoZWxwZXJzX29wdGlvbnMiLCJ0b0xpbmVIZWlnaHQiLCJ0b1BhZGRpbmciLCJfcGFyc2VGb250IiwiZ2xvYmFsRGVmYXVsdHMiLCJmb250RmFtaWx5IiwibGluZUhlaWdodCIsImZvbnRTdHlsZSIsImlucHV0cyIsImhlbHBlcnMkMSIsImVhc2luZyIsImNhbnZhcyIsImVhc2UiLCJvcmlnaW4iLCJjMCIsImMxIiwiRWxlbWVudCIsImNvbmZpZ3VyYXRpb24iLCJpbml0aWFsaXplIiwiaGlkZGVuIiwicGl2b3QiLCJfdmlldyIsIl9tb2RlbCIsIl9zdGFydCIsInRvb2x0aXBQb3NpdGlvbiIsImhhc1ZhbHVlIiwiY29yZV9lbGVtZW50IiwiZXhwb3J0cyQyIiwiY3VycmVudFN0ZXAiLCJudW1TdGVwcyIsIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCJvbkFuaW1hdGlvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb24iLCJhbmltYXRpb24iLCJvblByb2dyZXNzIiwib25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0IiwiYWRkQW5pbWF0aW9uIiwic3RhcnRUaW1lIiwiYW5pbWF0aW5nIiwiY2FuY2VsQW5pbWF0aW9uIiwiZmluZEluZGV4IiwicmVxdWVzdEFuaW1GcmFtZSIsInN0YXJ0RGlnZXN0IiwibmV4dFN0ZXAiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwiRGF0YXNldENvbnRyb2xsZXIiLCJkYXRhc2V0SW5kZXgiLCJkYXRhc2V0RWxlbWVudFR5cGUiLCJkYXRhRWxlbWVudFR5cGUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJ1cGRhdGVJbmRleCIsImdldE1ldGEiLCJnZXREYXRhc2V0IiwieEF4aXNJRCIsInNjYWxlcyIsInhBeGVzIiwieUF4aXNJRCIsInlBeGVzIiwiZ2V0RGF0YXNldE1ldGEiLCJnZXRTY2FsZUZvcklkIiwic2NhbGVJRCIsIl9nZXRWYWx1ZVNjYWxlSWQiLCJfZ2V0SW5kZXhTY2FsZUlkIiwiX2dldFZhbHVlU2NhbGUiLCJfZ2V0SW5kZXhTY2FsZSIsInJlc2V0IiwiY3JlYXRlTWV0YURhdGFzZXQiLCJfZGF0YXNldEluZGV4IiwiY3JlYXRlTWV0YURhdGEiLCJfaW5kZXgiLCJtZXRhRGF0YSIsImFkZEVsZW1lbnRBbmRSZXNldCIsInVwZGF0ZUVsZW1lbnQiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJyZXN5bmNFbGVtZW50cyIsImVhc2luZ1ZhbHVlIiwiZWxlbWVudHMiLCJkcmF3IiwicmVtb3ZlSG92ZXJTdHlsZSIsIiRwcmV2aW91c1N0eWxlIiwic2V0SG92ZXJTdHlsZSIsImN1c3RvbSIsImdldEhvdmVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJCb3JkZXJXaWR0aCIsIm51bU1ldGEiLCJudW1EYXRhIiwiaW5zZXJ0RWxlbWVudHMiLCJvbkRhdGFQdXNoIiwib25EYXRhUG9wIiwib25EYXRhU2hpZnQiLCJvbkRhdGFTcGxpY2UiLCJvbkRhdGFVbnNoaWZ0IiwiY29yZV9kYXRhc2V0Q29udHJvbGxlciIsImJvcmRlckFsaWduIiwiZWxlbWVudF9hcmMiLCJpbkxhYmVsUmFuZ2UiLCJtb3VzZVgiLCJob3ZlclJhZGl1cyIsImluUmFuZ2UiLCJjaGFydFgiLCJjaGFydFkiLCJwb2ludFJlbGF0aXZlUG9zaXRpb24iLCJnZXRBbmdsZUZyb21Qb2ludCIsImFuZ2xlIiwiZGlzdGFuY2UiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImdldENlbnRlclBvaW50IiwiaGFsZkFuZ2xlIiwiaGFsZlJhZGl1cyIsImdldEFyZWEiLCJjZW50cmVBbmdsZSIsInJhbmdlRnJvbUNlbnRyZSIsInNBIiwiZUEiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJzdHJva2VTdHlsZSIsInZhbHVlT3JEZWZhdWx0JDEiLCJsaW5lIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsImNhcEJlemllclBvaW50cyIsImVsZW1lbnRfbGluZSIsInNwYW5HYXBzIiwicG9pbnRzIiwiX2NoaWxkcmVuIiwiZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzIiwibGFzdERyYXduSW5kZXgiLCJjdXJyZW50Vk0iLCJfbG9vcCIsImxpbmVDYXAiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicHJldmlvdXNJdGVtIiwic2tpcCIsInZhbHVlT3JEZWZhdWx0JDIiLCJkZWZhdWx0Q29sb3IkMSIsInBvaW50U3R5bGUiLCJoaXRSYWRpdXMiLCJ4UmFuZ2UiLCJ5UmFuZ2UiLCJtb3VzZVkiLCJlbGVtZW50X3BvaW50IiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsInBhZGRpbmciLCJjaGFydEFyZWEiLCJkZWZhdWx0Q29sb3IkMiIsInJlY3RhbmdsZSIsImJvcmRlclNraXBwZWQiLCJpc1ZlcnRpY2FsIiwiZ2V0QmFyQm91bmRzIiwieDEiLCJ4MiIsInkxIiwiaGFsZiIsInN3YXAiLCJvcmlnIiwidjIiLCJwYXJzZUJvcmRlclNraXBwZWQiLCJlZGdlIiwiaG9yaXpvbnRhbCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJib3JkZXIiLCJvdXRlciIsImlubmVyIiwic2tpcFgiLCJza2lwWSIsImVsZW1lbnRfcmVjdGFuZ2xlIiwicmVjdHMiLCJmaWxsUmVjdCIsIkFyYyIsIkxpbmUiLCJQb2ludCIsIlJlY3RhbmdsZSIsInJlc29sdmUkMSIsImhvdmVyIiwiY2F0ZWdvcnlQZXJjZW50YWdlIiwiYmFyUGVyY2VudGFnZSIsImdyaWRMaW5lcyIsIm9mZnNldEdyaWRMaW5lcyIsImNvbXB1dGVNaW5TYW1wbGVTaXplIiwicGl4ZWxzIiwiaXNIb3Jpem9udGFsIiwidGlja3MiLCJnZXRUaWNrcyIsImN1cnIiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsInN0YWNrQ291bnQiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwicGVyY2VudCIsImNvbnRyb2xsZXJfYmFyIiwiYmFyIiwiX3J1bGVyIiwiZ2V0UnVsZXIiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiX3hTY2FsZSIsIl95U2NhbGUiLCJkYXRhc2V0TGFiZWwiLCJfdXBkYXRlRWxlbWVudEdlb21ldHJ5IiwidnNjYWxlIiwiZ2V0QmFzZVBpeGVsIiwidnBpeGVscyIsImNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsImNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiaGVhZCIsImNlbnRlciIsIl9nZXRTdGFja3MiLCJzdGFja3MiLCJpc0RhdGFzZXRWaXNpYmxlIiwiZ2V0U3RhY2tDb3VudCIsImdldFN0YWNrSW5kZXgiLCJnZXRQaXhlbEZvclZhbHVlIiwiZ2V0UmlnaHRWYWx1ZSIsIm1pbkJhckxlbmd0aCIsImltZXRhIiwiaXZhbHVlIiwiY29udHJvbGxlciIsInN0YWNrSW5kZXgiLCJtYXhCYXJUaGlja25lc3MiLCJJbmZpbml0eSIsImRhdGFJbmRleCIsInZhbHVlT3JEZWZhdWx0JDMiLCJyZXNvbHZlJDIiLCJwb3NpdGlvbiIsInRvb2x0aXBzIiwiZGF0YVBvaW50IiwieExhYmVsIiwieUxhYmVsIiwiY29udHJvbGxlcl9idWJibGUiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJkc0luZGV4IiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwiX29wdGlvbnMiLCJyZXNvbHZlJDMiLCJ2YWx1ZU9yRGVmYXVsdCQ0IiwiYW5pbWF0ZVJvdGF0ZSIsImFuaW1hdGVTY2FsZSIsImxlZ2VuZENhbGxiYWNrIiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJkcyIsImFyY09wdHMiLCJidyIsIm9uQ2xpY2siLCJsZWdlbmRJdGVtIiwiY3V0b3V0UGVyY2VudGFnZSIsImNpcmN1bWZlcmVuY2UiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImNvbnRyb2xsZXJfZG91Z2hudXQiLCJnZXRSaW5nSW5kZXgiLCJyaW5nSW5kZXgiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsIm1pblNpemUiLCJhcmNzIiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsImNvbnRhaW5zMCIsImNvbnRhaW5zOTAiLCJjb250YWluczE4MCIsImNvbnRhaW5zMjcwIiwiY3V0b3V0IiwiZ2V0TWF4Qm9yZGVyV2lkdGgiLCJyYWRpdXNMZW5ndGgiLCJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY2FsY3VsYXRlVG90YWwiLCJfZ2V0UmluZ1dlaWdodE9mZnNldCIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCJob3ZlcldpZHRoIiwicmluZ1dlaWdodE9mZnNldCIsImRhdGFTZXRJbmRleCIsImF4aXMiLCJjb250cm9sbGVyX2hvcml6b250YWxCYXIiLCJ2YWx1ZU9yRGVmYXVsdCQ1IiwicmVzb2x2ZSQ0IiwiaXNQb2ludEluQXJlYSIsImxpbmVFbmFibGVkIiwic2hvd0xpbmUiLCJjb250cm9sbGVyX2xpbmUiLCJsaW5lVGVuc2lvbiIsIl9zY2FsZSIsIl9yZXNvbHZlTGluZU9wdGlvbnMiLCJ1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwibGluZU1vZGVsIiwiX3Jlc29sdmVQb2ludE9wdGlvbnMiLCJjYWxjdWxhdGVQb2ludFkiLCJFTEVNRU5UX09QVElPTlMiLCJlbGVtZW50T3B0aW9ucyIsInN1bVBvcyIsInN1bU5lZyIsImRzTWV0YSIsInN0YWNrZWRSaWdodFZhbHVlIiwicmlnaHRWYWx1ZSIsImNvbnRyb2xQb2ludHMiLCJwdCIsImNhcENvbnRyb2xQb2ludCIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic3BsaW5lQ3VydmUiLCJuZXh0SXRlbSIsImhhbGZCb3JkZXJXaWR0aCIsInJlc29sdmUkNSIsImFuZ2xlTGluZXMiLCJwb2ludExhYmVscyIsImJlZ2luQXRaZXJvIiwiY29udHJvbGxlcl9wb2xhckFyZWEiLCJzdGFydHMiLCJfc3RhcnRzIiwiYW5nbGVzIiwiX2FuZ2xlcyIsIl91cGRhdGVSYWRpdXMiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwicmVzZXRSYWRpdXMiLCJkb3VnaG51dCIsImNvbnRyb2xsZXJfcGllIiwidmFsdWVPckRlZmF1bHQkNiIsInJlc29sdmUkNiIsImNvbnRyb2xsZXJfcmFkYXIiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwiY29udHJvbGxlcl9zY2F0dGVyIiwiY29udHJvbGxlcnMiLCJob3Jpem9udGFsQmFyIiwicG9sYXJBcmVhIiwicGllIiwicmFkYXIiLCJzY2F0dGVyIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsInBhcnNlVmlzaWJsZUl0ZW1zIiwiamxlbiIsImdldEludGVyc2VjdEl0ZW1zIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiaW50ZXJzZWN0IiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsIlBPU0lUSVZFX0lORklOSVRZIiwibmVhcmVzdEl0ZW1zIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJpbmRleE1vZGUiLCJjb3JlX2ludGVyYWN0aW9uIiwibW9kZXMiLCJzaW5nbGUiLCJuZWFyZXN0IiwiaW50ZXJzZWN0c0l0ZW0iLCJmaWx0ZXJCeVBvc2l0aW9uIiwid2hlcmUiLCJzb3J0QnlXZWlnaHQiLCJfdG1wSW5kZXhfIiwiZmluZE1heFBhZGRpbmciLCJib3hlcyIsImJveCIsImdldFBhZGRpbmciLCJib3hQYWRkaW5nIiwiYWRkU2l6ZUJ5UG9zaXRpb24iLCJsYXlvdXQiLCJjb3JlX2xheW91dHMiLCJhZGRCb3giLCJmdWxsV2lkdGgiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwibGF5b3V0T3B0aW9ucyIsImxlZnRQYWRkaW5nIiwicmlnaHRQYWRkaW5nIiwidG9wUGFkZGluZyIsImJvdHRvbVBhZGRpbmciLCJsZWZ0Qm94ZXMiLCJyaWdodEJveGVzIiwidG9wQm94ZXMiLCJib3R0b21Cb3hlcyIsImNoYXJ0QXJlYUJveGVzIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsIm91dGVyQm94ZXMiLCJjaGFydFdpZHRoIiwiY2hhcnRIZWlnaHQiLCJjaGFydEFyZWFXaWR0aCIsInZlcnRpY2FsQm94V2lkdGgiLCJtYXhDaGFydEFyZWFXaWR0aCIsIm1heENoYXJ0QXJlYUhlaWdodCIsIm91dGVyQm94U2l6ZXMiLCJtaW5Cb3hTaXplcyIsIm1heFBhZGRpbmciLCJnZXRNaW5pbXVtQm94U2l6ZSIsImZpdEJveCIsIm1pbkJveFNpemUiLCJmaW5kTmV4dFdoZXJlIiwibWluQm94Iiwic2NhbGVNYXJnaW4iLCJmaW5hbEZpdFZlcnRpY2FsQm94IiwibGVmdFBhZGRpbmdBZGRpdGlvbiIsInRvcFBhZGRpbmdBZGRpdGlvbiIsIm5ld01heENoYXJ0QXJlYUhlaWdodCIsIm5ld01heENoYXJ0QXJlYVdpZHRoIiwicGxhY2VCb3giLCJwbGF0Zm9ybV9iYXNpYyIsImFjcXVpcmVDb250ZXh0IiwiZ2V0Q29udGV4dCIsInBsYXRmb3JtX2RvbSIsInBsYXRmb3JtX2RvbSQxIiwiZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSIsInN0eWxlc2hlZXQiLCJFWFBBTkRPX0tFWSIsIkNTU19QUkVGSVgiLCJDU1NfU0laRV9NT05JVE9SIiwiQ1NTX1JFTkRFUl9NT05JVE9SIiwiQ1NTX1JFTkRFUl9BTklNQVRJT04iLCJBTklNQVRJT05fU1RBUlRfRVZFTlRTIiwiRVZFTlRfVFlQRVMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm91dCIsInJlYWRVc2VkU2l6ZSIsImluaXRDYW52YXMiLCJyZW5kZXJIZWlnaHQiLCJyZW5kZXJXaWR0aCIsImRpc3BsYXlXaWR0aCIsImFzcGVjdFJhdGlvIiwiZGlzcGxheUhlaWdodCIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJzdXBwb3J0cyIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50IiwiZnJvbU5hdGl2ZUV2ZW50IiwidGhyb3R0bGVkIiwidGlja2luZyIsImNyZWF0ZURpdiIsImNsYXNzTmFtZSIsImNyZWF0ZVJlc2l6ZXIiLCJtYXhTaXplIiwicmVzaXplciIsImV4cGFuZCIsInNocmluayIsIl9yZXNldCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJvblNjcm9sbCIsIndhdGNoRm9yUmVuZGVyIiwiZXhwYW5kbyIsInJlbmRlclByb3h5IiwiYW5pbWF0aW9uTmFtZSIsInJlZmxvdyIsIm9mZnNldFBhcmVudCIsInVud2F0Y2hGb3JSZW5kZXIiLCJhZGRSZXNpemVMaXN0ZW5lciIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJjbGllbnRXaWR0aCIsInJlbW92ZVJlc2l6ZUxpc3RlbmVyIiwiaW5qZWN0Q1NTIiwiX3N0eWxlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJwbGF0Zm9ybV9kb20kMiIsImRpc2FibGVDU1NJbmplY3Rpb24iLCJfZW5hYmxlZCIsIl9lbnN1cmVMb2FkZWQiLCJfbG9hZGVkIiwiZ2V0RWxlbWVudEJ5SWQiLCJyZWxlYXNlQ29udGV4dCIsInByb3hpZXMiLCJhZGRFdmVudCIsInJlbW92ZUV2ZW50IiwiaW1wbGVtZW50YXRpb24iLCJwbHVnaW5zIiwiY29yZV9wbHVnaW5zIiwiX3BsdWdpbnMiLCJfY2FjaGVJZCIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsImlkeCIsImdldEFsbCIsImRlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIiRwbHVnaW5zIiwiX2ludmFsaWRhdGUiLCJjb3JlX3NjYWxlU2VydmljZSIsImNvbnN0cnVjdG9ycyIsInJlZ2lzdGVyU2NhbGVUeXBlIiwic2NhbGVDb25zdHJ1Y3RvciIsInNjYWxlRGVmYXVsdHMiLCJnZXRTY2FsZUNvbnN0cnVjdG9yIiwiZ2V0U2NhbGVEZWZhdWx0cyIsInVwZGF0ZVNjYWxlRGVmYXVsdHMiLCJhZGRpdGlvbnMiLCJhZGRTY2FsZXNUb0xheW91dCIsInZhbHVlT3JEZWZhdWx0JDciLCJlbmFibGVkIiwidGl0bGVGb250U3R5bGUiLCJ0aXRsZVNwYWNpbmciLCJ0aXRsZU1hcmdpbkJvdHRvbSIsInRpdGxlRm9udENvbG9yIiwidGl0bGVBbGlnbiIsImJvZHlTcGFjaW5nIiwiYm9keUZvbnRDb2xvciIsImJvZHlBbGlnbiIsImZvb3RlckZvbnRTdHlsZSIsImZvb3RlclNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJGb250Q29sb3IiLCJmb290ZXJBbGlnbiIsInlQYWRkaW5nIiwieFBhZGRpbmciLCJjYXJldFBhZGRpbmciLCJjYXJldFNpemUiLCJtdWx0aUtleUJhY2tncm91bmQiLCJkaXNwbGF5Q29sb3JzIiwiYmVmb3JlVGl0bGUiLCJ0b29sdGlwSXRlbXMiLCJsYWJlbENvdW50IiwiYWZ0ZXJUaXRsZSIsImJlZm9yZUJvZHkiLCJiZWZvcmVMYWJlbCIsImxhYmVsQ29sb3IiLCJsYWJlbFRleHRDb2xvciIsImFmdGVyTGFiZWwiLCJhZnRlckJvZHkiLCJiZWZvcmVGb290ZXIiLCJmb290ZXIiLCJhZnRlckZvb3RlciIsInBvc2l0aW9uZXJzIiwiYXZlcmFnZSIsImV2ZW50UG9zaXRpb24iLCJuZWFyZXN0RWxlbWVudCIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInRwIiwicHVzaE9yQ29uY2F0IiwidG9QdXNoIiwic3BsaXROZXdsaW5lcyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRMYWJlbEZvckluZGV4IiwiZ2V0QmFzZU1vZGVsIiwidG9vbHRpcE9wdHMiLCJ4QWxpZ24iLCJ5QWxpZ24iLCJfYm9keUZvbnRGYW1pbHkiLCJib2R5Rm9udEZhbWlseSIsIl9ib2R5Rm9udFN0eWxlIiwiYm9keUZvbnRTdHlsZSIsIl9ib2R5QWxpZ24iLCJib2R5Rm9udFNpemUiLCJfdGl0bGVGb250RmFtaWx5IiwidGl0bGVGb250RmFtaWx5IiwiX3RpdGxlRm9udFN0eWxlIiwidGl0bGVGb250U2l6ZSIsIl90aXRsZUFsaWduIiwiX2Zvb3RlckZvbnRGYW1pbHkiLCJmb290ZXJGb250RmFtaWx5IiwiX2Zvb3RlckZvbnRTdHlsZSIsImZvb3RlckZvbnRTaXplIiwiX2Zvb3RlckFsaWduIiwib3BhY2l0eSIsImxlZ2VuZENvbG9yQmFja2dyb3VuZCIsImdldFRvb2x0aXBTaXplIiwidG9vbHRpcCIsImNvbWJpbmVkQm9keUxlbmd0aCIsImJvZHlJdGVtIiwiYWZ0ZXIiLCJ0aXRsZUxpbmVDb3VudCIsImZvb3RlckxpbmVDb3VudCIsIndpZHRoUGFkZGluZyIsIm1heExpbmVXaWR0aCIsIm1lYXN1cmVUZXh0IiwiZm9udFN0cmluZyIsImRldGVybWluZUFsaWdubWVudCIsImxmIiwicmYiLCJvbGYiLCJvcmYiLCJ5ZiIsIm1pZFgiLCJtaWRZIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwicGFkZGluZ0FuZFNpemUiLCJyYWRpdXNBbmRQYWRkaW5nIiwiZ2V0QWxpZ25lZFgiLCJhbGlnbiIsImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwiZXhwb3J0cyQzIiwiX2xhc3RBY3RpdmUiLCJnZXRUaXRsZSIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiY2hhbmdlZCIsImV4aXN0aW5nTW9kZWwiLCJfYWN0aXZlIiwiYmFja2dyb3VuZFBvaW50IiwidG9vbHRpcFNpemUiLCJjYXJldFgiLCJjYXJldFkiLCJsYWJlbENvbG9ycyIsImxhYmVsVGV4dENvbG9ycyIsIl9ldmVudFBvc2l0aW9uIiwiaXRlbVNvcnQiLCJkYXRhUG9pbnRzIiwiZHJhd0NhcmV0IiwidG9vbHRpcFBvaW50IiwiY2FyZXRQb3NpdGlvbiIsImdldENhcmV0UG9zaXRpb24iLCJ4MyIsInkzIiwicHRYIiwicHRZIiwiZHJhd1RpdGxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJkcmF3Qm9keSIsImRyYXdDb2xvckJveGVzIiwieExpbmVQYWRkaW5nIiwiY29sb3JYIiwidGV4dENvbG9yIiwiZmlsbExpbmVPZlRleHQiLCJzdHJva2VSZWN0IiwiZHJhd0Zvb3RlciIsImRyYXdCYWNrZ3JvdW5kIiwicXVhZHJhdGljQ3VydmVUbyIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJoYW5kbGVFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJwb3NpdGlvbmVyc18xIiwiY29yZV90b29sdGlwIiwidmFsdWVPckRlZmF1bHQkOCIsIm9uSG92ZXIiLCJhbmltYXRpb25EdXJhdGlvbiIsInJlc3BvbnNpdmUiLCJyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb24iLCJtZXJnZVNjYWxlQ29uZmlnIiwic2xlbiIsIm1lcmdlQ29uZmlnIiwiaW5pdENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsIm5ld09wdGlvbnMiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiQ2hhcnQiLCJjb25zdHJ1Y3QiLCJfYnVmZmVyZWRSZW5kZXIiLCJpbnN0YW5jZXMiLCJyZXRpbmFTY2FsZSIsImRldmljZVBpeGVsUmF0aW8iLCJiaW5kRXZlbnRzIiwicmVzaXplIiwiaW5pdFRvb2xUaXAiLCJuZXdXaWR0aCIsImdldE1heGltdW1XaWR0aCIsIm5ld0hlaWdodCIsImdldE1heGltdW1IZWlnaHQiLCJuZXdTaXplIiwib25SZXNpemUiLCJzY2FsZXNPcHRpb25zIiwic2NhbGVPcHRpb25zIiwieEF4aXNPcHRpb25zIiwieUF4aXNPcHRpb25zIiwiZHR5cGUiLCJkcG9zaXRpb24iLCJpc0RlZmF1bHQiLCJzY2FsZVR5cGUiLCJzY2FsZUNsYXNzIiwibWVyZ2VUaWNrc09wdGlvbnMiLCJoYXNVcGRhdGVkIiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJkZXN0cm95RGF0YXNldE1ldGEiLCJDb250cm9sbGVyQ2xhc3MiLCJyZXNldEVsZW1lbnRzIiwidXBkYXRlTGF5b3V0IiwidXBkYXRlRGF0YXNldHMiLCJsYXN0QWN0aXZlIiwiX2J1ZmZlcmVkUmVxdWVzdCIsInVwZGF0ZURhdGFzZXQiLCJhbmltYXRpb25PcHRpb25zIiwiYW5pbWF0aW9uT2JqZWN0IiwiZWFzaW5nRnVuY3Rpb24iLCJzdGVwRGVjaW1hbCIsImRyYXdEYXRhc2V0cyIsIl9kcmF3VG9vbHRpcCIsImRyYXdEYXRhc2V0IiwiZ2V0RWxlbWVudEF0RXZlbnQiLCJnZXRFbGVtZW50c0F0RXZlbnQiLCJnZXRFbGVtZW50c0F0WEF4aXMiLCJnZXREYXRhc2V0QXRFdmVudCIsIl9tZXRhIiwiZ2VuZXJhdGVMZWdlbmQiLCJ1bmJpbmRFdmVudHMiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiX2NoYXJ0SW5zdGFuY2UiLCJfbGlzdGVuZXJzIiwiZXZlbnRIYW5kbGVyIiwidXBkYXRlSG92ZXJTdHlsZSIsImJ1ZmZlcmVkUmVxdWVzdCIsImhvdmVyT3B0aW9ucyIsImNvcmVfY29udHJvbGxlciIsIkNvbnRyb2xsZXIiLCJjb25maWdNZXJnZSIsInNjYWxlTWVyZ2UiLCJjb3JlX2hlbHBlcnMiLCJmaWx0ZXJDYWxsYmFjayIsImZpbHRlcmVkIiwiYXJyYXlUb1NlYXJjaCIsInN0YXJ0SW5kZXgiLCJjdXJyZW50SXRlbSIsImZpbmRQcmV2aW91c1doZXJlIiwiYWxtb3N0RXF1YWxzIiwiYWxtb3N0V2hvbGUiLCJyb3VuZGVkIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJsb2cxMCIsImV4cG9uZW50IiwiTE9HMTBFIiwicG93ZXJPZjEwIiwiaXNQb3dlck9mMTAiLCJ0b1JhZGlhbnMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImQwMSIsImQxMiIsInMwMSIsInMxMiIsImZhIiwiZmIiLCJFUFNJTE9OIiwicG9pbnRzV2l0aFRhbmdlbnRzIiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJwb2ludEJlZm9yZSIsInBvaW50Q3VycmVudCIsInBvaW50QWZ0ZXIiLCJzbG9wZURlbHRhWCIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJsb29wIiwibmljZU51bSIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZXZ0Iiwib3JpZ2luYWxFdmVudCIsInNyY0VsZW1lbnQiLCJib3VuZGluZ1JlY3QiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFyc2VNYXhTdHlsZSIsInBhcmVudFByb3BlcnR5IiwidmFsdWVJblBpeGVscyIsImlzQ29uc3RyYWluZWRWYWx1ZSIsImdldENvbnN0cmFpbnREaW1lbnNpb24iLCJkb21Ob2RlIiwibWF4U3R5bGUiLCJwZXJjZW50YWdlUHJvcGVydHkiLCJkZWZhdWx0VmlldyIsIl9nZXRQYXJlbnROb2RlIiwiY29uc3RyYWluZWROb2RlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJfY2FsY3VsYXRlUGFkZGluZyIsInBhcmVudERpbWVuc2lvbiIsImhvc3QiLCJjdyIsImNsaWVudEhlaWdodCIsImN1cnJlbnRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsInBpeGVsU2l6ZSIsImxvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImdjIiwiZ2FyYmFnZUNvbGxlY3QiLCJsb25nZXN0IiwidGhpbmciLCJuZXN0ZWRUaGluZyIsImdjTGVuIiwidGV4dFdpZHRoIiwibnVtYmVyT2ZMYWJlbExpbmVzIiwibnVtYmVyT2ZMaW5lcyIsImNvbG9yIiwiQ2FudmFzR3JhZGllbnQiLCJjb2xvclZhbHVlIiwiQ2FudmFzUGF0dGVybiIsIkRhdGVBZGFwdGVyIiwiX2NyZWF0ZSIsIm92ZXJyaWRlIiwibWVtYmVycyIsIl9kYXRlIiwiY29yZV9hZGFwdGVycyIsImNvcmVfdGlja3MiLCJmb3JtYXR0ZXJzIiwidGlja1ZhbHVlIiwibG9nRGVsdGEiLCJ0aWNrU3RyaW5nIiwibWF4VGljayIsImxvZ1RpY2siLCJ0b0V4cG9uZW50aWFsIiwibnVtRGVjaW1hbCIsImxvZ2FyaXRobWljIiwicmVtYWluIiwidmFsdWVPckRlZmF1bHQkOSIsImRyYXdCb3JkZXIiLCJkcmF3T25DaGFydEFyZWEiLCJkcmF3VGlja3MiLCJ0aWNrTWFya0xlbmd0aCIsInplcm9MaW5lV2lkdGgiLCJ6ZXJvTGluZUNvbG9yIiwiemVyb0xpbmVCb3JkZXJEYXNoIiwiemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0Iiwic2NhbGVMYWJlbCIsImxhYmVsU3RyaW5nIiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJtaW5vciIsIm1ham9yIiwibGFiZWxzRnJvbVRpY2tzIiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsImxpbmVWYWx1ZSIsImNvbXB1dGVUZXh0U2l6ZSIsInRpY2siLCJjb3JlX3NjYWxlIiwiX3RpY2tzIiwiYmVmb3JlVXBkYXRlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJtYXJnaW5zIiwiX21heExhYmVsTGluZXMiLCJsb25nZXN0TGFiZWxXaWR0aCIsImxvbmdlc3RUZXh0Q2FjaGUiLCJiZWZvcmVTZXREaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsImFmdGVyU2V0RGltZW5zaW9ucyIsImJlZm9yZURhdGFMaW1pdHMiLCJkZXRlcm1pbmVEYXRhTGltaXRzIiwiYWZ0ZXJEYXRhTGltaXRzIiwiYmVmb3JlQnVpbGRUaWNrcyIsImJ1aWxkVGlja3MiLCJhZnRlckJ1aWxkVGlja3MiLCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJjb252ZXJ0VGlja3NUb0xhYmVscyIsImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiY2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24iLCJiZWZvcmVGaXQiLCJmaXQiLCJhZnRlckZpdCIsImFmdGVyVXBkYXRlIiwidGlja09wdHMiLCJ1c2VyQ2FsbGJhY2siLCJ0aWNrRm9udCIsImxhYmVsUm90YXRpb24iLCJvcmlnaW5hbExhYmVsV2lkdGgiLCJsYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tXaWR0aCIsImFuZ2xlUmFkaWFucyIsInNjYWxlTGFiZWxPcHRzIiwiZ3JpZExpbmVPcHRzIiwiX2lzVmlzaWJsZSIsInBhcnNlRm9udCIsImlzRnVsbFdpZHRoIiwic2NhbGVMYWJlbEZvbnQiLCJzY2FsZUxhYmVsUGFkZGluZyIsImRlbHRhSGVpZ2h0IiwibGFyZ2VzdFRleHRXaWR0aCIsInRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImxhYmVsSGVpZ2h0IiwiZmlyc3RMYWJlbFdpZHRoIiwibGFzdExhYmVsV2lkdGgiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UmlnaHQiLCJoYW5kbGVNYXJnaW5zIiwicmF3VmFsdWUiLCJnZXRWYWx1ZUZvclBpeGVsIiwiaW5uZXJXaWR0aCIsImZpbmFsVmFsIiwiaW5uZXJIZWlnaHQiLCJkZWNpbWFsIiwidmFsdWVPZmZzZXQiLCJnZXRCYXNlVmFsdWUiLCJfYXV0b1NraXAiLCJvcHRpb25UaWNrcyIsInRpY2tDb3VudCIsInNraXBSYXRpbyIsIm1heFRpY2tzIiwibWF4VGlja3NMaW1pdCIsInRpY2tzTGVuZ3RoIiwiX3RpY2tTaXplIiwiYXhpc0xlbmd0aCIsIlBhZGRpbmdCb3R0b20iLCJyb3QiLCJvcHRpb25NYWpvclRpY2tzIiwiaXNSb3RhdGVkIiwiaXNNaXJyb3JlZCIsInRpY2tGb250Q29sb3IiLCJmb250Q29sb3IiLCJtYWpvclRpY2tGb250Q29sb3IiLCJtYWpvclRpY2tGb250IiwidGwiLCJzY2FsZUxhYmVsRm9udENvbG9yIiwibGFiZWxSb3RhdGlvblJhZGlhbnMiLCJpdGVtc1RvRHJhdyIsImF4aXNXaWR0aCIsImFsaWduUGl4ZWwiLCJib3JkZXJWYWx1ZSIsInRpY2tTdGFydCIsInRpY2tFbmQiLCJsaW5lQ29sb3IiLCJ6ZXJvTGluZUluZGV4IiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwibGFiZWxYIiwibGFiZWxZIiwidGV4dE9mZnNldCIsImxhYmVsWU9mZnNldCIsImxhYmVsWE9mZnNldCIsImdsV2lkdGgiLCJnbENvbG9yIiwiZ2xCb3JkZXJEYXNoIiwiZ2xCb3JkZXJEYXNoT2Zmc2V0IiwiaXRlbVRvRHJhdyIsInRyYW5zbGF0ZSIsInNjYWxlTGFiZWxYIiwic2NhbGVMYWJlbFkiLCJoYWxmTGluZUhlaWdodCIsImlzTGVmdCIsImZpcnN0TGluZVdpZHRoIiwibGFzdExpbmVXaWR0aCIsImRlZmF1bHRDb25maWciLCJzY2FsZV9jYXRlZ29yeSIsImdldExhYmVscyIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJvZmZzZXRBbXQiLCJ2YWx1ZUNhdGVnb3J5IiwidmFsdWVXaWR0aCIsIndpZHRoT2Zmc2V0IiwidmFsdWVIZWlnaHQiLCJoZWlnaHRPZmZzZXQiLCJob3J6IiwidmFsdWVEaW1lbnNpb24iLCJfZGVmYXVsdHMiLCJnZW5lcmF0ZVRpY2tzIiwiZ2VuZXJhdGlvbk9wdGlvbnMiLCJkYXRhUmFuZ2UiLCJNSU5fU1BBQ0lORyIsInN0ZXBTaXplIiwibWF4TnVtU3BhY2VzIiwicHJlY2lzaW9uIiwicm1pbiIsInJtYXgiLCJzcGFjaW5nIiwiZmFjdG9yIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJzY2FsZV9saW5lYXJiYXNlIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsIm1pblNpZ24iLCJtYXhTaWduIiwic2V0TWluIiwic3VnZ2VzdGVkTWluIiwic2V0TWF4Iiwic3VnZ2VzdGVkTWF4IiwiZ2V0VGlja0xpbWl0IiwiX2NvbXB1dGVUaWNrTGltaXQiLCJoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMiLCJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsImZpeGVkU3RlcFNpemUiLCJ0aWNrc0FzTnVtYmVycyIsImRlZmF1bHRDb25maWckMSIsInNjYWxlX2xpbmVhciIsIkRFRkFVTFRfTUlOIiwiREVGQVVMVF9NQVgiLCJJRE1hdGNoZXMiLCJoYXNTdGFja3MiLCJ2YWx1ZXNQZXJTdGFjayIsInBvc2l0aXZlVmFsdWVzIiwibmVnYXRpdmVWYWx1ZXMiLCJyZWxhdGl2ZVBvaW50cyIsInZhbHVlc0ZvclR5cGUiLCJtaW5WYWwiLCJtYXhWYWwiLCJpbm5lckRpbWVuc2lvbiIsIl9kZWZhdWx0cyQxIiwidmFsdWVPckRlZmF1bHQkYSIsImdlbmVyYXRlVGlja3MkMSIsInRpY2tWYWwiLCJlbmRFeHAiLCJlbmRTaWduaWZpY2FuZCIsInNpZ25pZmljYW5kIiwibWluTm90WmVybyIsImxhc3RUaWNrIiwiZGVmYXVsdENvbmZpZyQyIiwibm9uTmVnYXRpdmVPckRlZmF1bHQiLCJzY2FsZV9sb2dhcml0aG1pYyIsInRpY2tWYWx1ZXMiLCJfZ2V0Rmlyc3RUaWNrVmFsdWUiLCJmaXJzdFRpY2tWYWx1ZSIsIl9kZWZhdWx0cyQyIiwidmFsdWVPckRlZmF1bHQkYiIsInZhbHVlQXRJbmRleE9yRGVmYXVsdCQxIiwicmVzb2x2ZSQ3IiwiZGVmYXVsdENvbmZpZyQzIiwiYW5pbWF0ZSIsInNob3dMYWJlbEJhY2tkcm9wIiwiYmFja2Ryb3BDb2xvciIsImJhY2tkcm9wUGFkZGluZ1kiLCJiYWNrZHJvcFBhZGRpbmdYIiwiZ2V0VmFsdWVDb3VudCIsImdldFRpY2tCYWNrZHJvcEhlaWdodCIsIm1lYXN1cmVMYWJlbFNpemUiLCJkZXRlcm1pbmVMaW1pdHMiLCJmaXRXaXRoUG9pbnRMYWJlbHMiLCJwbEZvbnQiLCJmdXJ0aGVzdExpbWl0cyIsImZ1cnRoZXN0QW5nbGVzIiwidGV4dFNpemUiLCJfcG9pbnRMYWJlbFNpemVzIiwidmFsdWVDb3VudCIsImdldFBvaW50UG9zaXRpb24iLCJkcmF3aW5nQXJlYSIsImdldEluZGV4QW5nbGUiLCJoTGltaXRzIiwidkxpbWl0cyIsInNldFJlZHVjdGlvbnMiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodCIsImRyYXdQb2ludExhYmVscyIsImFuZ2xlTGluZU9wdHMiLCJwb2ludExhYmVsT3B0cyIsInRpY2tCYWNrZHJvcEhlaWdodCIsIm91dGVyRGlzdGFuY2UiLCJvdXRlclBvc2l0aW9uIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJwb2ludExhYmVsRm9udENvbG9yIiwiZHJhd1JhZGl1c0xpbmUiLCJudW1iZXJPclplcm8iLCJzY2FsZV9yYWRpYWxMaW5lYXIiLCJzZXRDZW50ZXJQb2ludCIsImxhcmdlc3RQb3NzaWJsZVJhZGl1cyIsInJhZGl1c1JlZHVjdGlvbkxlZnQiLCJyYWRpdXNSZWR1Y3Rpb25SaWdodCIsInJhZGl1c1JlZHVjdGlvblRvcCIsInJhZGl1c1JlZHVjdGlvbkJvdHRvbSIsImxlZnRNb3ZlbWVudCIsInJpZ2h0TW92ZW1lbnQiLCJ0b3BNb3ZlbWVudCIsImJvdHRvbU1vdmVtZW50IiwibWF4UmlnaHQiLCJtYXhMZWZ0IiwibWF4VG9wIiwibWF4Qm90dG9tIiwiYW5nbGVNdWx0aXBsaWVyIiwic3RhcnRBbmdsZVJhZGlhbnMiLCJzY2FsaW5nRmFjdG9yIiwiZGlzdGFuY2VGcm9tQ2VudGVyIiwidGhpc0FuZ2xlIiwiZ2V0QmFzZVBvc2l0aW9uIiwieUNlbnRlck9mZnNldCIsIl9kZWZhdWx0cyQzIiwidmFsdWVPckRlZmF1bHQkYyIsIk1JTl9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiSU5URVJWQUxTIiwiY29tbW9uIiwic3RlcHMiLCJVTklUUyIsInNvcnRlciIsImFycmF5VW5pcXVlIiwiYnVpbGRMb29rdXBUYWJsZSIsInRpbWVzdGFtcHMiLCJkaXN0cmlidXRpb24iLCJ0YWJsZSIsImxvb2t1cCIsImxvIiwibWlkIiwiaTAiLCJpMSIsImludGVycG9sYXRlJDEiLCJza2V5IiwidGtleSIsInNwYW4iLCJ0b1RpbWVzdGFtcCIsImFkYXB0ZXIiLCJfYWRhcHRlciIsInBhcnNlciIsImRldGVybWluZVN0ZXBTaXplIiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCJkZXRlcm1pbmVNYWpvclVuaXQiLCJ0aW1lT3B0cyIsInVuaXRTdGVwU2l6ZSIsIm1ham9yVGlja3NFbmFibGVkIiwiZmlyc3QiLCJjb21wdXRlT2Zmc2V0cyIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJtYWpvclVuaXQiLCJkZWZhdWx0Q29uZmlnJDQiLCJhZGFwdGVycyIsImRpc3BsYXlGb3JtYXQiLCJkaXNwbGF5Rm9ybWF0cyIsInNjYWxlX3RpbWUiLCJ0aW1lc3RhbXAiLCJkYXRhTGFiZWxzIiwiX2hvcml6b250YWwiLCJfdGFibGUiLCJfdGltZXN0YW1wcyIsImdldExhYmVsQ2FwYWNpdHkiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfb2Zmc2V0cyIsInRvb2x0aXBGb3JtYXQiLCJ0aWNrRm9ybWF0RnVuY3Rpb24iLCJtaW5vckZvcm1hdCIsIm1ham9yRm9ybWF0IiwibWFqb3JUaW1lIiwibWFqb3JUaWNrT3B0cyIsImZvcm1hdHRlciIsImdldFBpeGVsRm9yT2Zmc2V0IiwiaXNSZXZlcnNlIiwiZ2V0TGFiZWxXaWR0aCIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwidGlja0ZvbnRTaXplIiwiZXhhbXBsZVRpbWUiLCJleGFtcGxlTGFiZWwiLCJfZGVmYXVsdHMkNCIsImNhdGVnb3J5IiwicmFkaWFsTGluZWFyIiwiRk9STUFUUyIsIl9pZCIsImFtb3VudCIsImZpbGxlciIsInByb3BhZ2F0ZSIsIm1hcHBlcnMiLCJ2aXNpYmxlIiwiYm91bmRhcnkiLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUJvdW5kYXJ5Iiwic2NhbGVCb3R0b20iLCJzY2FsZVRvcCIsInNjYWxlWmVybyIsInJlc29sdmVUYXJnZXQiLCJ2aXNpdGVkIiwiY3JlYXRlTWFwcGVyIiwiaXNEcmF3YWJsZSIsImRyYXdBcmVhIiwiY3VydmUwIiwiY3VydmUxIiwibGVuMCIsImxlbjEiLCJkb0ZpbGwiLCJtYXBwZXIiLCJwMCIsImQwIiwiZDEiLCJwbHVnaW5fZmlsbGVyIiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEYXRhc2V0RHJhdyIsIm5vb3AkMSIsInZhbHVlT3JEZWZhdWx0JGQiLCJjaSIsIm9uTGVhdmUiLCJib3hXaWR0aCIsImxpbmVEYXNoIiwiZ2V0Qm94V2lkdGgiLCJsYWJlbE9wdHMiLCJ1c2VQb2ludFN0eWxlIiwiTGVnZW5kIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJiZWZvcmVCdWlsZExhYmVscyIsImJ1aWxkTGFiZWxzIiwiYWZ0ZXJCdWlsZExhYmVscyIsImxlZ2VuZEl0ZW1zIiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiaXRlbUhlaWdodCIsIml0ZW1XaWR0aCIsImxpbmVEZWZhdWx0IiwibGVnZW5kV2lkdGgiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiU1FSVDIiLCJoYWxmRm9udFNpemUiLCJ4TGVmdCIsInlNaWRkbGUiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJob3ZlcmVkSXRlbSIsImNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaCIsImxlZ2VuZE9wdHMiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJiZWZvcmVJbml0IiwiYWZ0ZXJFdmVudCIsIm5vb3AkMiIsIlRpdGxlIiwibGluZUNvdW50IiwiZm9udE9wdHMiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoIiwidGl0bGVPcHRzIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIl9hZGFwdGVycyIsIkFuaW1hdGlvbiIsImFuaW1hdGlvblNlcnZpY2UiLCJJbnRlcmFjdGlvbiIsImxheW91dHMiLCJTY2FsZSIsInNjYWxlU2VydmljZSIsIlRpY2tzIiwiVG9vbHRpcCIsInBsdWdpblNlcnZpY2UiLCJQbHVnaW5CYXNlIiwiY2FudmFzSGVscGVycyIsImxheW91dFNlcnZpY2UiLCJMaW5lYXJTY2FsZUJhc2UiLCJjZmciLCJnZW5lcmF0ZUNoYXJ0IiwiY2hhcnRJZCIsImNoYXJ0VHlwZSIsImNzc0NsYXNzZXMiLCJfZGVmYXVsdCIsImFkZFBsdWdpbiIsImJlZm9yZURlc3Ryb3kiLCJCYXIiLCJIb3Jpem9udGFsQmFyIiwiUGllIiwiY2hhcnRMYWJlbHMiLCJjaGFydERhdGFMaXN0IiwiQ2hhcnREYXRhIiwiQ2hhcnRCYXIiLCJDaGFydENvbXBvbmVudCIsIkNoYXJ0SG9yaXpvbnRhbEJhciIsIkNoYXJ0TGluZSIsIkNoYXJ0UGllIiwibnljbyIsImljb25zIiwidHJhY2siLCJzZWxlY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBTUEsSUFBTUEsT0FBTyxHQUtYLGdCQUFBLEdBQWM7RUFDZCxTQUFTLElBQVQ7RUFDQyxDQVBIOzs7Ozs7O0VBY0FBLE9BQU8sQ0FBQ0MsS0FBUixlQUFtQjtXQUFJRCxPQUFPLENBQUNFLGVBQVIsQ0FBd0JGLE9BQU8sQ0FBQ0csTUFBUixDQUFlQyxLQUF2QyxNQUFrRDtFQUFJLENBQTdFOzs7Ozs7Ozs7O0VBU0FKLE9BQU8sQ0FBQ0UsZUFBUixhQUEyQkcsTUFBTUMsYUFBYTtFQUM1Q0MsTUFBTUMsS0FBSyxHQUFHRixXQUFXLElBQUlHLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsTUFBN0NKO0VBQ0FBLE1BQU1LLEtBQUssR0FBR1AsSUFBSSxDQUFDUSxPQUFMLENBQWEsTUFBYixFQUFxQixLQUFyQixFQUE0QkEsT0FBNUIsQ0FBb0MsTUFBcEMsRUFBNEMsS0FBNUMsQ0FBZE47RUFD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QUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkJNO0VBd0JoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeEJBO0VBeUJoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekJNO0VBMEJoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBMUJJO0VBMkJoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0JNO0VBNEJoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUJJO0VBNkJoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBN0JFO0VBOEJoQkMsTUFBQUEsY0FBYyxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBOUJBO0VBK0JoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBL0JJO0VBZ0NoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaENJO0VBaUNoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBakNNO0VBa0NoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbENJO0VBbUNoQkMsTUFBQUEsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkNFO0VBb0NoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBcENBO0VBcUNoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBckNBO0VBc0NoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBdENBO0VBdUNoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkNBO0VBd0NoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBeENJO0VBeUNoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBekNNO0VBMENoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBMUNFO0VBMkNoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0NNO0VBNENoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUNNO0VBNkNoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBN0NJO0VBOENoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBOUNJO0VBK0NoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0NFO0VBZ0RoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBaERFO0VBaURoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBakRNO0VBa0RoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbERJO0VBbURoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkRJO0VBb0RoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERVO0VBcURoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBckRJO0VBc0RoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdERVO0VBdURoQkMsTUFBQUEsS0FBSyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBdkRRO0VBd0RoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeERFO0VBeURoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekRVO0VBMERoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMURNO0VBMkRoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0RNO0VBNERoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNURJO0VBNkRoQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsRUFBRCxFQUFJLENBQUosRUFBTSxHQUFOLENBN0RRO0VBOERoQkMsTUFBQUEsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOURRO0VBK0RoQkMsTUFBQUEsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0RRO0VBZ0VoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEVNO0VBaUVoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakVBO0VBa0VoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBbEVJO0VBbUVoQkMsTUFBQUEsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkVFO0VBb0VoQkMsTUFBQUEsU0FBUyxFQUFHLENB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QUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEdJO0VBbUdoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkdJO0VBb0doQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEdNO0VBcUdoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckdFO0VBc0doQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLENBdEdVO0VBdUdoQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdkdNO0VBd0doQkMsTUFBQUEsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBeEdRO0VBeUdoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBekdJO0VBMEdoQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBMUdRO0VBMkdoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxDQUFSLENBM0dJO0VBNEdoQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUdRO0VBNkdoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0dBO0VBOEdoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOUdJO0VBK0doQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0dBO0VBZ0hoQkMsTUFBQUEsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEhBO0VBaUhoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakhJO0VBa0hoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEhJO0VBbUhoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBbkhVO0VBb0hoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEhVO0VBcUhoQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckhVO0VBc0hoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEhJO0VBdUhoQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBdkhRO0VBd0hoQkMsTUFBQUEsYUFBYSxFQUFFLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxHQUFWLENBeEhDO0VBeUhoQkMsTUFBQUEsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBekhVO0VBMEhoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUhJO0VBMkhoQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBM0hJO0VBNEhoQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNUhFO0VBNkhoQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0hRO0VBOEhoQkMsTUFBQUEsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBOUhJO0VBK0hoQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBL0hNO0VBZ0loQkMsTUFBQUEsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaElNO0VBaUloQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBaklRO0VBa0loQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbElRO0VBbUloQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbklNO0VBb0loQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBcElJO0VBcUloQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcklJO0VBc0loQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdElJO0VBdUloQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdklVO0VBd0loQkMsTUFBQUEsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBeElFO0VBeUloQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBeklJO0VBMEloQkMsTUFBQUEsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUlVO0VBMkloQkMsTUFBQUEsSUFBSSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBM0lVO0VBNEloQkMsTUFBQUEsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUlNO0VBNkloQkMsTUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBN0lRO0VBOEloQkMsTUFBQUEsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBOUlJO0VBK0loQkMsTUFBQUEsTUFBTSxF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
