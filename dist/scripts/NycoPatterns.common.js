'use strict';

/**
 * The Utility class
 * @class
 */

var Utility$1 = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility$1.debug = function () {
  return Utility$1.getUrlParameter(Utility$1.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility$1.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility$1.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility$1.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility$1.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility$1.debug()) {
        console.dir(response);
      }
  })["catch"](function (error) {
    // eslint-disable-next-line no-console
    if (Utility$1.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

  var sourceURL = hasOwnProperty$9.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  // Like with sourceURL, we take care to not check the option's prototype,
  // as this configuration is a code injection vector.

  var variable = hasOwnProperty$9.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$d.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$b.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$c.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$g = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$d = objectProto$g.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$d.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$d.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE$1 = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE$1) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */

function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
}

/**
 *
 */

var Feed = function Feed(config) {
  this["default"] = Feed["default"];
  this._settings = merge({}, Feed["default"], config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts

    items = uniqBy(items, function (item) {
      return item.guid;
    });
    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed["default"] = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$e = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$e.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-2e703d21_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bzier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  "extends": Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  "extends": HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  "extends": Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  "extends": Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

//
//
var script$5 = {
  props: {
    'layers': {
      type: Array
    },
    'config': {
      type: Object
    }
  },
  data: function data() {
    return {
      map: null,
      mapPopup: null,
      mapFilter: null,
      activeLayer: null,
      mapLoaded: false,
      menuItems: [],
      selectedItems: []
    };
  },
  mounted: function mounted() {
    this.initializeMap();
  },
  destroyed: function destroyed() {
    this.map.remove();
  },
  watch: {
    'layers': function layers() {
      var layers = this.layers;

      if (this.config.mapType === 'multi') {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          this.trackLayer(layer.name);

          if (layer["default"] || this.layers.length === 1) {
            this.activeLayer = layer.name;
          }

          if (this.mapLoaded) {
            this.initializeLayer(layer);
          }
        }
      } else if (this.config.mapType === 'single') {
        var layer$1 = this.layers[0];
        this.activeLayer = layer$1.name;
        this.generateLegend(layer$1.data);

        if (this.mapLoaded) {
          this.initializeLayer(layer$1);
        }
      } else {
        throw new Error('mapType must be defined');
      }
    },
    'mapLoaded': function mapLoaded() {
      if (this.mapLoaded && this.layers.length) {
        var layers = this.layers;

        for (var i = 0; i < layers.length; i++) {
          this.initializeLayer(layers[i]);
        }
      }
    },
    'menuItems': function menuItems() {
      if (this.menuItems.length > 1) {
        this.initializeToggle(this.menuItems);
      }
    },
    'selectedItems': function selectedItems() {
      var layer = this.layers[0];
      var filter = ['in', layer.legendColumn];

      for (var i = 0; i < this.selectedItems.length; i++) {
        filter.push(this.selectedItems[i]);
      }

      if (this.selectedItems.length > 0) {
        var relatedFeatures = this.map.querySourceFeatures(layer.name, {
          sourceLayer: layer.name,
          filter: filter
        }); // set filter when legend item selected

        this.map.setFilter(layer.name + "-highlighted", filter);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'visible');
      }

      if (!this.selectedItems.length && !this.mapPopup) {
        this.map.setFilter(layer.name + "-highlighted", null);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'none');
      }
    }
  },
  methods: {
    initializeMap: function initializeMap() {
      var this$1 = this;
      var mapConfig = this.config;
      var options = {
        container: mapConfig.containerId
      };

      if (mapConfig.center) {
        options.center = mapConfig.center;
      }

      if (mapConfig.style) {
        options.style = mapConfig.style;
      }

      if (mapConfig.zoom) {
        options.zoom = mapConfig.zoom;
      }

      mapboxgl.accessToken = mapConfig.APIKey;
      this.map = new mapboxgl.Map(options);
      this.map.addControl(new mapboxgl.NavigationControl()); // disable map zoom when using scroll

      if (mapConfig.disableScroll) {
        this.map.scrollZoom.disable();
      }

      this.map.on('load', function () {
        return this$1.mapLoaded = true;
      });
    },
    initializeLayer: function initializeLayer(layer) {
      if (this.map.getLayer(layer.name) === undefined && Object.entries(layer.data).length !== 0) {
        var visibility = layer.name === this.activeLayer ? 'visible' : 'none';
        var filter = layer.filterBy ? ['in', layer.filterBy, ''] : [];
        var fill = this.config.colors ? this.generateFillColor(this.config.colors) : layer.fill;
        this.map.addSource(layer.name, {
          'type': 'geojson',
          'data': layer.data
        });
        this.map.addLayer({
          'id': layer.name,
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 0.7
          },
          'layout': {
            'visibility': visibility
          }
        });
        this.map.addLayer({
          'id': layer.name + "-highlighted",
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 1
          },
          'filter': filter,
          'layout': {
            'visibility': visibility
          }
        });
        this.initializeFilter(layer);
        this.updateCursorOnHover(layer.name);
      }
    },
    initializePopup: function initializePopup(event, layer) {
      this.config.mapType === 'multi' ? this.popupMultiLayer(event, layer) : this.popupSingleLayer(event, layer);
    },
    initializeToggle: function initializeToggle(toggleList) {
      this.config.mapType === 'multi' ? this.toggleMultiLayer(toggleList) : this.toggleSingleLayer(toggleList);
    },
    initializeFilter: function initializeFilter(layer) {
      this.config.mapType === 'multi' ? this.filterMultiLayer(layer) : this.filterSingleLayer(layer);
    },
    updateCursorOnHover: function updateCursorOnHover(layerId) {
      var map = this.map; // change the cursor to a pointer when the mouse is over the layer.

      map.on('mouseenter', layerId, function () {
        map.getCanvas().style.cursor = 'pointer';
      }); // change the cursor back to the default when it leaves the layer.

      map.on('mouseleave', layerId, function () {
        map.getCanvas().style.cursor = '';
      });
    },
    generateFillColor: function generateFillColor(colors) {
      return colors[Math.floor(Math.random() * colors.length)];
    },
    // multi layer
    trackLayer: function trackLayer(reference) {
      if (!this.menuItems.includes(reference)) {
        this.menuItems.push(reference);
      }
    },
    popupMultiLayer: function popupMultiLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted";
      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup;
        map.setLayoutProperty(layerName, 'visibility', 'visible');
        map.setFilter(layerName, $this.mapFilter);
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null;
          map.setFilter(layerName, null);
          map.setLayoutProperty(layerName, 'visibility', 'none');
        }
      });
    },
    filterMultiLayer: function filterMultiLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var filter = features.reduce(function (memo, feature) {
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleMultiLayer: function toggleMultiLayer(layersToToggle) {
      var $this = this;
      var map = $this.map;
      var activeLayer = $this.activeLayer;
      var linkContainer = document.getElementById(this.config.legendId); // clear all links before appending new ones to prevent duplicates

      while (linkContainer.firstChild) {
        linkContainer.removeChild(linkContainer.firstChild);
      }

      for (var i = 0; i < layersToToggle.length; i++) {
        var layerRef = layersToToggle[i];
        var link = document.createElement('a');
        link.href = '#';
        link.textContent = layerRef;

        if (layerRef === activeLayer) {
          link.classList.add('active');
        } // on click update link state, active layer reference, and layer visibility


        link.onclick = function (e) {
          e.preventDefault();
          e.stopPropagation();
          var selectedLayer = this.textContent;
          var links = linkContainer.getElementsByTagName('a'); // remove active popup

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          for (var i = 0; i < links.length; i++) {
            var currentLink = links[i];
            var currentLayer = currentLink.textContent;
            var currentLayerHighlight = currentLayer + "-highlighted";
            var layerVisibility = map.getLayoutProperty(currentLayer, 'visibility');

            if (currentLayer === selectedLayer) {
              // return if layer is already selected
              if (layerVisibility === 'visible' && currentLink.classList.contains('active')) {
                return;
              } // set our current layer as the global active layer,
              // add active class to link, set layer as visible


              $this.activeLayer = currentLayer;
              currentLink.classList.add('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'visible');
            } else {
              // remove links active class, set layer visibility to none and remove filters
              currentLink.classList.remove('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'none');
              map.setLayoutProperty(currentLayerHighlight, 'visibility', 'none');
              map.setFilter(currentLayerHighlight, null);
            }
          }
        };

        linkContainer.appendChild(link);
      }
    },
    // single layer
    generateLegend: function generateLegend(layerData) {
      var this$1 = this;
      layerData.features.forEach(function (feature) {
        var item = feature.properties[this$1.layers[0].legendColumn];

        if (!this$1.menuItems.includes(item) && item) {
          this$1.menuItems.push(item);
        }
      });
    },
    popupSingleLayer: function popupSingleLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted"; // check whether shape falls under current legend selection

      var inCurrentSelection = true;
      var columnFilter = event.features[0].properties[layer.legendColumn];

      if (!$this.selectedItems.includes(columnFilter)) {
        inCurrentSelection = false;
      }

      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup; // if there are no legend items selected, highlight selected map shape

        if (!$this.selectedItems.length) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter);
        } // if there are legend items selected and selected map shape isn't
        // within any of the selected legend items, highlight selected
        // map shape and clear legend


        if ($this.selectedItems.length > 0 && !inCurrentSelection) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter); // reset all checked legend items

          $this.selectedItems = [];
          var filterGroupInputs = document.getElementById(this.config.legendId).querySelectorAll('input:checked');

          for (var i = 0; i < filterGroupInputs.length; i++) {
            filterGroupInputs[i].checked = false;
          }
        }
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null; // if there are no legend items selected, reset all filters

          if (!$this.selectedItems.length) {
            map.setFilter(layerName, null);
            map.setLayoutProperty(layerName, 'visibility', 'none');
          }
        }
      });
    },
    filterSingleLayer: function filterSingleLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var legendColumnValue = null;
        var filter = features.reduce(function (memo, feature) {
          legendColumnValue = feature.properties[layer.legendColumn];
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleSingleLayer: function toggleSingleLayer(filtersToToggle) {
      var $this = this;
      var map = $this.map;
      var filterGroup = document.getElementById(this.config.legendId);
      var layer = $this.layers[0];
      var legendColumn = layer.legendColumn; // clear all links before appending new ones to prevent duplicates

      while (filterGroup.firstChild) {
        filterGroup.removeChild(filterGroup.firstChild);
      } // initilize an input element for each filter type


      for (var i = 0; i < filtersToToggle.length; i++) {
        var layerRef = filtersToToggle[i]; // checkbox

        var input = document.createElement('input');
        input.type = 'checkbox';
        input.id = layerRef;
        input.value = layerRef;
        filterGroup.appendChild(input); // checkbox label

        var label = document.createElement('label');
        label.setAttribute('for', layerRef);
        label.setAttribute('title', layerRef);
        label.textContent = layerRef;
        filterGroup.appendChild(label); // when the checkbox changes state, update the selected items array.

        input.addEventListener('change', function (e) {
          var item = e.target.value; // reset the checkboxes checked state

          e.target.checked ? 'visible' : 'none'; // remove popup if one exists

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          if (e.target.checked && !$this.selectedItems.includes(item)) {
            $this.selectedItems.push(item);
          }

          if (!e.target.checked && $this.selectedItems.includes(item)) {
            $this.selectedItems = $this.selectedItems.filter(function (val) {
              return val !== item;
            });
          }
        });
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div")
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var MapComponent = normalizeComponent_1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    undefined,
    undefined
  );

/**
 * Config
 */
var nycoColors = {
  colors: {
    'primary-navy': '#2F334F',
    'primary-navy-70t': '#6E7085',
    'primary-navy-50t': '#9698A7',
    'primary-navy-30t': '#C0C2CA',
    'primary-blue': '#3155A6',
    'primary-blue-70t': '#6C88C1',
    'primary-blue-50t': '#96ABD2',
    'primary-blue-30t': '#C0CCE3',
    'primary-red': '#F2695D',
    'primary-red-70t': '#F6958D',
    'primary-red-50t': '#F8B2AD',
    'primary-red-30t': '#FBD1CE',
    'secondary-grey': '#ACAEB9',
    'secondary-grey-70t': '#C4C6CD',
    'secondary-grey-50t': '#D5D6DC',
    'secondary-grey-30t': '#E8E7E9',
    'secondary-white': '#F3F3F3',
    'secondary-white-70t': '#F6F6F6',
    'secondary-white-50t': '#F9F9FA',
    'secondary-white-30t': '#FBFCFC',
    'secondary-orange': '#F9A137',
    'secondary-orange-70t': '#FFA133',
    'secondary-orange-50t': '#FED09A',
    'secondary-orange-30t': '#FFE3C2',
    'secondary-pink': '#EBBCD8',
    'secondary-pink-70t': '#F2D0E3',
    'secondary-pink-50t': '#F7DDEB',
    'secondary-pink-30t': '#FDEBF3',
    'base-black': '#000000',
    'base-white': '#FFFFFF'
  },
  colorCombinations: {
    'light-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'base-white',
      'border': 'secondary-grey',
      'placeholder': 'secondary-grey',
      'checkbox-background': 'primary-navy',
      'error': 'primary-red'
    },
    'mid-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'secondary-white'
    },
    'dark-background': {
      'color': 'base-white',
      'font-smooth': true,
      'headings': 'base-white',
      'hyperlinks': 'base-white',
      'visited': 'base-white',
      'hover': 'base-white',
      'background-color': 'primary-navy'
    },
    'primary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-blue'
    },
    'secondary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-red'
    }
  }
};
var color = nycoColors.colors;
var mapColorCombinations = [[color['primary-navy'], color['primary-navy-70t']], [color['base-black'], color['secondary-orange']], [color['primary-navy'], color['secondary-grey']], [color['primary-blue'], color['secondary-orange']]];
var colors = {
  nycoColors: nycoColors,
  mapColorCombinations: mapColorCombinations
};
var colors_2 = colors.mapColorCombinations;

var MapData = {
  single: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-sl',
      legendId: 'nyco-map-legend',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'single'
    }
  },
  multi: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-ml',
      legendId: 'nyco-map-menu',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'multi',
      colors: colors_2
    }
  }
};

var geojson = createCommonjsModule(function (module) {
  (function (GeoJSON) {
    GeoJSON.version = '0.5.0'; // Allow user to specify default parameters

    GeoJSON.defaults = {
      doThrows: {
        invalidGeometry: false
      }
    };

    function InvalidGeometryError() {
      var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      var item = args.shift();
      var params = args.shift();
      Error.apply(this, args);
      this.message = this.message || "Invalid Geometry: " + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);
    }

    InvalidGeometryError.prototype = Error;
    GeoJSON.errors = {
      InvalidGeometryError: InvalidGeometryError
    }; //exposing so this can be overriden maybe by geojson-validation or the like

    GeoJSON.isGeometryValid = function (geometry) {
      if (!geometry || !Object.keys(geometry).length) {
        return false;
      }

      return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;
    }; // The one and only public function.
    // Converts an array of objects into a GeoJSON feature collection


    GeoJSON.parse = function (objects, params, callback) {
      var geojson,
          settings = applyDefaults(params, this.defaults),
          propFunc;
      geomAttrs.length = 0; // Reset the list of geometry fields

      setGeom(settings);
      propFunc = getPropFunction(settings);

      if (Array.isArray(objects)) {
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        objects.forEach(function (item) {
          geojson.features.push(getFeature({
            item: item,
            params: settings,
            propFunc: propFunc
          }));
        });
        addOptionals(geojson, settings);
      } else {
        geojson = getFeature({
          item: objects,
          params: settings,
          propFunc: propFunc
        });
        addOptionals(geojson, settings);
      }

      if (callback && typeof callback === 'function') {
        callback(geojson);
      } else {
        return geojson;
      }
    }; // Helper functions


    var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],
        geomAttrs = []; // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify

    function applyDefaults(params, defaults) {
      var settings = params || {};

      for (var setting in defaults) {
        if (defaults.hasOwnProperty(setting) && !settings[setting]) {
          settings[setting] = defaults[setting];
        }
      }

      return settings;
    } // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified


    function addOptionals(geojson, settings) {
      if (settings.crs && checkCRS(settings.crs)) {
        if (settings.isPostgres) {
          geojson.geometry.crs = settings.crs;
        } else {
          geojson.crs = settings.crs;
        }
      }

      if (settings.bbox) {
        geojson.bbox = settings.bbox;
      }

      if (settings.extraGlobal) {
        geojson.properties = {};

        for (var key in settings.extraGlobal) {
          geojson.properties[key] = settings.extraGlobal[key];
        }
      }
    } // Verify that the structure of CRS object is valid


    function checkCRS(crs) {
      if (crs.type === 'name') {
        if (crs.properties && crs.properties.name) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "name" key');
        }
      } else if (crs.type === 'link') {
        if (crs.properties && crs.properties.href && crs.properties.type) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "href" and "type" key');
        }
      } else {
        throw new Error('Invald CRS. Type attribute must be "name" or "link"');
      }
    } // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access


    function setGeom(params) {
      params.geom = {};

      for (var param in params) {
        if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {
          params.geom[param] = params[param];
          delete params[param];
        }
      }

      setGeomAttrList(params.geom);
    } // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key


    function setGeomAttrList(params) {
      for (var param in params) {
        if (params.hasOwnProperty(param)) {
          if (typeof params[param] === 'string') {
            geomAttrs.push(params[param]);
          } else if (typeof params[param] === 'object') {
            // Array of coordinates for Point
            geomAttrs.push(params[param][0]);
            geomAttrs.push(params[param][1]);
          }
        }
      }

      if (geomAttrs.length === 0) {
        throw new Error('No geometry attributes specified');
      }
    } // Creates a feature object to be added
    // to the GeoJSON features array


    function getFeature(args) {
      var item = args.item,
          params = args.params,
          propFunc = args.propFunc;
      var feature = {
        "type": "Feature"
      };
      feature.geometry = buildGeom(item, params);
      feature.properties = propFunc.call(item);
      return feature;
    }

    function isNested(val) {
      return /^.+\..+$/.test(val);
    } // Assembles the `geometry` property
    // for the feature output


    function buildGeom(item, params) {
      var geom = {};

      for (var gtype in params.geom) {
        var val = params.geom[gtype]; // Geometry parameter specified as: {Point: 'coords'}

        if (typeof val === 'string' && item.hasOwnProperty(val)) {
          if (gtype === 'GeoJSON') {
            geom = item[val];
          } else {
            geom.type = gtype;
            geom.coordinates = item[val];
          }
        }
        /* Handle things like:
        Polygon: {
          northeast: ['lat', 'lng'],
          southwest: ['lat', 'lng']
        }
        */
        else if (typeof val === 'object' && !Array.isArray(val)) {
            /*jshint loopfunc: true */
            var points = Object.keys(val).map(function (key) {
              var order = val[key];
              var newItem = item[key];
              return buildGeom(newItem, {
                geom: {
                  Point: order
                }
              });
            });
            geom.type = gtype;
            /*jshint loopfunc: true */

            geom.coordinates = [].concat(points.map(function (p) {
              return p.coordinates;
            }));
          } // Geometry parameter specified as: {Point: ['lat', 'lng']}
          else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
              geom.type = gtype;
              geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];
            } // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                var coordinates = [];

                for (var i = 0; i < val.length; i++) {
                  // i.e. 0 and 1
                  var paths = val[i].split('.');
                  var itemClone = item;

                  for (var j = 0; j < paths.length; j++) {
                    if (!itemClone.hasOwnProperty(paths[j])) {
                      return false;
                    }

                    itemClone = itemClone[paths[j]]; // Iterate deeper into the object
                  }

                  coordinates[i] = itemClone;
                }

                geom.type = gtype;
                geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];
              }
      }

      if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {
        throw new InvalidGeometryError(item, params);
      }

      return geom;
    } // Returns the function to be used to
    // build the properties object for each feature


    function getPropFunction(params) {
      var func;

      if (!params.exclude && !params.include) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      } else if (params.include) {
        func = function (properties) {
          params.include.forEach(function (attr) {
            properties[attr] = this[attr];
          }, this);
        };
      } else if (params.exclude) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      }

      return function () {
        var properties = {};
        func.call(this, properties);

        if (params.extra) {
          addExtra(properties, params.extra);
        }

        return properties;
      };
    } // Adds data contained in the `extra`
    // parameter if it has been specified


    function addExtra(properties, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          properties[key] = extra[key];
        }
      }

      return properties;
    }
  })(module.exports);
});

var RADIUS = 6378137;
var FLATTENING = 1 / 298.257223563;
var POLAR_RADIUS = 6356752.3142;
var wgs84 = {
  RADIUS: RADIUS,
  FLATTENING: FLATTENING,
  POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
  var area = 0,
      i;

  switch (_.type) {
    case 'Polygon':
      return polygonArea(_.coordinates);

    case 'MultiPolygon':
      for (i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
      }

      return area;

    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
      return 0;

    case 'GeometryCollection':
      for (i = 0; i < _.geometries.length; i++) {
        area += geometry(_.geometries[i]);
      }

      return area;
  }
}

function polygonArea(coords) {
  var area = 0;

  if (coords && coords.length > 0) {
    area += Math.abs(ringArea(coords[0]));

    for (var i = 1; i < coords.length; i++) {
      area -= Math.abs(ringArea(coords[i]));
    }
  }

  return area;
}
/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */


function ringArea(coords) {
  var p1,
      p2,
      p3,
      lowerIndex,
      middleIndex,
      upperIndex,
      i,
      area = 0,
      coordsLength = coords.length;

  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        // i = N-2
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        // i = N-1
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        // i = 0 to N-3
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }

      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }

    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
  }

  return area;
}

function rad(_) {
  return _ * Math.PI / 180;
}

var geojsonArea = {
  geometry: geometry_1,
  ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
  switch (gj && gj.type || null) {
    case 'FeatureCollection':
      gj.features = gj.features.map(curryOuter(rewind, outer));
      return gj;

    case 'Feature':
      gj.geometry = rewind(gj.geometry, outer);
      return gj;

    case 'Polygon':
    case 'MultiPolygon':
      return correct(gj, outer);

    default:
      return gj;
  }
}

function curryOuter(a, b) {
  return function (_) {
    return a(_, b);
  };
}

function correct(_, outer) {
  if (_.type === 'Polygon') {
    _.coordinates = correctRings(_.coordinates, outer);
  } else if (_.type === 'MultiPolygon') {
    _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
  }

  return _;
}

function correctRings(_, outer) {
  outer = !!outer;
  _[0] = wind(_[0], outer);

  for (var i = 1; i < _.length; i++) {
    _[i] = wind(_[i], !outer);
  }

  return _;
}

function wind(_, dir) {
  return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
  return geojsonArea.ring(_) >= 0;
}

var MapMultiLayer = function MapMultiLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapMultiLayer.prototype.init = function init() {
  Vue.component('nyco-map-ml', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-ml"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.multi.layers,
        config: MapData.multi.config
      };
    },
    created: function created() {
      this.getZipcodeData();
      this.getBoroughData();
      this.getNeighborhoodData();
    },
    methods: {
      getZipcodeData: function getZipcodeData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/tiger-zcta.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.multi.layers.push({
            name: 'zipcodes',
            data: JSON.parse(data),
            "default": true,
            filterBy: 'GEOID10'
          });
        });
      },
      getBoroughData: function getBoroughData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/7t3b-ywvw.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'boroughs',
            data: this$1.convertToGeoJSON(data),
            "default": false,
            filterBy: 'boro_name'
          });
        });
      },
      getNeighborhoodData: function getNeighborhoodData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/q2z5-ai38.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'neighborhoods',
            data: this$1.convertToGeoJSON(data),
            "default": false,
            filterBy: 'ntaname'
          });
        });
      },
      convertToGeoJSON: function convertToGeoJSON(jsonData) {
        // ensure geojson satisfies right-hand rule
        var data = geojsonRewind(geojson.parse(jsonData, {
          GeoJSON: 'the_geom'
        }));
        return data;
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapMultiLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

var MapSingleLayer = function MapSingleLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapSingleLayer.prototype.init = function init() {
  Vue.component('nyco-map-sl', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-sl"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.single.layers,
        config: MapData.single.config
      };
    },
    created: function created() {
      this.getData();
    },
    methods: {
      getData: function getData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/nyco-nyc_zipcodes.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.single.layers.push({
            name: 'nyco-nyc_zipcodes',
            data: JSON.parse(data),
            filterBy: 'ZCTA5CE10',
            legendColumn: 'BORO',
            fill: colors_2[3]
          });
        });
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapSingleLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

/**
 * JaroWinkler function.
 * https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @return {number} amount of matches.
 */
function jaro(s1, s2) {
  var assign;
  var shorter;
  var longer;
  assign = s1.length > s2.length ? [s1, s2] : [s2, s1], longer = assign[0], shorter = assign[1];
  var matchingWindow = Math.floor(longer.length / 2) - 1;
  var shorterMatches = [];
  var longerMatches = [];

  for (var i = 0; i < shorter.length; i++) {
    var ch = shorter[i];
    var windowStart = Math.max(0, i - matchingWindow);
    var windowEnd = Math.min(i + matchingWindow + 1, longer.length);

    for (var j = windowStart; j < windowEnd; j++) {
      if (longerMatches[j] === undefined && ch === longer[j]) {
        shorterMatches[i] = longerMatches[j] = ch;
        break;
      }
    }
  }

  var shorterMatchesString = shorterMatches.join('');
  var longerMatchesString = longerMatches.join('');
  var numMatches = shorterMatchesString.length;
  var transpositions = 0;

  for (var i$1 = 0; i$1 < shorterMatchesString.length; i$1++) {
    if (shorterMatchesString[i$1] !== longerMatchesString[i$1]) {
      transpositions++;
    }
  }

  return numMatches > 0 ? (numMatches / shorter.length + numMatches / longer.length + (numMatches - Math.floor(transpositions / 2)) / numMatches) / 3.0 : 0;
}
/**
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @param {number} prefixScalingFactor
 * @return {number} jaroSimilarity
 */


function jaroWinkler (s1, s2, prefixScalingFactor) {
  if (prefixScalingFactor === void 0) prefixScalingFactor = 0.2;
  var jaroSimilarity = jaro(s1, s2);
  var commonPrefixLength = 0;

  for (var i = 0; i < s1.length; i++) {
    if (s1[i] === s2[i]) {
      commonPrefixLength++;
    } else {
      break;
    }
  }

  return jaroSimilarity + Math.min(commonPrefixLength, 4) * prefixScalingFactor * (1 - jaroSimilarity);
}

function memoize$1 (fn) {
  var cache = {};
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) {
      args[len] = arguments[len];
    }

    var key = JSON.stringify(args);
    return cache[key] || (cache[key] = fn.apply(void 0, args));
  };
}

/* eslint-env browser */
/**
 * Autocomplete for autocomplete.
 * Forked and modified from https://github.com/xavi/miss-plete
 */

var Autocomplete = function Autocomplete(settings) {
  var this$1 = this;
  if (settings === void 0) settings = {};
  this.settings = {
    'selector': settings.selector,
    // required
    'options': settings.options,
    // required
    'classname': settings.classname,
    // required
    'selected': settings.hasOwnProperty('selected') ? settings.selected : false,
    'score': settings.hasOwnProperty('score') ? settings.score : memoize$1(Autocomplete.score),
    'listItem': settings.hasOwnProperty('listItem') ? settings.listItem : Autocomplete.listItem,
    'getSiblingIndex': settings.hasOwnProperty('getSiblingIndex') ? settings.getSiblingIndex : Autocomplete.getSiblingIndex
  };
  this.scoredOptions = null;
  this.container = null;
  this.ul = null;
  this.highlighted = -1;
  this.SELECTORS = Autocomplete.selectors;
  this.STRINGS = Autocomplete.strings;
  this.MAX_ITEMS = Autocomplete.maxItems;
  window.addEventListener('keydown', function (e) {
    this$1.keydownEvent(e);
  });
  window.addEventListener('keyup', function (e) {
    this$1.keyupEvent(e);
  });
  window.addEventListener('input', function (e) {
    this$1.inputEvent(e);
  });
  var body = document.querySelector('body');
  body.addEventListener('focus', function (e) {
    this$1.focusEvent(e);
  }, true);
  body.addEventListener('blur', function (e) {
    this$1.blurEvent(e);
  }, true);
  return this;
};
/**
 * EVENTS
 */

/**
 * The input focus event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.focusEvent = function focusEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value === '') {
    this.message('INIT');
  }
};
/**
 * The input keydown event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keydownEvent = function keydownEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.ul) {
    switch (event.keyCode) {
      case 13:
        this.keyEnter(event);
        break;

      case 27:
        this.keyEscape(event);
        break;

      case 40:
        this.keyDown(event);
        break;

      case 38:
        this.keyUp(event);
        break;
    }
  }
};
/**
 * The input keyup event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keyupEvent = function keyupEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;
};
/**
 * The input event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.inputEvent = function inputEvent(event) {
  var this$1 = this;

  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value.length > 0) {
    this.scoredOptions = this.settings.options.map(function (option) {
      return this$1.settings.score(this$1.input.value, option);
    }).sort(function (a, b) {
      return b.score - a.score;
    });
  } else {
    this.scoredOptions = [];
  }

  this.dropdown();
};
/**
 * The input blur event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.blurEvent = function blurEvent(event) {
  if (event.target === window || !event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.dataset.persistDropdown === 'true') {
    return;
  }

  this.remove();
  this.highlighted = -1;
};
/**
 * KEY INPUT EVENTS
 */

/**
 * What happens when the user presses the down arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyDown = function keyDown(event) {
  event.preventDefault();
  this.highlight(this.highlighted < this.ul.children.length - 1 ? this.highlighted + 1 : -1);
  return this;
};
/**
 * What happens when the user presses the up arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyUp = function keyUp(event) {
  event.preventDefault();
  this.highlight(this.highlighted > -1 ? this.highlighted - 1 : this.ul.children.length - 1);
  return this;
};
/**
 * What happens when the user presses the enter key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEnter = function keyEnter(event) {
  this.selected();
  return this;
};
/**
 * What happens when the user presses the escape key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEscape = function keyEscape(event) {
  this.remove();
  return this;
};
/**
 * STATIC
 */

/**
 * It must return an object with at least the properties 'score'
 * and 'displayValue.' Default is a JaroWinkler similarity function.
 * @param{array}value
 * @param{array}synonyms
 * @return {int}  Score or displayValue
 */


Autocomplete.score = function score(value, synonyms) {
  var closestSynonym = null;
  synonyms.forEach(function (synonym) {
    var similarity = jaroWinkler(synonym.trim().toLowerCase(), value.trim().toLowerCase());

    if (closestSynonym === null || similarity > closestSynonym.similarity) {
      closestSynonym = {
        similarity: similarity,
        value: synonym
      };

      if (similarity === 1) {
        return;
      }
    }
  });
  return {
    score: closestSynonym.similarity,
    displayValue: synonyms[0]
  };
};
/**
 * List item for dropdown list.
 * @param{Number}scoredOption
 * @param{Number}index
 * @return {string}The a list item <li>.
 */


Autocomplete.listItem = function listItem(scoredOption, index, maxItems) {
  var normalizedIndex = index + 1; // start at 1

  var li = normalizedIndex > maxItems ? null : document.createElement('li');

  if (li) {
    li.setAttribute('role', 'option');
    li.setAttribute('tabindex', '-1');
    li.setAttribute('aria-selected', 'false');
  }

  li && li.appendChild(document.createTextNode(scoredOption.displayValue));
  return li;
};
/**
 * Get index of previous element.
 * @param{array} node
 * @return {number}index of previous element.
 */


Autocomplete.getSiblingIndex = function getSiblingIndex(node) {
  var index = -1;
  var n = node;

  do {
    index++;
    n = n.previousElementSibling;
  } while (n);

  return index;
};
/**
 * PUBLIC METHODS
 */

/**
 * Display options as a list.
 * @return{object} The Class
 */


Autocomplete.prototype.dropdown = function dropdown() {
  var this$1 = this;
  var documentFragment = document.createDocumentFragment();
  this.scoredOptions.every(function (scoredOption, i) {
    var listItem = this$1.settings.listItem(scoredOption, i, this$1.MAX_ITEMS);
    listItem && documentFragment.appendChild(listItem);
    return !!listItem;
  });
  this.remove();
  this.highlighted = -1;

  if (documentFragment.hasChildNodes()) {
    var newUl = document.createElement('ul');
    newUl.setAttribute('role', 'listbox');
    newUl.setAttribute('tabindex', '0');
    newUl.setAttribute('id', this.SELECTORS.OPTIONS);
    newUl.addEventListener('mouseover', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.highlight(this$1.settings.getSiblingIndex(event.target));
      }
    });
    newUl.addEventListener('mousedown', function (event) {
      return event.preventDefault();
    });
    newUl.addEventListener('click', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.selected();
      }
    });
    newUl.appendChild(documentFragment); // See CSS to understand why the <ul> has to be wrapped in a <div>

    var newContainer = document.createElement('div');
    newContainer.className = this.settings.classname;
    newContainer.appendChild(newUl);
    this.input.setAttribute('aria-expanded', 'true'); // Inserts the dropdown just after the <input> element

    this.input.parentNode.insertBefore(newContainer, this.input.nextSibling);
    this.container = newContainer;
    this.ul = newUl;
    this.message('TYPING', this.settings.options.length);
  }

  return this;
};
/**
 * Highlight new option selected.
 * @param {Number}newIndex
 * @return{object}The Class
 */


Autocomplete.prototype.highlight = function highlight(newIndex) {
  if (newIndex > -1 && newIndex < this.ul.children.length) {
    // If any option already selected, then unselect it
    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.remove(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].removeAttribute('aria-selected');
      this.ul.children[this.highlighted].removeAttribute('id');
      this.input.removeAttribute('aria-activedescendant');
    }

    this.highlighted = newIndex;

    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.add(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].setAttribute('aria-selected', 'true');
      this.ul.children[this.highlighted].setAttribute('id', this.SELECTORS.ACTIVE_DESCENDANT);
      this.input.setAttribute('aria-activedescendant', this.SELECTORS.ACTIVE_DESCENDANT);
    }
  }

  return this;
};
/**
 * Selects an option from a list of items.
 * @return{object} The Class
 */


Autocomplete.prototype.selected = function selected() {
  if (this.highlighted !== -1) {
    this.input.value = this.scoredOptions[this.highlighted].displayValue;
    this.remove();
    this.message('SELECTED', this.input.value);

    if (window.innerWidth <= 768) {
      this.input.scrollIntoView(true);
    }
  } // User provided callback method for selected option.


  if (this.settings.selected) {
    this.settings.selected(this.input.value, this);
  }

  return this;
};
/**
 * Remove dropdown list once a list item is selected.
 * @return{object} The Class
 */


Autocomplete.prototype.remove = function remove() {
  this.container && this.container.remove();
  this.input.setAttribute('aria-expanded', 'false');
  this.container = null;
  this.ul = null;
  return this;
};
/**
 * Messaging that is passed to the screen reader
 * @param {string}key     The Key of the message to write
 * @param {string}variableA variable to provide to the string.
 * @return{object}          The Class
 */


Autocomplete.prototype.message = function message(key, variable) {
  var this$1 = this;
  if (key === void 0) key = false;
  if (variable === void 0) variable = '';

  if (!key) {
    return this;
  }

  var messages = {
    'INIT': function INIT() {
      return this$1.STRINGS.DIRECTIONS_TYPE;
    },
    'TYPING': function TYPING() {
      return [this$1.STRINGS.OPTION_AVAILABLE.replace('{{ NUMBER }}', variable), this$1.STRINGS.DIRECTIONS_REVIEW].join('. ');
    },
    'SELECTED': function SELECTED() {
      return [this$1.STRINGS.OPTION_SELECTED.replace('{{ VALUE }}', variable), this$1.STRINGS.DIRECTIONS_TYPE].join('. ');
    }
  };
  document.querySelector("#" + this.input.getAttribute('aria-describedby')).innerHTML = messages[key]();
  return this;
};
/** Selectors for the Autocomplete class. */


Autocomplete.selectors = {
  'HIGHLIGHT': 'input-autocomplete__highlight',
  'OPTIONS': 'input-autocomplete__options',
  'ACTIVE_DESCENDANT': 'input-autocomplete__selected',
  'SCREEN_READER_ONLY': 'sr-only'
};
/**  */

Autocomplete.strings = {
  'DIRECTIONS_TYPE': 'Start typing to generate a list of potential input options',
  'DIRECTIONS_REVIEW': ['Keyboard users can use the up and down arrows to ', 'review options and press enter to select an option'].join(''),
  'OPTION_AVAILABLE': '{{ NUMBER }} options available',
  'OPTION_SELECTED': '{{ VALUE }} selected'
};
/** Maximum amount of results to be returned. */

Autocomplete.maxItems = 5;

/**
 * The InputAutocomplete class.
 */

var InputAutocomplete = function InputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  this.library = new Autocomplete({
    options: settings.hasOwnProperty('options') ? settings.options : InputAutocomplete.options,
    selected: settings.hasOwnProperty('selected') ? settings.selected : false,
    selector: settings.hasOwnProperty('selector') ? settings.selector : InputAutocomplete.selector,
    classname: settings.hasOwnProperty('classname') ? settings.classname : InputAutocomplete.classname
  });
  return this;
};
/**
 * Setter for the Autocomplete options
 * @param{object} reset Set of array options for the Autocomplete class
 * @return {object} InputAutocomplete object with new options.
 */


InputAutocomplete.prototype.options = function options(reset) {
  this.library.settings.options = reset;
  return this;
};
/**
 * Setter for the Autocomplete strings
 * @param{object}localizedStringsObject containing strings.
 * @return {object} Autocomplete strings
 */


InputAutocomplete.prototype.strings = function strings(localizedStrings) {
  Object.assign(this.library.STRINGS, localizedStrings);
  return this;
};
/** @type {array} Default options for the autocomplete class */


InputAutocomplete.options = [];
/** @type {string} The search box dom selector */

InputAutocomplete.selector = '[data-js="input-autocomplete__input"]';
/** @type {string} The classname for the dropdown element */

InputAutocomplete.classname = 'input-autocomplete__dropdown';

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};
/**
 * Method for the Map Module
 * @return{Object} Map Module
 */


nyco.prototype.map = function map(type) {
  if (type === 'multi') {
    return new MapMultiLayer();
  }

  if (type === 'single') {
    return new MapSingleLayer();
  }
};
/**
 * Method for the Input Autocomplete Element
 * @return{Object} Input Autocomplete instance
 */


nyco.prototype.inputAutocomplete = function inputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  return new InputAutocomplete(settings);
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJbmRleE9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlJbmNsdWRlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuaXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaXFCeS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2ZlZWQvRmVlZC5qcyIsIi4uLy4uL3NyYy91dGlsaXRpZXMvdG9nZ2xlL1RvZ2dsZS5qcyIsIi4uLy4uL3NyYy91dGlsaXRpZXMvdHJhY2svVHJhY2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QudnVlIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuZGF0YS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9zZWxlY3Qvc2VsZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1jaGFydGpzL2VzL21peGlucy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvQ2hhcnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvQmFzZUNoYXJ0cy5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tYmFyLnZ1ZSIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC5kYXRhLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWhvcml6b250YWwtYmFyLnZ1ZSIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1saW5lLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1waWUudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1waWUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9tYXAvbWFwLnZ1ZSIsIi4uLy4uL2NvbmZpZy9jb2xvcnMuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9tYXAvbWFwLmRhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2VvanNvbi9nZW9qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dnczg0L2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXBib3gvZ2VvanNvbi1hcmVhL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL2luZGV4LmpzIiwiLi4vLi4vc3JjL2pzL01hcC5qcyIsIi4uLy4uL3NyYy9qcy9tb2R1bGVzL2phcm9XaW5rbGVyLmpzIiwiLi4vLi4vc3JjL2pzL21vZHVsZXMvbWVtb2l6ZS5qcyIsIi4uLy4uL3NyYy9qcy9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pbnB1dHMvaW5wdXQtYXV0b2NvbXBsZXRlLmpzIiwiLi4vLi4vc3JjL2pzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBVdGlsaXR5IGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVXRpbGl0eSB7XG4gIC8qKlxuICAgKiBUaGUgVXRpbGl0eSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBVdGlsaXR5IGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIEJvb2xlYW4gZm9yIGRlYnVnIG1vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciBvciBub3QgdGhlIGZyb250LWVuZCBpcyBpbiBkZWJ1ZyBtb2RlLlxuICovXG5VdGlsaXR5LmRlYnVnID0gKCkgPT4gKFV0aWxpdHkuZ2V0VXJsUGFyYW1ldGVyKFV0aWxpdHkuUEFSQU1TLkRFQlVHKSA9PT0gJzEnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGtleSBpbiBhIFVSTCBxdWVyeSBzdHJpbmcuIElmIG5vIFVSTCBxdWVyeVxuICogc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgY3VycmVudCBVUkwgbG9jYXRpb24gaXMgdXNlZC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAgICAgIC0gS2V5IG5hbWUuXG4gKiBAcGFyYW0gIHs/c3RyaW5nfSBxdWVyeVN0cmluZyAtIE9wdGlvbmFsIHF1ZXJ5IHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFF1ZXJ5IHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIgPSAobmFtZSwgcXVlcnlTdHJpbmcpID0+IHtcbiAgY29uc3QgcXVlcnkgPSBxdWVyeVN0cmluZyB8fCB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICBjb25zdCBwYXJhbSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpO1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScpO1xuICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyhxdWVyeSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyAnJyA6XG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xufTtcblxuLyoqXG4gKiBGb3IgdHJhbnNsYXRpbmcgc3RyaW5ncywgdGhlcmUgaXMgYSBnbG9iYWwgTE9DQUxJWkVEX1NUUklOR1MgYXJyYXkgdGhhdFxuICogaXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0ZW1wbGF0ZSBsZXZlbCBzbyB0aGF0IHRob3NlIHN0cmluZ3MgYXJlIGV4cG9zZWQgdG9cbiAqIFdQTUwgdHJhbnNsYXRpb24uIFRoZSBMT0NBTElaRURfU1RSSU5HUyBhcnJheSBpcyBjb21wb3NlZCBvZiBvYmplY3RzIHdpdGggYVxuICogYHNsdWdgIGtleSB3aG9zZSB2YWx1ZSBpcyBzb21lIGNvbnN0YW50LCBhbmQgYSBgbGFiZWxgIHZhbHVlIHdoaWNoIGlzIHRoZVxuICogdHJhbnNsYXRlZCBlcXVpdmFsZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgc2x1ZyBuYW1lIGFuZCByZXR1cm5zIHRoZVxuICogbGFiZWwuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNsdWdcbiAqIEByZXR1cm4ge3N0cmluZ30gbG9jYWxpemVkIHZhbHVlXG4gKi9cblV0aWxpdHkubG9jYWxpemUgPSBmdW5jdGlvbihzbHVnKSB7XG4gIGxldCB0ZXh0ID0gc2x1ZyB8fCAnJztcbiAgY29uc3Qgc3RyaW5ncyA9IHdpbmRvdy5MT0NBTElaRURfU1RSSU5HUyB8fCBbXTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmdzLmZpbHRlcihcbiAgICAocykgPT4gKHMuaGFzT3duUHJvcGVydHkoJ3NsdWcnKSAmJiBzWydzbHVnJ10gPT09IHNsdWcpID8gcyA6IGZhbHNlXG4gICk7XG4gIHJldHVybiAobWF0Y2hbMF0gJiYgbWF0Y2hbMF0uaGFzT3duUHJvcGVydHkoJ2xhYmVsJykpID8gbWF0Y2hbMF0ubGFiZWwgOiB0ZXh0O1xufTtcblxuLyoqXG4gKiBBcHBsaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlsaXR5LlBBUkFNUyA9IHtcbiAgREVCVUc6ICdkZWJ1Zydcbn07XG5cbi8qKlxuICogU2VsZWN0b3JzIGZvciB0aGUgVXRpbGl0eSBtb2R1bGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuU0VMRUNUT1JTID0ge1xuICBwYXJzZU1hcmtkb3duOiAnW2RhdGEtanM9XCJtYXJrZG93blwiXSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVdGlsaXR5IGZyb20gJy4uLy4uL2pzL21vZHVsZXMvdXRpbGl0eSc7XG5cbi8qKlxuICogVGhlIEljb24gbW9kdWxlXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgSWNvbnMge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgcGF0aCA9IChwYXRoKSA/IHBhdGggOiBJY29ucy5wYXRoO1xuXG4gICAgZmV0Y2gocGF0aClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzcHJpdGUuaW5uZXJIVE1MID0gZGF0YTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcHJpdGUpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIHBhdGggb2YgdGhlIGljb24gZmlsZSAqL1xuSWNvbnMucGF0aCA9ICdpY29ucy5zdmcnO1xuXG5leHBvcnQgZGVmYXVsdCBJY29ucztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25zdGFudDtcbiIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZXN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSXRlcmF0ZWVDYWxsO1xuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluV2l0aDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcnJvcjtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGF0dGVtcHQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcbiIsIi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlU3RyaW5nQ2hhcjtcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlSW50ZXJwb2xhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eU9mO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eU9mIGZyb20gJy4vX2Jhc2VQcm9wZXJ0eU9mLmpzJztcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZUh0bWxDaGFyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG4iLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG4iLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcbiIsImltcG9ydCBlc2NhcGUgZnJvbSAnLi9lc2NhcGUuanMnO1xuaW1wb3J0IHJlRXNjYXBlIGZyb20gJy4vX3JlRXNjYXBlLmpzJztcbmltcG9ydCByZUV2YWx1YXRlIGZyb20gJy4vX3JlRXZhbHVhdGUuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVTZXR0aW5ncztcbiIsImltcG9ydCBhc3NpZ25JbldpdGggZnJvbSAnLi9hc3NpZ25JbldpdGguanMnO1xuaW1wb3J0IGF0dGVtcHQgZnJvbSAnLi9hdHRlbXB0LmpzJztcbmltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGN1c3RvbURlZmF1bHRzQXNzaWduSW4gZnJvbSAnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nQ2hhciBmcm9tICcuL19lc2NhcGVTdHJpbmdDaGFyLmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHRlbXBsYXRlU2V0dGluZ3MgZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG4iLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RGdW5jdGlvbjtcbiIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrU2V0O1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IHN0YWNrQ2xlYXIgZnJvbSAnLi9fc3RhY2tDbGVhci5qcyc7XG5pbXBvcnQgc3RhY2tEZWxldGUgZnJvbSAnLi9fc3RhY2tEZWxldGUuanMnO1xuaW1wb3J0IHN0YWNrR2V0IGZyb20gJy4vX3N0YWNrR2V0LmpzJztcbmltcG9ydCBzdGFja0hhcyBmcm9tICcuL19zdGFja0hhcy5qcyc7XG5pbXBvcnQgc3RhY2tTZXQgZnJvbSAnLi9fc3RhY2tTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQnVmZmVyO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IFVpbnQ4QXJyYXk7XG4iLCJpbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUFycmF5QnVmZmVyO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDcmVhdGU7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUdldDtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9QbGFpbk9iamVjdDtcbiIsImltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5pbXBvcnQgdG9QbGFpbk9iamVjdCBmcm9tICcuL3RvUGxhaW5PYmplY3QuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1lcmdlO1xuIiwiaW1wb3J0IGJhc2VNZXJnZSBmcm9tICcuL19iYXNlTWVyZ2UuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlO1xuIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUhhcztcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVBZGQgZnJvbSAnLi9fc2V0Q2FjaGVBZGQuanMnO1xuaW1wb3J0IHNldENhY2hlSGFzIGZyb20gJy4vX3NldENhY2hlSGFzLmpzJztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5leHBvcnQgZGVmYXVsdCBTZXRDYWNoZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYWNoZUhhcztcbiIsImltcG9ydCBTZXRDYWNoZSBmcm9tICcuL19TZXRDYWNoZS5qcyc7XG5pbXBvcnQgYXJyYXlTb21lIGZyb20gJy4vX2FycmF5U29tZS5qcyc7XG5pbXBvcnQgY2FjaGVIYXMgZnJvbSAnLi9fY2FjaGVIYXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEFycmF5cztcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRUb0FycmF5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IG1hcFRvQXJyYXkgZnJvbSAnLi9fbWFwVG9BcnJheS5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxCeVRhZztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlQdXNoO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0QWxsS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlGaWx0ZXI7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViQXJyYXk7XG4iLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IHN0dWJBcnJheSBmcm9tICcuL3N0dWJBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9scztcbiIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbEtleXM7XG4iLCJpbXBvcnQgZ2V0QWxsS2V5cyBmcm9tICcuL19nZXRBbGxLZXlzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsT2JqZWN0cztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFWaWV3O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNldDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBXZWFrTWFwO1xuIiwiaW1wb3J0IERhdGFWaWV3IGZyb20gJy4vX0RhdGFWaWV3LmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4vX1Byb21pc2UuanMnO1xuaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IFdlYWtNYXAgZnJvbSAnLi9fV2Vha01hcC5qcyc7XG5pbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFRhZztcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IGVxdWFsQnlUYWcgZnJvbSAnLi9fZXF1YWxCeVRhZy5qcyc7XG5pbXBvcnQgZXF1YWxPYmplY3RzIGZyb20gJy4vX2VxdWFsT2JqZWN0cy5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbERlZXA7XG4iLCJpbXBvcnQgYmFzZUlzRXF1YWxEZWVwIGZyb20gJy4vX2Jhc2VJc0VxdWFsRGVlcC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNNYXRjaDtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N0cmljdENvbXBhcmFibGU7XG4iLCJpbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWF0Y2hEYXRhO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBiYXNlSXNNYXRjaCBmcm9tICcuL19iYXNlSXNNYXRjaC5qcyc7XG5pbXBvcnQgZ2V0TWF0Y2hEYXRhIGZyb20gJy4vX2dldE1hdGNoRGF0YS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXM7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5O1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplQ2FwcGVkO1xuIiwiaW1wb3J0IG1lbW9pemVDYXBwZWQgZnJvbSAnLi9fbWVtb2l6ZUNhcHBlZC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVG9QYXRoO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgc3RyaW5nVG9QYXRoIGZyb20gJy4vX3N0cmluZ1RvUGF0aC5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RQYXRoO1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9LZXk7XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSGFzSW47XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc1BhdGg7XG4iLCJpbXBvcnQgYmFzZUhhc0luIGZyb20gJy4vX2Jhc2VIYXNJbi5qcyc7XG5pbXBvcnQgaGFzUGF0aCBmcm9tICcuL19oYXNQYXRoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNJbjtcbiIsImltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5pbXBvcnQgZ2V0IGZyb20gJy4vZ2V0LmpzJztcbmltcG9ydCBoYXNJbiBmcm9tICcuL2hhc0luLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlEZWVwO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuaW1wb3J0IGJhc2VQcm9wZXJ0eURlZXAgZnJvbSAnLi9fYmFzZVByb3BlcnR5RGVlcC5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlTWF0Y2hlcyBmcm9tICcuL19iYXNlTWF0Y2hlcy5qcyc7XG5pbXBvcnQgYmFzZU1hdGNoZXNQcm9wZXJ0eSBmcm9tICcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgcHJvcGVydHkgZnJvbSAnLi9wcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJdGVyYXRlZTtcbiIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU29ydEJ5O1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVBc2NlbmRpbmc7XG4iLCJpbXBvcnQgY29tcGFyZUFzY2VuZGluZyBmcm9tICcuL19jb21wYXJlQXNjZW5kaW5nLmpzJztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZU11bHRpcGxlO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlTWFwIGZyb20gJy4vX2Jhc2VNYXAuanMnO1xuaW1wb3J0IGJhc2VTb3J0QnkgZnJvbSAnLi9fYmFzZVNvcnRCeS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgY29tcGFyZU11bHRpcGxlIGZyb20gJy4vX2NvbXBhcmVNdWx0aXBsZS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlT3JkZXJCeTtcbiIsImltcG9ydCBiYXNlT3JkZXJCeSBmcm9tICcuL19iYXNlT3JkZXJCeS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKiBdO1xuICpcbiAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gKi9cbmZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gIH1cbiAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9yZGVyQnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZpbmRJbmRleDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hTjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaWN0SW5kZXhPZjtcbiIsImltcG9ydCBiYXNlRmluZEluZGV4IGZyb20gJy4vX2Jhc2VGaW5kSW5kZXguanMnO1xuaW1wb3J0IGJhc2VJc05hTiBmcm9tICcuL19iYXNlSXNOYU4uanMnO1xuaW1wb3J0IHN0cmljdEluZGV4T2YgZnJvbSAnLi9fc3RyaWN0SW5kZXhPZi5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJbmRleE9mO1xuIiwiaW1wb3J0IGJhc2VJbmRleE9mIGZyb20gJy4vX2Jhc2VJbmRleE9mLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlJbmNsdWRlcztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcbiIsImltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBub29wIGZyb20gJy4vbm9vcC5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2V0O1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheUluY2x1ZGVzIGZyb20gJy4vX2FycmF5SW5jbHVkZXMuanMnO1xuaW1wb3J0IGFycmF5SW5jbHVkZXNXaXRoIGZyb20gJy4vX2FycmF5SW5jbHVkZXNXaXRoLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5pbXBvcnQgY3JlYXRlU2V0IGZyb20gJy4vX2NyZWF0ZVNldC5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuaXE7XG4iLCJpbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVVuaXEgZnJvbSAnLi9fYmFzZVVuaXEuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiBbMi4xLCAxLjJdXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAqL1xuZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdW5pcUJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgX3RlbXBsYXRlIGZyb20gJ2xvZGFzaC1lcy90ZW1wbGF0ZSc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoLWVzL2ZvckVhY2gnO1xuaW1wb3J0IF9tZXJnZSBmcm9tICdsb2Rhc2gtZXMvbWVyZ2UnO1xuaW1wb3J0IF92YWx1ZXMgZnJvbSAnbG9kYXNoLWVzL3ZhbHVlcyc7XG5pbXBvcnQgX29yZGVyQnkgZnJvbSAnbG9kYXNoLWVzL29yZGVyQnknO1xuaW1wb3J0IF91bmlxQnkgZnJvbSAnbG9kYXNoLWVzL3VuaXFCeSc7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgRmVlZCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdCA9IEZlZWQuZGVmYXVsdDtcblxuICAgIHRoaXMuX3NldHRpbmdzID0gX21lcmdlKHt9LCBGZWVkLmRlZmF1bHQsIGNvbmZpZyk7XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIGxldCBkYXRhID0gW107XG4gICAgbGV0IGZlZWQgPSB0aGlzLl9zZXR0aW5ncy5mZWVkO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICByc3NUb0pzb246IEZlZWQucnNzVG9Kc29uLFxuICAgICAgcnNzVXJsOiAoQXJyYXkuaXNBcnJheShmZWVkKSkgPyBmZWVkIDogW2ZlZWRdXG4gICAgfTtcblxuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBmZWVkXG4gICAgX2ZvckVhY2goY29uZmlnLnJzc1VybCwgKHVybCwgaW5kZXgpID0+IHtcbiAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcblxuICAgICAgdGhpcy5fcmVxdWVzdChjb25maWcsIHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhXG4gICAgICAgICAgZGF0YS5wdXNoKHRoaXMuX3Byb2Nlc3MoSlNPTi5wYXJzZShyZXNwb25zZSksIHRoaXMuX3NldHRpbmdzKSk7XG4gICAgICAgICAgLy8gV2hlbiBhbGwgZmVlZHMgaGF2ZSBiZWVuIHJlcXVlc3RlZCwgbWVyZ2UgdGhlIGRhdGEgYW5kIGNvbXBpbGVcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGNvbmZpZy5yc3NVcmwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGxldCBjb21waWxlZCA9IHRoaXMuX3JlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5fbWVyZ2UoZGF0YSwgdGhpcy5fc2V0dGluZ3MpLFxuICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9zZXR0aW5ncy5zZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGNvbXBpbGVkO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0IGZvciB0aGUgZmVlZCBkYXRhXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnIFRoZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgVGhlIHJlcXVlc3QgdXJsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFJlc29sdmVzIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHJlYWR5LCByZWplY3RzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXQgb3IgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAqL1xuICBfcmVxdWVzdChjb25maWcsIHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbGV0IF94aHIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChfeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoX3hoci5zdGF0dXMgPj0gMjAwICYmIF94aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKF94aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF94aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgRmVlZCByZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgIH07XG4gICAgICB4aHIub3BlbignR0VUJywgYCR7Y29uZmlnLnJzc1RvSnNvbn0/cnNzX3VybD0ke3VybH1gLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICB4aHIgPSBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgcHJvY2Vzc2luZyBmdW5jdGlvbiBiYXNlZCBvbiB0eXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBwcm9jZXNzZWQgZGF0YVxuICAgKi9cbiAgX3Byb2Nlc3MoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gRmVlZC5wcm9jZXNzW3NldHRpbmdzLnR5cGVdKGRhdGEsIHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzIGRhdGEgdG8gdGhlIGFwcHJvcHJpYXRlIG1lcmdlIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIG1lcmdlZCBmZWVkIGRhdGFcbiAgICovXG4gIF9tZXJnZShkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLm1lcmdlW3NldHRpbmdzLnR5cGVdKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGVtcGxhdGUgY29tcG9uZW50cywgcGFzcyBkYXRhLCBhbmQgcmV0dXJuIGNvbXBpbGVkIHRlbWxhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgVGhlIGNvbXBsaWVkIGh0bWwgc3RyaW5nXG4gICAqL1xuICBfcmVuZGVyKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgaWYgKHNldHRpbmdzLmxvZylcbiAgICAgIGNvbnNvbGUuZGlyKGRhdGEpO1xuXG4gICAgbGV0IHRlbXBsYXRlID0gX3ZhbHVlcyhzZXR0aW5ncy50ZW1wbGF0ZXMpLmpvaW4oJycpO1xuICAgIGxldCBjb21waWxlZCA9IF90ZW1wbGF0ZShcbiAgICAgIHRlbXBsYXRlLFxuICAgICAge1xuICAgICAgICAnaW1wb3J0cyc6IHtcbiAgICAgICAgICAnX2VhY2gnOiBfZm9yRWFjaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29tcGlsZWQoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvcGVuIFJTUyB0byBKU09OIGFwaSwgc2VlIGh0dHBzOi8vcnNzMmpzb24uY29tXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5GZWVkLnJzc1RvSnNvbiA9ICdodHRwczovL2FwaS5yc3MyanNvbi5jb20vdjEvYXBpLmpzb24nO1xuXG4vKipcbiAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdpZGdldC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQudGVtcGxhdGVzID0ge1xuICBtZWRpdW06IHtcbiAgICBvcGVuZXI6IFtcbiAgICAgICc8c2VjdGlvbiBjbGFzcz1cIm8tZmVlZCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy53cmFwcGVyICU+XCIgc3R5bGU9XCInLFxuICAgICAgICAnPCUgaWYgKHNldHRpbmdzLmZvbnRTaXplKSB7ICU+Zm9udC1zaXplOiA8JS0gc2V0dGluZ3MuZm9udFNpemUgJT47PCUgfSAlPicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yKSB7ICU+Ym9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OzwlIH0gJT4nLFxuICAgICAgJ1wiPidcbiAgICBdLFxuICAgIGhlYWRlcjogW1xuICAgICAgJzxoZWFkZXIgY2xhc3M9XCJvLWZlZWRfX2hlYWRlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5oZWFkZXIgJT5cIj4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9fYXZhdGFyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmF2YXRhciAlPlwiPicsXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnByb2ZpbGVJbWcgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy5wcm9maWxlSW1nICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBmZWVkLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9ICU+XCIgJyxcbiAgICAgICAgICAgICAgICd3aWR0aD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMF0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ2hlaWdodD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMV0gJT5cIj4nLFxuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzxhIGNsYXNzPVwiby1mZWVkX191cmwgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCIgJyxcbiAgICAgICAgICAnaHJlZj1cIjwlIGlmIChzZXR0aW5ncy50aXRsZVVybCAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlVXJsICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnVybCAlPicsXG4gICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgJzwlIGlmIChzZXR0aW5ncy50aXRsZSAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSAlPicsXG4gICAgICAgICc8L2E+JyxcbiAgICAgICc8L2hlYWRlcj4nXG4gICAgXSxcbiAgICBwb3N0czogW1xuICAgICAgJzxkaXYgY2xhc3M9XCJvLWZlZWRfX2l0ZW1zXCIgc3R5bGU9XCInLFxuICAgICAgICAnYm9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OycsXG4gICAgICAnXCI+JyxcbiAgICAgICAgJzwlIF9lYWNoKGl0ZW1zLCBmdW5jdGlvbihwb3N0KSB7ICU+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmZlZWRJdGVtICU+XCI+JyxcbiAgICAgICAgICAgICc8aDQgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGl0bGUgPCUtIHNldHRpbmdzLmNsYXNzZXMudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJjLWZlZWQtaXRlbV9fbGluayA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5saW5rICU+XCInLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIicsXG4gICAgICAgICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIicsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHBvc3QudGl0bGUgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9oND4nLFxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2RhdGUgPCUtIHNldHRpbmdzLmNsYXNzZXMuZGF0ZSAlPlwiICcsXG4gICAgICAgICAgICAgICAgICAndGl0bGU9XCI8JS0gc2V0dGluZ3MucG9zdERhdGVUaXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8JS0gcG9zdC5kYXRlICU+JyxcbiAgICAgICAgICAgICc8L3NwYW4+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX3RodW1ibmFpbCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aHVtYm5haWwgJT5cIicsXG4gICAgICAgICAgICAgICAgICdzdHlsZT1cIicsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlOiB1cmwoPCUtIHBvc3QudGh1bWJuYWlsICU+KTsnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0OiA8JS0gc2V0dGluZ3MucG9zdEltZ0hlaWdodCAlPjtcIicsXG4gICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbj1cInRydWVcIj4nLFxuICAgICAgICAgICAgICAnPGltZyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgc3JjPVwiPCUtIHBvc3QudGh1bWJuYWlsICU+XCIgYWx0PVwiPCUtIHBvc3QudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPHAgY2xhc3M9XCJjLWZlZWQtaXRlbV9fZXhjZXJwdCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5leGNlcnB0ICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmV4Y2VycHQgJT48JS0gc2V0dGluZ3MucG9zdEV4Y2VycHRUcmFpbCAlPicsXG4gICAgICAgICAgICAnPC9wPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtX19mb290ZXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuaXRlbUZvb3RlciAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19jdGEgPCUtIHNldHRpbmdzLmNsYXNzZXMuY3RhICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ2hyZWY9XCI8JS0gcG9zdC5ndWlkICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnBvc3RDdGFUZXh0ICU+JyxcbiAgICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8JSB9KTsgJT4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLFxuICAgIGNsb3NlcjogW1xuICAgICAgJzwvc2VjdGlvbj4nXG4gICAgXVxuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgcHJvY2Vzc2luZyB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5wcm9jZXNzID0ge1xuICBtZWRpdW06IGZ1bmN0aW9uKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgbGV0IGxlbmd0aCA9IHNldHRpbmdzLnBvc3RFeGNlcnB0TGVuZ3RoO1xuXG4gICAgX2ZvckVhY2goZGF0YS5pdGVtcywgZnVuY3Rpb24ocG9zdCwgaW5kZXgpIHtcbiAgICAgIGxldCBleGNlcnB0ID0gJyc7XG4gICAgICBsZXQgZGF0ZSA9ICcnO1xuXG4gICAgICAvLyBSZW1vdmUgZmlndXJlcyBmaXJzdFxuICAgICAgZXhjZXJwdCA9IHBvc3QuZGVzY3JpcHRpb25cbiAgICAgICAgLnJlcGxhY2UoLzxmaWd1cmUuKj4uKj88XFwvZmlndXJlPi9nLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgdGFnc1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQucmVwbGFjZSgvPCgufFxcbikqPz4vZywgJycpO1xuXG4gICAgICAvLyBUcmltIHRoZSBleGNlcnB0XG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLFxuICAgICAgICBNYXRoLm1pbihleGNlcnB0Lmxlbmd0aCwgZXhjZXJwdC5sYXN0SW5kZXhPZignICcpKVxuICAgICAgKTtcblxuICAgICAgcG9zdC5leGNlcnB0ID0gZXhjZXJwdDtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlXG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShwb3N0LnB1YkRhdGUucmVwbGFjZSgnICcsICdUJykpKVxuICAgICAgICAudG9Mb2NhbGVEYXRlU3RyaW5nKHNldHRpbmdzLnBvc3REYXRlTG9jYWwsIHNldHRpbmdzLnBvc3REYXRlRm9ybWF0KTtcblxuICAgICAgcG9zdC5kYXRlID0gZGF0ZTtcblxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgbWVyZ2luZyB0aGUgZGF0YSBmZWVkcyB0b2dldGhlciwgYmFzZWQgb24gdGhlIGZlZWQgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQubWVyZ2UgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSkge1xuICAgIGxldCBtZXJnZWQgPSB7fTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIC8vIENvbWJpbmUgdGhlIHBvc3QgaXRlbXNcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KGZlZWQuaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGRhdGEsIHRoaXMgd2lsbCBvdmVycmlkZSB2YWx1ZXMsIGl0IHByb2JhYmx5IHdvbid0IGJlXG4gICAgLy8gcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZmVlZHMgdGhhdCBhcmUgdGhlIHNhbWUsIGJ1dCBwb3RlbnRpYWxseVxuICAgIC8vIGRpZmZlcmVudCBmZWVkIHR5cGVzIGNvdWxkIHVzZSB0aGlzIGFuZCBjb21iaW5lIHVuaXF1ZSBkYXRhXG4gICAgZGF0YS5mb3JFYWNoKChmZWVkKSA9PiB7XG4gICAgICBtZXJnZWQgPSBfbWVyZ2UobWVyZ2VkLCBmZWVkKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCB1bmlxdWUgcG9zdHNcbiAgICBpdGVtcyA9IF91bmlxQnkoaXRlbXMsIChpdGVtKSA9PiBpdGVtLmd1aWQpO1xuXG4gICAgbWVyZ2VkLml0ZW1zID0gX29yZGVyQnkoaXRlbXMsICdwdWJEYXRlJywgJ2Rlc2MnKTtcblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9yc3MyanNvbi5jb20vZG9jcyBmb3IgZGV0YWlscyBvbiBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQuZGVmYXVsdCA9IHtcbiAgZmVlZDogJycsXG4gIHNlbGVjdG9yOiAnI2pzLWZlZWQnLFxuICB0eXBlOiAnbWVkaXVtJyxcbiAgdGl0bGU6ICcnLFxuICB0aXRsZVVybDogJycsXG4gIHByb2ZpbGVJbWc6ICcnLFxuICBmb250U2l6ZTogJycsXG4gIHJhdGlvUHJvZmlsZTogWyc1MCcsICc1MCddLFxuICBwb3N0Qm9yZGVyQ29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gIHBvc3RJbWdIZWlnaHQ6ICcyMDBweCcsXG4gIHBvc3RFeGNlcnB0TGVuZ3RoOiAxMjAsXG4gIHBvc3RFeGNlcnB0VHJhaWw6ICfigKYnLFxuICBwb3N0Q3RhVGV4dDogJ1JlYWQgdGhlIGZ1bGwgcG9zdCcsXG4gIHBvc3REYXRlTG9jYWw6ICdlbi1VUycsXG4gIHBvc3REYXRlRm9ybWF0OiB7XG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYydcbiAgfSxcbiAgcG9zdERhdGVUaXRsZTogJ1B1Ymxpc2hlZCBEYXRlJyxcbiAgY2xhc3Nlczoge1xuICAgIHdyYXBwZXI6ICcnLFxuICAgIGhlYWRlcjogJycsXG4gICAgdXJsOiAnJyxcbiAgICBmZWVkSXRlbTogJycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGxpbms6ICcnLFxuICAgIHRodW1ibmFpbDogJycsXG4gICAgZXhjZXJwdDogJycsXG4gICAgaXRlbUZvb3RlcjogJycsXG4gICAgY3RhOiAnJyxcbiAgICBkYXRlOiAnJ1xuICB9LFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBvcGVuZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5vcGVuZXIuam9pbignJyksXG4gICAgaGVhZGVyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uaGVhZGVyLmpvaW4oJycpLFxuICAgIHBvc3RzOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0ucG9zdHMuam9pbignJyksXG4gICAgY2xvc2VyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uY2xvc2VyLmpvaW4oJycpXG4gIH0sXG4gIGxvZzogZmFsc2UsXG4gIHVuaXF1ZTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZlZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFNpbXBsZSBUb2dnbGUgY2xhc3MuIFRoaXMgd2lsbCB0b2dnbGUgdGhlIGNsYXNzICdhY3RpdmUnIGFuZCAnaGlkZGVuJ1xuICogb24gdGFyZ2V0IGVsZW1lbnRzLCBkZXRlcm1pbmVkIGJ5IGEgY2xpY2sgZXZlbnQgb24gYSBzZWxlY3RlZCBsaW5rIG9yXG4gKiBlbGVtZW50LiBUaGlzIHdpbGwgYWxzbyB0b2dnbGUgdGhlIGFyaWEtaGlkZGVuIGF0dHJpYnV0ZSBmb3IgdGFyZ2V0ZWRcbiAqIGVsZW1lbnRzIHRvIHN1cHBvcnQgc2NyZWVuIHJlYWRlcnMuIFRhcmdldCBzZXR0aW5ncyBhbmQgb3RoZXIgZnVuY3Rpb25hbGl0eVxuICogY2FuIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBkYXRhIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyB1c2VzIHRoZSAubWF0Y2hlcygpIG1ldGhvZCB3aGljaCB3aWxsIHJlcXVpcmUgYSBwb2x5ZmlsbCBmb3IgSUVcbiAqIGh0dHBzOi8vcG9seWZpbGwuaW8vdjIvZG9jcy9mZWF0dXJlcy8jRWxlbWVudF9wcm90b3R5cGVfbWF0Y2hlc1xuICpcbiAqIEJhc2ljIFVzYWdlO1xuICpcbiAqIGphdmFzY3JpcHQ6XG4gKiAgIG5ldyBUb2dnbGUoKS5pbml0KCk7XG4gKlxuICogVG9nZ2xpbmcgQW5jaG9yIGxpbmtzOlxuICogICA8YSBkYXRhLWpzPSd0b2dnbGUnIGhyZWY9JyNtYWluLW1lbnUnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogVG9nZ2xpbmcgYXJpYS1jb250cm9sIGVsZW1lbnRzOlxuICpcbiAqICAgPGJ1dHRvbiBkYXRhLWpzPSd0b2dnbGUnIGFyaWEtY29udHJvbHM9JyNtYWluLW1lbnUnIGFyaWEtcHJlc3NlZD0nZmFsc2UnPlxuICogICAgICBNZW51XG4gKiAgIDwvYnV0dG9uPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz4gLi4uIDwvZGl2PlxuICpcbiAqIENyZWF0ZSBcIlVuZG9cIiBFdmVudCAodG8gY2xvc2UgYSBkaWFsb2d1ZSk7XG4gKiAgIDxhIGhyZWY9JyNtYWluLW1lbnUnIGRhdGEtanM9J3RvZ2dsZScgZGF0YS10b2dnbGUtdW5kbz0nI2Nsb3NlJz5NZW51PC9hPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAqICAgICA8YSBpZD1cImNsb3NlXCI+Q2xvc2U8L2E+XG4gKiAgIDwvZGl2PlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRvZ2dsZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzIFNldHRpbmdzIGZvciB0aGlzIFRvZ2dsZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHMgPSAoIXMpID8ge30gOiBzO1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICBzZWxlY3RvcjogKHMuc2VsZWN0b3IpID8gcy5zZWxlY3RvciA6IFRvZ2dsZS5zZWxlY3RvcixcbiAgICAgIG5hbWVzcGFjZTogKHMubmFtZXNwYWNlKSA/IHMubmFtZXNwYWNlIDogVG9nZ2xlLm5hbWVzcGFjZSxcbiAgICAgIGluYWN0aXZlQ2xhc3M6IChzLmluYWN0aXZlQ2xhc3MpID8gcy5pbmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmluYWN0aXZlQ2xhc3MsXG4gICAgICBhY3RpdmVDbGFzczogKHMuYWN0aXZlQ2xhc3MpID8gcy5hY3RpdmVDbGFzcyA6IFRvZ2dsZS5hY3RpdmVDbGFzcyxcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGV2ZW50ICBUaGUgbWFpbiBjbGljayBldmVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgY2xhc3NcbiAgICovXG4gIF90b2dnbGUoZXZlbnQpIHtcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IHRhcmdldCA9IGZhbHNlO1xuXG4gICAgLyoqIEFuY2hvciBMaW5rcyAqL1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgOiB0YXJnZXQ7XG5cbiAgICAvKiogVG9nZ2xlIENvbnRyb2xzICovXG4gICAgLy8gY29uc29sZS5kaXIoZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7ZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyl9YCkgOiB0YXJnZXQ7XG5cbiAgICAvKiogTWFpbiBGdW5jdGlvbmFsaXR5ICovXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcblxuICAgIC8qKiBVbmRvICovXG4gICAgaWYgKGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXSkge1xuICAgICAgY29uc3QgdW5kbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXVxuICAgICAgKTtcblxuICAgICAgdW5kby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG4gICAgICAgIHVuZG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIHRvZ2dsaW5nIG1ldGhvZFxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsICAgICBUaGUgY3VycmVudCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmVcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmUvaGlkZGVuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzICE9PSAnJykge1xuICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgZWxlbWVudCBmb3IgZGVmaW5lZCBhcmlhIHJvbGVzIGFuZCB0b2dnbGUgdGhlbSBpZiB0aGV5IGV4aXN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUb2dnbGUuZWxBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS50YXJnZXRBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pKVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0sXG4gICAgICAgICAgISh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcykpXG4gICAge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdG9nZ2xpbmcgZnVuY3Rpb24gdG8gKi9cblRvZ2dsZS5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0b2dnbGVcIl0nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG5hbWVzcGFjZSBmb3Igb3VyIGRhdGEgYXR0cmlidXRlIHNldHRpbmdzICovXG5Ub2dnbGUubmFtZXNwYWNlID0gJ3RvZ2dsZSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgaGlkZSBjbGFzcyAqL1xuVG9nZ2xlLmluYWN0aXZlQ2xhc3MgPSAnaGlkZGVuJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBhY3RpdmUgY2xhc3MgKi9cblRvZ2dsZS5hY3RpdmVDbGFzcyA9ICdhY3RpdmUnO1xuXG4vKiogQHR5cGUge0FycmF5fSBBcmlhIHJvbGVzIHRvIHRvZ2dsZSB0cnVlL2ZhbHNlIG9uIHRoZSB0b2dnbGluZyBlbGVtZW50ICovXG5Ub2dnbGUuZWxBcmlhUm9sZXMgPSBbJ2FyaWEtcHJlc3NlZCcsICdhcmlhLWV4cGFuZGVkJ107XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRhcmdldCBlbGVtZW50ICovXG5Ub2dnbGUudGFyZ2V0QXJpYVJvbGVzID0gWydhcmlhLWhpZGRlbiddO1xuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbGl0eSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL3V0aWxpdHknO1xuXG4vKipcbiAqIFRyYWNraW5nIGJ1cyBmb3IgR29vZ2xlIGFuYWx5dGljcyBhbmQgV2VidHJlbmRzLlxuICovXG5jbGFzcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVHJhY2suc2VsZWN0b3IsXG4gICAgfTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCBrZXkgPSBldmVudC50YXJnZXQuZGF0YXNldC50cmFja0tleTtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuZGF0YXNldC50cmFja0RhdGEpO1xuXG4gICAgICB0aGlzLmNsaWNrKGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB3cmFwcGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIGZpbmFsIGRhdGEgb2JqZWN0XG4gICAqL1xuICBjbGljayhrZXksIGRhdGEpIHtcbiAgICAvLyBTZXQgdGhlIHBhdGggbmFtZSBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgICBjb25zdCBkID0gZGF0YS5tYXAoZWwgPT4ge1xuICAgICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSlcbiAgICAgICAgICBlbFtUcmFjay5rZXldID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfS8ke2VsW1RyYWNrLmtleV19YFxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcblxuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZCk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnKGtleSwgZCk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERhdGEgYnVzIGZvciB0cmFja2luZyB2aWV3cyBpbiBXZWJ0cmVuZHMgYW5kIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgU2luZ2xlIFBhZ2UgQXBwbGljYXRpb24gdG8gdHJhY2tcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHZpZXcoYXBwLCBrZXksIGRhdGEpIHtcbiAgICBsZXQgd3QgPSB0aGlzLndlYnRyZW5kcyhrZXksIGRhdGEpO1xuICAgIGxldCBnYSA9IHRoaXMuZ3RhZ1ZpZXcoYXBwLCBrZXkpO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpXG4gICAgICBjb25zb2xlLmRpcih7J1RyYWNrJzogW3d0LCBnYV19KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBFdmVudHMgdG8gV2VidHJlbmRzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICB3ZWJ0cmVuZHMoa2V5LCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50ID0gW3tcbiAgICAgICdXVC50aSc6IGtleVxuICAgIH1dO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKSB7XG4gICAgICBldmVudC5wdXNoKHtcbiAgICAgICAgJ0RDUy5kY3N1cmknOiBkYXRhWzBdW1RyYWNrLmtleV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgZGF0YSBmb3IgV2VidHJlbmRzXG4gICAgbGV0IHd0ZCA9IHthcmdzYTogZXZlbnQuZmxhdE1hcChlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mbGF0TWFwKGsgPT4gW2ssIGVba11dKTtcbiAgICB9KX07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgV2VidHJlbmRzICE9PSAndW5kZWZpbmVkJylcbiAgICAgIFdlYnRyZW5kcy5tdWx0aVRyYWNrKHd0ZCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ1dlYnRyZW5kcycsIHd0ZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggQ2xpY2sgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIGd0YWcoa2V5LCBkYXRhKSB7XG4gICAgbGV0IHVyaSA9IGRhdGEuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKTtcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgICdldmVudF9jYXRlZ29yeSc6IGtleVxuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgZ3RhZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBndGFnKFRyYWNrLmtleSwgdXJpW1RyYWNrLmtleV0sIGV2ZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIFNjcmVlbiBWaWV3IEV2ZW50cyB0byBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGFwcCAgVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKi9cbiAgZ3RhZ1ZpZXcoYXBwLCBrZXkpIHtcbiAgICBsZXQgdmlldyA9IHtcbiAgICAgIGFwcF9uYW1lOiBhcHAsXG4gICAgICBzY3JlZW5fbmFtZToga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoJ2V2ZW50JywgJ3NjcmVlbl92aWV3Jywgdmlldyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnZ3RhZycsIFRyYWNrLmtleSwgJ3NjcmVlbl92aWV3Jywgdmlld107XG4gIH07XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBzZWxlY3RvciB0byBhZGQgdGhlIHRyYWNraW5nIGZ1bmN0aW9uIHRvICovXG5UcmFjay5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0cmFja1wiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBldmVudCB0cmFja2luZyBrZXkgdG8gbWFwIHRvIFdlYnRyZW5kcyBEQ1MudXJpICovXG5UcmFjay5rZXkgPSAnZXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjazsiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjZcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbmNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IHZhbCA9PiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldXG4gICAgOiB2YWwgPT4gbWFwW3ZhbF1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xuY29uc3QgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IG5vID0gKGEsIGIsIGMpID0+IGZhbHNlO1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5jb25zdCBpZGVudGl0eSA9IChfKSA9PiBfO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZSgoa2V5cywgbSkgPT4ge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgY29uc3QgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIGNvbnN0IGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG5jb25zdCBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxuY29uc3QgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlTGV0dGVycyA9ICdhLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIGNvbnN0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xuY29uc3QgYmFpbFJFID0gbmV3IFJlZ0V4cChgW14ke3VuaWNvZGVMZXR0ZXJzfS4kX1xcXFxkXWApO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSByZXR1cm5cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5jb25zdCBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG5jb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG5jb25zdCB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbmNvbnN0IGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuY29uc3QgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbmNvbnN0IGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5jb25zdCBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuY29uc3QgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxuY29uc3QgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxubGV0IF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGNsYXNzIFNldCAgIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH1cbiAgICBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgd2FybiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICBjb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICBjb25zdCBjbGFzc2lmeSA9IHN0ciA9PiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5cbiAgd2FybiA9IChtc2csIHZtKSA9PiB7XG4gICAgY29uc3QgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtWdWUgd2Fybl06ICR7bXNnfSR7dHJhY2V9YCk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IChtc2csIHZtKSA9PiB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbVnVlIHRpcF06ICR7bXNnfWAgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSAodm0sIGluY2x1ZGVGaWxlKSA9PiB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIGNvbnN0IGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpXG4gICAgKVxuICB9O1xuXG4gIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgcmVzICs9IHN0cjtcbiAgICAgIGlmIChuID4gMSkgc3RyICs9IHN0cjtcbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gdm0gPT4ge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7XG4gICAgICAgICAgaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpXG4gICAgICAgIH0ke1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/IGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pfS4uLiAoJHt2bVsxXX0gcmVjdXJzaXZlIGNhbGxzKWBcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSlcbiAgICAgICAgfWApXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFxcblxcbihmb3VuZCBpbiAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSlgXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG5jbGFzcyBEZXAge1xuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmlkID0gdWlkKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH1cblxuICBhZGRTdWIgKHN1Yikge1xuICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gIH1cblxuICByZW1vdmVTdWIgKHN1Yikge1xuICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gIH1cblxuICBkZXBlbmQgKCkge1xuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnkgKCkge1xuICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbmNvbnN0IHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG5jbGFzcyBWTm9kZSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gICAvLyByZW5kZXJlZCBpbiB0aGlzIGNvbXBvbmVudCdzIHNjb3BlXG4gIFxuICBcbiAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgLy8gY29tcG9uZW50IHBsYWNlaG9sZGVyIG5vZGVcblxuICAvLyBzdHJpY3RseSBpbnRlcm5hbFxuICAgLy8gY29udGFpbnMgcmF3IEhUTUw/IChzZXJ2ZXIgb25seSlcbiAgIC8vIGhvaXN0ZWQgc3RhdGljIG5vZGVcbiAgIC8vIG5lY2Vzc2FyeSBmb3IgZW50ZXIgdHJhbnNpdGlvbiBjaGVja1xuICAgLy8gZW1wdHkgY29tbWVudCBwbGFjZWhvbGRlcj9cbiAgIC8vIGlzIGEgY2xvbmVkIG5vZGU/XG4gICAvLyBpcyBhIHYtb25jZSBub2RlP1xuICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAgXG4gIFxuICBcbiAgIC8vIHJlYWwgY29udGV4dCB2bSBmb3IgZnVuY3Rpb25hbCBub2Rlc1xuICAgLy8gZm9yIFNTUiBjYWNoaW5nXG4gICAvLyB1c2VkIHRvIHN0b3JlIGZ1bmN0aW9uYWwgcmVuZGVyIGNvbnRleHQgZm9yIGRldnRvb2xzXG4gICAvLyBmdW5jdGlvbmFsIHNjb3BlIGlkIHN1cHBvcnRcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgdGV4dCxcbiAgICBlbG0sXG4gICAgY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIGFzeW5jRmFjdG9yeVxuICApIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZWxtID0gZWxtO1xuICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBjaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICBjb25zdCBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbmNvbnN0IG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICBjb25zdCBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfXztcbiAgICBsZXQgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xubGV0IHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICBcbiAgXG4gICAvLyBudW1iZXIgb2Ygdm1zIHRoYXQgaGF2ZSB0aGlzIG9iamVjdCBhcyByb290ICRkYXRhXG5cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICB3YWxrIChvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKi9cbiAgb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICBjb25zdCBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICBjb25zdCBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgbGV0IGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSByZXR1cm5cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yIChsZXQgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbmNvbnN0IHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBvcHRpb24gXCIke2tleX1cIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBgICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvXG4gIGxldCBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICBjb25zdCBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICBjb25zdCByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGhvb2sgPT4ge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5jb25zdCBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoYF5bYS16QS1aXVtcXFxcLVxcXFwuMC05XyR7dW5pY29kZUxldHRlcnN9XSokYCkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgbGV0IGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwicHJvcHNcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHByb3BzKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHJldHVyblxuICBjb25zdCBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3QpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcImluamVjdFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUoaW5qZWN0KX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgY29uc3QgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkaXJzKSB7XG4gICAgICBjb25zdCBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcIiR7bmFtZX1cIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHZhbHVlKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge307XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICBjb25zdCBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHJldHVybiBhc3NldHNbaWRdXG4gIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXVxuICBjb25zdCBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgY29uc3QgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIGxldCB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICBjb25zdCBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHR5cGUgPSBwcm9wLnR5cGU7XG4gIGxldCB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIGNvbnN0IG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJyl9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICBsZXQgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSByZXR1cm5cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKGBFcnJvciBpbiAke2luZm99OiBcIiR7ZXJyLnRvU3RyaW5nKCl9XCJgLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xubGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIGNvbnN0IGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG5sZXQgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHNldFRpbWVvdXQobm9vcCk7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICBsZXQgY291bnRlciA9IDE7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIGxldCBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBtYXJrO1xubGV0IG1lYXN1cmU7XG5cbntcbiAgY29uc3QgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gdGFnID0+IHBlcmYubWFyayh0YWcpO1xuICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxubGV0IGluaXRQcm94eTtcblxue1xuICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgb3IgbWV0aG9kIFwiJHtrZXl9XCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBgICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYFByb3BlcnR5IFwiJHtrZXl9XCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFwiJGRhdGEuJHtrZXl9XCIgYmVjYXVzZSBgICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgY29uc3QgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKGBBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC4ke2tleX1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIGxldCBpLCBrZXlzO1xuICBjb25zdCBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIGNvbnN0IGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBub3JtYWxpemVFdmVudCA9IGNhY2hlZCgobmFtZSkgPT4ge1xuICBjb25zdCBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3Qgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmUsXG4gICAgcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIGNvbnN0IGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYClcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIGxldCBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcIiR7ZXZlbnQubmFtZX1cIjogZ290IGAgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICBsZXQgaW52b2tlcjtcbiAgY29uc3Qgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICBjb25zdCBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IHsgYXR0cnMsIHByb3BzIH0gPSBkYXRhO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBjb25zdCBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBgUHJvcCBcIiR7a2V5SW5Mb3dlckNhc2V9XCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpfSwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNgICtcbiAgICAgICAgICAgIGAgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBgICtcbiAgICAgICAgICAgIGBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIGAgK1xuICAgICAgICAgICAgYHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2FsdEtleX1cIiBpbnN0ZWFkIG9mIFwiJHtrZXl9XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgY29udGludWVcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsIGAke25lc3RlZEluZGV4IHx8ICcnfV8ke2l9YCk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IGBfX3ZsaXN0JHtuZXN0ZWRJbmRleH1fJHtpfV9fYDtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIGNvbnN0IHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgKCkgPT4ge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgYGluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgY29udGludWVcbiAgICAgIGNvbnN0IHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgbGV0IHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihgSW5qZWN0aW9uIFwiJHtrZXl9XCIgbm90IGZvdW5kYCwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICBjb25zdCBzbG90cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3QgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICBjb25zdCBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIGxldCByZXM7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIHNsb3RzLiRzdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleV0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6IHRydWUpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gKCkgPT4gc2xvdHNba2V5XVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICBsZXQgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGxldCBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIGNvbnN0IHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIGNvbnN0IG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBsZXQgaGFzaDtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtjYW1lbGl6ZWRLZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIGxldCB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX29uY2VfXyR7aW5kZXh9JHtrZXkgPyBgXyR7a2V5fWAgOiBgYH1gLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBgJHtrZXl9XyR7aX1gLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgY29uc3Qgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICBoYXNEeW5hbWljS2V5cyxcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIGhhc0R5bmFtaWNLZXlzLCByZXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6ICR7a2V5fWAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICBsZXQgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICBjb25zdCBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgY29uc3QgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiB7XG4gICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XG4gIH1cblxuICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICBjb25zdCB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIGNvbnN0IGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuY29uc3QgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICBjb25zdCBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydCAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveSAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybihgSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogJHtTdHJpbmcoQ3Rvcil9YCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGxldCBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIGNvbnN0IGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICBjb25zdCBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIGNvbnN0IG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIGB2dWUtY29tcG9uZW50LSR7Q3Rvci5jaWR9JHtuYW1lID8gYC0ke25hbWV9YCA6ICcnfWAsXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3IsIHByb3BzRGF0YSwgbGlzdGVuZXJzLCB0YWcsIGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIGNvbnN0IGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICBjb25zdCB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIGNvbnN0IG1lcmdlZCA9IChhLCBiKSA9PiB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICBjb25zdCBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICBjb25zdCBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBTSU1QTEVfTk9STUFMSVpFID0gMTtcbmNvbnN0IEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICBsZXQgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgYXBwbHlOUyh2bm9kZSwgbnMpO1xuICAgIGlmIChpc0RlZihkYXRhKSkgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIGNvbnN0IHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgY29uc3QgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgeyByZW5kZXIsIF9wYXJlbnRWbm9kZSB9ID0gdm0uJG9wdGlvbnM7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICBsZXQgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlcmApO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyRXJyb3JgKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGNvbnN0IG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIGxldCBzeW5jID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0gKHJlbmRlckNvbXBsZXRlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXNvbHZlID0gb25jZSgocmVzKSA9PiB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVqZWN0ID0gb25jZShyZWFzb24gPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJHtTdHJpbmcoZmFjdG9yeSl9YCArXG4gICAgICAgIChyZWFzb24gPyBgXFxuUmVhc29uOiAke3JlYXNvbn1gIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBgdGltZW91dCAoJHtyZXMudGltZW91dH1tcylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICBjb25zdCBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbmxldCB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgY29uc3QgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIGNvbnN0IGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgbGV0IGNiO1xuICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xuICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgY29uc3QgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIGxldCBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHByZXZFbCA9IHZtLiRlbDtcbiAgICBjb25zdCBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgY29uc3QgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgbGV0IGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgY29uc3QgaWQgPSB2bS5fdWlkO1xuICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHtpZH1gO1xuICAgICAgY29uc3QgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke2lkfWA7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcGF0Y2hgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzICYmICFwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIXZtLiRzY29wZWRTbG90cy4kc3RhYmxlKVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICBjb25zdCBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBjb25zdCBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIGNvbnN0IHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgY29uc3Qgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgY29uc3QgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuY29uc3QgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbmxldCBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbmlmIChpbkJyb3dzZXIgJiYgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcbiAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcbiAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXG4gIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgbGV0IHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IGBpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYFxuICAgICAgICAgICAgICA6IGBpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uYFxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgY29uc3QgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICBjb25zdCB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgbGV0IGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgY29uc3Qgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIGNvbnN0IGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxubGV0IHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXCIke2V4cE9yRm59XCIgYCArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICBwdXNoVGFyZ2V0KHRoaXMpO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGFkZERlcCAoZGVwKSB7XG4gICAgY29uc3QgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgY2xlYW51cERlcHMgKCkge1xuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0bXAgPSB0aGlzLmRlcElkcztcbiAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgdG1wID0gdGhpcy5kZXBzO1xuICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICB0aGlzLmRlZXBcbiAgICAgICkge1xuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIGBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgZXZhbHVhdGUgKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIGRlcGVuZCAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7XG4gIGlmIChvcHRzLm1ldGhvZHMpIGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpO1xuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTtcbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICBjb25zdCBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICBjb25zdCBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIGNvbnN0IGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFwiJHtoeXBoZW5hdGVkS2V5fVwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgYCArXG4gICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIGAgK1xuICAgICAgICAgICAgYHZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgbGV0IGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGNvbnN0IG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIGAgK1xuICAgICAgICBgVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLmAsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5jb25zdCBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBjb25zdCB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgY29uc3QgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgY29uc3QgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgY29uc3QgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIGNvbnN0IHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kc1trZXldfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gYCArXG4gICAgICAgICAgYEF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHdhdGNoKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgY29uc3QgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgY29uc3QgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oYCRwcm9wcyBpcyByZWFkb25seS5gLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCBgY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICBsZXQgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke3ZtLl9uYW1lfSBpbml0YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIGNvbnN0IHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICBjb25zdCBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG1vZGlmaWVkO1xuICBjb25zdCBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgbW9kaWZpZWQgPSB7fTtcbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICBsZXQgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICBjb25zdCBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICBjb25zdCBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgYF9wcm9wc2AsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgY29uc3QgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUgfSA9IGtlZXBBbGl2ZUluc3RhbmNlO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIGNvbnN0IGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxuY29uc3QgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+ICFtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgY29uc3Qgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSB9ID0gdGhpcztcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBjYWNoZSwga2V5cyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gYDo6JHtjb21wb25lbnRPcHRpb25zLnRhZ31gIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgY29uc3QgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gIHtcbiAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2FybixcbiAgICBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IChvYmopID0+IHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjYnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuY29uc3QgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG5jb25zdCBtdXN0VXNlUHJvcCA9ICh0YWcsIHR5cGUsIGF0dHIpID0+IHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG5jb25zdCBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbmNvbnN0IGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuY29uc3QgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxuY29uc3QgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbmNvbnN0IGlzWGxpbmsgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG5jb25zdCBnZXRYbGlua1Byb3AgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbmNvbnN0IGlzRmFsc3lBdHRyVmFsdWUgPSAodmFsKSA9PiB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgbGV0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IHN0cmluZ2lmaWVkO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxuY29uc3QgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5jb25zdCBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5jb25zdCBpc1ByZVRhZyA9ICh0YWcpID0+IHRhZyA9PT0gJ3ByZSc7XG5cbmNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSAodGFnKSA9PiB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG5jb25zdCB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuY29uc3QgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgY29uc3Qga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgcmV0dXJuXG5cbiAgY29uc3Qgdm0gPSB2bm9kZS5jb250ZXh0O1xuICBjb25zdCByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuY29uc3QgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgcmV0dXJuIHRydWVcbiAgbGV0IGk7XG4gIGNvbnN0IHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgY29uc3QgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgbGV0IGksIGtleTtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIGxldCBpLCBqO1xuICBjb25zdCBjYnMgPSB7fTtcblxuICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICBsZXQgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgY29uc3QgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgbGV0IGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIGxldCBpLCBqO1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY29uc3QgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGxldCBvbGRTdGFydElkeCA9IDA7XG4gICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICBjb25zdCBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICcke2tleX0nLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuYCxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIGNvbnN0IGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgdGFnLCBkYXRhLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBsZXQgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIGNvbnN0IHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICBjb25zdCBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIGNvbnN0IGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICBjb25zdCBkaXJzV2l0aEluc2VydCA9IFtdO1xuICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIGxldCBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICBjb25zdCBjYWxsSW5zZXJ0ID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICBsZXQgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCBgJHtkaXIubmFtZX0uJHtPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJyl9YFxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCBgZGlyZWN0aXZlICR7ZGlyLm5hbWV9ICR7aG9va30gaG9va2ApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1ciwgb2xkO1xuICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgbGV0IGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIGNvbnN0IGJsb2NrZXIgPSBlID0+IHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgbGV0IGluU2luZ2xlID0gZmFsc2U7XG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICBsZXQgaW5SZWdleCA9IGZhbHNlO1xuICBsZXQgY3VybHkgPSAwO1xuICBsZXQgc3F1YXJlID0gMDtcbiAgbGV0IHBhcmVuID0gMDtcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSBpblJlZ2V4ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gYF9mKFwiJHtuYW1lfVwiKSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWBcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKGBbVnVlIGNvbXBpbGVyXTogJHttc2d9YCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAobSA9PiBtW2tleV0pLmZpbHRlcihfID0+IF8pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYFxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gYCgke25hbWV9KT09PSdjbGljayc/J2NvbnRleHRtZW51JzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICBsZXQgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgY29uc3QgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICBjb25zdCBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIGxldCB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuXG4gIGNvbnN0IGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIGAodHlwZW9mICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0gPT09ICdzdHJpbmcnYCArXG4gICAgICBgPyAke2Jhc2VWYWx1ZUV4cHJlc3Npb259LnRyaW0oKWAgK1xuICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgX24oJHt2YWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiBgKCR7dmFsdWV9KWAsXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIGNvbnN0IHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt2YWx1ZX09JHthc3NpZ25tZW50fWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCRzZXQoJHtyZXMuZXhwfSwgJHtyZXMua2V5fSwgJHthc3NpZ25tZW50fSlgXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICBsZXQgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIGluQnJhY2tldCsrO1xuICAgIGlmIChjaHIgPT09IDB4NUQpIGluQnJhY2tldC0tO1xuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICBjb25zdCBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmxldCB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG5jb25zdCBSQU5HRV9UT0tFTiA9ICdfX3InO1xuY29uc3QgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICBjb25zdCB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgY29uc3QgdGFnID0gZWwudGFnO1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgYEZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgd2FybiQxKFxuICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgIGB2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIGAgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBjb25zdCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICBjb25zdCBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgYEFycmF5LmlzQXJyYXkoJHt2YWx1ZX0pYCArXG4gICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IGA6KCR7dmFsdWV9KWBcbiAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYFxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgYHZhciAkJGE9JHt2YWx1ZX0sYCArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIGAkJGM9JCRlbC5jaGVja2VkPygke3RydWVWYWx1ZUJpbmRpbmd9KTooJHtmYWxzZVZhbHVlQmluZGluZ30pO2AgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgYHZhciAkJHY9JHtudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZ30sYCArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIGBpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJyl9KX1gICtcbiAgICAgIGBlbHNleyQkaT4tMSYmKCR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpfSl9YCArXG4gICAgYH1lbHNleyR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKX19YCxcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gYF9uKCR7dmFsdWVCaW5kaW5nfSlgIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIGBfcSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pYCk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHNlbGVjdGVkVmFsID0gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgICtcbiAgICBgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlgICtcbiAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgIGByZXR1cm4gJHtudW1iZXIgPyAnX24odmFsKScgOiAndmFsJ319KWA7XG5cbiAgY29uc3QgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gIGNvZGUgPSBgJHtjb2RlfSAke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KX1gO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICBjb25zdCBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIGNvbnN0IGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGAkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuXG4gIGxldCBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBgaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuOyR7Y29kZX1gO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgYCgke3ZhbHVlfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG5sZXQgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbmNvbnN0IHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICBjb25zdCBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vICM5NDYyIGJhaWwgZm9yIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgZS50aW1lU3RhbXAgPT09IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlLCBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5sZXQgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQga2V5LCBjdXI7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICBsZXQgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSBjb250aW51ZVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAvLyB0aGUgb25seSBleGNlcHRpb24gaXMgYHZhbHVlYCB3aGVyZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgLy8gVGhpcyBhbHNvIGNvdmVycyAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmIGN1ciA9PT0gb2xkUHJvcHNba2V5XSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgY29uc3Qgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxzdmc+JHtjdXJ9PC9zdmc+YDtcbiAgICAgIGNvbnN0IHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgbGV0IG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgY29uc3QgdmFsdWUgPSBlbG0udmFsdWU7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBjb25zdCBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgY29uc3Qgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmNvbnN0IGNzc1ZhclJFID0gL14tLS87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuY29uc3Qgc2V0UHJvcCA9IChlbCwgbmFtZSwgdmFsKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG5sZXQgZW1wdHlTdHlsZTtcbmNvbnN0IG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGN1ciwgbmFtZTtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgY29uc3Qgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICBjb25zdCBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgY29uc3QgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgZW50ZXJUb0NsYXNzOiBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgbGVhdmVUb0NsYXNzOiBgJHtuYW1lfS1sZWF2ZS10b2AsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogYCR7bmFtZX0tbGVhdmUtYWN0aXZlYFxuICB9XG59KTtcblxuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmxldCB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbmxldCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xubGV0IGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5jb25zdCByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuID0+IGZuKCk7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKCgpID0+IHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkgcmV0dXJuIGNiKClcbiAgY29uc3QgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4ge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGVudGVyQ2xhc3MsXG4gICAgZW50ZXJUb0NsYXNzLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVFbnRlcixcbiAgICBlbnRlcixcbiAgICBhZnRlckVudGVyLFxuICAgIGVudGVyQ2FuY2VsbGVkLFxuICAgIGJlZm9yZUFwcGVhcixcbiAgICBhcHBlYXIsXG4gICAgYWZ0ZXJBcHBlYXIsXG4gICAgYXBwZWFyQ2FuY2VsbGVkLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICBsZXQgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICBsZXQgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICBjb25zdCB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIGNvbnN0IGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIGNvbnN0IGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgY29uc3QgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICBjb25zdCBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIGNvbnN0IGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGxlYXZlQ2xhc3MsXG4gICAgbGVhdmVUb0NsYXNzLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MsXG4gICAgYmVmb3JlTGVhdmUsXG4gICAgbGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZSxcbiAgICBsZWF2ZUNhbmNlbGxlZCxcbiAgICBkZWxheUxlYXZlLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIGNvbnN0IGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5jb25zdCBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbmNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHMsIG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICBjb25zdCBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIGNvbnN0IGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKChvLCBpKSA9PiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSkpKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIGNvbnN0IG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUodiA9PiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpKVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCIke2JpbmRpbmcuZXhwcmVzc2lvbn1cIj4gYCArXG4gICAgICBgZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbiAgICAgIH1gLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShvID0+ICFsb29zZUVxdWFsKG8sIHZhbHVlKSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHJldHVyblxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQgKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGUgKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3dcbn07XG5cbi8qICAqL1xuXG5jb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIGNvbnN0IGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIGNvbnN0IGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuY29uc3QgaXNOb3RUZXh0Tm9kZSA9IChjKSA9PiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7XG5cbmNvbnN0IGlzVlNob3dEaXJlY3RpdmUgPSBkID0+IGQubmFtZSA9PT0gJ3Nob3cnO1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXIgKGgpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIGNvbnN0IGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICBjb25zdCBpZCA9IGBfX3RyYW5zaXRpb24tJHt0aGlzLl91aWR9LWA7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgY29uc3QgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIGNvbnN0IG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4geyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wcyxcblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9ICh2bm9kZSwgaHlkcmF0aW5nKSA9PiB7XG4gICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgICB0aGlzLl92bm9kZSxcbiAgICAgICAgdGhpcy5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPCR7bmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBrZXB0ID0gW107XG4gICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYy5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgY29uc3QgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsbTtcbiAgICAgICAgY29uc3QgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgY29uc3QgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICBjb25zdCBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICBjb25zdCBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgY29uc3QgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIGBZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuYCArXG4gICAgICAgIGBNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuYCArXG4gICAgICAgIGBTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbGBcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmNvbnN0IGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuY29uc3QgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbmNvbnN0IGJ1aWxkUmVnZXggPSBjYWNoZWQoZGVsaW1pdGVycyA9PiB7XG4gIGNvbnN0IG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICBjb25zdCBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICBjb25zdCB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcmF3VG9rZW5zID0gW107XG4gIGxldCBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICBsZXQgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBjb25zdCBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaChgX3MoJHtleHB9KWApO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBjbGFzcz1cIiR7c3RhdGljQ2xhc3N9XCI6IGAgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgY29uc3QgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBgc3RhdGljQ2xhc3M6JHtlbC5zdGF0aWNDbGFzc30sYDtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgY2xhc3M6JHtlbC5jbGFzc0JpbmRpbmd9LGA7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBzdHlsZT1cIiR7c3RhdGljU3R5bGV9XCI6IGAgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBgc3RhdGljU3R5bGU6JHtlbC5zdGF0aWNTdHlsZX0sYDtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgc3R5bGU6KCR7ZWwuc3R5bGVCaW5kaW5nfSksYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmxldCBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5jb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbmNvbnN0IGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5jb25zdCBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBuY25hbWUgPSBgW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHt1bmljb2RlTGV0dGVyc31dKmA7XG5jb25zdCBxbmFtZUNhcHR1cmUgPSBgKCg/OiR7bmNuYW1lfVxcXFw6KT8ke25jbmFtZX0pYDtcbmNvbnN0IHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoYF48JHtxbmFtZUNhcHR1cmV9YCk7XG5jb25zdCBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5jb25zdCBlbmRUYWcgPSBuZXcgUmVnRXhwKGBePFxcXFwvJHtxbmFtZUNhcHR1cmV9W14+XSo+YCk7XG5jb25zdCBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG5jb25zdCBjb21tZW50ID0gL148IVxcLS0vO1xuY29uc3QgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuY29uc3QgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCByZUNhY2hlID0ge307XG5cbmNvbnN0IGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbmNvbnN0IGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xuY29uc3QgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxuY29uc3QgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSAodGFnLCBodG1sKSA9PiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICBjb25zdCByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIG1hdGNoID0+IGRlY29kaW5nTWFwW21hdGNoXSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIGNvbnN0IGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIGNvbnN0IGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIGxldCB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICBjb25zdCBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgY29uc3QgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0LCByZXN0LCBuZXh0O1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSBicmVha1xuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgY29uc3Qgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgY29uc3QgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oYE1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXCIke2h0bWx9XCJgLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICBjb25zdCBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICBsZXQgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIGNvbnN0IHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgY29uc3QgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSBpbmRleDtcbiAgICBpZiAoZW5kID09IG51bGwpIGVuZCA9IGluZGV4O1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKGkgPiBwb3MgfHwgIXRhZ05hbWUgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgb25SRSA9IC9eQHxedi1vbjovO1xuY29uc3QgZGlyUkUgPSAvXnYtfF5AfF46LztcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmNvbnN0IGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxuY29uc3Qgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbmNvbnN0IGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbmNvbnN0IHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxuY29uc3QgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxuY29uc3QgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbmxldCB3YXJuJDI7XG5sZXQgZGVsaW1pdGVycztcbmxldCB0cmFuc2Zvcm1zO1xubGV0IHByZVRyYW5zZm9ybXM7XG5sZXQgcG9zdFRyYW5zZm9ybXM7XG5sZXQgcGxhdGZvcm1Jc1ByZVRhZztcbmxldCBwbGF0Zm9ybU11c3RVc2VQcm9wO1xubGV0IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xubGV0IG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gKGVsKSA9PiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgY29uc3Qgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBjdXJyZW50UGFyZW50O1xuICBsZXQgaW5WUHJlID0gZmFsc2U7XG4gIGxldCBpblByZSA9IGZhbHNlO1xuICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgYCArXG4gICAgICAgICAgYHVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLmAsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGMgPT4gIShjKS5zbG90U2NvcGUpO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihgW2ApLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIGA8JHt0YWd9PmAgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQgKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgdGV4dCBcIiR7dGV4dH1cIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIGNvbnN0IGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLmAsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIGAgK1xuICAgICAgICAgICAgYHRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuYCxcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIGNvbnN0IHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICBsZXQgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246ICR7ZXhwfWAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBjb25zdCBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDIoXG4gICAgICBgdi0ke2VsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJ30gYCArXG4gICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgYHRleHQgXCIke2NoaWxkcmVuW2ldLnRleHQudHJpbSgpfVwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgYCArXG4gICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgY29uc3Qgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIGxldCBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgYHJlcGxhY2VkIGJ5IFwic2xvdC1zY29wZVwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcInNsb3Qtc2NvcGVcIiBhdHRyaWJ1dGUgYCArXG4gICAgICAgIGBjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gYCArXG4gICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgYCh2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBgICtcbiAgICAgICAgYHNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgY29uc3Qgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICBgdGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50YCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZHluYW1pYyB9ID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIGNvbnN0IHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5gLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIGAgK1xuICAgICAgICAgICAgICBgPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGNvbnN0IHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgbGV0IG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBcXGBrZXlcXGAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBgICtcbiAgICAgICAgYGFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIGAgK1xuICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCxcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgbGV0IGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGxldCBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXCJ2LWJpbmQ6JHtuYW1lfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBgJGV2ZW50YCk7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtjYW1lbGl6ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6XCIrKCR7bmFtZX0pYCxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgY29uc3QgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICBsZXQgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2gobSA9PiB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbmNvbnN0IGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG5jb25zdCBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIGxldCBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgYFlvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBgICtcbiAgICAgICAgYFRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIGAgK1xuICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgIGBDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgY29uc3QgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGAoJHttYXBbJ3YtYmluZCddfSkudHlwZWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyBgJiYoJHtpZkNvbmRpdGlvbn0pYCA6IGBgO1xuICAgICAgY29uc3QgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgY29uc3QgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIGNvbnN0IGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IGAoJHt0eXBlQmluZGluZ30pPT09J2NoZWNrYm94J2AgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgY29uc3QgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYCgke3R5cGVCaW5kaW5nfSk9PT0ncmFkaW8nYCArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsLFxuICB0ZXh0LFxuICBodG1sXG59O1xuXG4vKiAgKi9cblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxubGV0IGlzU3RhdGljS2V5O1xubGV0IGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHJldHVyblxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG5jb25zdCBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG5jb25zdCBnZW5HdWFyZCA9IGNvbmRpdGlvbiA9PiBgaWYoJHtjb25kaXRpb259KXJldHVybiBudWxsO2A7XG5cbmNvbnN0IG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoYCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0YCksXG4gIGN0cmw6IGdlbkd1YXJkKGAhJGV2ZW50LmN0cmxLZXlgKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gIGFsdDogZ2VuR3VhcmQoYCEkZXZlbnQuYWx0S2V5YCksXG4gIG1ldGE6IGdlbkd1YXJkKGAhJGV2ZW50Lm1ldGFLZXlgKSxcbiAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gIG1pZGRsZTogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxYCksXG4gIHJpZ2h0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJgKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICBsZXQgc3RhdGljSGFuZGxlcnMgPSBgYDtcbiAgbGV0IGR5bmFtaWNIYW5kbGVycyA9IGBgO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgY29uc3QgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IGBcIiR7bmFtZX1cIjoke2hhbmRsZXJDb2RlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGBbJHtoYW5kbGVyLm1hcChoYW5kbGVyID0+IGdlbkhhbmRsZXIoaGFuZGxlcikpLmpvaW4oJywnKX1dYFxuICB9XG5cbiAgY29uc3QgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICBjb25zdCBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtcbiAgICAgIGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9YCA6IGhhbmRsZXIudmFsdWVcbiAgICB9fWAgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIGxldCBjb2RlID0gJyc7XG4gICAgbGV0IGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAubWFwKGtleU1vZGlmaWVyID0+IGAkZXZlbnQuJHtrZXlNb2RpZmllcn1LZXlgKVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX0oJGV2ZW50KWBcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KSgkZXZlbnQpYFxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske2NvZGV9JHtoYW5kbGVyQ29kZX19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBgaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZgICtcbiAgICBgJHtrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpfSlyZXR1cm4gbnVsbDtgXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIGNvbnN0IGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIGAkZXZlbnQua2V5Q29kZSE9PSR7a2V5VmFsfWBcbiAgfVxuICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgY29uc3Qga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgYF9rKCRldmVudC5rZXlDb2RlLGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleSl9LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICBgJGV2ZW50LmtleSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXlOYW1lKX1gICtcbiAgICBgKWBcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IChjb2RlKSA9PiBgX2coJHtjb2RlfSwke2Rpci52YWx1ZX0pYDtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IChjb2RlKSA9PiB7XG4gICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke1xuICAgICAgZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgfSR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJ1xuICAgIH0pYFxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxuY2xhc3MgQ29kZWdlblN0YXRlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICBjb25zdCBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIHRoaXMubWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG4gICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gICAgdGhpcy5wcmUgPSBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIGNvbnN0IGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IGB3aXRoKHRoaXMpe3JldHVybiAke2NvZGV9fWAsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIGxldCBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IGBfYygnJHtlbC50YWd9JyR7XG4gICAgICAgIGRhdGEgPyBgLCR7ZGF0YX1gIDogJycgLy8gZGF0YVxuICAgICAgfSR7XG4gICAgICAgIGNoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgfSlgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goYHdpdGgodGhpcyl7cmV0dXJuICR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfX1gKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIGBfbSgke1xuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxXG4gIH0ke1xuICAgIGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnXG4gIH0pYFxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICBsZXQga2V5ID0gJyc7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgIGB2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIGNvbnN0IGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5leHB9KT8ke1xuICAgICAgZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spXG4gICAgfToke1xuICAgICAgZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICAgIH1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2dlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKX1gXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgY29uc3QgYWxpYXMgPSBlbC5hbGlhcztcbiAgY29uc3QgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gYCwke2VsLml0ZXJhdG9yMX1gIDogJyc7XG4gIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuXG4gIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIGA8JHtlbC50YWd9IHYtZm9yPVwiJHthbGlhc30gaW4gJHtleHB9XCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBgICtcbiAgICAgIGB2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBgICtcbiAgICAgIGBTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gYCR7YWx0SGVscGVyIHx8ICdfbCd9KCgke2V4cH0pLGAgK1xuICAgIGBmdW5jdGlvbigke2FsaWFzfSR7aXRlcmF0b3IxfSR7aXRlcmF0b3IyfSl7YCArXG4gICAgICBgcmV0dXJuICR7KGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfWAgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgbGV0IGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgY29uc3QgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIGRhdGEgKz0gZGlycyArICcsJztcblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gYGtleToke2VsLmtleX0sYDtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gYHJlZjoke2VsLnJlZn0sYDtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IGByZWZJbkZvcjp0cnVlLGA7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IGBwcmU6dHJ1ZSxgO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IGBhdHRyczoke2dlblByb3BzKGVsLmF0dHJzKX0sYDtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSl9LGA7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKX0sYDtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IGBtb2RlbDp7dmFsdWU6JHtcbiAgICAgIGVsLm1vZGVsLnZhbHVlXG4gICAgfSxjYWxsYmFjazoke1xuICAgICAgZWwubW9kZWwuY2FsbGJhY2tcbiAgICB9LGV4cHJlc3Npb246JHtcbiAgICAgIGVsLm1vZGVsLmV4cHJlc3Npb25cbiAgICB9fSxgO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGAke2lubGluZVRlbXBsYXRlfSxgO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgcmV0dXJuXG4gIGxldCByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgbGV0IGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIGNvbnN0IGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IGB7bmFtZTpcIiR7ZGlyLm5hbWV9XCIscmF3TmFtZTpcIiR7ZGlyLnJhd05hbWV9XCIke1xuICAgICAgICBkaXIudmFsdWUgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5hcmcgPyBgLGFyZzoke2Rpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogYFwiJHtkaXIuYXJnfVwiYH1gIDogJydcbiAgICAgIH0ke1xuICAgICAgICBkaXIubW9kaWZpZXJzID8gYCxtb2RpZmllcnM6JHtKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKX1gIDogJydcbiAgICAgIH19LGA7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIGBpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7JHtcbiAgICAgIGlubGluZVJlbmRlckZucy5yZW5kZXJcbiAgICB9fSxzdGF0aWNSZW5kZXJGbnM6WyR7XG4gICAgICBpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IGBmdW5jdGlvbigpeyR7Y29kZX19YCkuam9pbignLCcpXG4gICAgfV19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgbGV0IG5lZWRzRm9yY2VVcGRhdGUgPSBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgIGNvbnN0IHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90ICh0aGUgcmVhY3Rpdml0eSBpcyBkaXNjb25uZWN0ZWQpXG4gIC8vICM5NDM4XG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBzY29wZWRTbG90czpfdShbJHtcbiAgICBPYmplY3Qua2V5cyhzbG90cykubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJylcbiAgfV0ke25lZWRzRm9yY2VVcGRhdGUgPyBgLHRydWVgIDogYGB9KWBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgY29uc3Qgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBgYFxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgYHJldHVybiAke2VsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfX1gO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgcmV0dXJuIGB7a2V5OiR7ZWwuc2xvdFRhcmdldCB8fCBgXCJkZWZhdWx0XCJgfSxmbjoke2ZufSR7cmV2ZXJzZVByb3h5fX1gXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbC5mb3IgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpID8gYCwxYCA6IGAsMGBcbiAgICAgICAgOiBgYDtcbiAgICAgIHJldHVybiBgJHsoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfSR7bm9ybWFsaXphdGlvblR5cGV9YFxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiBgWyR7Y2hpbGRyZW4ubWFwKGMgPT4gZ2VuKGMsIHN0YXRlKSkuam9pbignLCcpfV0ke1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPyBgLCR7bm9ybWFsaXphdGlvblR5cGV9YCA6ICcnXG4gICAgfWBcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoYyA9PiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gYF92KCR7dGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIGNvbnN0IGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgbGV0IHJlcyA9IGBfdCgke3Nsb3ROYW1lfSR7Y2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnfWA7XG4gIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChhdHRyID0+ICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KSkpXG4gICAgOiBudWxsO1xuICBjb25zdCBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBgLG51bGxgO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBgLCR7YXR0cnN9YDtcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kJCQxfWA7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEkMihlbCwgc3RhdGUpfSR7XG4gICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gIGxldCBkeW5hbWljUHJvcHMgPSBgYDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gYCR7cHJvcC5uYW1lfSwke3ZhbHVlfSxgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBgXCIke3Byb3AubmFtZX1cIjoke3ZhbHVlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IGB7JHtzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gYF9kKCR7c3RhdGljUHJvcHN9LFske2R5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCBgdi1mb3I9XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNvbnN0IHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIGNvbnN0IGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiIGluIGV4cHJlc3Npb24gJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBpbnZhbGlkICR7dHlwZX0gXCIke2lkZW50fVwiIGluIGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oYHJldHVybiAke2V4cH1gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBpbnZhbGlkIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICBgICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1cXG5gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0ID0gMCxcbiAgZW5kID0gc291cmNlLmxlbmd0aFxuKSB7XG4gIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZVxuICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGAgYCwgcGFkKSArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgbikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gICAgbiA+Pj49IDE7XG4gICAgaWYgKG4gPD0gMCkgYnJlYWtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVyciwgY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIGNvbnN0IGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke3RlbXBsYXRlfVxcblxcbmAgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChlID0+IGAtICR7ZX1gKS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2gobXNnID0+IHRpcChtc2csIHZtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYCkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdGlwcyA9IFtdO1xuXG4gICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgY29uc3QgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5sZXQgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBgPGEgaHJlZj1cIlxcblwiLz5gIDogYDxkaXYgYT1cIlxcblwiLz5gO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gIGNvbnN0IGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2FybihcbiAgICAgIGBEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoYHZ1ZSAke3RoaXMuX25hbWV9IGNvbXBpbGVgLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHNlbGVjdCBjbGFzcz0nc2VsZWN0JyB2LW1vZGVsPSdzZWxlY3RlZCcgQGlucHV0PSdldmVudCA9PiB7ICRlbWl0KFwiaW5wdXRcIiwgZXZlbnQudGFyZ2V0LnZhbHVlKSB9Jz5cbiAgICAgIDxvcHRpb24gdi1mb3I9J29wdGlvbiBpbiBvcHRpb25zJyA6a2V5PSdvcHRpb24udmFsdWUnIDp2YWx1ZT0nb3B0aW9uLnZhbHVlJz5cbiAgICAgICAge3sgb3B0aW9uLnRleHQgfX1cbiAgICAgIDwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnb3B0aW9ucycsICd2YWx1ZSddLFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZDogbnVsbCxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTZWxlY3REYXRhID0gW1xuICB7IHRleHQ6ICdBbGwgQm9yb3VnaHMnLCB2YWx1ZTogJ2FsbCcgfSxcbiAgeyB0ZXh0OiAnQnJvb2tseW4nLCB2YWx1ZTogJ2Jyb29rbHluJyB9LFxuICB7IHRleHQ6ICdRdWVlbnMnLCB2YWx1ZTogJ3F1ZWVucycgfSxcbiAgeyB0ZXh0OiAnTWFuaGF0dGFuJywgdmFsdWU6ICdtYW5oYXR0YW4nIH0sXG4gIHsgdGV4dDogJ1N0YXRlbiBJc2xhbmQnLCB2YWx1ZTogJ3N0YXRlbiBpc2xhbmQnIH0sXG4gIHsgdGV4dDogJ1RoZSBCcm9ueCcsIHZhbHVlOiAnYnJvbngnIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7IC8vXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4vc2VsZWN0LnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBTZWxlY3REYXRhIGZyb20gJy4vc2VsZWN0LmRhdGEuanMnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY2xhc3MgU2VsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLXNlbGVjdCcsIFNlbGVjdENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJhcHBcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IFNlbGVjdC5kYXRhLFxuICAgICAgICAgIHNlbGVjdGVkOiAnYWxsJyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5TZWxlY3QuZGF0YSA9IFNlbGVjdERhdGE7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDsiLCJmdW5jdGlvbiBkYXRhSGFuZGxlcihuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGlmIChvbGREYXRhKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy4kZGF0YS5fY2hhcnQ7XG4gICAgdmFyIG5ld0RhdGFzZXRMYWJlbHMgPSBuZXdEYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZERhdGFzZXRMYWJlbHMgPSBvbGREYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZExhYmVscyA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGFzZXRMYWJlbHMpO1xuICAgIHZhciBuZXdMYWJlbHMgPSBKU09OLnN0cmluZ2lmeShuZXdEYXRhc2V0TGFiZWxzKTtcblxuICAgIGlmIChuZXdMYWJlbHMgPT09IG9sZExhYmVscyAmJiBvbGREYXRhLmRhdGFzZXRzLmxlbmd0aCA9PT0gbmV3RGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIG5ld0RhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCwgaSkge1xuICAgICAgICB2YXIgb2xkRGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhLmRhdGFzZXRzW2ldKTtcbiAgICAgICAgdmFyIG5ld0RhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoZGF0YXNldCk7XG4gICAgICAgIHZhciBkZWxldGlvbktleXMgPSBvbGREYXRhc2V0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgIT09ICdfbWV0YScgJiYgbmV3RGF0YXNldEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChkZWxldGlvbktleSkge1xuICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2RlbGV0aW9uS2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGRhdGFzZXQpIHtcbiAgICAgICAgICBpZiAoZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2F0dHJpYnV0ZV0gPSBkYXRhc2V0W2F0dHJpYnV0ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ2xhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEubGFiZWxzID0gbmV3RGF0YS5sYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2xhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3hMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnhMYWJlbHMgPSBuZXdEYXRhLnhMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3hsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCd5TGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS55TGFiZWxzID0gbmV3RGF0YS55TGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCd5bGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnVwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhcnQpIHtcbiAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFydDpkZXN0cm95Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDpyZW5kZXInKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICB9XG59XG5cbmV4cG9ydCB2YXIgcmVhY3RpdmVEYXRhID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydERhdGE6IG51bGxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IHZhciByZWFjdGl2ZVByb3AgPSB7XG4gIHByb3BzOiB7XG4gICAgY2hhcnREYXRhOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hhcnREYXRhJzogZGF0YUhhbmRsZXJcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVhY3RpdmVEYXRhOiByZWFjdGl2ZURhdGEsXG4gIHJlYWN0aXZlUHJvcDogcmVhY3RpdmVQcm9wXG59OyIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohXG4gKiBDaGFydC5qcyB2Mi44LjBcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAxOSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KGdsb2JhbC5tb21lbnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5tb21lbnQgPSBtb21lbnQgJiYgbW9tZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBtb21lbnRbJ2RlZmF1bHQnXSA6IG1vbWVudDtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxudmFyIGNvbnZlcnNpb25zID0ge1xuICByZ2IyaHNsOiByZ2IyaHNsLFxuICByZ2IyaHN2OiByZ2IyaHN2LFxuICByZ2IyaHdiOiByZ2IyaHdiLFxuICByZ2IyY215azogcmdiMmNteWssXG4gIHJnYjJrZXl3b3JkOiByZ2Iya2V5d29yZCxcbiAgcmdiMnh5ejogcmdiMnh5eixcbiAgcmdiMmxhYjogcmdiMmxhYixcbiAgcmdiMmxjaDogcmdiMmxjaCxcblxuICBoc2wycmdiOiBoc2wycmdiLFxuICBoc2wyaHN2OiBoc2wyaHN2LFxuICBoc2wyaHdiOiBoc2wyaHdiLFxuICBoc2wyY215azogaHNsMmNteWssXG4gIGhzbDJrZXl3b3JkOiBoc2wya2V5d29yZCxcblxuICBoc3YycmdiOiBoc3YycmdiLFxuICBoc3YyaHNsOiBoc3YyaHNsLFxuICBoc3YyaHdiOiBoc3YyaHdiLFxuICBoc3YyY215azogaHN2MmNteWssXG4gIGhzdjJrZXl3b3JkOiBoc3Yya2V5d29yZCxcblxuICBod2IycmdiOiBod2IycmdiLFxuICBod2IyaHNsOiBod2IyaHNsLFxuICBod2IyaHN2OiBod2IyaHN2LFxuICBod2IyY215azogaHdiMmNteWssXG4gIGh3YjJrZXl3b3JkOiBod2Iya2V5d29yZCxcblxuICBjbXlrMnJnYjogY215azJyZ2IsXG4gIGNteWsyaHNsOiBjbXlrMmhzbCxcbiAgY215azJoc3Y6IGNteWsyaHN2LFxuICBjbXlrMmh3YjogY215azJod2IsXG4gIGNteWsya2V5d29yZDogY215azJrZXl3b3JkLFxuXG4gIGtleXdvcmQycmdiOiBrZXl3b3JkMnJnYixcbiAga2V5d29yZDJoc2w6IGtleXdvcmQyaHNsLFxuICBrZXl3b3JkMmhzdjoga2V5d29yZDJoc3YsXG4gIGtleXdvcmQyaHdiOiBrZXl3b3JkMmh3YixcbiAga2V5d29yZDJjbXlrOiBrZXl3b3JkMmNteWssXG4gIGtleXdvcmQybGFiOiBrZXl3b3JkMmxhYixcbiAga2V5d29yZDJ4eXo6IGtleXdvcmQyeHl6LFxuXG4gIHh5ejJyZ2I6IHh5ejJyZ2IsXG4gIHh5ejJsYWI6IHh5ejJsYWIsXG4gIHh5ejJsY2g6IHh5ejJsY2gsXG5cbiAgbGFiMnh5ejogbGFiMnh5eixcbiAgbGFiMnJnYjogbGFiMnJnYixcbiAgbGFiMmxjaDogbGFiMmxjaCxcblxuICBsY2gybGFiOiBsY2gybGFiLFxuICBsY2gyeHl6OiBsY2gyeHl6LFxuICBsY2gycmdiOiBsY2gycmdiXG59O1xuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufTtcblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9O1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG52YXIgY29sb3JTdHJpbmcgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59O1xuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszLDR9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KFthLWZBLUYwLTldezJ9KT8pJC9pLFxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIGtleXdvcmQgPSAvKFxcdyspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSxcbiAgICAgICBoZXhBbHBoYSA9IFwiXCI7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFsyXTtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiYSwgYSkge1xuICAgdmFyIGEgPSAoYSAhPT0gdW5kZWZpbmVkICYmIHJnYmEubGVuZ3RoID09PSAzKSA/IGEgOiByZ2JhWzNdO1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pIFxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzJdKVxuICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgKGEgPj0gMCAmJiBhIDwgMSlcbiAgICAgICAgICAgICAgICAgPyBoZXhEb3VibGUoTWF0aC5yb3VuZChhICogMjU1KSlcbiAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVbbmFtZV1dID0gbmFtZTtcbn1cblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gY29sb3JTdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb2xvckNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxudmFyIGNoYXJ0anNDb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG52YXIgaGVscGVycyA9IHtcblx0LyoqXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG5cdCAqL1xuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0dWlkOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaWQrKztcblx0XHR9O1xuXHR9KCkpLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzTnVsbE9yVW5kZWY6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNGaW5pdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IGhlbHBlcnMuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XG5cblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRtZXJnZSA9IG9wdGlvbnMubWVyZ2VyIHx8IGhlbHBlcnMuX21lcmdlcjtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIG9iamVjdHMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBzZXRGbiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMSwgaWxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGhlbHBlcnMuZWFjaChhcmd1bWVudHNbaV0sIHNldEZuKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogQmFzaWMgamF2YXNjcmlwdCBpbmhlcml0YW5jZSBiYXNlZCBvbiB0aGUgbW9kZWwgY3JlYXRlZCBpbiBCYWNrYm9uZS5qc1xuXHQgKi9cblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBDaGFydEVsZW1lbnQgPSAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSA/IGV4dGVuc2lvbnMuY29uc3RydWN0b3IgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gQ2hhcnRFbGVtZW50O1xuXHRcdH07XG5cblx0XHRTdXJyb2dhdGUucHJvdG90eXBlID0gbWUucHJvdG90eXBlO1xuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG5cblx0XHRpZiAoZXh0ZW5zaW9ucykge1xuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XG5cdFx0fVxuXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuaW5kZXhPZlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSwgZnJvbUluZGV4KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xudmFyIGVmZmVjdHMgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0O1xuXHR9LFxuXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLU1hdGguY29zKHQgKiAoTWF0aC5QSSAvIDIpKSArIDE7XG5cdH0sXG5cblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0fSxcblxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdH0sXG5cblx0ZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjQ1O1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRpZiAodCA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHR9LFxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuXHR9LFxuXG5cdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0fSxcblxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XG5cdFx0fVxuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzU7XG5cdH0sXG5cblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAwLjUpIHtcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0fVxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xuXHRlZmZlY3RzOiBlZmZlY3RzXG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHMgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5lYXNpbmdFZmZlY3RzID0gZWZmZWN0cztcblxudmFyIFBJID0gTWF0aC5QSTtcbnZhciBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xudmFyIERPVUJMRV9QSSA9IFBJICogMjtcbnZhciBIQUxGX1BJID0gUEkgLyAyO1xudmFyIFFVQVJURVJfUEkgPSBQSSAvIDQ7XG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xuICovXG52YXIgZXhwb3J0cyQxID0ge1xuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXG5cdCAqIGdpdmVuIHNpemUgKHdpZHRoLCBoZWlnaHQpIGFuZCB0aGUgc2FtZSBgcmFkaXVzYCBmb3IgYWxsIGNvcm5lcnMuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJvdW5kZWQgYW1vdW50IChpbiBwaXhlbHMpIGZvciB0aGUgZm91ciBjb3JuZXJzLlxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XG5cdCAqL1xuXHRyb3VuZGVkUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcblx0XHRcdHZhciBsZWZ0ID0geCArIHI7XG5cdFx0XHR2YXIgdG9wID0geSArIHI7XG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xuXHRcdFx0dmFyIGJvdHRvbSA9IHkgKyBoZWlnaHQgLSByO1xuXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XG5cdFx0XHRpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAtSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgUEkpO1xuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhsZWZ0LCB5KTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xuXHRcdFx0fSBlbHNlIGlmICh0b3AgPCBib3R0b20pIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCBQSSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKSB7XG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcblx0XHR2YXIgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShzdHlsZSwgeCAtIHN0eWxlLndpZHRoIC8gMiwgeSAtIHN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRzd2l0Y2ggKHN0eWxlKSB7XG5cdFx0Ly8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIERPVUJMRV9QSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0cmlhbmdsZSc6XG5cdFx0XHRjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxuXHRcdFx0Ly8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG5cdFx0XHQvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuXHRcdFx0Ly8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcblx0XHRcdC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcblx0XHRcdGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcblx0XHRcdGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdGlmICghcm90YXRpb24pIHtcblx0XHRcdFx0c2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ3JlY3RSb3QnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Nyb3NzUm90Jzpcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ2Nyb3NzJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJlYSAtIFRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXG5cdFx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBlcHNpbG9uICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIGVwc2lsb247XG5cdH0sXG5cblx0Y2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCwgYXJlYSkge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuXHRcdGN0eC5jbGlwKCk7XG5cdH0sXG5cblx0dW5jbGlwQXJlYTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuXHRcdHZhciBzdGVwcGVkID0gdGFyZ2V0LnN0ZXBwZWRMaW5lO1xuXHRcdGlmIChzdGVwcGVkKSB7XG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcblx0XHRcdFx0dmFyIG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyB0YXJnZXQueSA6IHByZXZpb3VzLnkpO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSBpZiAoKHN0ZXBwZWQgPT09ICdhZnRlcicgJiYgIWZsaXApIHx8IChzdGVwcGVkICE9PSAnYWZ0ZXInICYmIGZsaXApKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXQudGVuc2lvbikge1xuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWCA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRYLFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWSA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRZLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRZIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWSxcblx0XHRcdHRhcmdldC54LFxuXHRcdFx0dGFyZ2V0LnkpO1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jYW52YXMgPSBleHBvcnRzJDE7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jbGVhclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5kcmF3Um91bmRlZFJlY3RhbmdsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0ZXhwb3J0cyQxLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMkMSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0OiBmdW5jdGlvbihzY29wZSwgdmFsdWVzKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnNfY29yZS5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XG5cdH1cbn07XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZGVmYXVsdENvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRkZWZhdWx0Rm9udFNpemU6IDEyLFxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcblx0c2hvd0xpbmVzOiB0cnVlXG59KTtcblxudmFyIGNvcmVfZGVmYXVsdHMgPSBkZWZhdWx0cztcblxudmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVyc19jb3JlLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG5cdGlmICghZm9udCB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdCwgciwgYiwgbDtcblxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogdCxcblx0XHRcdHJpZ2h0OiByLFxuXHRcdFx0Ym90dG9tOiBiLFxuXHRcdFx0bGVmdDogbCxcblx0XHRcdGhlaWdodDogdCArIGIsXG5cdFx0XHR3aWR0aDogbCArIHJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gVGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAdG9kbyBTdXBwb3J0IGZvbnQuKiBvcHRpb25zIGFuZCByZW5hbWVkIHRvIHRvRm9udCgpLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BhcnNlRm9udDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udCA9IHtcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRsaW5lSGVpZ2h0OiBoZWxwZXJzX2NvcmUub3B0aW9ucy50b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0TGluZUhlaWdodCksIHNpemUpLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHR3ZWlnaHQ6IG51bGwsXG5cdFx0XHRzdHJpbmc6ICcnXG5cdFx0fTtcblxuXHRcdGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuXHRcdHJldHVybiBmb250O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcblx0ICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCkge1xuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzJDEgPSBoZWxwZXJzX2NvcmU7XG52YXIgZWFzaW5nID0gaGVscGVyc19lYXNpbmc7XG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XG52YXIgb3B0aW9ucyA9IGhlbHBlcnNfb3B0aW9ucztcbmhlbHBlcnMkMS5lYXNpbmcgPSBlYXNpbmc7XG5oZWxwZXJzJDEuY2FudmFzID0gY2FudmFzO1xuaGVscGVycyQxLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2RlbCk7XG5cdHZhciBpLCBpbGVuLCBrZXksIGFjdHVhbCwgb3JpZ2luLCB0YXJnZXQsIHR5cGUsIGMwLCBjMTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRrZXkgPSBrZXlzW2ldO1xuXG5cdFx0dGFyZ2V0ID0gbW9kZWxba2V5XTtcblxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xuXHRcdC8vIGRvZXNuJ3QgY29udGFpbiBpdCwgc28gbGV0J3MgaW5pdGlhbGl6ZSB0aGUgdmlldyB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuXHRcdGlmICghdmlldy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xuXG5cdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHN0YXJ0W2tleV0gPSBhY3R1YWw7XG5cdFx0fVxuXG5cdFx0b3JpZ2luID0gc3RhcnRba2V5XTtcblxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xuXG5cdFx0aWYgKHR5cGUgPT09IHR5cGVvZiBvcmlnaW4pIHtcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjMCA9IGNoYXJ0anNDb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdGlmIChjMS52YWxpZCkge1xuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0fVxufVxuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0fSxcblxuXHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5jbG9uZShtZS5fbW9kZWwpO1xuXHRcdH1cblx0XHRtZS5fc3RhcnQgPSB7fTtcblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xuXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcblx0XHRcdG1lLl92aWV3ID0gbW9kZWw7XG5cdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH1cblxuXHRcdGlmICghdmlldykge1xuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0c3RhcnQgPSBtZS5fc3RhcnQgPSB7fTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0fTtcblx0fSxcblxuXHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XG5cdH1cbn0pO1xuXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZWxlbWVudCA9IEVsZW1lbnQ7XG5cbnZhciBleHBvcnRzJDIgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxuXHRjdXJyZW50U3RlcDogMCwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXBcblx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cblx0cmVuZGVyOiBudWxsLCAvLyByZW5kZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgYW5pbWF0aW9uIHNlcnZpY2VcblxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzXG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9uID0gZXhwb3J0cyQyO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnYW5pbWF0aW9uT2JqZWN0Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jY2hhcnRJbnN0YW5jZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQyLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQ7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNoYXJ0ID0gdmFsdWU7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0Jyxcblx0XHRvblByb2dyZXNzOiBoZWxwZXJzJDEubm9vcCxcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzJDEubm9vcFxuXHR9XG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcblx0YW5pbWF0aW9uczogW10sXG5cdHJlcXVlc3Q6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcblx0ICovXG5cdGFkZEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0aWYgKCFsYXp5KSB7XG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuXHRcdC8vIElmIHRoZXJlIGFyZSBubyBhbmltYXRpb25zIHF1ZXVlZCwgbWFudWFsbHkga2lja3N0YXJ0IGEgZGlnZXN0LCBmb3IgbGFjayBvZiBhIGJldHRlciB3b3JkXG5cdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGluZGV4ID0gaGVscGVycyQxLmZpbmRJbmRleCh0aGlzLmFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcHJvY2Vzc2luZyBtb3VzZSBldmVudHMsIGUuZy4gJ21vdXNlbW92ZSdcblx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRtZS5zdGFydERpZ2VzdCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhcnREaWdlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRtZS5hZHZhbmNlKCk7XG5cblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cblx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uLCBjaGFydCwgbnVtU3RlcHMsIG5leHRTdGVwO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdC8vIDEgYW5pbWF0aW9uIHBlciBjaGFydCwgc28gd2UgYXJlIGxvb3BpbmcgY2hhcnRzIGhlcmVcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb25zW2ldO1xuXHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY3VycmVudFN0ZXAgc3RhcnRzIGF0IDFcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XG5cdFx0XHRuZXh0U3RlcCA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBhbmltYXRpb24uc3RhcnRUaW1lKSAvIGFuaW1hdGlvbi5kdXJhdGlvbiAqIG51bVN0ZXBzKSArIDE7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihuZXh0U3RlcCwgbnVtU3RlcHMpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdGlmIChhbmltYXRpb24uY3VycmVudFN0ZXAgPj0gbnVtU3RlcHMpIHtcblx0XHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0YW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgcmVzb2x2ZSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiB7XG5cdFx0XHRsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cblx0XHR9XG5cdH0pO1xuXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIG1ldGhvZCA9ICdvbkRhdGEnICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9iamVjdFttZXRob2RdLmFwcGx5KG9iamVjdCwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRpZiAoIXN0dWIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG5cdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRkZWxldGUgYXJyYXlba2V5XTtcblx0fSk7XG5cblx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdHRoaXMuaW5pdGlhbGl6ZShjaGFydCwgZGF0YXNldEluZGV4KTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZSkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhc2V0RWxlbWVudFR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnQpLlxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHQgKi9cblx0ZGF0YUVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdG1lLmFkZEVsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdH0sXG5cblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLmlkO1xuXHRcdH1cblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIG1lLmNoYXJ0LnNjYWxlcykpIHtcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcblx0fSxcblxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcblx0fSxcblxuXHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldFZhbHVlU2NhbGVJZCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkge1xuXHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0YWRkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YSB8fCBbXTtcblx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0fVxuXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XG5cdH0sXG5cblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVNZXRhRGF0YShpbmRleCk7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHQvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbiB0aHVzIHNpbXVsYXRlXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG5cdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRpZiAobWUuX2RhdGEgIT09IGRhdGEpIHtcblx0XHRcdGlmIChtZS5fZGF0YSkge1xuXHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKG1lLl9kYXRhLCBtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xuXHRcdFx0fVxuXHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRtZS5yZXN5bmNFbGVtZW50cygpO1xuXHR9LFxuXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0bWV0YS5kYXRhc2V0LnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdH1cblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRoZWxwZXJzJDEubWVyZ2UoZWxlbWVudC5fbW9kZWwsIGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgfHwge30pO1xuXHRcdGRlbGV0ZSBlbGVtZW50LiRwcmV2aW91c1N0eWxlO1xuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJDb2xvciwgZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJvcmRlckNvbG9yKV0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGgsIGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgbW9kZWwuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0dmFyIG51bU1ldGEgPSBtZXRhLmRhdGEubGVuZ3RoO1xuXHRcdHZhciBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG5cblx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcblx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHR0aGlzLmFkZEVsZW1lbnRBbmRSZXNldChzdGFydCArIGkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyh0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdH1cbn0pO1xuXG5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQgPSBoZWxwZXJzJDEuaW5oZXJpdHM7XG5cbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGFyYzoge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXJcdGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xuXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gdm0uZW5kQW5nbGU7XG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXG5cdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRyZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXG5cdFx0XHR5OiB2bS55ICsgKE1hdGguc2luKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSlcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgc0EgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdHZhciBlQSA9IHZtLmVuZEFuZ2xlO1xuXHRcdHZhciBwaXhlbE1hcmdpbiA9ICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcblx0XHR2YXIgYW5nbGVNYXJnaW47XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksIHNBLCBlQSk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGlmICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykge1xuXHRcdFx0XHQvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG5cdFx0XHRcdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIHZtLm91dGVyUmFkaXVzO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSAtIGFuZ2xlTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luKTtcblx0XHRcdFx0aWYgKHZtLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcblx0XHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0uaW5uZXJSYWRpdXM7XG5cdFx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luLCBzQSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHBpeGVsTWFyZ2luLCBlQSArIE1hdGguUEkgLyAyLCBzQSAtIE1hdGguUEkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5jbGlwKCk7XG5cblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSwgZUEpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoICogMjtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwLjQsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAzLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRcdGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcblx0XHRcdGNhcEJlemllclBvaW50czogdHJ1ZSxcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2xpbmUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHR2YXIgc3BhbkdhcHMgPSB2bS5zcGFuR2Fwcztcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XG5cdFx0dmFyIGluZGV4LCBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFZNO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRpZiAobWUuX2xvb3AgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmUgT3B0aW9uc1xuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdH1cblxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdGN0eC5saW5lSm9pbiA9IHZtLmJvcmRlckpvaW5TdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVySm9pblN0eWxlO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGgpO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblxuXHRcdC8vIFN0cm9rZSBMaW5lXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGxhc3REcmF3bkluZGV4ID0gLTE7XG5cblx0XHRmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG5cdFx0XHRjdXJyZW50ID0gcG9pbnRzW2luZGV4XTtcblx0XHRcdHByZXZpb3VzID0gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdGN1cnJlbnRWTSA9IGN1cnJlbnQuX3ZpZXc7XG5cblx0XHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRpZiAoKGxhc3REcmF3bkluZGV4ICE9PSAoaW5kZXggLSAxKSAmJiAhc3BhbkdhcHMpIHx8IGxhc3REcmF3bkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQyID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yJDEgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHBvaW50OiB7XG5cdFx0XHRyYWRpdXM6IDMsXG5cdFx0XHRwb2ludFN0eWxlOiAnY2lyY2xlJyxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdC8vIEhvdmVyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXG5cdFx0XHRob3ZlclJhZGl1czogNCxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiB4UmFuZ2UobW91c2VYKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VZIC0gdm0ueSkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbnZhciBlbGVtZW50X3BvaW50ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0gPyAoKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikpIDwgTWF0aC5wb3codm0uaGl0UmFkaXVzICsgdm0ucmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0aW5YUmFuZ2U6IHhSYW5nZSxcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRwYWRkaW5nOiB2bS5yYWRpdXMgKyB2bS5ib3JkZXJXaWR0aFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcblx0XHR2YXIgcmFkaXVzID0gdm0ucmFkaXVzO1xuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblxuXHRcdGlmICh2bS5za2lwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpcHBpbmcgZm9yIFBvaW50cy5cblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDIodm0uYm9yZGVyV2lkdGgsIGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBwb2ludFN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbG9yJDIgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKHZtKSB7XG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XG5cdHZhciB4MSwgeDIsIHkxLCB5MiwgaGFsZjtcblxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRoYWxmID0gdm0ud2lkdGggLyAyO1xuXHRcdHgxID0gdm0ueCAtIGhhbGY7XG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcblx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFsZiA9IHZtLmhlaWdodCAvIDI7XG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xuXHRcdHkxID0gdm0ueSAtIGhhbGY7XG5cdFx0eTIgPSB2bS55ICsgaGFsZjtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogeDEsXG5cdFx0dG9wOiB5MSxcblx0XHRyaWdodDogeDIsXG5cdFx0Ym90dG9tOiB5MlxuXHR9O1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuXHRyZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclNraXBwZWQodm0pIHtcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xuXHR2YXIgcmVzID0ge307XG5cblx0aWYgKCFlZGdlKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGlmICh2bS5ob3Jpem9udGFsKSB7XG5cdFx0aWYgKHZtLmJhc2UgPiB2bS54KSB7XG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh2bS5iYXNlIDwgdm0ueSkge1xuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XG5cdH1cblxuXHRyZXNbZWRnZV0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKHZtLCBtYXhXLCBtYXhIKSB7XG5cdHZhciB2YWx1ZSA9IHZtLmJvcmRlcldpZHRoO1xuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XG5cdHZhciB0LCByLCBiLCBsO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0fSBlbHNlIHtcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHQ6IHNraXAudG9wIHx8ICh0IDwgMCkgPyAwIDogdCA+IG1heEggPyBtYXhIIDogdCxcblx0XHRyOiBza2lwLnJpZ2h0IHx8IChyIDwgMCkgPyAwIDogciA+IG1heFcgPyBtYXhXIDogcixcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXG5cdFx0bDogc2tpcC5sZWZ0IHx8IChsIDwgMCkgPyAwIDogbCA+IG1heFcgPyBtYXhXIDogbFxuXHR9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKHZtKSB7XG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xuXHR2YXIgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcblx0dmFyIGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuXHRyZXR1cm4ge1xuXHRcdG91dGVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCxcblx0XHRcdHk6IGJvdW5kcy50b3AsXG5cdFx0XHR3OiB3aWR0aCxcblx0XHRcdGg6IGhlaWdodFxuXHRcdH0sXG5cdFx0aW5uZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG5cdFx0XHR5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG5cdFx0XHRoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iXG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XG5cdHZhciBza2lwWCA9IHggPT09IG51bGw7XG5cdHZhciBza2lwWSA9IHkgPT09IG51bGw7XG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcblxuXHRyZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXG5cdFx0JiYgKHNraXBZIHx8IHkgPj0gYm91bmRzLnRvcCAmJiB5IDw9IGJvdW5kcy5ib3R0b20pO1xufVxuXG52YXIgZWxlbWVudF9yZWN0YW5nbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xuXHRcdHZhciBvdXRlciA9IHJlY3RzLm91dGVyO1xuXHRcdHZhciBpbm5lciA9IHJlY3RzLmlubmVyO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguZmlsbFJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cblx0XHRpZiAob3V0ZXIudyA9PT0gaW5uZXIudyAmJiBvdXRlci5oID09PSBpbm5lci5oKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LnJlY3QoaW5uZXIueCwgaW5uZXIueSwgaW5uZXIudywgaW5uZXIuaCk7XG5cdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcblx0XHRcdDogaW5SYW5nZSh2bSwgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRpblhSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBudWxsKTtcblx0fSxcblxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgeCwgeTtcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRcdHggPSB2bS54O1xuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gKHZtLnggKyB2bS5iYXNlKSAvIDI7XG5cdFx0XHR5ID0gdm0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcblx0XHRcdDogdm0uaGVpZ2h0ICogTWF0aC5hYnModm0ueCAtIHZtLmJhc2UpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIGVsZW1lbnRzID0ge307XG52YXIgQXJjID0gZWxlbWVudF9hcmM7XG52YXIgTGluZSA9IGVsZW1lbnRfbGluZTtcbnZhciBQb2ludCA9IGVsZW1lbnRfcG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2JhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0fV1cblx0fVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XG5cdHZhciBtaW4gPSBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xuXHR2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuXHR2YXIgcHJldiwgY3VyciwgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMocGl4ZWxzW2ldIC0gcGl4ZWxzW2kgLSAxXSkpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG5cdFx0bWluID0gaSA+IDAgPyBNYXRoLm1pbihtaW4sIGN1cnIgLSBwcmV2KSA6IG1pbjtcblx0XHRwcmV2ID0gY3Vycjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XG5cdHZhciBjdXJyID0gcnVsZXIucGl4ZWxzW2luZGV4XTtcblx0dmFyIHNpemUsIHJhdGlvO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG5cdFx0c2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcblx0XHQvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcblx0XHRyYXRpbyA9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gY291bnQsXG5cdFx0cmF0aW86IHJhdGlvLFxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxuXHR9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuXHR2YXIgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHR2YXIgc3RhcnQsIHNpemU7XG5cblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHQvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG5cdH1cblxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG5cdH1cblxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXG5cdFx0cmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcblx0XHRzdGFydDogc3RhcnRcblx0fTtcbn1cblxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGE7XG5cblx0XHRjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuXHRcdG1ldGEuYmFyID0gdHJ1ZTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHJlY3RzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XG5cblx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXG5cdFx0fTtcblxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpO1xuXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCk7XG5cdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyKTtcblxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xuXHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBpbGVuID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggOiBsYXN0ICsgMTtcblx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0dmFyIGksIG1ldGE7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRpZiAobWV0YS5iYXIgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJlxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gZmFsc2UgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIChtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSkpKSB7XG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzdGFja3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIG5hbWUpIHtcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCk7XG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcblx0XHRcdD8gc3RhY2tzLmluZGV4T2YobmFtZSlcblx0XHRcdDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cblx0XHRyZXR1cm4gKGluZGV4ID09PSAtMSlcblx0XHRcdD8gc3RhY2tzLmxlbmd0aCAtIDFcblx0XHRcdDogaW5kZXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHN0YXJ0ID0gaXNIb3Jpem9udGFsID8gc2NhbGUubGVmdCA6IHNjYWxlLnRvcDtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaXNIb3Jpem9udGFsID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQpO1xuXHRcdHZhciBwaXhlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbWluO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBkYXRhc2V0SW5kZXgpKTtcblx0XHR9XG5cblx0XHRtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzY2FsZS5vcHRpb25zLmJhclRoaWNrbmVzcylcblx0XHRcdD8gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscylcblx0XHRcdDogLTE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiBtaW4sXG5cdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGVuZDogZW5kLFxuXHRcdFx0c3RhY2tDb3VudDogc3RhY2tDb3VudCxcblx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJWYWx1ZVBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgdmFsdWUgPSArc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgbWluQmFyTGVuZ3RoID0gc2NhbGUub3B0aW9ucy5taW5CYXJMZW5ndGg7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIHN0YWNrID0gbWV0YS5zdGFjaztcblx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdHZhciBpLCBpbWV0YSwgaXZhbHVlLCBiYXNlLCBoZWFkLCBzaXplO1xuXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRcdGltZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cblx0XHRcdFx0aWYgKGltZXRhLmJhciAmJlxuXHRcdFx0XHRcdGltZXRhLnN0YWNrID09PSBzdGFjayAmJlxuXHRcdFx0XHRcdGltZXRhLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBzY2FsZS5pZCAmJlxuXHRcdFx0XHRcdGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblxuXHRcdFx0XHRcdGl2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2ldLmRhdGFbaW5kZXhdKTtcblx0XHRcdFx0XHRpZiAoKHZhbHVlIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUgPj0gMCAmJiBpdmFsdWUgPiAwKSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XG5cblx0XHRpZiAobWluQmFyTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XG5cdFx0XHRpZiAodmFsdWUgPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IHZhbHVlIDwgMCAmJiBpc0hvcml6b250YWwpIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWFkID0gYmFzZSArIG1pbkJhckxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGJhc2U6IGJhc2UsXG5cdFx0XHRoZWFkOiBoZWFkLFxuXHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHJ1bGVyLnNjYWxlLm9wdGlvbnM7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcblx0XHRcdDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucyk7XG5cblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xuXHRcdHZhciBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcblx0XHRcdGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpLFxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG5cdFx0XHRoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0c2l6ZTogc2l6ZVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBpbGVuID0gcmVjdHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmICghaXNOYU4oc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0LmRhdGFbaV0pKSkge1xuXHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5yZWN0YW5nbGU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJTa2lwcGVkJyxcblx0XHRcdCdib3JkZXJXaWR0aCdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDEoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQyID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YXNldExhYmVsID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdHZhciBkYXRhUG9pbnQgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5kYXRhW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpbmRleCwgcmVzZXQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcblx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdH07XG5cblx0XHRwb2ludC5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdFx0J2hpdFJhZGl1cycsXG5cdFx0XHQncG9pbnRTdHlsZScsXG5cdFx0XHQncm90YXRpb24nXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQyKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG5cdFx0dmFsdWVzLnJhZGl1cyA9IHJlc29sdmUkMihbXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxuXHRcdFx0ZGF0YSA/IGRhdGEuciA6IHVuZGVmaW5lZCxcblx0XHRcdGRhdGFzZXQucmFkaXVzLFxuXHRcdFx0b3B0aW9ucy5yYWRpdXNcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdkb3VnaG51dCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0fSxcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjICYmIGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDMoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDMoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0aWYgKG1ldGEuZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHQvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuXHRyb3RhdGlvbjogTWF0aC5QSSAqIC0wLjUsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBNYXRoLlBJICogMi4wLFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFMYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9kb3VnaG51dCA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nSW5kZXggPSAwO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHQrK3JpbmdJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ0luZGV4O1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdHZhciBhdmFpbGFibGVIZWlnaHQgPSBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcDtcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuXHRcdHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH07XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGN1dG91dFBlcmNlbnRhZ2UgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2U7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgbWluU2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgTWF0aC5QSSAqIDIuMCkge1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyLjApO1xuXHRcdFx0c3RhcnRBbmdsZSArPSBNYXRoLlBJICogMi4wICogKHN0YXJ0QW5nbGUgPj0gTWF0aC5QSSA/IC0xIDogc3RhcnRBbmdsZSA8IC1NYXRoLlBJID8gMSA6IDApO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG5cdFx0XHR2YXIgc3RhcnQgPSB7eDogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpfTtcblx0XHRcdHZhciBlbmQgPSB7eDogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBNYXRoLnNpbihlbmRBbmdsZSl9O1xuXHRcdFx0dmFyIGNvbnRhaW5zMCA9IChzdGFydEFuZ2xlIDw9IDAgJiYgZW5kQW5nbGUgPj0gMCkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuMCAmJiBNYXRoLlBJICogMi4wIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDAuNSAmJiBNYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi41ICYmIE1hdGguUEkgKiAyLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgJiYgLU1hdGguUEkgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgJiYgTWF0aC5QSSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAqIDAuNSAmJiAtTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDEuNSAmJiBNYXRoLlBJICogMS41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjdXRvdXQgPSBjdXRvdXRQZXJjZW50YWdlIC8gMTAwLjA7XG5cdFx0XHR2YXIgbWluID0ge3g6IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydC54ICogKHN0YXJ0LnggPCAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54IDwgMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnkgKiAoc3RhcnQueSA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPCAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBtYXggPSB7eDogY29udGFpbnMwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnggKiAoc3RhcnQueCA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPiAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnkgKiAoc3RhcnQueSA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPiAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBzaXplID0ge3dpZHRoOiAobWF4LnggLSBtaW4ueCkgKiAwLjUsIGhlaWdodDogKG1heC55IC0gbWluLnkpICogMC41fTtcblx0XHRcdG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHNpemUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0XHRcdG9mZnNldCA9IHt4OiAobWF4LnggKyBtaW4ueCkgKiAtMC41LCB5OiAobWF4LnkgKyBtaW4ueSkgKiAtMC41fTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdH1cblxuXHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKTtcblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChjdXRvdXRQZXJjZW50YWdlKSA6IDAsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIChtZS5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHx8IDEpO1xuXHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXQueCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXQueSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXG5cdFx0bWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gTWF0aC5tYXgobWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gMCA6IGFyYy5oaWRkZW4gPyAwIDogbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKSAqIChvcHRzLmNpcmN1bWZlcmVuY2UgLyAoMi4wICogTWF0aC5QSSkpO1xuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuXHRcdHZhciBvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcblx0XHRcdFx0eTogY2VudGVyWSArIGNoYXJ0Lm9mZnNldFksXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcblx0XHRcdFx0Y2lyY3VtZmVyZW5jZTogY2lyY3VtZmVyZW5jZSxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQubGFiZWwsIGluZGV4LCBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXG5cdFx0Ly8gU2V0IGNvcnJlY3QgYW5nbGVzIGlmIG5vdCByZXNldHRpbmdcblx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcblx0XHR9XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0dmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIGlmICh0b3RhbCA9PT0gMCkge1xuXHRcdFx0dG90YWwgPSBOYU47XG5cdFx0fSovXG5cblx0XHRyZXR1cm4gdG90YWw7XG5cdH0sXG5cblx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcblx0XHRpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAoTWF0aC5QSSAqIDIuMCkgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXggPSAwO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhLCBhcmMsIGNvbnRyb2xsZXIsIG9wdGlvbnMsIGJvcmRlcldpZHRoLCBob3ZlcldpZHRoO1xuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmMgPSBhcmNzW2ldO1xuXHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjLCBpKSA6IGFyYy5fb3B0aW9ucztcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0aG92ZXJXaWR0aCA9IG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aDtcblxuXHRcdFx0XHRtYXggPSBib3JkZXJXaWR0aCA+IG1heCA/IGJvcmRlcldpZHRoIDogbWF4O1xuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1heDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJBbGlnbicsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMyhbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQkNCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YVNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XVxuXHR9LFxuXG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnbGVmdCdcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ1ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgaXNQb2ludEluQXJlYSA9IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWE7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucykge1xuXHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XG59XG5cbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNob3dMaW5lID0gbGluZUVuYWJsZWQoZGF0YXNldCwgbWUuY2hhcnQub3B0aW9ucyk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBVcGRhdGUgTGluZVxuXHRcdGlmIChzaG93TGluZSkge1xuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0Ly8gRGF0YVxuXHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0XHQvLyBNb2RlbFxuXHRcdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCwgeTtcblxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblxuXHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ1KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXHRcdFx0c3RlcHBlZExpbmU6IGxpbmVNb2RlbCA/IGxpbmVNb2RlbC5zdGVwcGVkTGluZSA6IGZhbHNlLFxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gb3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnLFxuXHRcdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0ZWxlbWVudE9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xuXHRcdC8vIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDM1I2lzc3VlY29tbWVudC0yMTY3MTgxNThcblx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LmxpbmVUZW5zaW9uLCBlbGVtZW50T3B0aW9ucy50ZW5zaW9uKTtcblx0XHR2YWx1ZXMuc3RlcHBlZExpbmUgPSByZXNvbHZlJDQoW2N1c3RvbS5zdGVwcGVkTGluZSwgZGF0YXNldC5zdGVwcGVkTGluZSwgZWxlbWVudE9wdGlvbnMuc3RlcHBlZF0pO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBzdW1Qb3MgPSAwO1xuXHRcdHZhciBzdW1OZWcgPSAwO1xuXHRcdHZhciBpLCBkcywgZHNNZXRhO1xuXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7IGkrKykge1xuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV07XG5cdFx0XHRcdGRzTWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHR2YXIgc3RhY2tlZFJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pKTtcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciByaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0aWYgKGxpbmVNb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGhhbGZCb3JkZXJXaWR0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobGluZUVuYWJsZWQobWUuZ2V0RGF0YXNldCgpLCBjaGFydC5vcHRpb25zKSkge1xuXHRcdFx0aGFsZkJvcmRlcldpZHRoID0gKG1ldGEuZGF0YXNldC5fbW9kZWwuYm9yZGVyV2lkdGggfHwgMCkgLyAyO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xuXHRcdFx0XHRsZWZ0OiBhcmVhLmxlZnQsXG5cdFx0XHRcdHJpZ2h0OiBhcmVhLnJpZ2h0LFxuXHRcdFx0XHR0b3A6IGFyZWEudG9wIC0gaGFsZkJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3R0b206IGFyZWEuYm90dG9tICsgaGFsZkJvcmRlcldpZHRoXG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblxuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB0aGUgcG9pbnRzXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9LFxufSk7XG5cbnZhciByZXNvbHZlJDUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BvbGFyQXJlYScsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRhbmdsZUxpbmVzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdH0sXG5cdFx0cG9pbnRMYWJlbHM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHR0aWNrczoge1xuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XG5cdGFuaW1hdGlvbjoge1xuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXG5cdH0sXG5cblx0c3RhcnRBbmdsZTogLTAuNSAqIE1hdGguUEksXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gcmVzb2x2ZSQ1KFtjdXN0b20uYmFja2dyb3VuZENvbG9yLCBkcy5iYWNrZ3JvdW5kQ29sb3IsIGFyY09wdHMuYmFja2dyb3VuZENvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJDb2xvciwgZHMuYm9yZGVyQ29sb3IsIGFyY09wdHMuYm9yZGVyQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gcmVzb2x2ZSQ1KFtjdXN0b20uYm9yZGVyV2lkdGgsIGRzLmJvcmRlcldpZHRoLCBhcmNPcHRzLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1tpdGVtLmluZGV4XSArICc6ICcgKyBpdGVtLnlMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9wb2xhckFyZWEgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IG1lLl9zdGFydHMgPSBbXTtcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuLCBhbmdsZTtcblxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcblxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXQuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xuXHRcdFx0YW5nbGVzW2ldID0gYW5nbGU7XG5cdFx0XHRzdGFydCArPSBhbmdsZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VwZGF0ZVJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGg7XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBzY2FsZSA9IGNoYXJ0LnNjYWxlO1xuXHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcblxuXHRcdHZhciBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcblx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG5cblx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XG5cdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBtZS5fc3RhcnRzW2luZGV4XTtcblx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogbWUuX2FuZ2xlc1tpbmRleF0pO1xuXG5cdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYLFxuXHRcdFx0XHR5OiBjZW50ZXJZLFxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IHJlc2V0ID8gcmVzZXRSYWRpdXMgOiBkaXN0YW5jZSxcblx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ1KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21wdXRlQW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY291bnQgPSB0aGlzLmdldE1ldGEoKS5jb3VudDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblxuXHRcdGlmIChpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogbWUuY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc29sdmUkNShbXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcblx0XHRcdCgyICogTWF0aC5QSSkgLyBjb3VudFxuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywgaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZG91Z2hudXQpKTtcbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywge1xuXHRjdXRvdXRQZXJjZW50YWdlOiAwXG59KTtcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbnZhciBjb250cm9sbGVyX3BpZSA9IGNvbnRyb2xsZXJfZG91Z2hudXQ7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcblx0fSxcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwIC8vIG5vIGJlemllciBpbiByYWRhclxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0fVxuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0Ly8gRGF0YVxuXHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xuXHRcdC8vIE1vZGVsXG5cdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0bGluZS5waXZvdCgpO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcblx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWUuZ2V0TWV0YSgpLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsIC8vIHZhbHVlIG5vdCB1c2VkIGluIGRhdGFzZXQgc2NhbGUsIGJ1dCB3ZSB3YW50IGEgY29uc2lzdGVudCBBUEkgYmV0d2VlbiBzY2FsZXNcblx0XHRcdHk6IHksXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNihjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcblxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJDYXBTdHlsZScsXG5cdFx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHRcdCdmaWxsJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ2KGRhdGFzZXQubGluZVRlbnNpb24sIG9wdGlvbnMudGVuc2lvbik7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdCk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJlemllciBnb2luZyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0c2hvd0xpbmVzOiBmYWxzZSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7ICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2UgZGF0YSBhcmUgZm9ybWF0dGVkIGFzIGEgcG9pbnRcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gJygnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcbnZhciBjb250cm9sbGVyX3NjYXR0ZXIgPSBjb250cm9sbGVyX2xpbmU7XG5cbi8vIE5PVEUgZXhwb3J0IGEgbWFwIGluIHdoaWNoIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgY29udHJvbGxlciB0eXBlLCBub3Rcbi8vIHRoZSBjbGFzcywgYW5kIHNvIG11c3QgYmUgQ2FtZWxDYXNlIGluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSByZXRyaWV2ZWRcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cblxudmFyIGNvbnRyb2xsZXJzID0ge1xuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxuXHRidWJibGU6IGNvbnRyb2xsZXJfYnViYmxlLFxuXHRkb3VnaG51dDogY29udHJvbGxlcl9kb3VnaG51dCxcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxuXHRsaW5lOiBjb250cm9sbGVyX2xpbmUsXG5cdHBvbGFyQXJlYTogY29udHJvbGxlcl9wb2xhckFyZWEsXG5cdHBpZTogY29udHJvbGxlcl9waWUsXG5cdHJhZGFyOiBjb250cm9sbGVyX3JhZGFyLFxuXHRzY2F0dGVyOiBjb250cm9sbGVyX3NjYXR0ZXJcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgYW4gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBldmVudCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG5cdGlmIChlLm5hdGl2ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBlLngsXG5cdFx0XHR5OiBlLnlcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcblx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmICghY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0RWxlbWVudFtdfSBpdGVtcyAtIGVsZW1lbnRzIHRvIGZpbHRlclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VNZXRyaWMgLSBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpIHtcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcblx0dmFyIHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0dmFyIGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG5cdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtpdGVtc1swXS5faW5kZXhdO1xuXG5cdFx0XHQvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBJSW50ZXJhY3Rpb25PcHRpb25zXG4gKi9cbi8qKlxuICogSWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9pbnRcbiAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbnZhciBjb3JlX2ludGVyYWN0aW9uID0ge1xuXHQvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuXHRtb2Rlczoge1xuXHRcdHNpbmdsZTogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmxhYmVsXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGxhYmVsOiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRpbmRleDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLngtYXhpc1xuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAuIFVzZSBpbmRleCBtb2RlIGFuZCBpbnRlcnNlY3QgPT0gdHJ1ZVxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0cmV0dXJuIGluZGV4TW9kZShjaGFydCwgZSwge2ludGVyc2VjdDogZmFsc2V9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5YUmFuZ2UocG9zaXRpb24ueCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR5OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pbllSYW5nZShwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcblx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG5cdFx0di5fdG1wSW5kZXhfID0gaTtcblx0XHRyZXR1cm4gdjtcblx0fSk7XG5cdGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cblx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcblx0fSk7XG5cdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdGRlbGV0ZSB2Ll90bXBJbmRleF87XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kTWF4UGFkZGluZyhib3hlcykge1xuXHR2YXIgdG9wID0gMDtcblx0dmFyIGxlZnQgPSAwO1xuXHR2YXIgYm90dG9tID0gMDtcblx0dmFyIHJpZ2h0ID0gMDtcblx0aGVscGVycyQxLmVhY2goYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdGlmIChib3guZ2V0UGFkZGluZykge1xuXHRcdFx0dmFyIGJveFBhZGRpbmcgPSBib3guZ2V0UGFkZGluZygpO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRsZWZ0ID0gTWF0aC5tYXgobGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcblx0XHRcdGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuXHRcdFx0cmlnaHQgPSBNYXRoLm1heChyaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHtcblx0XHR0b3A6IHRvcCxcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdGJvdHRvbTogYm90dG9tLFxuXHRcdHJpZ2h0OiByaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTaXplQnlQb3NpdGlvbihib3hlcywgc2l6ZSkge1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0c2l6ZVtib3gucG9zaXRpb25dICs9IGJveC5pc0hvcml6b250YWwoKSA/IGJveC5oZWlnaHQgOiBib3gud2lkdGg7XG5cdH0pO1xufVxuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbnZhciBjb3JlX2xheW91dHMgPSB7XG5cdGRlZmF1bHRzOiB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdCAqL1xuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG5cdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0Y2hhcnQuYm94ZXMucHVzaChpdGVtKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xuXHRcdHZhciBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG5cdGNvbmZpZ3VyZTogZnVuY3Rpb24oY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHByb3A7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0aXRlbVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoIWNoYXJ0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcblx0XHR2YXIgcGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhsYXlvdXRPcHRpb25zLnBhZGRpbmcpO1xuXHRcdHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmcubGVmdDtcblx0XHR2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZy5yaWdodDtcblx0XHR2YXIgdG9wUGFkZGluZyA9IHBhZGRpbmcudG9wO1xuXHRcdHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZy5ib3R0b207XG5cblx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHR2YXIgcmlnaHRCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdyaWdodCcpO1xuXHRcdHZhciB0b3BCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICd0b3AnKTtcblx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0dmFyIGNoYXJ0QXJlYUJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2NoYXJ0QXJlYScpO1xuXG5cdFx0Ly8gU29ydCBib3hlcyBieSB3ZWlnaHQuIEEgaGlnaGVyIHdlaWdodCBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChyaWdodEJveGVzLCBmYWxzZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHRvcEJveGVzLCB0cnVlKTtcblx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdHZhciB2ZXJ0aWNhbEJveGVzID0gbGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKTtcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gdG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKTtcblx0XHR2YXIgb3V0ZXJCb3hlcyA9IHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyk7XG5cblx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0Ly8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcblx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHQvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcblx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cblx0XHQvL1xuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vXG5cdFx0Ly8gV2hhdCB3ZSBkbyB0byBmaW5kIHRoZSBiZXN0IHNpemluZywgd2UgZG8gdGhlIGZvbGxvd2luZ1xuXHRcdC8vIDEuIERldGVybWluZSB0aGUgbWluaW11bSBzaXplIG9mIHRoZSBjaGFydCBhcmVhLlxuXHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdC8vIDMuIFNwbGl0IHRoZSByZW1haW5pbmcgaGVpZ2h0IGVxdWFsbHkgYmV0d2VlbiBlYWNoIGhvcml6b250YWwgYXhpc1xuXHRcdC8vIDQuIEdpdmUgZWFjaCBsYXlvdXQgdGhlIG1heGltdW0gc2l6ZSBpdCBjYW4gYmUuIFRoZSBsYXlvdXQgd2lsbCByZXR1cm4gaXQncyBtaW5pbXVtIHNpemVcblx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHQvLyA2LiBSZWZpdCBlYWNoIGF4aXNcblx0XHQvLyA3LiBQb3NpdGlvbiBlYWNoIGF4aXMgaW4gdGhlIGZpbmFsIGxvY2F0aW9uXG5cdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0Ly8gOS4gVGVsbCBhbnkgYXhlcyB0aGF0IG92ZXJsYXkgdGhlIGNoYXJ0IGFyZWEgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY2hhcnQgYXJlYVxuXG5cdFx0Ly8gU3RlcCAxXG5cdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdHZhciBjaGFydEhlaWdodCA9IGhlaWdodCAtIHRvcFBhZGRpbmcgLSBib3R0b21QYWRkaW5nO1xuXHRcdHZhciBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGggLyAyOyAvLyBtaW4gNTAlXG5cblx0XHQvLyBTdGVwIDJcblx0XHR2YXIgdmVydGljYWxCb3hXaWR0aCA9ICh3aWR0aCAtIGNoYXJ0QXJlYVdpZHRoKSAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCAzXG5cdFx0Ly8gVE9ETyByZS1saW1pdCBob3Jpem9udGFsIGF4aXMgaGVpZ2h0ICh0aGlzIGxpbWl0IGhhcyBhZmZlY3RlZCBvbmx5IHBhZGRpbmcgY2FsY3VsYXRpb24gc2luY2UgUFIgMTgzNylcblx0XHQvLyB2YXIgaG9yaXpvbnRhbEJveEhlaWdodCA9IChoZWlnaHQgLSBjaGFydEFyZWFIZWlnaHQpIC8gaG9yaXpvbnRhbEJveGVzLmxlbmd0aDtcblxuXHRcdC8vIFN0ZXAgNFxuXHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0dmFyIG1heENoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0O1xuXHRcdHZhciBvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0dmFyIG1pbkJveFNpemVzID0gW107XG5cdFx0dmFyIG1heFBhZGRpbmc7XG5cblx0XHRmdW5jdGlvbiBnZXRNaW5pbXVtQm94U2l6ZShib3gpIHtcblx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IGJveC5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZSh2ZXJ0aWNhbEJveFdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRtaW5Cb3hTaXplcy5wdXNoKHtcblx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHR3aWR0aDogbWluU2l6ZS53aWR0aCxcblx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChvdXRlckJveGVzLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHQvLyBJZiBhIGhvcml6b250YWwgYm94IGhhcyBwYWRkaW5nLCB3ZSBtb3ZlIHRoZSBsZWZ0IGJveGVzIG92ZXIgdG8gYXZvaWQgdWdseSBjaGFydHMgKHNlZSBpc3N1ZSAjMjQ3OClcblx0XHRtYXhQYWRkaW5nID0gZmluZE1heFBhZGRpbmcob3V0ZXJCb3hlcyk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdC8vIGJlIGlmIHRoZSBheGVzIGFyZSBkcmF3biBhdCB0aGVpciBtaW5pbXVtIHNpemVzLlxuXHRcdC8vIFN0ZXBzIDUgJiA2XG5cblx0XHQvLyBGdW5jdGlvbiB0byBmaXQgYSBib3hcblx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0cmV0dXJuIG1pbkJveC5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRpZiAobWluQm94U2l6ZS5ob3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5sZWZ0LCBtYXhQYWRkaW5nLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KG91dGVyQm94U2l6ZXMucmlnaHQsIG1heFBhZGRpbmcucmlnaHQpLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0Ym90dG9tOiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHQvLyBvbiB0aGUgbWFyZ2luLiBTb21ldGltZXMgdGhleSBuZWVkIHRvIGluY3JlYXNlIGluIHNpemUgc2xpZ2h0bHlcblx0XHRcdFx0XHRib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMiwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC51cGRhdGUobWluQm94U2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKHZlcnRpY2FsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZml0Qm94KTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbihob3Jpem9udGFsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0cmV0dXJuIG1pblNpemUuYm94ID09PSBib3g7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiBvdXRlckJveFNpemVzLnRvcCxcblx0XHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLmJvdHRvbVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQsIHNjYWxlTWFyZ2luKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMZXQgdGhlIGxlZnQgbGF5b3V0IGtub3cgdGhlIGZpbmFsIG1hcmdpblxuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpbmFsRml0VmVydGljYWxCb3gpO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgc2l6ZSBvZiBlYWNoIGxheW91dCBtaWdodCBoYXZlIGNoYW5nZWQgc2xpZ2h0bHkgZHVlIHRvIHRoZSBtYXJnaW5zIChsYWJlbCByb3RhdGlvbiBmb3IgaW5zdGFuY2UpXG5cdFx0b3V0ZXJCb3hTaXplcyA9IHt0b3A6IHRvcFBhZGRpbmcsIGxlZnQ6IGxlZnRQYWRkaW5nLCBib3R0b206IGJvdHRvbVBhZGRpbmcsIHJpZ2h0OiByaWdodFBhZGRpbmd9O1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKG91dGVyQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0dmFyIGxlZnRQYWRkaW5nQWRkaXRpb24gPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQgLSBvdXRlckJveFNpemVzLmxlZnQsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMubGVmdCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMucmlnaHQgKz0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCAtIG91dGVyQm94U2l6ZXMucmlnaHQsIDApO1xuXG5cdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wIC0gb3V0ZXJCb3hTaXplcy50b3AsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMudG9wICs9IHRvcFBhZGRpbmdBZGRpdGlvbjtcblx0XHRvdXRlckJveFNpemVzLmJvdHRvbSArPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSAtIG91dGVyQm94U2l6ZXMuYm90dG9tLCAwKTtcblxuXHRcdC8vIEZpZ3VyZSBvdXQgaWYgb3VyIGNoYXJ0IGFyZWEgY2hhbmdlZC4gVGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgZGF0YXNldCBsYXlvdXQgbGFiZWwgcm90YXRpb25cblx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHQvLyB3aXRob3V0IGNhbGxpbmcgYGZpdGAgYWdhaW5cblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ID0gaGVpZ2h0IC0gb3V0ZXJCb3hTaXplcy50b3AgLSBvdXRlckJveFNpemVzLmJvdHRvbTtcblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhV2lkdGggPSB3aWR0aCAtIG91dGVyQm94U2l6ZXMubGVmdCAtIG91dGVyQm94U2l6ZXMucmlnaHQ7XG5cblx0XHRpZiAobmV3TWF4Q2hhcnRBcmVhV2lkdGggIT09IG1heENoYXJ0QXJlYVdpZHRoIHx8IG5ld01heENoYXJ0QXJlYUhlaWdodCAhPT0gbWF4Q2hhcnRBcmVhSGVpZ2h0KSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChob3Jpem9udGFsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdG1heENoYXJ0QXJlYVdpZHRoID0gbmV3TWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0fVxuXG5cdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0dmFyIGxlZnQgPSBsZWZ0UGFkZGluZyArIGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0dmFyIHRvcCA9IHRvcFBhZGRpbmcgKyB0b3BQYWRkaW5nQWRkaXRpb247XG5cblx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gbGVmdFBhZGRpbmcgOiBvdXRlckJveFNpemVzLmxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyB3aWR0aCAtIHJpZ2h0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRib3gudG9wID0gdG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0dG9wID0gYm94LmJvdHRvbTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3gubGVmdCA9IGxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGxlZnQgKyBib3gud2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSBvdXRlckJveFNpemVzLnRvcDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRsZWZ0ID0gYm94LnJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKGxlZnRCb3hlcy5jb25jYXQodG9wQm94ZXMpLCBwbGFjZUJveCk7XG5cblx0XHQvLyBBY2NvdW50IGZvciBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHR0b3AgKz0gbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0aGVscGVycyQxLmVhY2gocmlnaHRCb3hlcywgcGxhY2VCb3gpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvdHRvbUJveGVzLCBwbGFjZUJveCk7XG5cblx0XHQvLyBTdGVwIDhcblx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRsZWZ0OiBvdXRlckJveFNpemVzLmxlZnQsXG5cdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0cmlnaHQ6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoLFxuXHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLnRvcCArIG1heENoYXJ0QXJlYUhlaWdodFxuXHRcdH07XG5cblx0XHQvLyBTdGVwIDlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3gubGVmdCA9IGNoYXJ0LmNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0LmNoYXJ0QXJlYS50b3A7XG5cdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRib3guYm90dG9tID0gY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTtcblxuXHRcdFx0Ym94LnVwZGF0ZShtYXhDaGFydEFyZWFXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcblx0fVxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxuICovXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxufVxcblxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxufVxcblxcbi8qXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXG4gKi9cXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxuXFx0cmlnaHQ6IDA7XFxuXFx0Ym90dG9tOiAwO1xcblxcdG92ZXJmbG93OiBoaWRkZW47XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcblxcdHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAyMDAlO1xcblxcdGhlaWdodDogMjAwJTtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbmRlZmF1bHQ6IHBsYXRmb3JtX2RvbVxufSk7XG5cbmZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcblx0cmV0dXJuIG4gJiYgbi5kZWZhdWx0IHx8IG47XG59XG5cbnZhciBzdHlsZXNoZWV0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShwbGF0Zm9ybV9kb20kMSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3JlbmRlci1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge1xuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcblx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcblx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuXHRwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN1cHBvcnRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuXHR9XG5cdHJldHVybiBzdXBwb3J0cztcbn0oKSk7XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xuXHRyZXR1cm4gZWw7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXG5cdC8vIE5PVEUoU0IpIERvbid0IHVzZSBpbm5lckhUTUwgYmVjYXVzZSBpdCBjb3VsZCBiZSBjb25zaWRlcmVkIHVuc2FmZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XG5cdHZhciBleHBhbmQgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctZXhwYW5kJyk7XG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XG5cblx0ZXhwYW5kLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblxuXHRyZXNpemVyLmFwcGVuZENoaWxkKGV4cGFuZCk7XG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRMaXN0ZW5lcihzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKHNocmluaywgJ3NocmluaycpKTtcblxuXHRyZXR1cm4gcmVzaXplcjtcbn1cblxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5mdW5jdGlvbiB3YXRjaEZvclJlbmRlcihub2RlLCBoYW5kbGVyKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IENTU19SRU5ERVJfQU5JTUFUSU9OKSB7XG5cdFx0XHRoYW5kbGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdH0pO1xuXG5cdC8vICM0NzM3OiBDaHJvbWUgbWlnaHQgc2tpcCB0aGUgQ1NTIGFuaW1hdGlvbiB3aGVuIHRoZSBDU1NfUkVOREVSX01PTklUT1IgY2xhc3Ncblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYSNib3gtbWV0cmljc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcblx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuXHRcdFx0XHQvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG5cdFx0XHRcdC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcblx0XHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbmplY3RDU1MocGxhdGZvcm0sIGNzcykge1xuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxuXHR2YXIgc3R5bGUgPSBwbGF0Zm9ybS5fc3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0aWYgKCFwbGF0Zm9ybS5fc3R5bGUpIHtcblx0XHRwbGF0Zm9ybS5fc3R5bGUgPSBzdHlsZTtcblx0XHRjc3MgPSAnLyogQ2hhcnQuanMgKi9cXG4nICsgY3NzO1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG59XG5cbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcblx0LyoqXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xuXHQgKiBzd2l0Y2ggaGFzIGJlZW4gYWRkZWQgdG8gYWxsb3cgZXh0ZXJuYWwgc3R5bGVzaGVldCAoYGRpc3QvQ2hhcnQoLm1pbik/LmpzYClcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHQgKi9cblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Vuc3VyZUxvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XG5cdFx0XHRpbmplY3RDU1ModGhpcywgc3R5bGVzaGVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG5cdFx0fSBlbHNlIGlmIChpdGVtLmxlbmd0aCkge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcblx0XHR9XG5cblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIHBvc3NpYmxlIHRvIGNoYW5nZVxuXHRcdC8vIHBsYXRmb3JtIG9wdGlvbnMgYWZ0ZXIgaW1wb3J0aW5nIHRoZSBsaWJyYXJ5IChlLmcuIGBkaXNhYmxlQ1NTSW5qZWN0aW9uYCkuXG5cdFx0dGhpcy5fZW5zdXJlTG9hZGVkKCk7XG5cblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG5cdFx0Ly8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3Ncblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xuXHRcdFx0aW5pdENhbnZhcyhpdGVtLCBjb25maWcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdGNhbnZhcy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcblx0XHQvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG5cdFx0ZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwgKGxpc3RlbmVyW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCAoZXhwYW5kby5wcm94aWVzID0ge30pO1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCB7fTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XG5cdFx0aWYgKCFwcm94eSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9XG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5hZGRFdmVudCA9IGFkZExpc3RlbmVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5yZW1vdmVFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHBsYXRmb3JtX2RvbSQyLl9lbmFibGVkID8gcGxhdGZvcm1fZG9tJDIgOiBwbGF0Zm9ybV9iYXNpYztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXG4gKiBAc2luY2UgMi40LjBcbiAqL1xudmFyIHBsYXRmb3JtID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdCAqL1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG5cbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHt9XG59KTtcblxuLyoqXG4gKiBUaGUgcGx1Z2luIHNlcnZpY2Ugc2luZ2xldG9uXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcbiAqIEBzaW5jZSAyLjEuMFxuICovXG52YXIgY29yZV9wbHVnaW5zID0ge1xuXHQvKipcblx0ICogR2xvYmFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BsdWdpbnM6IFtdLFxuXG5cdC8qKlxuXHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xuXHQgKiBpbmNyZW1lbnRlZCBhbmQgZGVzY3JpcHRvcnMgYXJlIHJlZ2VuZXJhdGVkIGR1cmluZyBmb2xsb3dpbmcgQVBJIGNhbGxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NhY2hlSWQ6IDAsXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0cC5wdXNoKHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgb25seSBpZiByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVnaXN0ZXJlZCBwbHVnaW5zP1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuXHRub3RpZnk6IGZ1bmN0aW9uKGNoYXJ0LCBob29rLCBhcmdzKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0dmFyIGksIGRlc2NyaXB0b3IsIHBsdWdpbiwgcGFyYW1zLCBtZXRob2Q7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG5cdFx0XHRwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBjYWNoZSA9IGNoYXJ0LiRwbHVnaW5zIHx8IChjaGFydC4kcGx1Z2lucyA9IHt9KTtcblx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcblx0XHR9XG5cblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuXHRcdHZhciBjb25maWcgPSAoY2hhcnQgJiYgY2hhcnQuY29uZmlnKSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcblxuXHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xuXHRcdFx0aWYgKG9wdHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0ZGVzY3JpcHRvcnMucHVzaCh7XG5cdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNhY2hlLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XG5cdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcblx0fSxcblxuXHQvKipcblx0ICogSW52YWxpZGF0ZXMgY2FjaGUgZm9yIHRoZSBnaXZlbiBjaGFydDogZGVzY3JpcHRvcnMgaG9sZCBhIHJlZmVyZW5jZSBvbiBwbHVnaW4gb3B0aW9uLFxuXHQgKiBidXQgaW4gc29tZSBjYXNlcywgdGhpcyByZWZlcmVuY2UgY2FuIGJlIGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiB1cGRhdGluZyBvcHRpb25zLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRkZWxldGUgY2hhcnQuJHBsdWdpbnM7XG5cdH1cbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcblx0Ly8gU2NhbGUgcmVnaXN0cmF0aW9uIG9iamVjdC4gRXh0ZW5zaW9ucyBjYW4gcmVnaXN0ZXIgbmV3IHNjYWxlIHR5cGVzIChzdWNoIGFzIGxvZyBvciBEQiBzY2FsZXMpIGFuZCB0aGVuXG5cdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxuXHQvLyBVc2UgYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gbW92ZSB0byBhbiBFUzYgbWFwIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gc3VwcG9ydFxuXHQvLyBvbGQgYnJvd3NlcnNcblxuXHQvLyBTY2FsZSBjb25maWcgZGVmYXVsdHNcblx0ZGVmYXVsdHM6IHt9LFxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xuXHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xuXHR9LFxuXHRnZXRTY2FsZUNvbnN0cnVjdG9yOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XG5cdH0sXG5cdGdldFNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKHt9LCBbY29yZV9kZWZhdWx0cy5zY2FsZSwgdGhpcy5kZWZhdWx0c1t0eXBlXV0pIDoge307XG5cdH0sXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0fVxuXHR9LFxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHQvLyBBZGRzIGVhY2ggc2NhbGUgdG8gdGhlIGNoYXJ0LmJveGVzIGFycmF5IHRvIGJlIHNpemVkIGFjY29yZGluZ2x5XG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgc2NhbGUpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRvb2x0aXBzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycyQxLm5vb3AsXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cdFx0XHRcdFx0aWYgKGl0ZW0ubGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS5sYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ueExhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRvb2x0aXBJdGVtLnZhbHVlKSkge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxDb2xvcjogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGFjdGl2ZUVsZW1lbnQgPSBtZXRhLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmlldyA9IGFjdGl2ZUVsZW1lbnQuX3ZpZXc7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IHZpZXcuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiB2aWV3LmJhY2tncm91bmRDb2xvclxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsVGV4dENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcblx0XHRcdH0sXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0YWZ0ZXJGb290ZXI6IGhlbHBlcnMkMS5ub29wXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIHBvc2l0aW9uZXJzID0ge1xuXHQvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0RWxlbWVudFtdfSB0aGUgZWxlbWVudHMgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaSwgbGVuO1xuXHRcdHZhciB4ID0gMDtcblx0XHR2YXIgeSA9IDA7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0eSArPSBwb3MueTtcblx0XHRcdFx0Kytjb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCAvIGNvdW50LFxuXHRcdFx0eTogeSAvIGNvdW50XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSBldmVudFBvc2l0aW9uIHtvYmplY3R9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0b29sdGlwIHBvc2l0aW9uXG5cdCAqL1xuXHRuZWFyZXN0OiBmdW5jdGlvbihlbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuXHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0XHR2YXIgZCA9IGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdFx0XHRpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmVhcmVzdEVsZW1lbnQpIHtcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0eCA9IHRwLng7XG5cdFx0XHR5ID0gdHAueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG5cdGlmICh0b1B1c2gpIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xuXHRcdFx0Ly8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiYXNlLnB1c2godG9QdXNoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XG5cdHZhciB4U2NhbGUgPSBlbGVtZW50Ll94U2NhbGU7XG5cdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHR2YXIgZGF0YXNldEluZGV4ID0gZWxlbWVudC5fZGF0YXNldEluZGV4O1xuXHR2YXIgY29udHJvbGxlciA9IGVsZW1lbnQuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XG5cdHZhciB2YWx1ZVNjYWxlID0gY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZSgpO1xuXG5cdHJldHVybiB7XG5cdFx0eExhYmVsOiB4U2NhbGUgPyB4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdHlMYWJlbDogeVNjYWxlID8geVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0dmFsdWU6IHZhbHVlU2NhbGUgPyAnJyArIHZhbHVlU2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGluZGV4OiBpbmRleCxcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHR4OiBlbGVtZW50Ll9tb2RlbC54LFxuXHRcdHk6IGVsZW1lbnQuX21vZGVsLnlcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB0b29sdGlwT3B0cyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxuXHRcdHlQYWRkaW5nOiB0b29sdGlwT3B0cy55UGFkZGluZyxcblx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcblxuXHRcdC8vIEJvZHlcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRib2R5Rm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcblxuXHRcdC8vIFRpdGxlXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X3RpdGxlRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXG5cdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdGZvb3RlclNwYWNpbmc6IHRvb2x0aXBPcHRzLmZvb3RlclNwYWNpbmcsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0b3BhY2l0eTogMCxcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHR2YXIgaGVpZ2h0ID0gbW9kZWwueVBhZGRpbmcgKiAyOyAvLyBUb29sdGlwIFBhZGRpbmdcblx0dmFyIHdpZHRoID0gMDtcblxuXHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0fSwgMCk7XG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcblx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0Ly8gVGl0bGUgd2lkdGhcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0fTtcblxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdH0pO1xuXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdC8vIEZvb3RlciB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBBZGQgcGFkZGluZ1xuXHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0cmV0dXJuIHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdHlBbGlnbiA9ICd0b3AnO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdH1cblxuXHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0fTtcblx0fVxuXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcblx0fTtcblx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XG5cdH07XG5cdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHR9O1xuXG5cdGlmIChsZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRyZXR1cm4ge1xuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHR2YXIgeCA9IHZtLng7XG5cdHZhciB5ID0gdm0ueTtcblxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggLT0gc2l6ZS53aWR0aDtcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XG5cdFx0XHR4ID0gY2hhcnQud2lkdGggLSBzaXplLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoeCA8IDApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR4OiB4LFxuXHRcdHk6IHlcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodm0sIGFsaWduKSB7XG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcblx0XHQ6IGFsaWduID09PSAncmlnaHQnXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG5cdHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxudmFyIGV4cG9ydHMkMyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9sYXN0QWN0aXZlID0gW107XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSB0aXRsZVxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0bGluZXM6IFtdLFxuXHRcdFx0XHRhZnRlcjogW11cblx0XHRcdH07XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBib2R5SXRlbXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHQvLyB3aGljaCBicmVha3MgYW55IGFuaW1hdGlvbnMuXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdHZhciBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcblx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0fTtcblx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcblx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0fTtcblxuXHRcdHZhciBpLCBsZW47XG5cblx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XG5cblx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwueSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0bW9kZWwubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXG5cdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxuXHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50LCBtZS5fY2hhcnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHR9XG5cblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblxuXHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcblxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XG5cblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcblx0fSxcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0fSxcblxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cblx0XHRpZiAodGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl90aXRsZUFsaWduO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHR2YXIgdGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XG5cdFx0XHR2YXIgdGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0udGl0bGVGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIHZtLl90aXRsZUZvbnRTdHlsZSwgdm0uX3RpdGxlRm9udEZhbWlseSk7XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aXRsZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGl0bGVbaV0sIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0aWYgKGkgKyAxID09PSB0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBib2R5Rm9udFNpemUgPSB2bS5ib2R5Rm9udFNpemU7XG5cdFx0dmFyIGJvZHlTcGFjaW5nID0gdm0uYm9keVNwYWNpbmc7XG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XG5cdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XG5cdFx0dmFyIGxhYmVsQ29sb3JzID0gdm0ubGFiZWxDb2xvcnM7XG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0dmFyIGNvbG9yWCA9IGRyYXdDb2xvckJveGVzID8gZ2V0QWxpZ25lZFgodm0sICdsZWZ0JykgOiAwO1xuXHRcdHZhciB0ZXh0Q29sb3I7XG5cblx0XHRjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XG5cblx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIGJvZHlBbGlnbik7XG5cblx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdHB0LnkgKz0gYm9keUZvbnRTaXplICsgYm9keVNwYWNpbmc7XG5cdFx0fTtcblxuXHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvZHlGb250Q29sb3I7XG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgJiYgYm9keUFsaWduICE9PSAncmlnaHQnXG5cdFx0XHQ/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm9keUZvbnRTaXplIC8gMiArIDEpIDogKGJvZHlGb250U2l6ZSArIDIpXG5cdFx0XHQ6IDA7XG5cblx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0Ly8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdm0ubGVnZW5kQ29sb3JCYWNrZ3JvdW5kO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclgsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIEJvcmRlclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gSW5uZXIgc3F1YXJlXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29sb3JYICsgMSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG5cdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcblx0fSxcblxuXHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRpZiAoZm9vdGVyLmxlbmd0aCkge1xuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xuXHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpIHtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHggPSBwdC54O1xuXHRcdHZhciB5ID0gcHQueTtcblx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHZtLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHB0ID0ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXG5cdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHQvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcblx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKTtcblxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxuXHRcdFx0cHQueSArPSB2bS55UGFkZGluZztcblxuXHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEJvZHlcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBGb290ZXJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuX2FjdGl2ZSwgbWUuX2xhc3RBY3RpdmUpO1xuXG5cdFx0Ly8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG5cdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBlLngsXG5cdFx0XHRcdFx0eTogZS55XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG59KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAqL1xudmFyIHBvc2l0aW9uZXJzXzEgPSBwb3NpdGlvbmVycztcblxudmFyIGNvcmVfdG9vbHRpcCA9IGV4cG9ydHMkMztcbmNvcmVfdG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzXzE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHt9LFxuXHRldmVudHM6IFtcblx0XHQnbW91c2Vtb3ZlJyxcblx0XHQnbW91c2VvdXQnLFxuXHRcdCdjbGljaycsXG5cdFx0J3RvdWNoc3RhcnQnLFxuXHRcdCd0b3VjaG1vdmUnXG5cdF0sXG5cdGhvdmVyOiB7XG5cdFx0b25Ib3ZlcjogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA0MDBcblx0fSxcblx0b25DbGljazogbnVsbCxcblx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0cmVzcG9uc2l2ZTogdHJ1ZSxcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXG59KTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVzYCBvcHRpb25cbiAqIGJ5IGluY29ycG9yYXRpbmcgc2NhbGUgZGVmYXVsdHMgaW4gYHhBeGVzYCBhbmQgYHlBeGVzYCBhcnJheSBpdGVtcywgdGhlblxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XG5cdFx0XHRcdHZhciBzbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuXHRcdFx0XHR2YXIgaSwgdHlwZSwgc2NhbGU7XG5cblx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcblx0XHRcdFx0XHR0eXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZS50eXBlLCBrZXkgPT09ICd4QXhlcycgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcicpO1xuXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XS5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldW2ldLnR5cGUgfHwgKHNjYWxlLnR5cGUgJiYgc2NhbGUudHlwZSAhPT0gdGFyZ2V0W2tleV1baV0udHlwZSkpIHtcblx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHR5cGUpLCBzY2FsZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgc2NhbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xuICogZGVmYXVsdCBzY2FsZSBvcHRpb25zIGZvciB0aGUgYHNjYWxlc2AgYW5kIGBzY2FsZWAgcHJvcGVydGllcywgdGhlbiByZXR1cm5zXG4gKiBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcblx0XHRcdFx0Ly8gc2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlU2NhbGVDb25maWcodHZhbCwgc3ZhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuXHRcdFx0XHQvLyB1c2VkIGluIHBvbGFyIGFyZWEgJiByYWRhciBjaGFydHMgc2luY2UgdGhlcmUgaXMgb25seSBvbmUgc2NhbGVcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzJDEubWVyZ2UodHZhbCwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIERvIE5PVCB1c2UgbWVyZ2VDb25maWcgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxuXHR2YXIgZGF0YSA9IGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdGNvbmZpZy5vcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjb25maWcudHlwZV0sXG5cdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xuXG5cdHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhjaGFydCkge1xuXHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cblx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHNjYWxlKTtcblx0fSk7XG5cblx0bmV3T3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY2hhcnQuY29uZmlnLnR5cGVdLFxuXHRcdG5ld09wdGlvbnMpO1xuXG5cdGNoYXJ0Lm9wdGlvbnMgPSBjaGFydC5jb25maWcub3B0aW9ucyA9IG5ld09wdGlvbnM7XG5cdGNoYXJ0LmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXG5cdC8vIFRvb2x0aXBcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XG5cdGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbn1cblxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdG1lLmlkID0gaGVscGVycyQxLnVpZCgpO1xuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcblx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdCAqIEBwcm9wIENoYXJ0I2NoYXJ0XG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0bWUuY29udHJvbGxlciA9IG1lOyAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cblxuXHRcdC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XG5cblx0XHQvLyBEZWZpbmUgYWxpYXMgdG8gdGhlIGNvbmZpZyBkYXRhOiBgY2hhcnQuZGF0YSA9PT0gY2hhcnQuY29uZmlnLmRhdGFgXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtZS5jb25maWcuZGF0YTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdG1lLmNvbmZpZy5kYXRhID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG5cdFx0XHQvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuXHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5pbml0aWFsaXplKCk7XG5cdFx0bWUudXBkYXRlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVJbml0Jyk7XG5cblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRtZS5iaW5kRXZlbnRzKCk7XG5cblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0bWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRcdG1lLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblx0XHRtZS5pbml0VG9vbFRpcCgpO1xuXG5cdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFN0b3BzIGFueSBjdXJyZW50IGFuaW1hdGlvbiBsb29wIG9jY3VycmluZ1xuXHRcdGNvcmVfYW5pbWF0aW9ucy5jYW5jZWxBbmltYXRpb24odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBhc3BlY3RSYXRpbyA9IChvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbWUuYXNwZWN0UmF0aW8pIHx8IG51bGw7XG5cblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XG5cdFx0Ly8gdGhlIGNhbnZhcyBkaXNwbGF5IHN0eWxlIHVzZXMgdGhlIHNhbWUgaW50ZWdlciB2YWx1ZXMgdG8gYXZvaWQgYmx1cnJpbmcgZWZmZWN0LlxuXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXG5cdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoKGNhbnZhcykpKTtcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XG5cblx0XHRpZiAobWUud2lkdGggPT09IG5ld1dpZHRoICYmIG1lLmhlaWdodCA9PT0gbmV3SGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdGlmICghc2lsZW50KSB7XG5cdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcblxuXHRcdFx0Ly8gTm90aWZ5IG9mIHJlc2l6ZVxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0b3B0aW9ucy5vblJlc2l6ZShtZSwgbmV3U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdG1lLnVwZGF0ZSh7XG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnhBeGVzLCBmdW5jdGlvbih4QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHR4QXhpc09wdGlvbnMuaWQgPSB4QXhpc09wdGlvbnMuaWQgfHwgKCd4LWF4aXMtJyArIGluZGV4KTtcblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IHlBeGlzT3B0aW9ucy5pZCB8fCAoJ3ktYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHR2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgaWQpIHtcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSwge30pO1xuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGVzKSB7XG5cdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB4QXhpc09wdGlvbnMsIGR0eXBlOiAnY2F0ZWdvcnknLCBkcG9zaXRpb246ICdib3R0b20nfTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeUF4aXNPcHRpb25zLCBkdHlwZTogJ2xpbmVhcicsIGRwb3NpdGlvbjogJ2xlZnQnfTtcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLnNjYWxlLFxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdGlzRGVmYXVsdDogdHJ1ZSxcblx0XHRcdFx0ZHBvc2l0aW9uOiAnY2hhcnRBcmVhJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG5cdFx0XHR2YXIgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cblx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcblx0XHRcdHZhciBzY2FsZSA9IG51bGw7XG5cdFx0XHRpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcblx0XHRcdFx0c2NhbGUub3B0aW9ucyA9IHNjYWxlT3B0aW9ucztcblx0XHRcdFx0c2NhbGUuY3R4ID0gbWUuY3R4O1xuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlQ2xhc3MgPSBjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdFx0dHlwZTogc2NhbGVUeXBlLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcblx0XHRcdFx0XHRjdHg6IG1lLmN0eCxcblx0XHRcdFx0XHRjaGFydDogbWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcblx0XHRcdH1cblxuXHRcdFx0c2NhbGUubWVyZ2VUaWNrc09wdGlvbnMoKTtcblxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHQvLyBhbmQgY29uc2lkZXIgaXQgYXMgYSByZWd1bGFyIHNjYWxlIHBhcnQgb2YgdGhlIFwic2NhbGVzXCJcIiBtYXAgb25seSEgVGhpcyB3b3VsZFxuXHRcdFx0Ly8gbWFrZSB0aGUgbG9naWMgZWFzaWVyIGFuZCByZW1vdmUgc29tZSB1c2VsZXNzPyBjdXN0b20gY29kZS5cblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRtZS5zY2FsZSA9IHNjYWxlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh1cGRhdGVkLCBmdW5jdGlvbihoYXNVcGRhdGVkLCBpZCkge1xuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBzY2FsZXNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bWUuc2NhbGVzID0gc2NhbGVzO1xuXG5cdFx0Y29yZV9zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcblxuXHRcdFx0aWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblxuXHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBDb250cm9sbGVyQ2xhc3MgPSBjb250cm9sbGVyc1ttZXRhLnR5cGVdO1xuXHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuXHRcdFx0fVxuXHRcdH0sIG1lKTtcblxuXHRcdHJldHVybiBuZXdDb250cm9sbGVycztcblx0fSxcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuXHRcdH0sIG1lKTtcblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXQncyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlc2V0RWxlbWVudHMoKTtcblx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dXBkYXRlQ29uZmlnKG1lKTtcblxuXHRcdC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdG1lLnRvb2x0aXAuX2RhdGEgPSBtZS5kYXRhO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcblx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLnVwZGF0ZUxheW91dCgpO1xuXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0aWYgKG1lLm9wdGlvbnMuYW5pbWF0aW9uICYmIG1lLm9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxuXHRcdC8vIGFmdGVyIHVwZGF0ZS5cblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcblxuXHRcdC8vIExhc3QgYWN0aXZlIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluIHRoZSB0b29sdGlwLlxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XG5cblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXG5cdFx0XHRcdGxhenk6IGNvbmZpZy5sYXp5XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5yZW5kZXIoY29uZmlnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGF5b3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb3JlX2xheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxuXHRcdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclNjYWxlVXBkYXRlXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1ldGEuY29udHJvbGxlci51cGRhdGUoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ4KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyUmVuZGVyJyk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XG5cdFx0fTtcblxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcblx0XHRcdFx0bnVtU3RlcHM6IGR1cmF0aW9uIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHR2YXIgc3RlcERlY2ltYWwgPSBjdXJyZW50U3RlcCAvIGFuaW1hdGlvbk9iamVjdC5udW1TdGVwcztcblxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcblx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvcmVfYW5pbWF0aW9ucy5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmNsZWFyKCk7XG5cblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoZWFzaW5nVmFsdWUpKSB7XG5cdFx0XHRlYXNpbmdWYWx1ZSA9IDE7XG5cdFx0fVxuXG5cdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRpZiAobWUud2lkdGggPD0gMCB8fCBtZS5oZWlnaHQgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgYWxsIHRoZSBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cdFx0bWUuX2RyYXdUb29sdGlwKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRmb3IgKHZhciBpID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5kcmF3RGF0YXNldChpLCBlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmF3RGF0YXNldDogZnVuY3Rpb24oaW5kZXgsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLmRyYXcoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyB0b29sdGlwIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVUb29sdGlwRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyVG9vbHRpcERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RyYXdUb29sdGlwOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVRvb2x0aXBEcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b29sdGlwLmRyYXcoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclRvb2x0aXBEcmF3JywgW2FyZ3NdKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XG5cdCAqL1xuXHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdFhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XG5cdFx0XHRkYXRhc2V0Ll9tZXRhID0ge307XG5cdFx0fVxuXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXTtcblx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXG5cdFx0XHRcdGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcblx0XHRcdFx0eUF4aXNJRDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YTtcblx0fSxcblxuXHRnZXRWaXNpYmxlRGF0YXNldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0aXNEYXRhc2V0VmlzaWJsZTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuXHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICF0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5oaWRkZW47XG5cdH0sXG5cblx0Z2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGEgJiYgZGF0YXNldC5fbWV0YVtpZF07XG5cblx0XHRpZiAobWV0YSkge1xuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuc3RvcCgpO1xuXG5cdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoaSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhbnZhcykge1xuXHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcblx0XHRcdHBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KG1lLmN0eCk7XG5cdFx0XHRtZS5jYW52YXMgPSBudWxsO1xuXHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xuXG5cdFx0ZGVsZXRlIENoYXJ0Lmluc3RhbmNlc1ttZS5pZF07XG5cdH0sXG5cblx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS50b29sdGlwID0gbmV3IGNvcmVfdG9vbHRpcCh7XG5cdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0X2NoYXJ0SW5zdGFuY2U6IG1lLCAvLyBkZXByZWNhdGVkLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRfZGF0YTogbWUuZGF0YSxcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xuXHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0fSk7XG5cblx0XHQvLyBFbGVtZW50cyB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZSBzaG91bGQgbm90IGJlIGluamVjdGVkIGZvciBub24gcmVzcG9uc2l2ZSBjaGFydHMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0bGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcblx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50cywgbW9kZSwgZW5hYmxlZCkge1xuXHRcdHZhciBtZXRob2QgPSBlbmFibGVkID8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbbWV0aG9kXShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBhbnkgdXBkYXRlIGNhbGxzIHNvIHRoYXQgcmVuZGVycyBkbyBub3Qgb2NjdXJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxuXHRcdC8vIHRoZSB0b29sdGlwIHNob3VsZCBiZSB0aGUgc291cmNlIG9mIGNoYW5nZVxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcblx0XHRcdFx0OiBjaGFuZ2VkIHwgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcblx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcblx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRtZS5yZW5kZXIoe1xuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0bGF6eTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0dmFyIGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIEludm9rZSBvbkhvdmVyIGhvb2tcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdH1cblxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxuICogd291bGQgbmVlZCB0byB3b3JrIG9uIG11bHRpcGxlIGNoYXJ0cz8hXG4gKi9cbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuY29uZmlnTWVyZ2UgPSBtZXJnZUNvbmZpZztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5zY2FsZU1lcmdlID0gbWVyZ2VTY2FsZUNvbmZpZztcblxudmFyIGNvcmVfaGVscGVycyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xuXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgYXJyYXlUb1NlYXJjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycyQxLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgoKHJvdW5kZWQgLSBlcHNpbG9uKSA8IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID4geCkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLmxvZzEwID0gTWF0aC5sb2cxMCA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTsgLy8gTWF0aC5MT0cxMEUgPSAxIC8gTWF0aC5MTjEwLlxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHdob2xlIHBvd2VycyBvZiAxMCxcblx0XHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxuXHRcdFx0dmFyIHBvd2VyT2YxMCA9IE1hdGgucm91bmQoZXhwb25lbnQpO1xuXHRcdFx0dmFyIGlzUG93ZXJPZjEwID0geCA9PT0gTWF0aC5wb3coMTAsIHBvd2VyT2YxMCk7XG5cblx0XHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xuXHRcdH07XG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdH07XG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQSBudW1iZXIuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGUgPSAxO1xuXHRcdHZhciBwID0gMDtcblx0XHR3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG5cdFx0XHRlICo9IDEwO1xuXHRcdFx0cCsrO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fTtcblxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuXHRoZWxwZXJzJDEuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG5cdFx0dmFyIHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbmdsZTogYW5nbGUsXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hbGlhc1BpeGVsXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XG5cdFx0cmV0dXJuIChwaXhlbFdpZHRoICUgMiA9PT0gMCkgPyAwIDogMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcblx0XHR2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuXHRcdHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcblx0fTtcblxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuXHRcdC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcblx0XHR2YXIgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuXG5cdFx0dmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50LnggLSBwcmV2aW91cy54LCAyKSArIE1hdGgucG93KGN1cnJlbnQueSAtIHByZXZpb3VzLnksIDIpKTtcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcblxuXHRcdHZhciBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cblx0XHQvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcblx0XHR2YXIgZmIgPSB0ICogczEyO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZXZpb3VzOiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHtcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLkVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRBZnRlci5tSyA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG5cdFx0XHRwb2ludEN1cnJlbnQubUsgPSBhbHBoYUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcblx0XHR2YXIgZGVsdGFYO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRDdXJyZW50Lm1vZGVsLnggLSBwb2ludEJlZm9yZS5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggKyBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcblx0XHRpZiAobG9vcCkge1xuXHRcdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdH07XG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzJDEubmljZU51bSA9IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHJhbmdlKSk7XG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHRcdHZhciBuaWNlRnJhY3Rpb247XG5cblx0XHRpZiAocm91bmQpIHtcblx0XHRcdGlmIChmcmFjdGlvbiA8IDEuNSkge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCA3KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDEuMCkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmljZUZyYWN0aW9uICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0fTtcblx0Ly8gUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGwgLSBodHRwczovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSgpKTtcblx0Ly8gLS0gRE9NIG1ldGhvZHNcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XG5cdFx0dmFyIG1vdXNlWCwgbW91c2VZO1xuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xuXHRcdHZhciBib3VuZGluZ1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcblx0XHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSBlLmNsaWVudFk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgbW91c2UgY29vcmRpbmF0ZXMgaW50byBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWxlZnQnKSk7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXRvcCcpKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctYm90dG9tJykpO1xuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcblx0XHRtb3VzZVggPSBNYXRoLnJvdW5kKChtb3VzZVggLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0KSAvICh3aWR0aCkgKiBjYW52YXMud2lkdGggLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IG1vdXNlWCxcblx0XHRcdHk6IG1vdXNlWVxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcblx0XHR2YXIgdmFsdWVJblBpeGVscztcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuXHRcdFx0XHR2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZUluUGl4ZWxzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXggd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBnaXZlbiBET00gbm9kZSBpbiBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSBmYXNoaW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbU5vZGUgLSB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwZXJjZW50YWdlUHJvcGVydHkgLSBwcm9wZXJ0eSBvZiBwYXJlbnQgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgd2lkdGggYXMgYSBwZXJjZW50YWdlXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3Nlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgbWF4U3R5bGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkge1xuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0dmFyIGNvbnN0cmFpbmVkTm9kZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcblx0XHR2YXIgaGFzQ0NvbnRhaW5lciA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZENvbnRhaW5lcik7XG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc0NOb2RlIHx8IGhhc0NDb250YWluZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbihcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxuXHRcdFx0XHRoYXNDQ29udGFpbmVyID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC13aWR0aCcsICdjbGllbnRXaWR0aCcpO1xuXHR9O1xuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG4gXHQgKi9cblx0aGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYWRkaW5nLCBwYXJlbnREaW1lbnNpb24pIHtcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XG5cblx0XHRyZXR1cm4gcGFkZGluZy5pbmRleE9mKCclJykgPiAtMSA/IHBhcmVudERpbWVuc2lvbiAqIHBhcnNlSW50KHBhZGRpbmcsIDEwKSAvIDEwMCA6IHBhcnNlSW50KHBhZGRpbmcsIDEwKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5ob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyZW50O1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1yaWdodCcsIGNsaWVudFdpZHRoKTtcblxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgY3cgPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoKGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjdykgPyB3IDogTWF0aC5taW4odywgY3cpO1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy10b3AnLCBjbGllbnRIZWlnaHQpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcblxuXHRcdHZhciBoID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGNoKSA/IGggOiBNYXRoLm1pbihoLCBjaCk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycyQxLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG5cdFx0aWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2hhcnQud2lkdGg7XG5cblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuXHRcdGlmICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSB7XG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHR9XG5cdH07XG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXG5cdGhlbHBlcnMkMS5mb250U3RyaW5nID0gZnVuY3Rpb24ocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXHR9O1xuXHRoZWxwZXJzJDEubG9uZ2VzdFRleHQgPSBmdW5jdGlvbihjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuXHRcdHZhciBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuXHRcdFx0ZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xuXHRcdH1cblxuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHR2YXIgbG9uZ2VzdCA9IDA7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0XHQvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKHRoaW5nLCBmdW5jdGlvbihuZXN0ZWRUaGluZykge1xuXHRcdFx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzJDEuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xuXHRcdFx0fVxuXHRcdFx0Z2Muc3BsaWNlKDAsIGdjTGVuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG5cdFx0aWYgKCF0ZXh0V2lkdGgpIHtcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5jb2xvciA9ICFjaGFydGpzQ29sb3IgP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xuXHRcdFx0Y29sb3JWYWx1ZSA6XG5cdFx0XHRoZWxwZXJzJDEuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXG5cdCk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxuICogQHR5cGVkZWYgeygnbWlsbGlzZWNvbmQnfCdzZWNvbmQnfCdtaW51dGUnfCdob3VyJ3wnZGF5J3wnd2Vlayd8J21vbnRoJ3wncXVhcnRlcid8J3llYXInKX1cbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBuYW1lIFVuaXRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIERhdGVBZGFwdGVyICovIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuXHQgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cblx0ICovXG5cdGZvcm1hdHM6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcblx0ICogQHJldHVybnMgeyhudW1iZXJ8bnVsbCl9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0cGFyc2U6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGZvcm1hdDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRhZGQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSB0aGUgdGltZXN0YW1wIHRvIHN1YnN0cmFjdFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGRpZmY6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcblx0ICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRzdGFydE9mOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGVuZE9mOiBhYnN0cmFjdCxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcblxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xudmFyIGNvcmVfdGlja3MgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3Ncblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHR2YXIgdGlja1N0cmluZyA9ICcnO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHZhciBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0pLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChNYXRoLmZsb29yKGxvZ1RpY2spIC0gTWF0aC5mbG9vcihsb2dEZWx0YSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2tTdHJpbmcgPSAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XG5cdFx0fSxcblxuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJzAnO1xuXHRcdFx0fSBlbHNlIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ5ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhbGUnLCB7XG5cdGRpc3BsYXk6IHRydWUsXG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cdG9mZnNldDogZmFsc2UsXG5cblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXG5cdGdyaWRMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcblx0XHRkcmF3VGlja3M6IHRydWUsXG5cdFx0dGlja01hcmtMZW5ndGg6IDEwLFxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXG5cdFx0emVyb0xpbmVDb2xvcjogJ3JnYmEoMCwwLDAsMC4yNSknLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0b2Zmc2V0R3JpZExpbmVzOiBmYWxzZSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHQvLyBzY2FsZSBsYWJlbFxuXHRzY2FsZUxhYmVsOiB7XG5cdFx0Ly8gZGlzcGxheSBwcm9wZXJ0eVxuXHRcdGRpc3BsYXk6IGZhbHNlLFxuXG5cdFx0Ly8gYWN0dWFsIGxhYmVsXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxuXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiA0LFxuXHRcdFx0Ym90dG9tOiA0XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxuXHRcdG1pblJvdGF0aW9uOiAwLFxuXHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRtaXJyb3I6IGZhbHNlLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRhdXRvU2tpcDogdHJ1ZSxcblx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG5cdFx0bWlub3I6IHt9LFxuXHRcdG1ham9yOiB7fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGFiZWxzRnJvbVRpY2tzKHRpY2tzKSB7XG5cdHZhciBsYWJlbHMgPSBbXTtcblx0dmFyIGksIGlsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxhYmVscy5wdXNoKHRpY2tzW2ldLmxhYmVsKTtcblx0fVxuXG5cdHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCk7XG5cblx0aWYgKG9mZnNldEdyaWRMaW5lcykge1xuXHRcdGlmIChzY2FsZS5nZXRUaWNrcygpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGluZVZhbHVlIC09IHNjYWxlLmlzSG9yaXpvbnRhbCgpID9cblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUubGVmdCwgc2NhbGUucmlnaHQgLSBsaW5lVmFsdWUpIDpcblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUudG9wLCBzY2FsZS5ib3R0b20gLSBsaW5lVmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4IC0gMSkpIC8gMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRleHRTaXplKGNvbnRleHQsIHRpY2ssIGZvbnQpIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHRpY2spID9cblx0XHRoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgZm9udCwgdGljaykgOlxuXHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG59XG5cbnZhciBjb3JlX3NjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtQYWRkaW5nfSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICovXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXG5cdFx0XHR0b3A6IG1lLnBhZGRpbmdUb3AgfHwgMCxcblx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cblx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90aWNrcztcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWxlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0aWYgKHRpY2tzLm1pbm9yID09PSBmYWxzZSkge1xuXHRcdFx0dGlja3MubWlub3IgPSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAodGlja3MubWFqb3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5tYWpvciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiB0aWNrcykge1xuXHRcdFx0aWYgKGtleSAhPT0gJ21ham9yJyAmJiBrZXkgIT09ICdtaW5vcicpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5taW5vcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1pbm9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWFqb3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aWNrcy5tYWpvcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBpbGVuLCBsYWJlbHMsIGxhYmVsLCB0aWNrcywgdGljaztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRib3R0b206IDBcblx0XHR9LCBtYXJnaW5zKTtcblxuXHRcdG1lLl9tYXhMYWJlbExpbmVzID0gMDtcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XG5cdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdC8vIERhdGEgbWluL21heFxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG5cblx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcblx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXG5cblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcblxuXHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxuXHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xuXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcblxuXHRcdC8vIElNUE9SVEFOVDogZnJvbSB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuXHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHR0aWNrID0gdGlja3NbaV07XG5cdFx0XHRpZiAoIXRpY2spIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aWNrID0ge1xuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRtYWpvcjogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuX3RpY2tzID0gdGlja3M7XG5cblx0XHQvLyBUaWNrIFJvdGF0aW9uXG5cdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBEYXRhIGxpbWl0c1xuXHRiZWZvcmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckRhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cdGJlZm9yZUJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQnVpbGRUaWNrcywgW3RoaXNdKTtcblx0fSxcblx0YnVpbGRUaWNrczogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIHRpY2tzIGlzIGVtcHR5IGZvciBvbGQgYXhpcyBpbXBsZW1lbnRhdGlvbnMgaGVyZVxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIHRpY2tzXSk7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcblx0XHRtZS50aWNrcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCBtZS50aWNrc10pIHx8IG1lLnRpY2tzO1xuXHRcdHJldHVybiB0aWNrcztcblx0fSxcblxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XG5cdH0sXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2Vcblx0XHQvLyBiZXR3ZWVuIHggb2Zmc2V0cyBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0Y29udGV4dC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGggJiYgbWUub3B0aW9ucy5kaXNwbGF5ICYmIG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxMYWJlbFdpZHRoID0gaGVscGVycyQxLmxvbmdlc3RUZXh0KGNvbnRleHQsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciBsYWJlbFdpZHRoID0gb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uLCBzaW5Sb3RhdGlvbjtcblxuXHRcdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcblx0XHRcdHZhciB0aWNrV2lkdGggPSBtZS5nZXRQaXhlbEZvclRpY2soMSkgLSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSA2O1xuXG5cdFx0XHQvLyBNYXggbGFiZWwgcm90YXRpb24gY2FuIGJlIHNldCBvciBkZWZhdWx0IHRvIDkwIC0gYWxzbyBhY3QgYXMgYSBsb29wIGNvdW50ZXJcblx0XHRcdHdoaWxlIChsYWJlbFdpZHRoID4gdGlja1dpZHRoICYmIGxhYmVsUm90YXRpb24gPCB0aWNrT3B0cy5tYXhSb3RhdGlvbikge1xuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhsYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0Y29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0aWYgKHNpblJvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoID4gbWUubWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0Ly8gZ28gYmFjayBvbmUgc3RlcFxuXHRcdFx0XHRcdGxhYmVsUm90YXRpb24tLTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxhYmVsUm90YXRpb24rKztcblx0XHRcdFx0bGFiZWxXaWR0aCA9IGNvc1JvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuXHR9LFxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG5cdH0sXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBSZXNldFxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblxuXHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5faXNWaXNpYmxlKCk7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbjtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgcGFyc2VGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udDtcblx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnQodGlja09wdHMpO1xuXHRcdHZhciB0aWNrTWFya0xlbmd0aCA9IG9wdHMuZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoO1xuXG5cdFx0Ly8gV2lkdGhcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgbWFyZ2lucyB0byBsaW5lIHVwIHdpdGggdGhlIGNoYXJ0QXJlYSBpZiB3ZSBhcmUgYSBmdWxsIHdpZHRoIHNjYWxlXG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1heFdpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodCA6IG1lLm1heFdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH1cblxuXHRcdC8vIGhlaWdodFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEFyZSB3ZSBzaG93aW5nIGEgdGl0bGUgZm9yIHRoZSBzY2FsZT9cblx0XHRpZiAoc2NhbGVMYWJlbE9wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnQoc2NhbGVMYWJlbE9wdHMpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0dmFyIGRlbHRhSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLmhlaWdodDtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG5cdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0dmFyIGxhcmdlc3RUZXh0V2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5zdHJpbmcsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHR2YXIgdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyA9IGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMobGFiZWxzKTtcblx0XHRcdHZhciBsaW5lU3BhY2UgPSB0aWNrRm9udC5zaXplICogMC41O1xuXHRcdFx0dmFyIHRpY2tQYWRkaW5nID0gbWUub3B0aW9ucy50aWNrcy5wYWRkaW5nO1xuXG5cdFx0XHQvLyBTdG9yZSBtYXggbnVtYmVyIG9mIGxpbmVzIGFuZCB3aWRlc3QgbGFiZWwgZm9yIF9hdXRvU2tpcFxuXHRcdFx0bWUuX21heExhYmVsTGluZXMgPSB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzO1xuXHRcdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSBsYXJnZXN0VGV4dFdpZHRoO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdC8vIFRPRE8gLSBpbXByb3ZlIHRoaXMgY2FsY3VsYXRpb25cblx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHQrICh0aWNrRm9udC5saW5lSGVpZ2h0ICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcylcblx0XHRcdFx0XHQrIGxpbmVTcGFjZTsgLy8gcGFkZGluZ1xuXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuXG5cdFx0XHRcdG1lLmN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXHRcdFx0XHR2YXIgZmlyc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzWzBdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgbGFzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGxhYmVscy5sZW5ndGggLSAxKTtcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG5cdFx0XHRcdGlmIChtZS5sYWJlbFJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBmaXJzdExhYmVsV2lkdGgpIDogKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKTtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpIDogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gZmlyc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQsIDApICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0LCAwKSArIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcblx0XHRcdFx0aWYgKHRpY2tPcHRzLm1pcnJvcikge1xuXHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVzZSBsaW5lU3BhY2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCArPSB0aWNrUGFkZGluZyArIGxpbmVTcGFjZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5tYXJnaW5zKSB7XG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0IC0gbWUubWFyZ2lucy5sZWZ0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wIC0gbWUubWFyZ2lucy50b3AsIDApO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0IC0gbWUubWFyZ2lucy5yaWdodCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSAtIG1lLm1hcmdpbnMuYm90dG9tLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3Rcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHQvLyBOdWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZpcnN0XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdGlmICgodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyB8fCByYXdWYWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRpZiAocmF3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLngpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFZhbHVlIGlzIGdvb2QsIHJldHVybiBpdFxuXHRcdHJldHVybiByYXdWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldFBpeGVsRm9yVmFsdWU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHBpeGVsXG5cdCAqL1xuXHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdFx0dmFyIHBpeGVsID0gKHRpY2tXaWR0aCAqIGluZGV4KSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHBpeGVsICs9IHRpY2tXaWR0aCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBwaXhlbDtcblx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdH1cblx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xuXHRcdHJldHVybiBtZS50b3AgKyAoaW5kZXggKiAoaW5uZXJIZWlnaHQgLyAobWUuX3RpY2tzLmxlbmd0aCAtIDEpKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yRGVjaW1hbDogZnVuY3Rpb24oZGVjaW1hbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChpbm5lcldpZHRoICogZGVjaW1hbCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHZhbHVlT2Zmc2V0O1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHJldHVybiBtZS50b3AgKyAoZGVjaW1hbCAqIG1lLmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcblx0fSxcblxuXHRnZXRCYXNlVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYXV0b1NraXA6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgdGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuXHRcdHZhciBza2lwUmF0aW8gPSBmYWxzZTtcblx0XHR2YXIgbWF4VGlja3MgPSBvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0O1xuXG5cdFx0Ly8gVG90YWwgc3BhY2UgbmVlZGVkIHRvIGRpc3BsYXkgYWxsIHRpY2tzLiBGaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmVcblx0XHQvLyBkcmF3biBhcyB0aGVpciBjZW50ZXIgYXQgZW5kIG9mIGF4aXMsIHNvIHRpY2tDb3VudC0xXG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gbWUuX3RpY2tTaXplKCkgKiAodGlja0NvdW50IC0gMSk7XG5cblx0XHQvLyBBeGlzIGxlbmd0aFxuXHRcdHZhciBheGlzTGVuZ3RoID0gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KVxuXHRcdFx0OiBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLlBhZGRpbmdCb3R0b20pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpLCB0aWNrO1xuXG5cdFx0aWYgKHRpY2tzTGVuZ3RoID4gYXhpc0xlbmd0aCkge1xuXHRcdFx0c2tpcFJhdGlvID0gMSArIE1hdGguZmxvb3IodGlja3NMZW5ndGggLyBheGlzTGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGV5IGRlZmluZWQgYSBtYXggbnVtYmVyIG9mIG9wdGlvblRpY2tzLFxuXHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRpZiAodGlja0NvdW50ID4gbWF4VGlja3MpIHtcblx0XHRcdHNraXBSYXRpbyA9IE1hdGgubWF4KHNraXBSYXRpbywgMSArIE1hdGguZmxvb3IodGlja0NvdW50IC8gbWF4VGlja3MpKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblxuXHRcdFx0aWYgKHNraXBSYXRpbyA+IDEgJiYgaSAlIHNraXBSYXRpbyA+IDApIHtcblx0XHRcdFx0Ly8gbGVhdmUgdGljayBpbiBwbGFjZSBidXQgbWFrZSBzdXJlIGl0J3Mgbm90IGRpc3BsYXllZCAoIzQ2MzUpXG5cdFx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2godGljayk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdGlja1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHZhciByb3QgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdHZhciBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuXHRcdHZhciB3ID0gKG1lLmxvbmdlc3RMYWJlbFdpZHRoICsgcGFkZGluZykgfHwgMDtcblxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9uVGlja3MpO1xuXHRcdHZhciBoID0gKG1lLl9tYXhMYWJlbExpbmVzICogdGlja0ZvbnQubGluZUhlaWdodCArIHBhZGRpbmcpIHx8IDA7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0cmV0dXJuIGlzSG9yaXpvbnRhbFxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuXHRcdFx0cmV0dXJuICEhZGlzcGxheTtcblx0XHR9XG5cblx0XHQvLyBXaGVuICdhdXRvJywgdGhlIHNjYWxlIGlzIHZpc2libGUgaWYgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgZGF0YXNldCBpcyB2aXNpYmxlLlxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFjdHVhbGx5IGRyYXcgdGhlIHNjYWxlIG9uIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYSAtIHRoZSBhcmVhIG9mIHRoZSBjaGFydCB0byBkcmF3IGZ1bGwgZ3JpZCBsaW5lcyBvblxuXHQgKi9cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Rm9udENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcjtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBvcHRpb25NYWpvclRpY2tzID0gb3B0aW9ucy50aWNrcy5tYWpvciB8fCBvcHRpb25UaWNrcztcblx0XHR2YXIgZ3JpZExpbmVzID0gb3B0aW9ucy5ncmlkTGluZXM7XG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuXHRcdHZhciBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrcyA9IG9wdGlvblRpY2tzLmRpc3BsYXkgJiYgb3B0aW9uVGlja3MuYXV0b1NraXAgPyBtZS5fYXV0b1NraXAobWUuZ2V0VGlja3MoKSkgOiBtZS5nZXRUaWNrcygpO1xuXHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShvcHRpb25UaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuXHRcdHZhciBtYWpvclRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvbk1ham9yVGlja3MuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgbWFqb3JUaWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25NYWpvclRpY2tzKTtcblx0XHR2YXIgdGlja1BhZGRpbmcgPSBvcHRpb25UaWNrcy5wYWRkaW5nO1xuXHRcdHZhciBsYWJlbE9mZnNldCA9IG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuXG5cdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHR2YXIgc2NhbGVMYWJlbEZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGVMYWJlbC5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsKTtcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHR2YXIgbGFiZWxSb3RhdGlvblJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0dmFyIGl0ZW1zVG9EcmF3ID0gW107XG5cblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xuXHRcdHZhciBib3JkZXJWYWx1ZSwgdGlja1N0YXJ0LCB0aWNrRW5kO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gYm9yZGVyVmFsdWUgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0dGlja0VuZCA9IG1lLnRvcCArIHRsO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR0aWNrRW5kID0gYm9yZGVyVmFsdWUgLSBheGlzV2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUubGVmdCArIHRsO1xuXHRcdH1cblxuXHRcdHZhciBlcHNpbG9uID0gMC4wMDAwMDAxOyAvLyAwLjAwMDAwMDEgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgQWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRoZWxwZXJzJDEuZWFjaCh0aWNrcywgZnVuY3Rpb24odGljaywgaW5kZXgpIHtcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aWNrLmxhYmVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYWJlbCA9IHRpY2subGFiZWw7XG5cdFx0XHR2YXIgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRpZiAoaW5kZXggPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIGluZGV4KTtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoIHx8IFtdO1xuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gcHJvcGVydGllc1xuXHRcdFx0dmFyIHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTIsIGxhYmVsWCwgbGFiZWxZLCB0ZXh0T2Zmc2V0LCB0ZXh0QWxpZ247XG5cdFx0XHR2YXIgbGFiZWxDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG5cdFx0XHR2YXIgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBsYWJlbFlPZmZzZXQgPSB0bCArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS5sZWZ0IC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cdFx0XHRcdHR5MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHkyID0gdGlja0VuZDtcblx0XHRcdFx0bGFiZWxYID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0OyAvLyB4IHZhbHVlcyBmb3Igb3B0aW9uVGlja3MgKG5lZWQgdG8gY29uc2lkZXIgb2Zmc2V0TGFiZWwgb3B0aW9uKVxuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHR5MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS50b3AsIGF4aXNXaWR0aCkgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCghaXNSb3RhdGVkID8gMC41IDogMSkgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ2xlZnQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLmJvdHRvbSAtIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5MSA9IGNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEuYm90dG9tLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCFpc1JvdGF0ZWQgPyAwLjUgOiAwKSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsYWJlbFhPZmZzZXQgPSAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRpZiAobGluZVZhbHVlIDwgbWUudG9wIC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHgyID0gdGlja0VuZDtcblx0XHRcdFx0dHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0bGFiZWxZID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0O1xuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEubGVmdCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eDIgPSBjaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcblx0XHRcdFx0XHR4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5yaWdodCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUubGVmdCArIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpdGVtc1RvRHJhdy5wdXNoKHtcblx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0bGFiZWxYOiBsYWJlbFgsXG5cdFx0XHRcdGxhYmVsWTogbGFiZWxZLFxuXHRcdFx0XHRnbFdpZHRoOiBsaW5lV2lkdGgsXG5cdFx0XHRcdGdsQ29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0Z2xCb3JkZXJEYXNoOiBib3JkZXJEYXNoLFxuXHRcdFx0XHRnbEJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdHJvdGF0aW9uOiAtMSAqIGxhYmVsUm90YXRpb25SYWRpYW5zLFxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdG1ham9yOiB0aWNrLm1ham9yLFxuXHRcdFx0XHR0ZXh0T2Zmc2V0OiB0ZXh0T2Zmc2V0LFxuXHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGljayBsYWJlbHMsIHRpY2sgbWFya3MsIGFuZCBncmlkIGxpbmVzIGF0IHRoZSBjb3JyZWN0IHBsYWNlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGl0ZW1zVG9EcmF3LCBmdW5jdGlvbihpdGVtVG9EcmF3KSB7XG5cdFx0XHR2YXIgZ2xXaWR0aCA9IGl0ZW1Ub0RyYXcuZ2xXaWR0aDtcblx0XHRcdHZhciBnbENvbG9yID0gaXRlbVRvRHJhdy5nbENvbG9yO1xuXG5cdFx0XHRpZiAoZ3JpZExpbmVzLmRpc3BsYXkgJiYgZ2xXaWR0aCAmJiBnbENvbG9yKSB7XG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGdsV2lkdGg7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnbENvbG9yO1xuXHRcdFx0XHRpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0TGluZURhc2goaXRlbVRvRHJhdy5nbEJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LnR4MSwgaXRlbVRvRHJhdy50eTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcudHgyLCBpdGVtVG9EcmF3LnR5Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcueDEsIGl0ZW1Ub0RyYXcueTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcueDIsIGl0ZW1Ub0RyYXcueTIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdGNvbnRleHQucm90YXRlKGl0ZW1Ub0RyYXcucm90YXRpb24pO1xuXHRcdFx0XHRjb250ZXh0LmZvbnQgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udC5zdHJpbmcgOiB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnRDb2xvciA6IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0dmFyIGxhYmVsID0gaXRlbVRvRHJhdy5sYWJlbDtcblx0XHRcdFx0dmFyIHkgPSBpdGVtVG9EcmF3LnRleHRPZmZzZXQ7XG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KCcnICsgbGFiZWxbaV0sIDAsIHkpO1xuXHRcdFx0XHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCB5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChzY2FsZUxhYmVsLmRpc3BsYXkpIHtcblx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHR2YXIgc2NhbGVMYWJlbFg7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFk7XG5cdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0dmFyIGhhbGZMaW5lSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCAvIDI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgKChtZS5yaWdodCAtIG1lLmxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHRzY2FsZUxhYmVsWSA9IHBvc2l0aW9uID09PSAnYm90dG9tJ1xuXHRcdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cblx0XHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XG5cdFx0XHRcdFx0PyBtZS5sZWZ0ICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3Bcblx0XHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgKChtZS5ib3R0b20gLSBtZS50b3ApIC8gMik7XG5cdFx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XG5cdFx0XHRjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gc2NhbGVMYWJlbEZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjb250ZXh0LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5zdHJpbmc7XG5cdFx0XHRjb250ZXh0LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xuXHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZSBhdCB0aGUgZWRnZSBvZiB0aGUgYXhpc1xuXHRcdFx0dmFyIGZpcnN0TGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgdGlja3MubGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkxID0geTIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkyID0gYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG5cdFx0XHRjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0cG9zaXRpb246ICdib3R0b20nXG59O1xuXG52YXIgc2NhbGVfY2F0ZWdvcnkgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdC8qKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHQqIGVsc2UgZmFsbCBiYWNrIHRvIGRhdGEubGFiZWxzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0bWUubWluSW5kZXggPSAwO1xuXHRcdG1lLm1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG5cdFx0dmFyIGZpbmRJbmRleDtcblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWluKTtcblx0XHRcdG1lLm1pbkluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1pbkluZGV4O1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtYXggdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWF4KTtcblx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGxhYmVsc1ttZS5taW5JbmRleF07XG5cdFx0bWUubWF4ID0gbGFiZWxzW21lLm1heEluZGV4XTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuXHRcdG1lLnRpY2tzID0gKG1lLm1pbkluZGV4ID09PSAwICYmIG1lLm1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWUubWluSW5kZXgsIG1lLm1heEluZGV4ICsgMSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cblx0XHRpZiAoY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gbWUuaWQpIHtcblx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lLnRpY2tzW2luZGV4IC0gbWUubWluSW5kZXhdO1xuXHR9LFxuXG5cdC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiAgVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHQvLyAxIGlzIGFkZGVkIGJlY2F1c2Ugd2UgbmVlZCB0aGUgbGVuZ3RoIGJ1dCB3ZSBoYXZlIHRoZSBpbmRleGVzXG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblxuXHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxuXHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHR2YWx1ZUNhdGVnb3J5ID0gbWUuaXNIb3Jpem9udGFsKCkgPyB2YWx1ZS54IDogdmFsdWUueTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHR2YXIgaWR4ID0gbGFiZWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgdmFsdWVXaWR0aCA9IG1lLndpZHRoIC8gb2Zmc2V0QW10O1xuXHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHdpZHRoT2Zmc2V0ICs9ICh2YWx1ZVdpZHRoIC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS5sZWZ0ICsgd2lkdGhPZmZzZXQ7XG5cdFx0fVxuXHRcdHZhciB2YWx1ZUhlaWdodCA9IG1lLmhlaWdodCAvIG9mZnNldEFtdDtcblx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKHZhbHVlSGVpZ2h0ICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdGhlaWdodE9mZnNldCArPSAodmFsdWVIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudG9wICsgaGVpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwpO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHR2YXIgaG9yeiA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciB2YWx1ZURpbWVuc2lvbiA9IChob3J6ID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gb2Zmc2V0QW10O1xuXG5cdFx0cGl4ZWwgLT0gaG9yeiA/IG1lLmxlZnQgOiBtZS50b3A7XG5cblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRwaXhlbCAtPSAodmFsdWVEaW1lbnNpb24gLyAyKTtcblx0XHR9XG5cblx0XHRpZiAocGl4ZWwgPD0gMCkge1xuXHRcdFx0dmFsdWUgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlICsgbWUubWluSW5kZXg7XG5cdH0sXG5cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMgPSBkZWZhdWx0Q29uZmlnO1xuc2NhbGVfY2F0ZWdvcnkuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuXG52YXIgbm9vcCA9IGhlbHBlcnMkMS5ub29wO1xudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3Ncblx0Ly8gZm9yIGRldGFpbHMuXG5cblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XG5cdHZhciBzdGVwU2l6ZSA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XG5cdHZhciBtaW4gPSBnZW5lcmF0aW9uT3B0aW9ucy5taW47XG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XG5cdHZhciBybWluID0gZGF0YVJhbmdlLm1pbjtcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdHZhciBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuXHQvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZihtaW4pICYmIGlzTnVsbE9yVW5kZWYobWF4KSkge1xuXHRcdHJldHVybiBbcm1pbiwgcm1heF07XG5cdH1cblxuXHRudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcblx0XHQvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuXHRcdHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuXHR9XG5cblx0aWYgKHN0ZXBTaXplIHx8IGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuXHRcdC8vIElmIGEgcHJlY2lzaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmYWN0b3IgYmFzZWQgb24gc3BhY2luZ1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0bmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1pbikgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1pbiAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1pbiA9IG1pbjtcblx0XHR9XG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1heCkgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1heCAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1heCA9IG1heDtcblx0XHR9XG5cdH1cblxuXHRudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuXHR9IGVsc2Uge1xuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xuXHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XG5cdH1cblx0dGlja3MucHVzaChpc051bGxPclVuZGVmKG1heCkgPyBuaWNlTWF4IDogbWF4KTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBzY2FsZV9saW5lYXJiYXNlID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XG5cdFx0Ly8gYXhpcywgdGhleSBjYW4gbWFudWFsbHkgb3ZlcnJpZGUgaXRcblx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcblx0XHRcdHZhciBtYXhTaWduID0gaGVscGVycyQxLnNpZ24obWUubWF4KTtcblxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIHRvcCB1cCB0byAwXG5cdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIGJvdHRvbSBkb3duIHRvIDBcblx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHNldE1heCA9IHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5taW47XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5zdWdnZXN0ZWRNaW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIHRpY2tPcHRzLnN1Z2dlc3RlZE1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNldE1pbiAhPT0gc2V0TWF4KSB7XG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cblx0XHRcdC8vIFNvIGVuc3VyZSB0aGF0IG91ciByYW5nZSBpcyBnb29kXG5cdFx0XHQvLyBJbnZlcnRlZCBvciAwIGxlbmd0aCByYW5nZSBjYW4gaGFwcGVuIHdoZW5cblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxuXHRcdFx0aWYgKG1lLm1pbiA+PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKHNldE1pbikge1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWF4IC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdGlmICghdGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0bWUubWluLS07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBzdGVwU2l6ZSA9IHRpY2tPcHRzLnN0ZXBTaXplO1xuXHRcdHZhciBtYXhUaWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdDtcblx0XHR2YXIgbWF4VGlja3M7XG5cblx0XHRpZiAoc3RlcFNpemUpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF4VGlja3MgPSBtZS5fY29tcHV0ZVRpY2tMaW1pdCgpO1xuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXhUaWNrcztcblx0fSxcblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0fSxcblxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuXHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuXHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuXHRcdHZhciBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuXHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0dmFyIG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuXHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRtYXg6IHRpY2tPcHRzLm1heCxcblx0XHRcdHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgbWUpO1xuXG5cdFx0bWUuaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzKCk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRtZS56ZXJvTGluZUluZGV4ID0gbWUudGlja3MuaW5kZXhPZigwKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9XG59O1xuXG52YXIgc2NhbGVfbGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxO1xuXG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBGaXJzdCBDYWxjdWxhdGUgdGhlIHJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlczogW10sXG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlc2UgcGVyIHR5cGVcblx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0dmFyIG5lZ2F0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5uZWdhdGl2ZVZhbHVlcztcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gcG9zaXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gPSBuZWdhdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gMTAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc0ZvclR5cGUucG9zaXRpdmVWYWx1ZXMuY29uY2F0KHZhbHVlc0ZvclR5cGUubmVnYXRpdmVWYWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycyQxLm1heCh2YWx1ZXMpO1xuXHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5taW4gPSBpc0Zpbml0ZShtZS5taW4pICYmICFpc05hTihtZS5taW4pID8gbWUubWluIDogREVGQVVMVF9NSU47XG5cdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tGb250O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xuXHRcdH1cblx0XHR0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobWUub3B0aW9ucy50aWNrcyk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcblx0fSxcblxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHQvLyBVdGlsc1xuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0Ly8gdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5yaWdodCwgYW5kIHRoaXMuYm90dG9tIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdHZhciByaWdodFZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdHZhciBwaXhlbDtcblx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKG1lLndpZHRoIC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgb2Zmc2V0ID0gKGlzSG9yaXpvbnRhbCA/IHBpeGVsIC0gbWUubGVmdCA6IG1lLmJvdHRvbSAtIHBpeGVsKSAvIGlubmVyRGltZW5zaW9uO1xuXHRcdHJldHVybiBtZS5zdGFydCArICgobWUuZW5kIC0gbWUuc3RhcnQpICogb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMSA9IGRlZmF1bHRDb25maWckMTtcbnNjYWxlX2xpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cblx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWF4KSk7XG5cdHZhciBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuXHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcblxuXHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW5Ob3RaZXJvIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSBlbHNlIHtcblx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdH1cblx0dmFyIHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuXG5cdGRvIHtcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0KytzaWduaWZpY2FuZDtcblx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHQrK2V4cDtcblx0XHRcdHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcblx0XHR9XG5cblx0XHR0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQkYShnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDIgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdH1cbn07XG5cbi8vIFRPRE8odjMpOiBjaGFuZ2UgdGhpcyB0byBwb3NpdGl2ZU9yRGVmYXVsdFxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gfHwgdmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc0ZvclR5cGUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gMCAmJiAobWUubWluTm90WmVybyA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1lLm1pbk5vdFplcm8pKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4XG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBERUZBVUxUX01JTiA9IDE7XG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XG5cblx0XHRtZS5taW4gPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4sIG1lLm1pbik7XG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgLSAxKTtcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcblx0XHRcdFx0bWUubWF4ID0gREVGQVVMVF9NQVg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSAtIDEpO1xuXHRcdH1cblx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcblx0XHRcdFx0PyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgKyAxKVxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xuXHRcdH1cblx0XHRpZiAobWUubWluTm90WmVybyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSBpZiAobWUubWF4IDwgMSkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIGdlbmVyYXRpb25PcHRpb25zID0ge1xuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHJldmVyc2UgPSAhcmV2ZXJzZTtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tWYWx1ZXNbaW5kZXhdKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRpY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIG5vdCB6ZXJvIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh2YWx1ZSkpO1xuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHRyZXR1cm4gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHBpeGVsLCBzdGFydCwgZW5kLCBzaWduO1xuXG5cdFx0dmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0XHRzaWduID0gMTtcblx0XHR9XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0cGl4ZWwgPSByZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHNpZ24gKj0gLTE7IC8vIGludmVydCwgc2luY2UgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMgaXMgYXQgcGl4ZWwgKDAsIDApXG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS50b3AgOiBtZS5ib3R0b207XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHRvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyRGltZW5zaW9uIC8gKGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCkpICogKGxvZzEwKHZhbHVlKSAtIGxvZzEwKHN0YXJ0KSk7XG5cdFx0XHR9XG5cdFx0XHRwaXhlbCArPSBzaWduICogb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHRcdHZhciBsb2cxMCA9IGhlbHBlcnMkMS5sb2cxMDtcblx0XHR2YXIgZmlyc3RUaWNrVmFsdWUgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uLCBzdGFydCwgZW5kLCB2YWx1ZTtcblxuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRzdGFydCA9IG1lLmVuZDtcblx0XHRcdGVuZCA9IG1lLnN0YXJ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0ZW5kID0gbWUuZW5kO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHR2YWx1ZSA9IHJldmVyc2UgPyBtZS5yaWdodCAtIHBpeGVsIDogcGl4ZWwgLSBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IHBpeGVsIC0gbWUudG9wIDogbWUuYm90dG9tIC0gcGl4ZWw7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYSh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFsdWUgLT0gb2Zmc2V0O1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSAqPSBsb2cxMChlbmQpIC0gbG9nMTAoc3RhcnQpO1xuXHRcdFx0dmFsdWUgLz0gaW5uZXJEaW1lbnNpb247XG5cdFx0XHR2YWx1ZSA9IE1hdGgucG93KDEwLCBsb2cxMChzdGFydCkgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQyID0gZGVmYXVsdENvbmZpZyQyO1xuc2NhbGVfbG9nYXJpdGhtaWMuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDI7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRiID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDcgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xuXHRkaXNwbGF5OiB0cnVlLFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG5cdGFuaW1hdGU6IHRydWUsXG5cdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuXHRhbmdsZUxpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdGdyaWRMaW5lczoge1xuXHRcdGNpcmN1bGFyOiBmYWxzZVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcblx0XHRzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXG5cdFx0YmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC43NSknLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWTogMixcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdYOiAyLFxuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0fSxcblxuXHRwb2ludExhYmVsczoge1xuXHRcdC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHQvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG5cdFx0Zm9udFNpemU6IDEwLFxuXG5cdFx0Ly8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUNvdW50KHNjYWxlKSB7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0cmV0dXJuIG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSA/IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG5cdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG5cdFx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSkgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMjtcblx0fVxuXHRyZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGxpbmVIZWlnaHQsIGxhYmVsKSB7XG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogaGVscGVycyQxLmxvbmdlc3RUZXh0KGN0eCwgY3R4LmZvbnQsIGxhYmVsKSxcblx0XHRcdGg6IGxhYmVsLmxlbmd0aCAqIGxpbmVIZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR3OiBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxuXHRcdGg6IGxpbmVIZWlnaHRcblx0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG5cdGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG5cdFx0XHRlbmQ6IHBvcyArIChzaXplIC8gMilcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplLFxuXHRcdFx0ZW5kOiBwb3Ncblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdGFydDogcG9zLFxuXHRcdGVuZDogcG9zICsgc2l6ZVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcblx0Ly8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG5cdC8vXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcblx0Ly9cblx0Ly8gU29sdXRpb246XG5cdC8vXG5cdC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuXHQvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuXHQvL1xuXHQvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuXHQvL1xuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcblx0Ly8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuXHQvL1xuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuXHQvLyBhbG9uZyB3aXRoIGxhYmVscy5cblx0Ly9cblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuXHQvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cblx0Ly9cblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG5cdC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG5cdC8vXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMpO1xuXG5cdC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuXHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xuXHRcdGw6IDAsXG5cdFx0cjogc2NhbGUud2lkdGgsXG5cdFx0dDogMCxcblx0XHRiOiBzY2FsZS5oZWlnaHQgLSBzY2FsZS5wYWRkaW5nVG9wXG5cdH07XG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuXHR2YXIgaSwgdGV4dFNpemUsIHBvaW50UG9zaXRpb247XG5cblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xuXHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzID0gW107XG5cblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgNSk7XG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnKTtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cdH1cblxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdHJldHVybiAnY2VudGVyJztcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdHJldHVybiAnbGVmdCc7XG5cdH1cblxuXHRyZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xuXHR2YXIgeSA9IHBvc2l0aW9uLnkgKyBsaW5lSGVpZ2h0IC8gMjtcblx0dmFyIGksIGlsZW47XG5cblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCB5KTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRwb3NpdGlvbi55IC09ICh0ZXh0U2l6ZS5oIC8gMik7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0fVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgYW5nbGVMaW5lT3B0cyA9IG9wdHMuYW5nbGVMaW5lcztcblx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHR2YXIgcG9pbnRMYWJlbE9wdHMgPSBvcHRzLnBvaW50TGFiZWxzO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkYihhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aCwgZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCk7XG5cdHZhciBsaW5lQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMuY29sb3IsIGdyaWRMaW5lT3B0cy5jb2xvcik7XG5cdHZhciB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG5cblx0Y3R4LnNhdmUoKTtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKHJlc29sdmUkNyhbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoLCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaCwgW11dKSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcblx0fVxuXG5cdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHQvLyBQb2ludCBMYWJlbCBGb250XG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHBvaW50TGFiZWxPcHRzKTtcblxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRmb3IgKHZhciBpID0gZ2V0VmFsdWVDb3VudChzY2FsZSkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmIChhbmdsZUxpbmVPcHRzLmRpc3BsYXkgJiYgbGluZVdpZHRoICYmIGxpbmVDb2xvcikge1xuXHRcdFx0dmFyIG91dGVyUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyKTtcblx0XHRcdGN0eC5saW5lVG8ob3V0ZXJQb3NpdGlvbi54LCBvdXRlclBvc2l0aW9uLnkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHQvLyBFeHRyYSBwaXhlbHMgb3V0IGZvciBzb21lIGxhYmVsIHNwYWNpbmdcblx0XHRcdHZhciBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuXHRcdFx0dmFyIHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgNSk7XG5cblx0XHRcdC8vIEtlZXAgdGhpcyBpbiBsb29wIHNpbmNlIHdlIG1heSBzdXBwb3J0IGFycmF5IHByb3BlcnRpZXMgaGVyZVxuXHRcdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcblx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycsIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xuXHRcdH1cblx0fVxuXHRjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdHZhciBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cdHZhciBwb2ludFBvc2l0aW9uO1xuXG5cdGlmICgoIWNpcmN1bGFyICYmICF2YWx1ZUNvdW50KSB8fCAhbGluZUNvbG9yIHx8ICFsaW5lV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHguc2F2ZSgpO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYgKGNpcmN1bGFyKSB7XG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuXHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cblxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cdFx0bWUucGFkZGluZ1RvcCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChtZS5vcHRpb25zKSAvIDI7XG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3AsIG1lLndpZHRoKSAvIDI7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBtZSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0fSxcblxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG5cdH0sXG5cblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gKE1hdGguUEkgKiAyKSAvIGdldFZhbHVlQ291bnQodGhpcyk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgdGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgP1xuXHRcdFx0dGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgOlxuXHRcdFx0MDtcblxuXHRcdHZhciBzdGFydEFuZ2xlUmFkaWFucyA9IHN0YXJ0QW5nbGUgKiBNYXRoLlBJICogMiAvIDM2MDtcblxuXHRcdC8vIFN0YXJ0IGZyb20gdGhlIHRvcCBpbnN0ZWFkIG9mIHJpZ2h0LCBzbyByZW1vdmUgYSBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblx0XHRyZXR1cm4gaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlUmFkaWFucztcblx0fSxcblxuXHRnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gMDsgLy8gbnVsbCBhbHdheXMgaW4gY2VudGVyXG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fVxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcblx0XHRcdHk6IE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0fSxcblxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLFxuXHRcdFx0bWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MCk7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblxuXHRcdFx0aWYgKG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdC8vIERvbid0IGRyYXcgYSBjZW50cmUgdmFsdWUgKGlmIGl0IGlzIG1pbmltdW0pXG5cdFx0XHRcdGlmIChpbmRleCA+IDAgfHwgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHZhciB5Q2VudGVyT2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0XHRcdC8vIERyYXcgY2lyY3VsYXIgbGluZXMgYXJvdW5kIHRoZSBzY2FsZVxuXHRcdFx0XHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSAmJiBpbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG5cblx0XHRcdFx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrT3B0cy5iYWNrZHJvcENvbG9yO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoXG5cdFx0XHRcdFx0XHRcdFx0LWxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHQteUNlbnRlck9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFdpZHRoICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCAqIDIsXG5cdFx0XHRcdFx0XHRcdFx0dGlja0ZvbnQuc2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCAwLCAteUNlbnRlck9mZnNldCk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDMgPSBkZWZhdWx0Q29uZmlnJDM7XG5zY2FsZV9yYWRpYWxMaW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRjID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbnZhciBJTlRFUlZBTFMgPSB7XG5cdG1pbGxpc2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIDI1MCwgNTAwXVxuXHR9LFxuXHRzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMTAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdG1pbnV0ZToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdGhvdXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMzYwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDYsIDEyXVxuXHR9LFxuXHRkYXk6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHR9LFxuXHR3ZWVrOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA2MDQ4MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHRtb250aDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAyLjYyOGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgM11cblx0fSxcblx0cXVhcnRlcjoge1xuXHRcdGNvbW1vbjogZmFsc2UsXG5cdFx0c2l6ZTogNy44ODRlOSxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdHllYXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcbiAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cbiAqIGFuZCBtYXggcmFuZ2UsIHNvIGJhc2ljYWxseSwgdGhlIHRhYmxlIHdpbGwgY29udGFpbnMgb25seSB0d28gaXRlbXM6IHttaW4sIDB9IGFuZCB7bWF4LCAxfS5cbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxuICogYmVzdCBjYXNlLCBhbGwgdGltZXN0YW1wcyBhcmUgbGluZWFyLCB0aGUgdGFibGUgY29udGFpbnMgb25seSBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XG5cdGlmIChkaXN0cmlidXRpb24gPT09ICdsaW5lYXInIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxuXHRcdFx0e3RpbWU6IG1heCwgcG9zOiAxfVxuXHRcdF07XG5cdH1cblxuXHR2YXIgdGFibGUgPSBbXTtcblx0dmFyIGl0ZW1zID0gW21pbl07XG5cdHZhciBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XG5cdFx0fVxuXHR9XG5cblx0aXRlbXMucHVzaChtYXgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRuZXh0ID0gaXRlbXNbaSArIDFdO1xuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xuXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuXHRcdFx0dGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWJsZTtcbn1cblxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuYW51amdha2hhci5jb20vMjAxNC8wMy8wMS9iaW5hcnktc2VhcmNoLWluLWphdmFzY3JpcHQvXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcblx0dmFyIGxvID0gMDtcblx0dmFyIGhpID0gdGFibGUubGVuZ3RoIC0gMTtcblx0dmFyIG1pZCwgaTAsIGkxO1xuXG5cdHdoaWxlIChsbyA+PSAwICYmIGxvIDw9IGhpKSB7XG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XG5cdFx0aTAgPSB0YWJsZVttaWQgLSAxXSB8fCBudWxsO1xuXHRcdGkxID0gdGFibGVbbWlkXTtcblxuXHRcdGlmICghaTApIHtcblx0XHRcdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGJlZm9yZSBmaXJzdCBpdGVtKVxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcblx0XHR9IGVsc2UgaWYgKGkxW2tleV0gPCB2YWx1ZSkge1xuXHRcdFx0bG8gPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XG5cdFx0XHRoaSA9IG1pZCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xuXHRcdH1cblx0fVxuXG5cdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGFmdGVyIGxhc3QgaXRlbSlcblx0cmV0dXJuIHtsbzogaTEsIGhpOiBudWxsfTtcbn1cblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxuICogcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBgdGtleWAgdmFsdWUuIEZvciBleGFtcGxlLCBpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCA0MiwgJ3BvcycpXG4gKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBmb3IgYSB0aW1lc3RhbXAgZXF1YWwgdG8gNDIuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlcyBhdFxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XG5cblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xuXHR2YXIgbmV4dCA9ICFyYW5nZS5sbyA/IHRhYmxlWzFdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMV0gOiByYW5nZS5oaTtcblxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xuXHR2YXIgcmF0aW8gPSBzcGFuID8gKHN2YWwgLSBwcmV2W3NrZXldKSAvIHNwYW4gOiAwO1xuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xuXG5cdHJldHVybiBwcmV2W3RrZXldICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzY2FsZSwgaW5wdXQpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciBwYXJzZXIgPSBvcHRpb25zLnBhcnNlcjtcblx0dmFyIGZvcm1hdCA9IHBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcblx0dmFyIHZhbHVlID0gaW5wdXQ7XG5cblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG5cdH1cblxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuXHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHR2YWx1ZSA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcblx0XHRcdDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAodmFsdWUgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gK3ZhbHVlO1xuXHR9XG5cblx0Ly8gTGFiZWxzIGFyZSBpbiBhbiBpbmNvbXBhdGlibGUgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cblx0aWYgKCFwYXJzZXIgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gZm9ybWF0KGlucHV0KTtcblxuXHRcdC8vIGBmb3JtYXRgIGNvdWxkIHJldHVybiBzb21ldGhpbmcgZWxzZSB0aGFuIGEgdGltZXN0YW1wLCBpZiBzbywgcGFyc2UgaXRcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGlucHV0KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciB2YWx1ZSA9IHRvVGltZXN0YW1wKHNjYWxlLCBzY2FsZS5nZXRSaWdodFZhbHVlKGlucHV0KSk7XG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XG5cdFx0dmFsdWUgPSArc2NhbGUuX2FkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgb3B0aW9ucy5yb3VuZCk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXQgdG8gc2tpcCB0byBiZSBhYmxlIHRvIGRpc3BsYXkgdXAgdG8gYGNhcGFjaXR5YCBudW1iZXIgb2YgdGlja3NcbiAqIGluIGB1bml0YCBmb3IgdGhlIGdpdmVuIGBtaW5gIC8gYG1heGAgcmFuZ2UgYW5kIHJlc3BlY3RpbmcgdGhlIGludGVydmFsIHN0ZXBzIGNvbnN0cmFpbnRzLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgY2FwYWNpdHkpIHtcblx0dmFyIHJhbmdlID0gbWF4IC0gbWluO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbdW5pdF07XG5cdHZhciBtaWxsaXNlY29uZHMgPSBpbnRlcnZhbC5zaXplO1xuXHR2YXIgc3RlcHMgPSBpbnRlcnZhbC5zdGVwcztcblx0dmFyIGksIGlsZW4sIGZhY3RvcjtcblxuXHRpZiAoIXN0ZXBzKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChyYW5nZSAvIChjYXBhY2l0eSAqIG1pbGxpc2Vjb25kcykpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHN0ZXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGZhY3RvciA9IHN0ZXBzW2ldO1xuXHRcdGlmIChNYXRoLmNlaWwocmFuZ2UgLyAobWlsbGlzZWNvbmRzICogZmFjdG9yKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWN0b3I7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcblxuXHRmb3IgKGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcblx0XHRmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzW2ludGVydmFsLnN0ZXBzLmxlbmd0aCAtIDFdIDogTUFYX0lOVEVHRVI7XG5cblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgdGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgdW5pdDtcblxuXHRmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcblx0XHR1bml0ID0gVU5JVFNbaV07XG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcbiAqIGBtaW5vcmAgdW5pdCwgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0IGFuZCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG4gKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHNjYWxlLCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xuXHR2YXIgbWFqb3IgPSBkZXRlcm1pbmVNYWpvclVuaXQobWlub3IpO1xuXHR2YXIgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUpO1xuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG5cdHZhciBtYWpvclRpY2tzRW5hYmxlZCA9IG9wdGlvbnMudGlja3MubWFqb3IuZW5hYmxlZDtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW21pbm9yXTtcblx0dmFyIGZpcnN0ID0gbWluO1xuXHR2YXIgbGFzdCA9IG1heDtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciB0aW1lO1xuXG5cdGlmICghc3RlcFNpemUpIHtcblx0XHRzdGVwU2l6ZSA9IGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCBtaW5vciwgY2FwYWNpdHkpO1xuXHR9XG5cblx0Ly8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuXHRpZiAod2Vla2RheSkge1xuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcblx0XHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QvbGFzdCB0aWNrcyBvbiB1bml0XG5cdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhc3QgdGljayBpbmNsdWRlIG1heFxuXHRpZiAobGFzdCA8IG1heCkge1xuXHRcdGxhc3QgPSArYWRhcHRlci5hZGQobGFzdCwgMSwgbWlub3IpO1xuXHR9XG5cblx0dGltZSA9IGZpcnN0O1xuXG5cdGlmIChtYWpvclRpY2tzRW5hYmxlZCAmJiBtYWpvciAmJiAhd2Vla2RheSAmJiAhdGltZU9wdHMucm91bmQpIHtcblx0XHQvLyBBbGlnbiB0aGUgZmlyc3QgdGljayBvbiB0aGUgcHJldmlvdXMgYG1pbm9yYCB1bml0IGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdDpcblx0XHQvLyB3ZSBmaXJzdCBhbGlnbmVkIHRpbWUgb24gdGhlIHByZXZpb3VzIGBtYWpvcmAgdW5pdCB0aGVuIGFkZCB0aGUgbnVtYmVyIG9mIGZ1bGxcblx0XHQvLyBzdGVwU2l6ZSB0aGVyZSBpcyBiZXR3ZWVuIGZpcnN0IGFuZCB0aGUgcHJldmlvdXMgbWFqb3IgdGltZS5cblx0XHR0aW1lID0gK2FkYXB0ZXIuc3RhcnRPZih0aW1lLCBtYWpvcik7XG5cdFx0dGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCB+figoZmlyc3QgLSB0aW1lKSAvIChpbnRlcnZhbC5zaXplICogc3RlcFNpemUpKSAqIHN0ZXBTaXplLCBtaW5vcik7XG5cdH1cblxuXHRmb3IgKDsgdGltZSA8IGxhc3Q7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSkge1xuXHRcdHRpY2tzLnB1c2goK3RpbWUpO1xuXHR9XG5cblx0dGlja3MucHVzaCgrdGltZSk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBlbmQgPSAwO1xuXHR2YXIgZmlyc3QsIGxhc3Q7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGlmICghb3B0aW9ucy50aW1lLm1pbikge1xuXHRcdFx0Zmlyc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzBdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhcnQgPSAoaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1sxXSwgJ3BvcycpIC0gZmlyc3QpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWF4KSB7XG5cdFx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xuXHRcdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRlbmQgPSBsYXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xufVxuXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIGksIGlsZW4sIHZhbHVlLCBtYWpvcjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdG1ham9yID0gbWFqb3JVbml0ID8gdmFsdWUgPT09ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBtYWpvclVuaXQpIDogZmFsc2U7XG5cblx0XHR0aWNrcy5wdXNoKHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdG1ham9yOiBtYWpvclxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyQ0ID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0LyoqXG5cdCAqIERhdGEgZGlzdHJpYnV0aW9uIGFsb25nIHRoZSBzY2FsZTpcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxuXHQgKiAtICdzZXJpZXMnOiBkYXRhIGFyZSBzcHJlYWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGRpc3RyaWJ1dGlvbjogJ2xpbmVhcicsXG5cblx0LyoqXG5cdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG5cdCAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGJvdW5kczogJ2RhdGEnLFxuXG5cdGFkYXB0ZXJzOiB7fSxcblx0dGltZToge1xuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdGZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURUQgZmFsc2UgPT0gZGF0ZSBvYmplY3RzLCBtb21lbnQgb2JqZWN0LCBjYWxsYmFjayBvciBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRkaXNwbGF5Rm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuXHRcdGRpc3BsYXlGb3JtYXRzOiB7fVxuXHR9LFxuXHR0aWNrczoge1xuXHRcdGF1dG9Ta2lwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdHNvdXJjZTogJ2F1dG8nLFxuXG5cdFx0bWFqb3I6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fVxuXHR9XG59O1xuXG52YXIgc2NhbGVfdGltZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lID0gb3B0aW9ucy50aW1lIHx8IChvcHRpb25zLnRpbWUgPSB7fSk7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XG5cblx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0aWYgKHRpbWUuZm9ybWF0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ29wdGlvbnMudGltZS5mb3JtYXQgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgb3B0aW9ucy50aW1lLnBhcnNlci4nKTtcblx0XHR9XG5cblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcblx0XHQvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuXHRcdC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcblx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXG5cdCAqL1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCByYXdWYWx1ZSk7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHR2YXIgdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgJ2RheSc7XG5cdFx0dmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciBkYXRhc2V0cyA9IFtdO1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wO1xuXHRcdHZhciBkYXRhTGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG5cblx0XHQvLyBDb252ZXJ0IGxhYmVscyB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFMYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGRhdGEgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGE7XG5cblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdChkYXRhWzBdKSkge1xuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKG1lLCBkYXRhW2pdKTtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV1bal0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2gobGFiZWxzW2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGgpIHtcblx0XHRcdC8vIFNvcnQgbGFiZWxzICoqYWZ0ZXIqKiBkYXRhIGhhdmUgYmVlbiBjb252ZXJ0ZWRcblx0XHRcdGxhYmVscyA9IGFycmF5VW5pcXVlKGxhYmVscykuc29ydChzb3J0ZXIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4obWluLCBsYWJlbHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcblx0XHR9XG5cblx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdHRpbWVzdGFtcHMgPSBhcnJheVVuaXF1ZSh0aW1lc3RhbXBzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdG1pbiA9IHBhcnNlKG1lLCB0aW1lT3B0cy5taW4pIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgdGltZU9wdHMubWF4KSB8fCBtYXg7XG5cblx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIHNldCBsaW1pdHMgYmFzZWQgb24gdW5pdCB0aW1lIG9wdGlvblxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcblx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl9ob3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0bWUuX3RhYmxlID0gW107XG5cdFx0bWUuX3RpbWVzdGFtcHMgPSB7XG5cdFx0XHRkYXRhOiB0aW1lc3RhbXBzLFxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxuXHRcdFx0bGFiZWxzOiBsYWJlbHNcblx0XHR9O1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xuXG5cdFx0c3dpdGNoIChvcHRpb25zLnRpY2tzLnNvdXJjZSkge1xuXHRcdGNhc2UgJ2RhdGEnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmRhdGE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbHMnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmxhYmVscztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2F1dG8nOlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWUsIG1pbiwgbWF4LCBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbiksIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0bWluID0gdGltZXN0YW1wc1swXTtcblx0XHRcdG1heCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcblx0XHR9XG5cblx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbWluO1xuXHRcdG1lLm1heCA9IG1heDtcblxuXHRcdC8vIFBSSVZBVEVcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCk7XG5cdFx0bWUuX21ham9yVW5pdCA9IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgb3B0aW9ucy5kaXN0cmlidXRpb24pO1xuXHRcdG1lLl9vZmZzZXRzID0gY29tcHV0ZU9mZnNldHMobWUuX3RhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpO1xuXG5cdFx0aWYgKG9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCB0aWNrcywgbWUuX21ham9yVW5pdCk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XG5cdFx0dmFyIHZhbHVlID0gZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5mb3JtYXQodG9UaW1lc3RhbXAobWUsIGxhYmVsKSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja0Zvcm1hdEZ1bmN0aW9uOiBmdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XG5cdFx0dmFyIG1ham9yVW5pdCA9IG1lLl9tYWpvclVuaXQ7XG5cdFx0dmFyIG1ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xuXHRcdHZhciBtYWpvclRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yVW5pdCk7XG5cdFx0dmFyIG1ham9yVGlja09wdHMgPSBvcHRpb25zLnRpY2tzLm1ham9yO1xuXHRcdHZhciBtYWpvciA9IG1ham9yVGlja09wdHMuZW5hYmxlZCAmJiBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGltZSA9PT0gbWFqb3JUaW1lO1xuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWFqb3IgPyBtYWpvclRpY2tPcHRzIDogb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgZm9ybWF0dGVyID0gdmFsdWVPckRlZmF1bHQkYyh0aWNrT3B0cy5jYWxsYmFjaywgdGlja09wdHMudXNlckNhbGxiYWNrKTtcblxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbih0aWNrc1tpXS52YWx1ZSwgaSwgdGlja3MpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc1JldmVyc2UgPSBtZS5vcHRpb25zLnRpY2tzLnJldmVyc2U7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gaXNSZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0IDogaXNSZXZlcnNlID8gbWUuYm90dG9tIDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XG5cdFx0dmFyIG9mZnNldCA9IHNpemUgKiAobWUuX29mZnNldHMuc3RhcnQgKyBwb3MpIC8gKG1lLl9vZmZzZXRzLnN0YXJ0ICsgMSArIG1lLl9vZmZzZXRzLmVuZCk7XG5cblx0XHRyZXR1cm4gaXNSZXZlcnNlID8gc3RhcnQgLSBvZmZzZXQgOiBzdGFydCArIG9mZnNldDtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHR9XG5cblx0XHRpZiAodGltZSA9PT0gbnVsbCkge1xuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldCh0aW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblx0XHRyZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCA/XG5cdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxuXHRcdFx0bnVsbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gbWUubGVmdCA6IG1lLnRvcDtcblx0XHR2YXIgcG9zID0gKHNpemUgPyAocGl4ZWwgLSBzdGFydCkgLyBzaXplIDogMCkgKiAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuc3RhcnQpIC0gbWUuX29mZnNldHMuZW5kO1xuXHRcdHZhciB0aW1lID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XG5cblx0XHQvLyBERVBSRUNBVElPTiwgd2Ugc2hvdWxkIHJldHVybiB0aW1lIGRpcmVjdGx5XG5cdFx0cmV0dXJuIG1lLl9hZGFwdGVyLl9jcmVhdGUodGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b1JhZGlhbnModGlja3NPcHRzLm1heFJvdGF0aW9uKTtcblx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblxuXHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXN0aW1hdGlvblxuXHRcdHZhciBmb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG5cdFx0dmFyIGV4YW1wbGVMYWJlbCA9IG1lLnRpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgW10sIGZvcm1hdCk7XG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuZ2V0TGFiZWxXaWR0aChleGFtcGxlTGFiZWwpO1xuXHRcdHZhciBpbm5lcldpZHRoID0gbWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKGlubmVyV2lkdGggLyB0aWNrTGFiZWxXaWR0aCk7XG5cblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDQgPSBkZWZhdWx0Q29uZmlnJDQ7XG5zY2FsZV90aW1lLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQ0O1xuXG52YXIgc2NhbGVzID0ge1xuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXG5cdGxpbmVhcjogc2NhbGVfbGluZWFyLFxuXHRsb2dhcml0aG1pYzogc2NhbGVfbG9nYXJpdGhtaWMsXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxuXHR0aW1lOiBzY2FsZV90aW1lXG59O1xuXG52YXIgRk9STUFUUyA9IHtcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcblx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJyxcblx0c2Vjb25kOiAnaDptbTpzcyBhJyxcblx0bWludXRlOiAnaDptbSBhJyxcblx0aG91cjogJ2hBJyxcblx0ZGF5OiAnTU1NIEQnLFxuXHR3ZWVrOiAnbGwnLFxuXHRtb250aDogJ01NTSBZWVlZJyxcblx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJyxcblx0eWVhcjogJ1lZWVknXG59O1xuXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG5cdF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRk9STUFUUztcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcblx0XHR9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuXHR9LFxuXG5cdGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihtb21lbnQobWF4KS5kaWZmKG1vbWVudChtaW4pKSkuYXModW5pdCk7XG5cdH0sXG5cblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xuXHRcdHRpbWUgPSBtb21lbnQodGltZSk7XG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xuXHR9LFxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBtYXBwZXJzID0ge1xuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0fTtcblx0fSxcblxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGJvdW5kYXJ5ID0gc291cmNlLmJvdW5kYXJ5O1xuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHR9XG5cblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdHN3aXRjaCAoZmlsbCkge1xuXHQvLyBjb21wYXRpYmlsaXR5XG5cdGNhc2UgJ2JvdHRvbSc6XG5cdFx0cmV0dXJuICdzdGFydCc7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0cmV0dXJuICdlbmQnO1xuXHRjYXNlICd6ZXJvJzpcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdGNhc2UgJ29yaWdpbic6XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0Y2FzZSAnZW5kJzpcblx0XHRyZXR1cm4gZmlsbDtcblx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0YXJnZXQgPSBudWxsO1xuXHR2YXIgaG9yaXpvbnRhbDtcblxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKCk7XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdH1cblxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmICghcHJvcGFnYXRlKSB7XG5cdFx0cmV0dXJuIGZpbGw7XG5cdH1cblxuXHR3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRmaWxsID0gdGFyZ2V0LmZpbGw7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpc0RyYXdhYmxlKHBvaW50KSB7XG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xuXHR2YXIgaTtcblxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdGN0eC5tb3ZlVG8oY3VydmUwWzBdLngsIGN1cnZlMFswXS55KTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2kgLSAxXSwgY3VydmUwW2ldKTtcblx0fVxuXG5cdC8vIGpvaW5pbmcgdGhlIHR3byBhcmVhIGN1cnZlc1xuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGxvb3ApIHtcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHR2YXIgY3VydmUwID0gW107XG5cdHZhciBjdXJ2ZTEgPSBbXTtcblx0dmFyIGxlbjAgPSAwO1xuXHR2YXIgbGVuMSA9IDA7XG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDE7XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoY291bnQgKyAhIWxvb3ApOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aW5kZXggPSBpICUgY291bnQ7XG5cdFx0cDAgPSBwb2ludHNbaW5kZXhdLl92aWV3O1xuXHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcblx0XHRkMSA9IGlzRHJhd2FibGUocDEpO1xuXG5cdFx0aWYgKGQwICYmIGQxKSB7XG5cdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcblx0XHR9IGVsc2UgaWYgKGxlbjAgJiYgbGVuMSkge1xuXHRcdFx0aWYgKCFzcGFuKSB7XG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXHRcdFx0XHRsZW4wID0gbGVuMSA9IDA7XG5cdFx0XHRcdGN1cnZlMCA9IFtdO1xuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkMCkge1xuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZDEpIHtcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0Y3R4LmZpbGwoKTtcbn1cblxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG5cdGlkOiAnZmlsbGVyJyxcblxuXHRhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xuXHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHRzb3VyY2UgPSBudWxsO1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xuXHRcdFx0XHRzb3VyY2UgPSB7XG5cdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXG5cdFx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRcdGVsOiBlbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG5cdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgcHJvcGFnYXRlKTtcblx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVEYXRhc2V0RHJhdzogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcblx0XHR2YXIgbWV0YSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIGVsID0gbWV0YS5lbDtcblx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdHZhciBwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0dmFyIG1hcHBlciA9IG1ldGEubWFwcGVyO1xuXHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuXHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMSA9IGhlbHBlcnMkMS5ub29wO1xudmFyIHZhbHVlT3JEZWZhdWx0JGQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsZWdlbmQ6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0d2VpZ2h0OiAxMDAwLFxuXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxuXHRcdFx0bWV0YS5oaWRkZW4gPSBtZXRhLmhpZGRlbiA9PT0gbnVsbCA/ICFjaS5kYXRhLmRhdGFzZXRzW2luZGV4XS5oaWRkZW4gOiBudWxsO1xuXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcblx0XHRcdGNpLnVwZGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG9uTGVhdmU6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkoZGF0YS5kYXRhc2V0cykgPyBkYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbihkYXRhc2V0LCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6ICghaGVscGVycyQxLmlzQXJyYXkoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IpID8gZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgOiBkYXRhc2V0LmJhY2tncm91bmRDb2xvclswXSksXG5cdFx0XHRcdFx0XHRoaWRkZW46ICFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdFx0bGluZUNhcDogZGF0YXNldC5ib3JkZXJDYXBTdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBkYXRhc2V0LmJvcmRlckRhc2gsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogZGF0YXNldC5ib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRcdFx0bGluZUpvaW46IGRhdGFzZXQuYm9yZGVySm9pblN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBkYXRhc2V0LmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IGRhdGFzZXQuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBkYXRhc2V0LnBvaW50U3R5bGUsXG5cblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IGlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LCB0aGlzKSA6IFtdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3IgKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0aWYgKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpIHtcblx0XHRcdFx0dGV4dC5wdXNoKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdH1cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSB0aGUgbGFiZWwgZm9udCBzaXplXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxuICovXG5mdW5jdGlvbiBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKSB7XG5cdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSAmJiBsYWJlbE9wdHMuYm94V2lkdGggPiBmb250U2l6ZSA/XG5cdFx0Zm9udFNpemUgOlxuXHRcdGxhYmVsT3B0cy5ib3hXaWR0aDtcbn1cblxuLyoqXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXG4gKi9cbnZhciBMZWdlbmQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHR0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHQvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG5cdFx0dGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG5cdFx0Ly8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuXHRcdHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMSxcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXHR9LFxuXHRhZnRlclVwZGF0ZTogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXG5cdGJ1aWxkTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcblx0XHR2YXIgbGVnZW5kSXRlbXMgPSBoZWxwZXJzJDEuY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG5cblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuXHRcdFx0bGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuXHR9LFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXG5cdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblxuXHRcdC8vIFJlc2V0IGhpdCBib3hlc1xuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuXHRcdFx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG5cdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IDA7XG5cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0aWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gdG90YWxIZWlnaHQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgY29sdW1uV2lkdGhzID0gbWUuY29sdW1uV2lkdGhzID0gW107XG5cdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHR2YXIgY3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdHZhciBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCA+IG1pblNpemUuaGVpZ2h0IC0gdlBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcblxuXHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuXHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQxLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSBsZWdlbmQgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZChsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblx0XHRcdHZhciBjdXJzb3I7XG5cblx0XHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBmb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG5cdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5sYWJlbHMgJiYgb3B0cy5sYWJlbHMudXNlUG9pbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHR2YXIgcmFkaXVzID0gYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBib3hXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dmFyIGNlbnRlclkgPSB5ICsgZm9udFNpemUgLyAyO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0XHR2YXIgeExlZnQgPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHg7XG5cdFx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0XHRjdHguZmlsbFRleHQobGVnZW5kSXRlbS50ZXh0LCB4TGVmdCwgeU1pZGRsZSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZEl0ZW0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4TGVmdCArIHRleHRXaWR0aCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbMF0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xuXHRcdFx0XHR2YXIgeCA9IGN1cnNvci54O1xuXHRcdFx0XHR2YXIgeSA9IGN1cnNvci55O1xuXG5cdFx0XHRcdC8vIFVzZSAobWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIGFuZCAobWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgbWUucmlnaHQgYW5kIG1lLmJvdHRvbSBiZWNhdXNlIG1lLndpZHRoIGFuZCBtZS5oZWlnaHRcblx0XHRcdFx0Ly8gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIHNpbmNlIG1lLm1pblNpemUgd2FzIGNhbGN1bGF0ZWRcblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBpdGVtSGVpZ2h0ID4gbWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSB4ICsgbWUuY29sdW1uV2lkdGhzW2N1cnNvci5saW5lXSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3TGVnZW5kQm94KHgsIHksIGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRoaXRib3hlc1tpXS50b3AgPSB5O1xuXG5cdFx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuXHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XG5cblx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdHZhciBob3ZlcmVkSXRlbTtcblxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0cy5vbkxlYXZlICYmIGhvdmVyZWRJdGVtICE9PSBtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xufVxuXG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcblx0aWQ6ICdsZWdlbmQnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBMZWdlbmQsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcblxuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDIgPSBoZWxwZXJzJDEubm9vcDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDIsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDIsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xuXHRcdHZhciBsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHR2YXIgdGV4dFNpemUgPSBkaXNwbGF5ID8gKGxpbmVDb3VudCAqIGZvbnRPcHRzLmxpbmVIZWlnaHQpICsgKG9wdHMucGFkZGluZyAqIDIpIDogMDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gdGV4dFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSB0ZXh0U2l6ZTtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDIsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgdG9wID0gbWUudG9wO1xuXHRcdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xuXHRcdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcblx0XHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xuXHRcdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR0aXRsZVggPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG5cdFx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGl0bGVYID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gbGVmdCArIG9mZnNldCA6IHJpZ2h0IC0gb2Zmc2V0O1xuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdFx0bWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG5cdFx0XHRcdHJvdGF0aW9uID0gTWF0aC5QSSAqIChvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyAtMC41IDogMC41KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xuXHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHRcdHZhciB5ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcblx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdHZhciB0aXRsZSA9IG5ldyBUaXRsZSh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG5cdGlkOiAndGl0bGUnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIHRpdGxlIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBUaXRsZSxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpdGxlT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBwbHVnaW5zID0ge307XG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcbnZhciBsZWdlbmQgPSBwbHVnaW5fbGVnZW5kO1xudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cblxuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycyA9IGhlbHBlcnMkMTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxuY29yZV9oZWxwZXJzKGNvcmVfY29udHJvbGxlcik7XG5cbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xuY29yZV9jb250cm9sbGVyLkFuaW1hdGlvbiA9IGNvcmVfYW5pbWF0aW9uO1xuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmNvcmVfY29udHJvbGxlci5EYXRhc2V0Q29udHJvbGxlciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXI7XG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XG5jb3JlX2NvbnRyb2xsZXIuZWxlbWVudHMgPSBlbGVtZW50cztcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xuY29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZSA9IGNvcmVfc2NhbGVTZXJ2aWNlO1xuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xuXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlLCB0eXBlKSB7XG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XG59KTtcblxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxuXG5cbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xuXG5mb3IgKHZhciBrIGluIHBsdWdpbnMpIHtcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcblx0fVxufVxuXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcbn1cblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5sYXlvdXRTZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxpbmVhclNjYWxlQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcbiAqIGJ5IHNldHRpbmcgdGhlIHR5cGUgaW4gdGhlIGNvbmZpZyAoYG5ldyBDaGFydChpZCwge3R5cGU6ICd7Y2hhcnQtdHlwZX0nfWApLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxuXHRbXG5cdFx0J0JhcicsXG5cdFx0J0J1YmJsZScsXG5cdFx0J0RvdWdobnV0Jyxcblx0XHQnTGluZScsXG5cdFx0J1BvbGFyQXJlYScsXG5cdFx0J1JhZGFyJyxcblx0XHQnU2NhdHRlcidcblx0XSxcblx0ZnVuY3Rpb24oa2xhc3MpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXJba2xhc3NdID0gZnVuY3Rpb24oY3R4LCBjZmcpIHtcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcblx0XHRcdH0pKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5yZXR1cm4gc3JjO1xuXG59KSkpO1xuIiwiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJ0KGNoYXJ0SWQsIGNoYXJ0VHlwZSkge1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgY2xhc3M6IHRoaXMuY3NzQ2xhc3Nlc1xuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5jaGFydElkLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnY2FudmFzJ1xuICAgICAgfSldKTtcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGFydElkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGNoYXJ0SWQsXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgY3NzQ2xhc3Nlczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9jaGFydDogbnVsbCxcbiAgICAgICAgX3BsdWdpbnM6IHRoaXMucGx1Z2luc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGFkZFBsdWdpbjogZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgICB0aGlzLiRkYXRhLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24gZ2VuZXJhdGVMZWdlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRkYXRhLl9jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uIHJlbmRlckNoYXJ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuJHJlZnMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHtcbiAgICAgICAgICB0eXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgIHBsdWdpbnM6IHRoaXMuJGRhdGEuX3BsdWdpbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgdmFyIEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2Jhci1jaGFydCcsICdiYXInKTtcbmV4cG9ydCB2YXIgSG9yaXpvbnRhbEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2hvcml6b250YWxiYXItY2hhcnQnLCAnaG9yaXpvbnRhbEJhcicpO1xuZXhwb3J0IHZhciBEb3VnaG51dCA9IGdlbmVyYXRlQ2hhcnQoJ2RvdWdobnV0LWNoYXJ0JywgJ2RvdWdobnV0Jyk7XG5leHBvcnQgdmFyIExpbmUgPSBnZW5lcmF0ZUNoYXJ0KCdsaW5lLWNoYXJ0JywgJ2xpbmUnKTtcbmV4cG9ydCB2YXIgUGllID0gZ2VuZXJhdGVDaGFydCgncGllLWNoYXJ0JywgJ3BpZScpO1xuZXhwb3J0IHZhciBQb2xhckFyZWEgPSBnZW5lcmF0ZUNoYXJ0KCdwb2xhci1jaGFydCcsICdwb2xhckFyZWEnKTtcbmV4cG9ydCB2YXIgUmFkYXIgPSBnZW5lcmF0ZUNoYXJ0KCdyYWRhci1jaGFydCcsICdyYWRhcicpO1xuZXhwb3J0IHZhciBCdWJibGUgPSBnZW5lcmF0ZUNoYXJ0KCdidWJibGUtY2hhcnQnLCAnYnViYmxlJyk7XG5leHBvcnQgdmFyIFNjYXR0ZXIgPSBnZW5lcmF0ZUNoYXJ0KCdzY2F0dGVyLWNoYXJ0JywgJ3NjYXR0ZXInKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmFyOiBCYXIsXG4gIEhvcml6b250YWxCYXI6IEhvcml6b250YWxCYXIsXG4gIERvdWdobnV0OiBEb3VnaG51dCxcbiAgTGluZTogTGluZSxcbiAgUGllOiBQaWUsXG4gIFBvbGFyQXJlYTogUG9sYXJBcmVhLFxuICBSYWRhcjogUmFkYXIsXG4gIEJ1YmJsZTogQnViYmxlLFxuICBTY2F0dGVyOiBTY2F0dGVyXG59OyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjaGFydExhYmVscyA9IFsnMTk4MCcsICcxOTkwJywgJzIwMDAnLCAnMjAxMCcsICcyMDIwJ107XG5cbmNvbnN0IGNoYXJ0RGF0YUxpc3QgPSBbNjU0MjU2NCwgNzMyMjU2NCwgODAwODI3OCwgODE3NTEzMywgNTQ3NTEzM107XG5cbmNvbnN0IENoYXJ0RGF0YSA9IHtcbiAgZGF0YToge1xuICAgIGxhYmVsczogY2hhcnRMYWJlbHMsXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtcbiAgICAgICAgZGF0YTogY2hhcnREYXRhTGlzdCxcbiAgICAgICAgZmlsbDogZmFsc2UsIC8vIHVzZWQgYnkgbGluZSBjaGFydFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAnIzJGMzM0RicsXG4gICAgICAgICAgJyMzMTU1QTYnLFxuICAgICAgICAgICcjRjI2OTVEJyxcbiAgICAgICAgICAnI0VCQkNEOCcsXG4gICAgICAgICAgJyNGOUExMzcnLFxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgICcjQUNBRUI5J1xuICAgICAgICBdLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSxcbiAgICBdXG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWxCYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1llYXJzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAyNSxcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2Jhcic7XG5cbmNsYXNzIENoYXJ0QmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSG9yaXpvbnRhbEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogSG9yaXpvbnRhbEJhcixcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWhvcml6b250YWwtYmFyLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdob3Jpem9udGFsLWJhcic7XG5cbmNsYXNzIENoYXJ0SG9yaXpvbnRhbEJhciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5ob3Jpem9udGFsQmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEhvcml6b250YWxCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgTGluZSwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogTGluZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWxpbmUudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2xpbmUnO1xuXG5jbGFzcyBDaGFydExpbmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydExpbmU7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgUGllLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBQaWUsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLXBpZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAncGllJztcblxuY2xhc3MgQ2hhcnRQaWUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEucGllLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydFBpZTsiLCI8dGVtcGxhdGU+PC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiB7XG4gICAgICAnbGF5ZXJzJzoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgICdjb25maWcnOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgbWFwUG9wdXA6IG51bGwsXG4gICAgICAgIG1hcEZpbHRlcjogbnVsbCxcbiAgICAgICAgYWN0aXZlTGF5ZXI6IG51bGwsXG4gICAgICAgIG1hcExvYWRlZDogZmFsc2UsXG4gICAgICAgIG1lbnVJdGVtczogW10sXG4gICAgICAgIHNlbGVjdGVkSXRlbXM6IFtdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVNYXAoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgIHRoaXMubWFwLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICdsYXllcnMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgdGhpcy50cmFja0xheWVyKGxheWVyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXIuZGVmYXVsdCB8fCB0aGlzLmxheWVycy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGF5ZXIgPSBsYXllci5uYW1lO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpXG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuXG4gICAgICAgICAgdGhpcy5hY3RpdmVMYXllciA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUxlZ2VuZChsYXllci5kYXRhKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZClcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWFwTG9hZGVkJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQgJiYgdGhpcy5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5ZXIobGF5ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWVudUl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51SXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVUb2dnbGUodGhpcy5tZW51SXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdzZWxlY3RlZEl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBbJ2luJywgbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbHRlci5wdXNoKHRoaXMuc2VsZWN0ZWRJdGVtc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCByZWxhdGVkRmVhdHVyZXMgPSB0aGlzLm1hcC5xdWVyeVNvdXJjZUZlYXR1cmVzKGxheWVyLm5hbWUsIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHNldCBmaWx0ZXIgd2hlbiBsZWdlbmQgaXRlbSBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMubWFwLnNldEZpbHRlcihgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsIGZpbHRlcik7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggJiYgIXRoaXMubWFwUG9wdXApIHtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRGaWx0ZXIoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCBudWxsKTtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGluaXRpYWxpemVNYXAoKSB7XG4gICAgICAgIGNvbnN0IG1hcENvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogbWFwQ29uZmlnLmNvbnRhaW5lcklkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBDb25maWcuY2VudGVyKVxuICAgICAgICAgIG9wdGlvbnMuY2VudGVyID0gbWFwQ29uZmlnLmNlbnRlcjtcblxuICAgICAgICBpZiAobWFwQ29uZmlnLnN0eWxlKVxuICAgICAgICAgIG9wdGlvbnMuc3R5bGUgPSBtYXBDb25maWcuc3R5bGU7XG5cbiAgICAgICAgaWYgKG1hcENvbmZpZy56b29tKVxuICAgICAgICAgIG9wdGlvbnMuem9vbSA9IG1hcENvbmZpZy56b29tO1xuXG4gICAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gbWFwQ29uZmlnLkFQSUtleTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgbWFwYm94Z2wuTWFwKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5OYXZpZ2F0aW9uQ29udHJvbCgpKTtcblxuICAgICAgICAvLyBkaXNhYmxlIG1hcCB6b29tIHdoZW4gdXNpbmcgc2Nyb2xsXG4gICAgICAgIGlmIChtYXBDb25maWcuZGlzYWJsZVNjcm9sbClcbiAgICAgICAgICB0aGlzLm1hcC5zY3JvbGxab29tLmRpc2FibGUoKTtcblxuICAgICAgICB0aGlzLm1hcC5vbignbG9hZCcsICgpID0+IHRoaXMubWFwTG9hZGVkID0gdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcC5nZXRMYXllcihsYXllci5uYW1lKSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5lbnRyaWVzKGxheWVyLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBsYXllci5uYW1lID09PSB0aGlzLmFjdGl2ZUxheWVyID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGxheWVyLmZpbHRlckJ5ID8gWydpbicsIGxheWVyLmZpbHRlckJ5LCAnJ10gOiBbXTtcbiAgICAgICAgICBjb25zdCBmaWxsID0gdGhpcy5jb25maWcuY29sb3JzID8gdGhpcy5nZW5lcmF0ZUZpbGxDb2xvcih0aGlzLmNvbmZpZy5jb2xvcnMpIDogbGF5ZXIuZmlsbDtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZFNvdXJjZShsYXllci5uYW1lLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdnZW9qc29uJyxcbiAgICAgICAgICAgICdkYXRhJzogbGF5ZXIuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLjdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IHZpc2liaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IGZpbHRlcixcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogdmlzaWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplRmlsdGVyKGxheWVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnNvck9uSG92ZXIobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplUG9wdXAoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnBvcHVwTXVsdGlMYXllcihldmVudCwgbGF5ZXIpIDogdGhpcy5wb3B1cFNpbmdsZUxheWVyKGV2ZW50LCBsYXllcik7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZVRvZ2dsZSh0b2dnbGVMaXN0KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnRvZ2dsZU11bHRpTGF5ZXIodG9nZ2xlTGlzdCkgOiB0aGlzLnRvZ2dsZVNpbmdsZUxheWVyKHRvZ2dsZUxpc3QpO1xuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVGaWx0ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ211bHRpJyA/IHRoaXMuZmlsdGVyTXVsdGlMYXllcihsYXllcikgOiB0aGlzLmZpbHRlclNpbmdsZUxheWVyKGxheWVyKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDdXJzb3JPbkhvdmVyKGxheWVySWQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5tYXA7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgdG8gYSBwb2ludGVyIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGxheWVyLlxuICAgICAgICBtYXAub24oJ21vdXNlZW50ZXInLCBsYXllcklkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgZGVmYXVsdCB3aGVuIGl0IGxlYXZlcyB0aGUgbGF5ZXIuXG4gICAgICAgIG1hcC5vbignbW91c2VsZWF2ZScsIGxheWVySWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlRmlsbENvbG9yKGNvbG9ycykge1xuICAgICAgICByZXR1cm4gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbiAgICAgIH0sXG4gICAgICAvLyBtdWx0aSBsYXllclxuICAgICAgdHJhY2tMYXllcihyZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhyZWZlcmVuY2UpKVxuICAgICAgICAgIHRoaXMubWVudUl0ZW1zLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgIH0sXG4gICAgICBwb3B1cE11bHRpTGF5ZXIoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBsYXllck5hbWUgPSBgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGA7XG4gICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRMbmdMYXQoZXZlbnQubG5nTGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEhUTUwoZXZlbnQuZmVhdHVyZXNbMF0ucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVG8obWFwKTtcblxuICAgICAgICBpZiAocG9wdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IHBvcHVwO1xuICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsIG51bGwpO1xuICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyTXVsdGlMYXllcihsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcblxuICAgICAgICBtYXAub24oJ2NsaWNrJywgbGF5ZXIubmFtZSwgKGUpID0+IHtcbiAgICAgICAgICAvLyBzZXQgYmJveCBhcyByZWFjdGFuZ2xlIGFyZWEgYXJvdW5kIGNsaWNrZWQgcG9pbnRcbiAgICAgICAgICBsZXQgYmJveCA9IFtbZS5wb2ludC54LCBlLnBvaW50LnldLCBbZS5wb2ludC54LCBlLnBvaW50LnldXTtcbiAgICAgICAgICBsZXQgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHsgbGF5ZXJzOiBbbGF5ZXIubmFtZV0gfSk7XG5cbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZmVhdHVyZSkge1xuICAgICAgICAgICAgbWVtby5wdXNoKGZlYXR1cmUucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgWydpbicsIGAke2xheWVyLmZpbHRlckJ5fWBdKTtcblxuICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAkdGhpcy5pbml0aWFsaXplUG9wdXAoZSwgbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVNdWx0aUxheWVyKGxheWVyc1RvVG9nZ2xlKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBhY3RpdmVMYXllciA9ICR0aGlzLmFjdGl2ZUxheWVyO1xuICAgICAgICBjb25zdCBsaW5rQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcubGVnZW5kSWQpO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBsaW5rcyBiZWZvcmUgYXBwZW5kaW5nIG5ldyBvbmVzIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICB3aGlsZSAobGlua0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgbGlua0NvbnRhaW5lci5yZW1vdmVDaGlsZChsaW5rQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnNUb1RvZ2dsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVmID0gbGF5ZXJzVG9Ub2dnbGVbaV07XG4gICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICAgIGxpbmsuaHJlZiA9ICcjJztcbiAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gbGF5ZXJSZWY7XG5cbiAgICAgICAgICBpZiAobGF5ZXJSZWYgPT09IGFjdGl2ZUxheWVyKVxuICAgICAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgICAgICAgIC8vIG9uIGNsaWNrIHVwZGF0ZSBsaW5rIHN0YXRlLCBhY3RpdmUgbGF5ZXIgcmVmZXJlbmNlLCBhbmQgbGF5ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIGxpbmsub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZExheWVyID0gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gbGlua0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgYWN0aXZlIHBvcHVwXG4gICAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXApXG4gICAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5rID0gbGlua3NbaV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IGN1cnJlbnRMaW5rLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5ZXJIaWdobGlnaHQgPSBgJHtjdXJyZW50TGF5ZXJ9LWhpZ2hsaWdodGVkYDtcbiAgICAgICAgICAgICAgY29uc3QgbGF5ZXJWaXNpYmlsaXR5ID0gbWFwLmdldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknKTtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyID09PSBzZWxlY3RlZExheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGlmIGxheWVyIGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJWaXNpYmlsaXR5ID09PSAndmlzaWJsZScgJiYgY3VycmVudExpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBvdXIgY3VycmVudCBsYXllciBhcyB0aGUgZ2xvYmFsIGFjdGl2ZSBsYXllcixcbiAgICAgICAgICAgICAgICAvLyBhZGQgYWN0aXZlIGNsYXNzIHRvIGxpbmssIHNldCBsYXllciBhcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgJHRoaXMuYWN0aXZlTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaW5rcyBhY3RpdmUgY2xhc3MsIHNldCBsYXllciB2aXNpYmlsaXR5IHRvIG5vbmUgYW5kIHJlbW92ZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXJIaWdobGlnaHQsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGN1cnJlbnRMYXllckhpZ2hsaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGlua0NvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHNpbmdsZSBsYXllclxuICAgICAgZ2VuZXJhdGVMZWdlbmQobGF5ZXJEYXRhKSB7XG4gICAgICAgIGxheWVyRGF0YS5mZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGZlYXR1cmUucHJvcGVydGllc1t0aGlzLmxheWVyc1swXS5sZWdlbmRDb2x1bW5dO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhpdGVtKSAmJiBpdGVtKVxuICAgICAgICAgICAgdGhpcy5tZW51SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcG9wdXBTaW5nbGVMYXllcihldmVudCwgbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYDtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHNoYXBlIGZhbGxzIHVuZGVyIGN1cnJlbnQgbGVnZW5kIHNlbGVjdGlvblxuICAgICAgICBsZXQgaW5DdXJyZW50U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IGNvbHVtbkZpbHRlciA9IGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoY29sdW1uRmlsdGVyKSlcbiAgICAgICAgICBpbkN1cnJlbnRTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0TG5nTGF0KGV2ZW50LmxuZ0xhdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRIVE1MKGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRvKG1hcCk7XG5cbiAgICAgICAgaWYgKHBvcHVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBwb3B1cDtcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBsZWdlbmQgaXRlbXMgc2VsZWN0ZWQsIGhpZ2hsaWdodCBzZWxlY3RlZCBtYXAgc2hhcGVcbiAgICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbGVnZW5kIGl0ZW1zIHNlbGVjdGVkIGFuZCBzZWxlY3RlZCBtYXAgc2hhcGUgaXNuJ3RcbiAgICAgICAgICAvLyB3aXRoaW4gYW55IG9mIHRoZSBzZWxlY3RlZCBsZWdlbmQgaXRlbXMsIGhpZ2hsaWdodCBzZWxlY3RlZFxuICAgICAgICAgIC8vIG1hcCBzaGFwZSBhbmQgY2xlYXIgbGVnZW5kXG4gICAgICAgICAgaWYgKCR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCAmJiAhaW5DdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGNoZWNrZWQgbGVnZW5kIGl0ZW1zXG4gICAgICAgICAgICAkdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJHcm91cElucHV0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29uZmlnLmxlZ2VuZElkKS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpjaGVja2VkJyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyR3JvdXBJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZmlsdGVyR3JvdXBJbnB1dHNbaV0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbGVnZW5kIGl0ZW1zIHNlbGVjdGVkLCByZXNldCBhbGwgZmlsdGVyc1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlclNpbmdsZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuXG4gICAgICAgIG1hcC5vbignY2xpY2snLCBsYXllci5uYW1lLCAoZSkgPT4ge1xuICAgICAgICAgIC8vIHNldCBiYm94IGFzIHJlYWN0YW5nbGUgYXJlYSBhcm91bmQgY2xpY2tlZCBwb2ludFxuICAgICAgICAgIGxldCBiYm94ID0gW1tlLnBvaW50LngsIGUucG9pbnQueV0sIFtlLnBvaW50LngsIGUucG9pbnQueV1dO1xuICAgICAgICAgIGxldCBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCwgeyBsYXllcnM6IFtsYXllci5uYW1lXSB9KTtcbiAgICAgICAgICBsZXQgbGVnZW5kQ29sdW1uVmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbHVtblZhbHVlID0gZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmxlZ2VuZENvbHVtbl07XG4gICAgICAgICAgICBtZW1vLnB1c2goZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCBbJ2luJywgYCR7bGF5ZXIuZmlsdGVyQnl9YF0pO1xuXG4gICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICR0aGlzLmluaXRpYWxpemVQb3B1cChlLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVNpbmdsZUxheWVyKGZpbHRlcnNUb1RvZ2dsZSkge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgZmlsdGVyR3JvdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5sZWdlbmRJZCk7XG5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSAkdGhpcy5sYXllcnNbMF07XG4gICAgICAgIGNvbnN0IGxlZ2VuZENvbHVtbiA9IGxheWVyLmxlZ2VuZENvbHVtbjtcblxuICAgICAgICAvLyBjbGVhciBhbGwgbGlua3MgYmVmb3JlIGFwcGVuZGluZyBuZXcgb25lcyB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgd2hpbGUgKGZpbHRlckdyb3VwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBmaWx0ZXJHcm91cC5yZW1vdmVDaGlsZChmaWx0ZXJHcm91cC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpbGl6ZSBhbiBpbnB1dCBlbGVtZW50IGZvciBlYWNoIGZpbHRlciB0eXBlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyc1RvVG9nZ2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJSZWYgPSBmaWx0ZXJzVG9Ub2dnbGVbaV07XG5cbiAgICAgICAgICAvLyBjaGVja2JveFxuICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICBpbnB1dC5pZCA9IGxheWVyUmVmO1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gbGF5ZXJSZWY7XG4gICAgICAgICAgZmlsdGVyR3JvdXAuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgLy8gY2hlY2tib3ggbGFiZWxcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBsYXllclJlZik7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxheWVyUmVmKTtcbiAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGxheWVyUmVmO1xuICAgICAgICAgIGZpbHRlckdyb3VwLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICAgIC8vIHdoZW4gdGhlIGNoZWNrYm94IGNoYW5nZXMgc3RhdGUsIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgaXRlbXMgYXJyYXkuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgY2hlY2tib3hlcyBjaGVja2VkIHN0YXRlXG4gICAgICAgICAgICBlLnRhcmdldC5jaGVja2VkID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgcG9wdXAgaWYgb25lIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwKVxuICAgICAgICAgICAgICAkdGhpcy5tYXBQb3B1cC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQgJiYgISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpXG4gICAgICAgICAgICAgICR0aGlzLnNlbGVjdGVkSXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5jaGVja2VkICYmICR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgJHRoaXMuc2VsZWN0ZWRJdGVtcyA9ICR0aGlzLnNlbGVjdGVkSXRlbXMuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSBpdGVtO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbjwvc2NyaXB0PiIsIi8qKlxuICogQ29uZmlnXG4gKi9cblxuY29uc3Qgbnljb0NvbG9ycyA9IHtcbiAgY29sb3JzOiB7XG4gICAgJ3ByaW1hcnktbmF2eSc6ICcjMkYzMzRGJyxcbiAgICAncHJpbWFyeS1uYXZ5LTcwdCc6ICcjNkU3MDg1JyxcbiAgICAncHJpbWFyeS1uYXZ5LTUwdCc6ICcjOTY5OEE3JyxcbiAgICAncHJpbWFyeS1uYXZ5LTMwdCc6ICcjQzBDMkNBJyxcbiAgICAncHJpbWFyeS1ibHVlJzogJyMzMTU1QTYnLFxuICAgICdwcmltYXJ5LWJsdWUtNzB0JzogJyM2Qzg4QzEnLFxuICAgICdwcmltYXJ5LWJsdWUtNTB0JzogJyM5NkFCRDInLFxuICAgICdwcmltYXJ5LWJsdWUtMzB0JzogJyNDMENDRTMnLFxuICAgICdwcmltYXJ5LXJlZCc6ICcjRjI2OTVEJyxcbiAgICAncHJpbWFyeS1yZWQtNzB0JzogJyNGNjk1OEQnLFxuICAgICdwcmltYXJ5LXJlZC01MHQnOiAnI0Y4QjJBRCcsXG4gICAgJ3ByaW1hcnktcmVkLTMwdCc6ICcjRkJEMUNFJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXknOiAnI0FDQUVCOScsXG4gICAgJ3NlY29uZGFyeS1ncmV5LTcwdCc6ICcjQzRDNkNEJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXktNTB0JzogJyNENUQ2REMnLFxuICAgICdzZWNvbmRhcnktZ3JleS0zMHQnOiAnI0U4RTdFOScsXG4gICAgJ3NlY29uZGFyeS13aGl0ZSc6ICcjRjNGM0YzJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTcwdCc6ICcjRjZGNkY2JyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTUwdCc6ICcjRjlGOUZBJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTMwdCc6ICcjRkJGQ0ZDJyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZSc6ICcjRjlBMTM3JyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZS03MHQnOiAnI0ZGQTEzMycsXG4gICAgJ3NlY29uZGFyeS1vcmFuZ2UtNTB0JzogJyNGRUQwOUEnLFxuICAgICdzZWNvbmRhcnktb3JhbmdlLTMwdCc6ICcjRkZFM0MyJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmsnOiAnI0VCQkNEOCcsXG4gICAgJ3NlY29uZGFyeS1waW5rLTcwdCc6ICcjRjJEMEUzJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmstNTB0JzogJyNGN0RERUInLFxuICAgICdzZWNvbmRhcnktcGluay0zMHQnOiAnI0ZERUJGMycsXG4gICAgJ2Jhc2UtYmxhY2snOiAnIzAwMDAwMCcsXG4gICAgJ2Jhc2Utd2hpdGUnOiAnI0ZGRkZGRidcbiAgfSxcbiAgY29sb3JDb21iaW5hdGlvbnM6IHtcbiAgICAnbGlnaHQtYmFja2dyb3VuZCc6IHtcbiAgICAgICdjb2xvcic6ICdiYXNlLWJsYWNrJyxcbiAgICAgICdoZWFkaW5ncyc6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2h5cGVybGlua3MnOiAncHJpbWFyeS1ibHVlJyxcbiAgICAgICd2aXNpdGVkJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAnaG92ZXInOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2JvcmRlcic6ICdzZWNvbmRhcnktZ3JleScsXG4gICAgICAncGxhY2Vob2xkZXInOiAnc2Vjb25kYXJ5LWdyZXknLFxuICAgICAgJ2NoZWNrYm94LWJhY2tncm91bmQnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdlcnJvcic6ICdwcmltYXJ5LXJlZCcsXG4gICAgfSxcbiAgICAnbWlkLWJhY2tncm91bmQnOiB7XG4gICAgICAnY29sb3InOiAnYmFzZS1ibGFjaycsXG4gICAgICAnaGVhZGluZ3MnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAndmlzaXRlZCc6ICdwcmltYXJ5LWJsdWUnLFxuICAgICAgJ2hvdmVyJzogJ3ByaW1hcnktbmF2eScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdzZWNvbmRhcnktd2hpdGUnXG4gICAgfSxcbiAgICAnZGFyay1iYWNrZ3JvdW5kJzoge1xuICAgICAgJ2NvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2ZvbnQtc21vb3RoJzogdHJ1ZSxcbiAgICAgICdoZWFkaW5ncyc6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ3Zpc2l0ZWQnOiAnYmFzZS13aGl0ZScsXG4gICAgICAnaG92ZXInOiAnYmFzZS13aGl0ZScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdwcmltYXJ5LW5hdnknXG4gICAgfSxcbiAgICAncHJpbWFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1ibHVlJ1xuICAgIH0sXG4gICAgJ3NlY29uZGFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1yZWQnXG4gICAgfVxuICB9LFxufTtcblxuY29uc3QgY29sb3IgPSBueWNvQ29sb3JzLmNvbG9ycztcbmNvbnN0IG1hcENvbG9yQ29tYmluYXRpb25zID0gW1xuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsncHJpbWFyeS1uYXZ5LTcwdCddXSxcbiAgW2NvbG9yWydiYXNlLWJsYWNrJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsnc2Vjb25kYXJ5LWdyZXknXV0sXG4gIFtjb2xvclsncHJpbWFyeS1ibHVlJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG55Y29Db2xvcnMsXG4gIG1hcENvbG9yQ29tYmluYXRpb25zXG59OyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgbWFwQ29sb3JDb21iaW5hdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb25maWcvY29sb3JzJztcblxuY29uc3QgTWFwRGF0YSA9IHtcbiAgc2luZ2xlOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1zbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLWxlZ2VuZCcsXG4gICAgICBjZW50ZXI6IFstNzMuOTg2NzEwLCA0MC42OTMzOTFdLFxuICAgICAgem9vbTogOSxcbiAgICAgIGRpc2FibGVTY3JvbGw6IHRydWUsXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ3NpbmdsZSdcbiAgICB9XG4gIH0sXG4gIG11bHRpOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1tbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLW1lbnUnLFxuICAgICAgY2VudGVyOiBbLTczLjk4NjcxMCwgNDAuNjkzMzkxXSxcbiAgICAgIHpvb206IDksXG4gICAgICBkaXNhYmxlU2Nyb2xsOiB0cnVlLFxuICAgICAgc3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbnljby1wcm9kdWN0cy9janY2d2pxODgxMnlzMWdwMzltbnZ1azJ3JyxcbiAgICAgIG1hcFR5cGU6ICdtdWx0aScsXG4gICAgICBjb2xvcnM6IG1hcENvbG9yQ29tYmluYXRpb25zXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcERhdGE7IiwiKGZ1bmN0aW9uKEdlb0pTT04pIHtcbiAgR2VvSlNPTi52ZXJzaW9uID0gJzAuNS4wJztcblxuICAvLyBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gIEdlb0pTT04uZGVmYXVsdHMgPSB7XG4gICAgZG9UaHJvd3M6IHtcbiAgICAgIGludmFsaWRHZW9tZXRyeTogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSW52YWxpZEdlb21ldHJ5RXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICB2YXIgaXRlbSA9IGFyZ3Muc2hpZnQoKTtcbiAgICB2YXIgcGFyYW1zID0gYXJncy5zaGlmdCgpO1xuXG4gICAgRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlIHx8IFwiSW52YWxpZCBHZW9tZXRyeTogXCIgKyAnaXRlbTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pICsgJywgcGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgfVxuXG4gIEludmFsaWRHZW9tZXRyeUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG5cbiAgR2VvSlNPTi5lcnJvcnMgPSB7XG4gICAgSW52YWxpZEdlb21ldHJ5RXJyb3I6IEludmFsaWRHZW9tZXRyeUVycm9yXG4gIH07XG5cbiAgLy9leHBvc2luZyBzbyB0aGlzIGNhbiBiZSBvdmVycmlkZW4gbWF5YmUgYnkgZ2VvanNvbi12YWxpZGF0aW9uIG9yIHRoZSBsaWtlXG4gIEdlb0pTT04uaXNHZW9tZXRyeVZhbGlkID0gZnVuY3Rpb24oZ2VvbWV0cnkpe1xuICAgIGlmKCFnZW9tZXRyeSB8fCAhT2JqZWN0LmtleXMoZ2VvbWV0cnkpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiAhIWdlb21ldHJ5LnR5cGUgJiYgISFnZW9tZXRyeS5jb29yZGluYXRlcyAmJiBBcnJheS5pc0FycmF5KGdlb21ldHJ5LmNvb3JkaW5hdGVzKSAmJiAhIWdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgfTtcblxuICAvLyBUaGUgb25lIGFuZCBvbmx5IHB1YmxpYyBmdW5jdGlvbi5cbiAgLy8gQ29udmVydHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgR2VvSlNPTiBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgR2VvSlNPTi5wYXJzZSA9IGZ1bmN0aW9uKG9iamVjdHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2VvanNvbixcbiAgICAgICAgc2V0dGluZ3MgPSBhcHBseURlZmF1bHRzKHBhcmFtcywgdGhpcy5kZWZhdWx0cyksXG4gICAgICAgIHByb3BGdW5jO1xuXG4gICAgZ2VvbUF0dHJzLmxlbmd0aCA9IDA7IC8vIFJlc2V0IHRoZSBsaXN0IG9mIGdlb21ldHJ5IGZpZWxkc1xuICAgIHNldEdlb20oc2V0dGluZ3MpO1xuICAgIHByb3BGdW5jID0gZ2V0UHJvcEZ1bmN0aW9uKHNldHRpbmdzKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdHMpKSB7XG4gICAgICBnZW9qc29uID0ge1widHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIFwiZmVhdHVyZXNcIjogW119O1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goZ2V0RmVhdHVyZSh7aXRlbTppdGVtLCBwYXJhbXM6IHNldHRpbmdzLCBwcm9wRnVuYzpwcm9wRnVuY30pKTtcbiAgICAgIH0pO1xuICAgICAgYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvanNvbiA9IGdldEZlYXR1cmUoe2l0ZW06b2JqZWN0cywgcGFyYW1zOiBzZXR0aW5ncywgcHJvcEZ1bmM6cHJvcEZ1bmN9KTtcbiAgICAgIGFkZE9wdGlvbmFscyhnZW9qc29uLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2soZ2VvanNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW9qc29uO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIHZhciBnZW9tcyA9IFsnUG9pbnQnLCAnTXVsdGlQb2ludCcsICdMaW5lU3RyaW5nJywgJ011bHRpTGluZVN0cmluZycsICdQb2x5Z29uJywgJ011bHRpUG9seWdvbicsICdHZW9KU09OJ10sXG4gICAgICBnZW9tQXR0cnMgPSBbXTtcblxuICAvLyBBZGRzIGRlZmF1bHQgc2V0dGluZ3MgdG8gdXNlci1zcGVjaWZpZWQgcGFyYW1zXG4gIC8vIERvZXMgbm90IG92ZXJ3cml0ZSBhbnkgc2V0dGluZ3MtLW9ubHkgYWRkcyBkZWZhdWx0c1xuICAvLyB0aGUgdGhlIHVzZXIgZGlkIG5vdCBzcGVjaWZ5XG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMocGFyYW1zLCBkZWZhdWx0cykge1xuICAgIHZhciBzZXR0aW5ncyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGZvcih2YXIgc2V0dGluZyBpbiBkZWZhdWx0cykge1xuICAgICAgaWYoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoc2V0dGluZykgJiYgIXNldHRpbmdzW3NldHRpbmddKSB7XG4gICAgICAgIHNldHRpbmdzW3NldHRpbmddID0gZGVmYXVsdHNbc2V0dGluZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG5cbiAgLy8gQWRkcyB0aGUgb3B0aW9uYWwgR2VvSlNPTiBwcm9wZXJ0aWVzIGNycyBhbmQgYmJveFxuICAvLyBpZiB0aGV5IGhhdmUgYmVlbiBzcGVjaWZpZWRcbiAgZnVuY3Rpb24gYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKXtcbiAgICBpZihzZXR0aW5ncy5jcnMgJiYgY2hlY2tDUlMoc2V0dGluZ3MuY3JzKSkge1xuICAgICAgaWYoc2V0dGluZ3MuaXNQb3N0Z3JlcylcbiAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jcnMgPSBzZXR0aW5ncy5jcnM7XG4gICAgICBlbHNlXG4gICAgICAgIGdlb2pzb24uY3JzID0gc2V0dGluZ3MuY3JzO1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MuYmJveCkge1xuICAgICAgZ2VvanNvbi5iYm94ID0gc2V0dGluZ3MuYmJveDtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmV4dHJhR2xvYmFsKSB7XG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzZXR0aW5ncy5leHRyYUdsb2JhbCkge1xuICAgICAgICBnZW9qc29uLnByb3BlcnRpZXNba2V5XSA9IHNldHRpbmdzLmV4dHJhR2xvYmFsW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cnVjdHVyZSBvZiBDUlMgb2JqZWN0IGlzIHZhbGlkXG4gIGZ1bmN0aW9uIGNoZWNrQ1JTKGNycykge1xuICAgIGlmIChjcnMudHlwZSA9PT0gJ25hbWUnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDUlMuIFByb3BlcnRpZXMgbXVzdCBjb250YWluIFwibmFtZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChjcnMudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5ocmVmICYmIGNycy5wcm9wZXJ0aWVzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENSUy4gUHJvcGVydGllcyBtdXN0IGNvbnRhaW4gXCJocmVmXCIgYW5kIFwidHlwZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgQ1JTLiBUeXBlIGF0dHJpYnV0ZSBtdXN0IGJlIFwibmFtZVwiIG9yIFwibGlua1wiJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZXMgdGhlIHVzZXItc3BlY2lmaWVkIGdlb21ldHJ5IHBhcmFtZXRlcnNcbiAgLy8gdW5kZXIgdGhlIGBnZW9tYCBrZXkgaW4gcGFyYW0gZm9yIGVhc2llciBhY2Nlc3NcbiAgZnVuY3Rpb24gc2V0R2VvbShwYXJhbXMpIHtcbiAgICBwYXJhbXMuZ2VvbSA9IHt9O1xuXG4gICAgZm9yKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkgJiYgZ2VvbXMuaW5kZXhPZihwYXJhbSkgIT09IC0xKXtcbiAgICAgICAgcGFyYW1zLmdlb21bcGFyYW1dID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgZGVsZXRlIHBhcmFtc1twYXJhbV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0R2VvbUF0dHJMaXN0KHBhcmFtcy5nZW9tKTtcbiAgfVxuXG4gIC8vIEFkZHMgZmllbGRzIHdoaWNoIGNvbnRhaW4gZ2VvbWV0cnkgZGF0YVxuICAvLyB0byBnZW9tQXR0cnMuIFRoaXMgbGlzdCBpcyB1c2VkIHdoZW4gYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gdGhlIGZlYXR1cmVzIHNvIHRoYXQgbm8gZ2VvbWV0cnlcbiAgLy8gZmllbGRzIGFyZSBhZGRlZCB0aGUgcHJvcGVydGllcyBrZXlcbiAgZnVuY3Rpb24gc2V0R2VvbUF0dHJMaXN0KHBhcmFtcykge1xuICAgIGZvcih2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgIGlmKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGdlb21BdHRycy5wdXNoKHBhcmFtc1twYXJhbV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnb2JqZWN0JykgeyAvLyBBcnJheSBvZiBjb29yZGluYXRlcyBmb3IgUG9pbnRcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzBdKTtcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGdlb21BdHRycy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyeSBhdHRyaWJ1dGVzIHNwZWNpZmllZCcpOyB9XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgZmVhdHVyZSBvYmplY3QgdG8gYmUgYWRkZWRcbiAgLy8gdG8gdGhlIEdlb0pTT04gZmVhdHVyZXMgYXJyYXlcbiAgZnVuY3Rpb24gZ2V0RmVhdHVyZShhcmdzKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzLml0ZW0sXG4gICAgICBwYXJhbXMgPSBhcmdzLnBhcmFtcyxcbiAgICAgIHByb3BGdW5jID0gYXJncy5wcm9wRnVuYztcblxuICAgIHZhciBmZWF0dXJlID0geyBcInR5cGVcIjogXCJGZWF0dXJlXCIgfTtcblxuICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBidWlsZEdlb20oaXRlbSwgcGFyYW1zKTtcbiAgICBmZWF0dXJlLnByb3BlcnRpZXMgPSBwcm9wRnVuYy5jYWxsKGl0ZW0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc05lc3RlZCh2YWwpe1xuICAgIHJldHVybiAoL14uK1xcLi4rJC8udGVzdCh2YWwpKTtcbiAgfVxuXG4gIC8vIEFzc2VtYmxlcyB0aGUgYGdlb21ldHJ5YCBwcm9wZXJ0eVxuICAvLyBmb3IgdGhlIGZlYXR1cmUgb3V0cHV0XG4gIGZ1bmN0aW9uIGJ1aWxkR2VvbShpdGVtLCBwYXJhbXMpIHtcbiAgICB2YXIgZ2VvbSA9IHt9LFxuICAgICAgICBhdHRyO1xuXG4gICAgZm9yKHZhciBndHlwZSBpbiBwYXJhbXMuZ2VvbSkge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtcy5nZW9tW2d0eXBlXTtcblxuICAgICAgLy8gR2VvbWV0cnkgcGFyYW1ldGVyIHNwZWNpZmllZCBhczoge1BvaW50OiAnY29vcmRzJ31cbiAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsKSkge1xuICAgICAgICBpZihndHlwZSA9PT0gJ0dlb0pTT04nKSB7XG4gICAgICAgICAgZ2VvbSA9IGl0ZW1bdmFsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gaXRlbVt2YWxdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIEhhbmRsZSB0aGluZ3MgbGlrZTpcbiAgICAgIFBvbHlnb246IHtcbiAgICAgICAgbm9ydGhlYXN0OiBbJ2xhdCcsICdsbmcnXSxcbiAgICAgICAgc291dGh3ZXN0OiBbJ2xhdCcsICdsbmcnXVxuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGVsc2UgaWYodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgcG9pbnRzID0gT2JqZWN0LmtleXModmFsKS5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgICB2YXIgb3JkZXIgPSB2YWxba2V5XTtcbiAgICAgICAgICB2YXIgbmV3SXRlbSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgICByZXR1cm4gYnVpbGRHZW9tKG5ld0l0ZW0sIHtnZW9tOnsgUG9pbnQ6IG9yZGVyfX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbXS5jb25jYXQocG9pbnRzLm1hcChmdW5jdGlvbihwKXtcbiAgICAgICAgICByZXR1cm4gcC5jb29yZGluYXRlcztcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW9tZXRyeSBwYXJhbWV0ZXIgc3BlY2lmaWVkIGFzOiB7UG9pbnQ6IFsnbGF0JywgJ2xuZyddfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHZhbCkgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSh2YWxbMF0pICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsWzFdKSl7XG4gICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gW051bWJlcihpdGVtW3ZhbFsxXV0pLCBOdW1iZXIoaXRlbVt2YWxbMF1dKV07XG4gICAgICB9XG5cbiAgICAgIC8vIEdlb21ldHJ5IHBhcmFtZXRlciBzcGVjaWZpZWQgYXM6IHtQb2ludDogWydjb250YWluZXIubGF0JywgJ2NvbnRhaW5lci5sbmcnXX1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2YWwpICYmIGlzTmVzdGVkKHZhbFswXSkgJiYgaXNOZXN0ZWQodmFsWzFdKSl7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1x0Ly8gaS5lLiAwIGFuZCAxXG4gICAgICAgICAgdmFyIHBhdGhzID0gdmFsW2ldLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGl0ZW1DbG9uZSA9IGl0ZW07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFpdGVtQ2xvbmUuaGFzT3duUHJvcGVydHkocGF0aHNbal0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1DbG9uZSA9IGl0ZW1DbG9uZVtwYXRoc1tqXV07XHQvLyBJdGVyYXRlIGRlZXBlciBpbnRvIHRoZSBvYmplY3RcbiAgICAgICAgICB9XG4gICAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBpdGVtQ2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSwgTnVtYmVyKGNvb3JkaW5hdGVzWzBdKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYocGFyYW1zLmRvVGhyb3dzICYmIHBhcmFtcy5kb1Rocm93cy5pbnZhbGlkR2VvbWV0cnkgJiYgIUdlb0pTT04uaXNHZW9tZXRyeVZhbGlkKGdlb20pKXtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkR2VvbWV0cnlFcnJvcihpdGVtLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW9tO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZnVuY3Rpb24gdG8gYmUgdXNlZCB0b1xuICAvLyBidWlsZCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGVhY2ggZmVhdHVyZVxuICBmdW5jdGlvbiBnZXRQcm9wRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGZ1bmM7XG5cbiAgICBpZighcGFyYW1zLmV4Y2x1ZGUgJiYgIXBhcmFtcy5pbmNsdWRlKSB7XG4gICAgICBmdW5jID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBmb3IodmFyIGF0dHIgaW4gdGhpcykge1xuICAgICAgICAgIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgKGdlb21BdHRycy5pbmRleE9mKGF0dHIpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbYXR0cl0gPSB0aGlzW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmluY2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHBhcmFtcy5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XG4gICAgICAgICAgcHJvcGVydGllc1thdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmV4Y2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvcih2YXIgYXR0ciBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiAoZ2VvbUF0dHJzLmluZGV4T2YoYXR0cikgPT09IC0xKSAmJiAocGFyYW1zLmV4Y2x1ZGUuaW5kZXhPZihhdHRyKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2F0dHJdID0gdGhpc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgZnVuYy5jYWxsKHRoaXMsIHByb3BlcnRpZXMpO1xuXG4gICAgICBpZihwYXJhbXMuZXh0cmEpIHsgYWRkRXh0cmEocHJvcGVydGllcywgcGFyYW1zLmV4dHJhKTsgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEFkZHMgZGF0YSBjb250YWluZWQgaW4gdGhlIGBleHRyYWBcbiAgLy8gcGFyYW1ldGVyIGlmIGl0IGhhcyBiZWVuIHNwZWNpZmllZFxuICBmdW5jdGlvbiBhZGRFeHRyYShwcm9wZXJ0aWVzLCBleHRyYSkge1xuICAgIGZvcih2YXIga2V5IGluIGV4dHJhKXtcbiAgICAgIGlmKGV4dHJhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0gZXh0cmFba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG59KHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgPyBtb2R1bGUuZXhwb3J0cyA6IHdpbmRvdy5HZW9KU09OID0ge30pKTtcbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwidmFyIHdnczg0ID0gcmVxdWlyZSgnd2dzODQnKTtcblxubW9kdWxlLmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbm1vZHVsZS5leHBvcnRzLnJpbmcgPSByaW5nQXJlYTtcblxuZnVuY3Rpb24gZ2VvbWV0cnkoXykge1xuICAgIHZhciBhcmVhID0gMCwgaTtcbiAgICBzd2l0Y2ggKF8udHlwZSkge1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgKz0gZ2VvbWV0cnkoXy5nZW9tZXRyaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9seWdvbkFyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBhcmVhIG9mIHRoZSBwb2x5Z29uIHdlcmUgaXQgcHJvamVjdGVkIG9udG9cbiAqICAgICB0aGUgZWFydGguICBOb3RlIHRoYXQgdGhpcyBhcmVhIHdpbGwgYmUgcG9zaXRpdmUgaWYgcmluZyBpcyBvcmllbnRlZFxuICogICAgIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiAgICAgUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogICAgIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3IGh0dHA6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9kc3BhY2UvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBSZXR1cm5zOlxuICoge2Zsb2F0fSBUaGUgYXBwcm94aW1hdGUgc2lnbmVkIGdlb2Rlc2ljIGFyZWEgb2YgdGhlIHBvbHlnb24gaW4gc3F1YXJlXG4gKiAgICAgbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBwMSwgcDIsIHAzLCBsb3dlckluZGV4LCBtaWRkbGVJbmRleCwgdXBwZXJJbmRleCwgaSxcbiAgICBhcmVhID0gMCxcbiAgICBjb29yZHNMZW5ndGggPSBjb29yZHMubGVuZ3RoO1xuXG4gICAgaWYgKGNvb3Jkc0xlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMikgey8vIGkgPSBOLTJcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGNvb3Jkc0xlbmd0aCAtMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMSkgey8vIGkgPSBOLTFcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpID0gMCB0byBOLTNcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGkrMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gaSsyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDEgPSBjb29yZHNbbG93ZXJJbmRleF07XG4gICAgICAgICAgICBwMiA9IGNvb3Jkc1ttaWRkbGVJbmRleF07XG4gICAgICAgICAgICBwMyA9IGNvb3Jkc1t1cHBlckluZGV4XTtcbiAgICAgICAgICAgIGFyZWEgKz0gKCByYWQocDNbMF0pIC0gcmFkKHAxWzBdKSApICogTWF0aC5zaW4oIHJhZChwMlsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYSA9IGFyZWEgKiB3Z3M4NC5SQURJVVMgKiB3Z3M4NC5SQURJVVMgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiByYWQoXykge1xuICAgIHJldHVybiBfICogTWF0aC5QSSAvIDE4MDtcbn0iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdAbWFwYm94L2dlb2pzb24tYXJlYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJld2luZDtcblxuZnVuY3Rpb24gcmV3aW5kKGdqLCBvdXRlcikge1xuICAgIHN3aXRjaCAoKGdqICYmIGdqLnR5cGUpIHx8IG51bGwpIHtcbiAgICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZ2ouZmVhdHVyZXMgPSBnai5mZWF0dXJlcy5tYXAoY3VycnlPdXRlcihyZXdpbmQsIG91dGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgICAgZ2ouZ2VvbWV0cnkgPSByZXdpbmQoZ2ouZ2VvbWV0cnksIG91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdChnaiwgb3V0ZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VycnlPdXRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIGEoXywgYik7IH07XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3QoXywgb3V0ZXIpIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IGNvcnJlY3RSaW5ncyhfLmNvb3JkaW5hdGVzLCBvdXRlcik7XG4gICAgfSBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBfLmNvb3JkaW5hdGVzLm1hcChjdXJyeU91dGVyKGNvcnJlY3RSaW5ncywgb3V0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RSaW5ncyhfLCBvdXRlcikge1xuICAgIG91dGVyID0gISFvdXRlcjtcbiAgICBfWzBdID0gd2luZChfWzBdLCBvdXRlcik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9baV0gPSB3aW5kKF9baV0sICFvdXRlcik7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiB3aW5kKF8sIGRpcikge1xuICAgIHJldHVybiBjdyhfKSA9PT0gZGlyID8gXyA6IF8ucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBjdyhfKSB7XG4gICAgcmV0dXJuIGdlb2pzb25BcmVhLnJpbmcoXykgPj0gMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IE1hcENvbXBvbmVudCBmcm9tICcuLi9vYmplY3RzL21hcC9tYXAudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IE1hcERhdGEgZnJvbSAnLi4vb2JqZWN0cy9tYXAvbWFwLmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcbmltcG9ydCBHZW9KU09OIGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHJld2luZCBmcm9tICdnZW9qc29uLXJld2luZCc7XG5pbXBvcnQgeyBtYXBDb2xvckNvbWJpbmF0aW9ucyB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb2xvcnMnXG5cbmNsYXNzIE1hcE11bHRpTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tbWFwLW1sJywgTWFwQ29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cIm55Y28tbWFwLW1sXCJdJyxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXllcnM6IE1hcERhdGEubXVsdGkubGF5ZXJzLFxuICAgICAgICAgIGNvbmZpZzogTWFwRGF0YS5tdWx0aS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldFppcGNvZGVEYXRhKCk7XG4gICAgICAgIHRoaXMuZ2V0Qm9yb3VnaERhdGEoKTtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcmhvb2REYXRhKCk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRaaXBjb2RlRGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2tpbXBlbmd1aW4vZ2VvSlNPTkBtYXN0ZXIvdGlnZXItemN0YS5nZW9qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd6aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnR0VPSUQxMCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qm9yb3VnaERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vZGF0YS5jaXR5b2ZuZXd5b3JrLnVzL3Jlc291cmNlLzd0M2IteXd2dy5qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib3JvdWdocycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnYm9yb19uYW1lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXROZWlnaGJvcmhvb2REYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2RhdGEuY2l0eW9mbmV3eW9yay51cy9yZXNvdXJjZS9xMno1LWFpMzguanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgICAgICAgICBNYXBEYXRhLm11bHRpLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmVpZ2hib3Job29kcycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnbnRhbmFtZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFRvR2VvSlNPTihqc29uRGF0YSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBnZW9qc29uIHNhdGlzZmllcyByaWdodC1oYW5kIHJ1bGVcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmV3aW5kKEdlb0pTT04ucGFyc2UoanNvbkRhdGEsIHtHZW9KU09OOiAndGhlX2dlb20nfSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmNsYXNzIE1hcFNpbmdsZUxheWVyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLW1hcC1zbCcsIE1hcENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJueWNvLW1hcC1zbFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXJzOiBNYXBEYXRhLnNpbmdsZS5sYXllcnMsXG4gICAgICAgICAgY29uZmlnOiBNYXBEYXRhLnNpbmdsZS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9raW1wZW5ndWluL2dlb0pTT05AbWFzdGVyL255Y28tbnljX3ppcGNvZGVzLmdlb2pzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgTWFwRGF0YS5zaW5nbGUubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdueWNvLW55Y196aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ1pDVEE1Q0UxMCcsXG4gICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1uOiAnQk9STycsXG4gICAgICAgICAgICAgICAgZmlsbDogbWFwQ29sb3JDb21iaW5hdGlvbnNbM11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTWFwTXVsdGlMYXllcixcbiAgTWFwU2luZ2xlTGF5ZXJcbn0iLCIvKipcbiAqIEphcm9XaW5rbGVyIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmFybyVFMiU4MCU5M1dpbmtsZXJfZGlzdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzMSBzdHJpbmcgb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHMyIHNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGFtb3VudCBvZiBtYXRjaGVzLlxuICovXG5mdW5jdGlvbiBqYXJvKHMxLCBzMikge1xuICBsZXQgc2hvcnRlcjtcbiAgbGV0IGxvbmdlcjtcblxuICBbbG9uZ2VyLCBzaG9ydGVyXSA9IHMxLmxlbmd0aCA+IHMyLmxlbmd0aCA/IFtzMSwgczJdIDogW3MyLCBzMV07XG5cbiAgY29uc3QgbWF0Y2hpbmdXaW5kb3cgPSBNYXRoLmZsb29yKGxvbmdlci5sZW5ndGggLyAyKSAtIDE7XG4gIGNvbnN0IHNob3J0ZXJNYXRjaGVzID0gW107XG4gIGNvbnN0IGxvbmdlck1hdGNoZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2ggPSBzaG9ydGVyW2ldO1xuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5tYXgoMCwgaSAtIG1hdGNoaW5nV2luZG93KTtcbiAgICBjb25zdCB3aW5kb3dFbmQgPSBNYXRoLm1pbihpICsgbWF0Y2hpbmdXaW5kb3cgKyAxLCBsb25nZXIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBqID0gd2luZG93U3RhcnQ7IGogPCB3aW5kb3dFbmQ7IGorKylcbiAgICAgIGlmIChsb25nZXJNYXRjaGVzW2pdID09PSB1bmRlZmluZWQgJiYgY2ggPT09IGxvbmdlcltqXSkge1xuICAgICAgICBzaG9ydGVyTWF0Y2hlc1tpXSA9IGxvbmdlck1hdGNoZXNbal0gPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICBjb25zdCBzaG9ydGVyTWF0Y2hlc1N0cmluZyA9IHNob3J0ZXJNYXRjaGVzLmpvaW4oJycpO1xuICBjb25zdCBsb25nZXJNYXRjaGVzU3RyaW5nID0gbG9uZ2VyTWF0Y2hlcy5qb2luKCcnKTtcbiAgY29uc3QgbnVtTWF0Y2hlcyA9IHNob3J0ZXJNYXRjaGVzU3RyaW5nLmxlbmd0aDtcblxuICBsZXQgdHJhbnNwb3NpdGlvbnMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXJNYXRjaGVzU3RyaW5nLmxlbmd0aDsgaSsrKVxuICAgIGlmIChzaG9ydGVyTWF0Y2hlc1N0cmluZ1tpXSAhPT0gbG9uZ2VyTWF0Y2hlc1N0cmluZ1tpXSlcbiAgICAgIHRyYW5zcG9zaXRpb25zKys7XG4gIHJldHVybiBudW1NYXRjaGVzID4gMFxuICAgID8gKFxuICAgICAgICBudW1NYXRjaGVzIC8gc2hvcnRlci5sZW5ndGggK1xuICAgICAgICBudW1NYXRjaGVzIC8gbG9uZ2VyLmxlbmd0aCArXG4gICAgICAgIChudW1NYXRjaGVzIC0gTWF0aC5mbG9vcih0cmFuc3Bvc2l0aW9ucyAvIDIpKSAvIG51bU1hdGNoZXNcbiAgICAgICkgLyAzLjBcbiAgICA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMxIHN0cmluZyBvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gczIgc2Vjb25kIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVmaXhTY2FsaW5nRmFjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGphcm9TaW1pbGFyaXR5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMxLCBzMiwgcHJlZml4U2NhbGluZ0ZhY3RvciA9IDAuMikge1xuICBjb25zdCBqYXJvU2ltaWxhcml0eSA9IGphcm8oczEsIHMyKTtcblxuICBsZXQgY29tbW9uUHJlZml4TGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKylcbiAgICBpZiAoczFbaV0gPT09IHMyW2ldKVxuICAgICAgY29tbW9uUHJlZml4TGVuZ3RoKys7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG5cbiAgcmV0dXJuIGphcm9TaW1pbGFyaXR5ICtcbiAgICBNYXRoLm1pbihjb21tb25QcmVmaXhMZW5ndGgsIDQpICpcbiAgICBwcmVmaXhTY2FsaW5nRmFjdG9yICpcbiAgICAoMSAtIGphcm9TaW1pbGFyaXR5KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICAgIHJldHVybiBjYWNoZVtrZXldIHx8IChcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKVxuICAgICk7XG4gIH07XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBqYXJvV2lua2xlciBmcm9tICcuL2phcm9XaW5rbGVyLmpzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKlxuICogQXV0b2NvbXBsZXRlIGZvciBhdXRvY29tcGxldGUuXG4gKiBGb3JrZWQgYW5kIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3hhdmkvbWlzcy1wbGV0ZVxuICovXG5jbGFzcyBBdXRvY29tcGxldGUge1xuICAvKipcbiAgICogQHBhcmFtICAge29iamVjdH0gc2V0dGluZ3MgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuICB7dGhpc30gICAgICAgICAgICAgVGhlIGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAnc2VsZWN0b3InOiBzZXR0aW5ncy5zZWxlY3RvciwgLy8gcmVxdWlyZWRcbiAgICAgICdvcHRpb25zJzogc2V0dGluZ3Mub3B0aW9ucywgLy8gcmVxdWlyZWRcbiAgICAgICdjbGFzc25hbWUnOiBzZXR0aW5ncy5jbGFzc25hbWUsIC8vIHJlcXVpcmVkXG4gICAgICAnc2VsZWN0ZWQnOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkJykpID9cbiAgICAgICAgc2V0dGluZ3Muc2VsZWN0ZWQgOiBmYWxzZSxcbiAgICAgICdzY29yZSc6IChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnc2NvcmUnKSkgP1xuICAgICAgICBzZXR0aW5ncy5zY29yZSA6IG1lbW9pemUoQXV0b2NvbXBsZXRlLnNjb3JlKSxcbiAgICAgICdsaXN0SXRlbSc6IChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnbGlzdEl0ZW0nKSkgP1xuICAgICAgICBzZXR0aW5ncy5saXN0SXRlbSA6IEF1dG9jb21wbGV0ZS5saXN0SXRlbSxcbiAgICAgICdnZXRTaWJsaW5nSW5kZXgnOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2dldFNpYmxpbmdJbmRleCcpKSA/XG4gICAgICAgIHNldHRpbmdzLmdldFNpYmxpbmdJbmRleCA6IEF1dG9jb21wbGV0ZS5nZXRTaWJsaW5nSW5kZXhcbiAgICB9O1xuXG4gICAgdGhpcy5zY29yZWRPcHRpb25zID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy51bCA9IG51bGw7XG4gICAgdGhpcy5oaWdobGlnaHRlZCA9IC0xO1xuXG4gICAgdGhpcy5TRUxFQ1RPUlMgPSBBdXRvY29tcGxldGUuc2VsZWN0b3JzO1xuICAgIHRoaXMuU1RSSU5HUyA9IEF1dG9jb21wbGV0ZS5zdHJpbmdzO1xuICAgIHRoaXMuTUFYX0lURU1TID0gQXV0b2NvbXBsZXRlLm1heEl0ZW1zO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgdGhpcy5rZXlkb3duRXZlbnQoZSk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5rZXl1cEV2ZW50KGUpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgIHRoaXMuaW5wdXRFdmVudChlKTtcbiAgICB9KTtcblxuICAgIGxldCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChlKSA9PiB7XG4gICAgICB0aGlzLmZvY3VzRXZlbnQoZSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZSkgPT4ge1xuICAgICAgdGhpcy5ibHVyRXZlbnQoZSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFVkVOVFNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBmb2N1cyBldmVudFxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICovXG4gIGZvY3VzRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKSByZXR1cm47XG5cbiAgICB0aGlzLmlucHV0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMuaW5wdXQudmFsdWUgPT09ICcnKVxuICAgICAgdGhpcy5tZXNzYWdlKCdJTklUJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlucHV0IGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBrZXlkb3duRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKSByZXR1cm47XG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0aGlzLnVsKVxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTM6IHRoaXMua2V5RW50ZXIoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OiB0aGlzLmtleUVzY2FwZShldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6IHRoaXMua2V5RG93bihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6IHRoaXMua2V5VXAoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBrZXl1cCBldmVudFxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICovXG4gIGtleXVwRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBpbnB1dEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgIHJldHVybjtcblxuICAgIHRoaXMuaW5wdXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5pbnB1dC52YWx1ZS5sZW5ndGggPiAwKVxuICAgICAgdGhpcy5zY29yZWRPcHRpb25zID0gdGhpcy5zZXR0aW5ncy5vcHRpb25zXG4gICAgICAgIC5tYXAoKG9wdGlvbikgPT4gdGhpcy5zZXR0aW5ncy5zY29yZSh0aGlzLmlucHV0LnZhbHVlLCBvcHRpb24pKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuc2NvcmVkT3B0aW9ucyA9IFtdO1xuXG4gICAgdGhpcy5kcm9wZG93bigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBibHVyIGV2ZW50XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgYmx1ckV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gd2luZG93IHx8XG4gICAgICAgICAgIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0aGlzLmlucHV0LmRhdGFzZXQucGVyc2lzdERyb3Bkb3duID09PSAndHJ1ZScpXG4gICAgICByZXR1cm47XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLRVkgSU5QVVQgRVZFTlRTXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaGF0IGhhcHBlbnMgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBkb3duIGFycm93XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgICAgICAgIFRoZSBDbGFzc1xuICAgKi9cbiAga2V5RG93bihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCgodGhpcy5oaWdobGlnaHRlZCA8IHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgP1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkICsgMSA6IC0xXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgdXAgYXJyb3dcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4gIHtvYmplY3R9ICAgICAgICAgVGhlIENsYXNzXG4gICAqL1xuICBrZXlVcChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCgodGhpcy5oaWdobGlnaHRlZCA+IC0xKSA/XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgLSAxIDogdGhpcy51bC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgZW50ZXIga2V5XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgICAgICAgIFRoZSBDbGFzc1xuICAgKi9cbiAga2V5RW50ZXIoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgZXNjYXBlIGtleVxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIGtleUVzY2FwZShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU1RBVElDXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJdCBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyAnc2NvcmUnXG4gICAqIGFuZCAnZGlzcGxheVZhbHVlLicgRGVmYXVsdCBpcyBhIEphcm/igJNXaW5rbGVyIHNpbWlsYXJpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge2FycmF5fSAgdmFsdWVcbiAgICogQHBhcmFtICB7YXJyYXl9ICBzeW5vbnltc1xuICAgKiBAcmV0dXJuIHtpbnR9ICAgIFNjb3JlIG9yIGRpc3BsYXlWYWx1ZVxuICAgKi9cbiAgc3RhdGljIHNjb3JlKHZhbHVlLCBzeW5vbnltcykge1xuICAgIGxldCBjbG9zZXN0U3lub255bSA9IG51bGw7XG5cbiAgICBzeW5vbnltcy5mb3JFYWNoKChzeW5vbnltKSA9PiB7XG4gICAgICBsZXQgc2ltaWxhcml0eSA9IGphcm9XaW5rbGVyKFxuICAgICAgICAgIHN5bm9ueW0udHJpbSgpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKTtcblxuICAgICAgaWYgKGNsb3Nlc3RTeW5vbnltID09PSBudWxsIHx8IHNpbWlsYXJpdHkgPiBjbG9zZXN0U3lub255bS5zaW1pbGFyaXR5KSB7XG4gICAgICAgIGNsb3Nlc3RTeW5vbnltID0ge3NpbWlsYXJpdHksIHZhbHVlOiBzeW5vbnltfTtcbiAgICAgICAgaWYgKHNpbWlsYXJpdHkgPT09IDEpIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY29yZTogY2xvc2VzdFN5bm9ueW0uc2ltaWxhcml0eSxcbiAgICAgIGRpc3BsYXlWYWx1ZTogc3lub255bXNbMF1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgaXRlbSBmb3IgZHJvcGRvd24gbGlzdC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgc2NvcmVkT3B0aW9uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIGluZGV4XG4gICAqIEByZXR1cm4ge3N0cmluZ30gIFRoZSBhIGxpc3QgaXRlbSA8bGk+LlxuICAgKi9cbiAgc3RhdGljIGxpc3RJdGVtKHNjb3JlZE9wdGlvbiwgaW5kZXgsIG1heEl0ZW1zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGV4ID0gaW5kZXggKyAxOyAvLyBzdGFydCBhdCAxXG5cbiAgICBjb25zdCBsaSA9IChub3JtYWxpemVkSW5kZXggPiBtYXhJdGVtcykgP1xuICAgICAgbnVsbCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICBpZiAobGkpIHtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgncm9sZScsICdvcHRpb24nKTtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGxpICYmIGxpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNjb3JlZE9wdGlvbi5kaXNwbGF5VmFsdWUpKTtcblxuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgcHJldmlvdXMgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgbm9kZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICBpbmRleCBvZiBwcmV2aW91cyBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIGdldFNpYmxpbmdJbmRleChub2RlKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IG4gPSBub2RlO1xuXG4gICAgZG8ge1xuICAgICAgaW5kZXgrKzsgbiA9IG4ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgd2hpbGUgKG4pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFBVQkxJQyBNRVRIT0RTXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IG9wdGlvbnMgYXMgYSBsaXN0LlxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSBUaGUgQ2xhc3NcbiAgICovXG4gIGRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB0aGlzLnNjb3JlZE9wdGlvbnMuZXZlcnkoKHNjb3JlZE9wdGlvbiwgaSkgPT4ge1xuICAgICAgbGV0IGxpc3RJdGVtID0gdGhpcy5zZXR0aW5ncy5saXN0SXRlbShzY29yZWRPcHRpb24sIGksIHRoaXMuTUFYX0lURU1TKTtcblxuICAgICAgbGlzdEl0ZW0gJiYgZG9jdW1lbnRGcmFnbWVudC5hcHBlbmRDaGlsZChsaXN0SXRlbSk7XG4gICAgICByZXR1cm4gISFsaXN0SXRlbTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpcy5oaWdobGlnaHRlZCA9IC0xO1xuXG4gICAgaWYgKGRvY3VtZW50RnJhZ21lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjb25zdCBuZXdVbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICAgIG5ld1VsLnNldEF0dHJpYnV0ZSgncm9sZScsICdsaXN0Ym94Jyk7XG4gICAgICBuZXdVbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgIG5ld1VsLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLlNFTEVDVE9SUy5PUFRJT05TKTtcblxuICAgICAgbmV3VWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0xJJylcbiAgICAgICAgICB0aGlzLmhpZ2hsaWdodCh0aGlzLnNldHRpbmdzLmdldFNpYmxpbmdJbmRleChldmVudC50YXJnZXQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdVbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuXG4gICAgICBuZXdVbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdMSScpXG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIG5ld1VsLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuXG4gICAgICAvLyBTZWUgQ1NTIHRvIHVuZGVyc3RhbmQgd2h5IHRoZSA8dWw+IGhhcyB0byBiZSB3cmFwcGVkIGluIGEgPGRpdj5cbiAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBuZXdDb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5zZXR0aW5ncy5jbGFzc25hbWU7XG4gICAgICBuZXdDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3VWwpO1xuXG4gICAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgIC8vIEluc2VydHMgdGhlIGRyb3Bkb3duIGp1c3QgYWZ0ZXIgdGhlIDxpbnB1dD4gZWxlbWVudFxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDb250YWluZXIsIHRoaXMuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICB0aGlzLnVsID0gbmV3VWw7XG5cbiAgICAgIHRoaXMubWVzc2FnZSgnVFlQSU5HJywgdGhpcy5zZXR0aW5ncy5vcHRpb25zLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSGlnaGxpZ2h0IG5ldyBvcHRpb24gc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICBuZXdJbmRleFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgVGhlIENsYXNzXG4gICAqL1xuICBoaWdobGlnaHQobmV3SW5kZXgpIHtcbiAgICBpZiAobmV3SW5kZXggPiAtMSAmJiBuZXdJbmRleCA8IHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBhbnkgb3B0aW9uIGFscmVhZHkgc2VsZWN0ZWQsIHRoZW4gdW5zZWxlY3QgaXRcbiAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdLmNsYXNzTGlzdFxuICAgICAgICAgIC5yZW1vdmUodGhpcy5TRUxFQ1RPUlMuSElHSExJR0hUKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbmV3SW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdLmNsYXNzTGlzdFxuICAgICAgICAgIC5hZGQodGhpcy5TRUxFQ1RPUlMuSElHSExJR0hUKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdXG4gICAgICAgICAgLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLlNFTEVDVE9SUy5BQ1RJVkVfREVTQ0VOREFOVCk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsXG4gICAgICAgICAgdGhpcy5TRUxFQ1RPUlMuQUNUSVZFX0RFU0NFTkRBTlQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gb3B0aW9uIGZyb20gYSBsaXN0IG9mIGl0ZW1zLlxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSBUaGUgQ2xhc3NcbiAgICovXG4gIHNlbGVjdGVkKCkge1xuICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHRoaXMuc2NvcmVkT3B0aW9uc1t0aGlzLmhpZ2hsaWdodGVkXS5kaXNwbGF5VmFsdWU7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgdGhpcy5tZXNzYWdlKCdTRUxFQ1RFRCcsIHRoaXMuaW5wdXQudmFsdWUpO1xuXG4gICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gNzY4KVxuICAgICAgICB0aGlzLmlucHV0LnNjcm9sbEludG9WaWV3KHRydWUpO1xuICAgIH1cblxuICAgIC8vIFVzZXIgcHJvdmlkZWQgY2FsbGJhY2sgbWV0aG9kIGZvciBzZWxlY3RlZCBvcHRpb24uXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWQpXG4gICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdGVkKHRoaXMuaW5wdXQudmFsdWUsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGRyb3Bkb3duIGxpc3Qgb25jZSBhIGxpc3QgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICogQHJldHVybiAge29iamVjdH0gVGhlIENsYXNzXG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLnVsID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lc3NhZ2luZyB0aGF0IGlzIHBhc3NlZCB0byB0aGUgc2NyZWVuIHJlYWRlclxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAga2V5ICAgICAgIFRoZSBLZXkgb2YgdGhlIG1lc3NhZ2UgdG8gd3JpdGVcbiAgICogQHBhcmFtICAge3N0cmluZ30gIHZhcmlhYmxlICBBIHZhcmlhYmxlIHRvIHByb3ZpZGUgdG8gdGhlIHN0cmluZy5cbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIG1lc3NhZ2Uoa2V5ID0gZmFsc2UsIHZhcmlhYmxlID0gJycpIHtcbiAgICBpZiAoIWtleSkgcmV0dXJuIHRoaXM7XG5cbiAgICBsZXQgbWVzc2FnZXMgPSB7XG4gICAgICAnSU5JVCc6ICgpID0+IHRoaXMuU1RSSU5HUy5ESVJFQ1RJT05TX1RZUEUsXG4gICAgICAnVFlQSU5HJzogKCkgPT4gKFtcbiAgICAgICAgICB0aGlzLlNUUklOR1MuT1BUSU9OX0FWQUlMQUJMRS5yZXBsYWNlKCd7eyBOVU1CRVIgfX0nLCB2YXJpYWJsZSksXG4gICAgICAgICAgdGhpcy5TVFJJTkdTLkRJUkVDVElPTlNfUkVWSUVXXG4gICAgICAgIF0uam9pbignLiAnKSksXG4gICAgICAnU0VMRUNURUQnOiAoKSA9PiAoW1xuICAgICAgICAgIHRoaXMuU1RSSU5HUy5PUFRJT05fU0VMRUNURUQucmVwbGFjZSgne3sgVkFMVUUgfX0nLCB2YXJpYWJsZSksXG4gICAgICAgICAgdGhpcy5TVFJJTkdTLkRJUkVDVElPTlNfVFlQRVxuICAgICAgICBdLmpvaW4oJy4gJykpXG4gICAgfTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyl9YClcbiAgICAgIC5pbm5lckhUTUwgPSBtZXNzYWdlc1trZXldKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogU2VsZWN0b3JzIGZvciB0aGUgQXV0b2NvbXBsZXRlIGNsYXNzLiAqL1xuQXV0b2NvbXBsZXRlLnNlbGVjdG9ycyA9IHtcbiAgJ0hJR0hMSUdIVCc6ICdpbnB1dC1hdXRvY29tcGxldGVfX2hpZ2hsaWdodCcsXG4gICdPUFRJT05TJzogJ2lucHV0LWF1dG9jb21wbGV0ZV9fb3B0aW9ucycsXG4gICdBQ1RJVkVfREVTQ0VOREFOVCc6ICdpbnB1dC1hdXRvY29tcGxldGVfX3NlbGVjdGVkJyxcbiAgJ1NDUkVFTl9SRUFERVJfT05MWSc6ICdzci1vbmx5J1xufTtcblxuLyoqICAqL1xuQXV0b2NvbXBsZXRlLnN0cmluZ3MgPSB7XG4gICdESVJFQ1RJT05TX1RZUEUnOlxuICAgICdTdGFydCB0eXBpbmcgdG8gZ2VuZXJhdGUgYSBsaXN0IG9mIHBvdGVudGlhbCBpbnB1dCBvcHRpb25zJyxcbiAgJ0RJUkVDVElPTlNfUkVWSUVXJzogW1xuICAgICAgJ0tleWJvYXJkIHVzZXJzIGNhbiB1c2UgdGhlIHVwIGFuZCBkb3duIGFycm93cyB0byAnLFxuICAgICAgJ3JldmlldyBvcHRpb25zIGFuZCBwcmVzcyBlbnRlciB0byBzZWxlY3QgYW4gb3B0aW9uJ1xuICAgIF0uam9pbignJyksXG4gICdPUFRJT05fQVZBSUxBQkxFJzogJ3t7IE5VTUJFUiB9fSBvcHRpb25zIGF2YWlsYWJsZScsXG4gICdPUFRJT05fU0VMRUNURUQnOiAne3sgVkFMVUUgfX0gc2VsZWN0ZWQnXG59O1xuXG4vKiogTWF4aW11bSBhbW91bnQgb2YgcmVzdWx0cyB0byBiZSByZXR1cm5lZC4gKi9cbkF1dG9jb21wbGV0ZS5tYXhJdGVtcyA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IEF1dG9jb21wbGV0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dG9jb21wbGV0ZSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL2F1dG9jb21wbGV0ZSc7XG5cbi8qKlxuICogVGhlIElucHV0QXV0b2NvbXBsZXRlIGNsYXNzLlxuICovXG5jbGFzcyBJbnB1dEF1dG9jb21wbGV0ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoaXMgY291bGQgYmUgc29tZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBwYXR0ZXJuIG1vZHVsZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgdGhpcy5saWJyYXJ5ID0gbmV3IEF1dG9jb21wbGV0ZSh7XG4gICAgICBvcHRpb25zOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSlcbiAgICAgICAgPyBzZXR0aW5ncy5vcHRpb25zIDogSW5wdXRBdXRvY29tcGxldGUub3B0aW9ucyxcbiAgICAgIHNlbGVjdGVkOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkJykpXG4gICAgICAgID8gc2V0dGluZ3Muc2VsZWN0ZWQgOiBmYWxzZSxcbiAgICAgIHNlbGVjdG9yOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykpXG4gICAgICAgID8gc2V0dGluZ3Muc2VsZWN0b3IgOiBJbnB1dEF1dG9jb21wbGV0ZS5zZWxlY3RvcixcbiAgICAgIGNsYXNzbmFtZTogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdjbGFzc25hbWUnKSlcbiAgICAgICAgPyBzZXR0aW5ncy5jbGFzc25hbWUgOiBJbnB1dEF1dG9jb21wbGV0ZS5jbGFzc25hbWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBBdXRvY29tcGxldGUgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHJlc2V0IFNldCBvZiBhcnJheSBvcHRpb25zIGZvciB0aGUgQXV0b2NvbXBsZXRlIGNsYXNzXG4gICAqIEByZXR1cm4ge29iamVjdH0gSW5wdXRBdXRvY29tcGxldGUgb2JqZWN0IHdpdGggbmV3IG9wdGlvbnMuXG4gICAqL1xuICBvcHRpb25zKHJlc2V0KSB7XG4gICAgdGhpcy5saWJyYXJ5LnNldHRpbmdzLm9wdGlvbnMgPSByZXNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBBdXRvY29tcGxldGUgc3RyaW5nc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBsb2NhbGl6ZWRTdHJpbmdzICBPYmplY3QgY29udGFpbmluZyBzdHJpbmdzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IEF1dG9jb21wbGV0ZSBzdHJpbmdzXG4gICAqL1xuICBzdHJpbmdzKGxvY2FsaXplZFN0cmluZ3MpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMubGlicmFyeS5TVFJJTkdTLCBsb2NhbGl6ZWRTdHJpbmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge2FycmF5fSBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBhdXRvY29tcGxldGUgY2xhc3MgKi9cbklucHV0QXV0b2NvbXBsZXRlLm9wdGlvbnMgPSBbXTtcblxuLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBzZWFyY2ggYm94IGRvbSBzZWxlY3RvciAqL1xuSW5wdXRBdXRvY29tcGxldGUuc2VsZWN0b3IgPSAnW2RhdGEtanM9XCJpbnB1dC1hdXRvY29tcGxldGVfX2lucHV0XCJdJztcblxuLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBjbGFzc25hbWUgZm9yIHRoZSBkcm9wZG93biBlbGVtZW50ICovXG5JbnB1dEF1dG9jb21wbGV0ZS5jbGFzc25hbWUgPSAnaW5wdXQtYXV0b2NvbXBsZXRlX19kcm9wZG93bic7XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0QXV0b2NvbXBsZXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSWNvbnMgZnJvbSAnLi4vZWxlbWVudHMvaWNvbnMvSWNvbnMnO1xuaW1wb3J0IEZlZWQgZnJvbSAnLi4vb2JqZWN0cy9mZWVkL0ZlZWQnO1xuaW1wb3J0IFRvZ2dsZSBmcm9tICcuLi91dGlsaXRpZXMvdG9nZ2xlL1RvZ2dsZSc7XG5pbXBvcnQgVHJhY2sgZnJvbSAnLi4vdXRpbGl0aWVzL3RyYWNrL1RyYWNrJztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vZWxlbWVudHMvc2VsZWN0L3NlbGVjdCc7XG5pbXBvcnQgQ2hhcnRCYXIgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhcic7XG5pbXBvcnQgQ2hhcnRIb3Jpem9udGFsQmFyIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhcic7XG5pbXBvcnQgQ2hhcnRMaW5lIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1saW5lJztcbmltcG9ydCBDaGFydFBpZSBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tcGllJztcbmltcG9ydCB7IE1hcE11bHRpTGF5ZXIsIE1hcFNpbmdsZUxheWVyIH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IElucHV0QXV0b2NvbXBsZXRlIGZyb20gJy4uL2VsZW1lbnRzL2lucHV0cy9pbnB1dC1hdXRvY29tcGxldGUnO1xuLyoqIGltcG9ydCBtb2R1bGVzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIHRoZSBnbG9iYWwgTnljb1BhdHRlcm5zIGluc3RhbmNlXG4gKi9cbmNsYXNzIG55Y28ge1xuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgSWNvbnMgRWxlbWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBJY29ucyBpbnN0YW5jZVxuICAgKi9cbiAgaWNvbnMocGF0aCkge1xuICAgIHJldHVybiBuZXcgSWNvbnMocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgRmVlZCBPYmplY3RcbiAgICogQHBhcmFtICAge09iamVjdH0gIHNldHRpbmdzICBTZXR0aW5nIGZvciB0aGUgZmVlZFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgICAgICAgIEZlZWQgaW5zdGFuY2VcbiAgICovXG4gIGZlZWQoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZlZWQoc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIFRvZ2dsZSBVdGlsaXR5XG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRvZ2dsZSBpbnN0YW5jZVxuICAgKi9cbiAgdG9nZ2xlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUb2dnbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUcmFjayBNb2R1bGVcbiAgICogQHJldHVybiAge09iamVjdH0gVHJhY2sgTW9kdWxlXG4gICAqL1xuICB0cmFjayhzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVHJhY2soKTtcbiAgfVxuXG4gIHNlbGVjdCgpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBDaGFydCBPYmplY3RzXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IENoYXJ0IGluc3RhbmNlXG4gICAqL1xuICBjaGFydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdiYXInKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdob3Jpem9udGFsQmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRIb3Jpem9udGFsQmFyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydExpbmUoKTtcblxuICAgIGlmICh0eXBlID09PSAncGllJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRQaWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBNYXAgTW9kdWxlXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IE1hcCBNb2R1bGVcbiAgICovXG4gIG1hcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdtdWx0aScpXG4gICAgICByZXR1cm4gbmV3IE1hcE11bHRpTGF5ZXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnc2luZ2xlJylcbiAgICAgIHJldHVybiBuZXcgTWFwU2luZ2xlTGF5ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBJbnB1dCBBdXRvY29tcGxldGUgRWxlbWVudFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBJbnB1dCBBdXRvY29tcGxldGUgaW5zdGFuY2VcbiAgICovXG4gIGlucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IElucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKiBhZGQgQVBJcyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4gKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgbnljbztcbiJdLCJuYW1lcyI6WyJVdGlsaXR5IiwiZGVidWciLCJnZXRVcmxQYXJhbWV0ZXIiLCJQQVJBTVMiLCJERUJVRyIsIm5hbWUiLCJxdWVyeVN0cmluZyIsInF1ZXJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJzZWFyY2giLCJjb25zdCIsInBhcmFtIiwicmVwbGFjZSIsInJlZ2V4IiwiUmVnRXhwIiwicmVzdWx0cyIsImV4ZWMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJsb2NhbGl6ZSIsInNsdWciLCJ0ZXh0IiwibGV0Iiwic3RyaW5ncyIsIkxPQ0FMSVpFRF9TVFJJTkdTIiwibWF0Y2giLCJmaWx0ZXIiLCJzIiwiaGFzT3duUHJvcGVydHkiLCJsYWJlbCIsIlNFTEVDVE9SUyIsInBhcnNlTWFya2Rvd24iLCJJY29ucyIsInBhdGgiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsIm9rIiwiY29uc29sZSIsImRpciIsImVycm9yIiwiZGF0YSIsInNwcml0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJPYmplY3QiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJTeW1ib2wiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0UmF3VGFnIiwidmFsdWUiLCJpc093biIsImNhbGwiLCJ0YWciLCJ1bm1hc2tlZCIsImUiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJ0eXBlIiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJrZXlzIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwidGVzdCIsImdldFZhbHVlIiwib2JqZWN0Iiwia2V5IiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsIm90aGVyIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImNvcHlPYmplY3QiLCJzb3VyY2UiLCJwcm9wcyIsImN1c3RvbWl6ZXIiLCJpc05ldyIsImluZGV4IiwibGVuZ3RoIiwibmV3VmFsdWUiLCJpZGVudGl0eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3MiLCJuYXRpdmVNYXgiLCJNYXRoIiwibWF4Iiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsImFyZ3VtZW50cyIsImFycmF5IiwiQXJyYXkiLCJvdGhlckFyZ3MiLCJjb25zdGFudCIsImJhc2VTZXRUb1N0cmluZyIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsInNob3J0T3V0IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJzZXRUb1N0cmluZyIsImJhc2VSZXN0IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJyZUlzVWludCIsImlzSW5kZXgiLCJpc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJiYXNlVGltZXMiLCJuIiwiaXRlcmF0ZWUiLCJpc09iamVjdExpa2UiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJwdXNoIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIm5hdGl2ZUtleXNJbiIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwia2V5c0luIiwiYXNzaWduSW5XaXRoIiwic3JjSW5kZXgiLCJvdmVyQXJnIiwiYXJnIiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJvYmplY3RDdG9yU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImRvbUV4Y1RhZyIsImlzRXJyb3IiLCJtZXNzYWdlIiwiYXR0ZW1wdCIsIkVycm9yIiwiYXJyYXlNYXAiLCJiYXNlVmFsdWVzIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInNyY1ZhbHVlIiwic3RyaW5nRXNjYXBlcyIsImVzY2FwZVN0cmluZ0NoYXIiLCJjaHIiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJyZUludGVycG9sYXRlIiwiYmFzZVByb3BlcnR5T2YiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJlc2NhcGUiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJ0ZW1wbGF0ZVNldHRpbmdzIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJ0ZW1wbGF0ZSIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJfIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwib2Zmc2V0Iiwic2xpY2UiLCJ2YXJpYWJsZSIsImFycmF5RWFjaCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiYmFzZUZvciIsImJhc2VGb3JPd24iLCJjcmVhdGVCYXNlRWFjaCIsImVhY2hGdW5jIiwiY29sbGVjdGlvbiIsImJhc2VFYWNoIiwiY2FzdEZ1bmN0aW9uIiwiZm9yRWFjaCIsImxpc3RDYWNoZUNsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiYXNzb2NJbmRleE9mIiwiYXJyYXlQcm90byIsInNwbGljZSIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwiaGFzIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsIk1hcCIsIm5hdGl2ZUNyZWF0ZSIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJtYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcCIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJMQVJHRV9BUlJBWV9TSVpFIiwic3RhY2tTZXQiLCJwYWlycyIsIlN0YWNrIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImFsbG9jVW5zYWZlIiwiY2xvbmVCdWZmZXIiLCJidWZmZXIiLCJpc0RlZXAiLCJjb3B5IiwiVWludDhBcnJheSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZVR5cGVkQXJyYXkiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImNvcHlBcnJheSIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImJhc2VDcmVhdGUiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsInNhZmVHZXQiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU1lcmdlRGVlcCIsIm1lcmdlRnVuYyIsInN0YWNrIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNUeXBlZCIsImJhc2VNZXJnZSIsIm1lcmdlIiwidmFsdWVzIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiYWRkIiwiYXJyYXlTb21lIiwicHJlZGljYXRlIiwiY2FjaGVIYXMiLCJjYWNoZSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImVxdWFsQXJyYXlzIiwiYml0bWFzayIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInNlZW4iLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiY29udmVydCIsImFycmF5UHVzaCIsImJhc2VHZXRBbGxLZXlzIiwic3ltYm9sc0Z1bmMiLCJhcnJheUZpbHRlciIsInJlc0luZGV4Iiwic3R1YkFycmF5IiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJnZXRBbGxLZXlzIiwiZXF1YWxPYmplY3RzIiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJEYXRhVmlldyIsIlByb21pc2UiLCJTZXQiLCJXZWFrTWFwIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsImdldFRhZyIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJiYXNlSXNFcXVhbERlZXAiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc0VxdWFsIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJpc1N0cmljdENvbXBhcmFibGUiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VNYXRjaGVzIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwibWVtb2l6ZWQiLCJDYWNoZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiZGVmYXVsdFZhbHVlIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJoYXNJbiIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUiLCJiYXNlTWFwIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwic29ydCIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc051bGwiLCJ2YWxJc1JlZmxleGl2ZSIsInZhbElzU3ltYm9sIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsImNvbXBhcmVNdWx0aXBsZSIsIm9yZGVycyIsIm9iakNyaXRlcmlhIiwiY3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiYmFzZU9yZGVyQnkiLCJpdGVyYXRlZXMiLCJvcmRlckJ5IiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImJhc2VJc05hTiIsInN0cmljdEluZGV4T2YiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJub29wIiwiY3JlYXRlU2V0IiwiYmFzZVVuaXEiLCJpbmNsdWRlcyIsIm91dGVyIiwiY29tcHV0ZWQiLCJzZWVuSW5kZXgiLCJ1bmlxQnkiLCJGZWVkIiwiY29uZmlnIiwiX3NldHRpbmdzIiwiX21lcmdlIiwiaW5pdCIsImZlZWQiLCJyc3NUb0pzb24iLCJyc3NVcmwiLCJfZm9yRWFjaCIsInVybCIsInRoaXMiLCJfcmVxdWVzdCIsIl9wcm9jZXNzIiwiSlNPTiIsInBhcnNlIiwidGhpcyQxIiwiY29tcGlsZWQiLCJfcmVuZGVyIiwiZWwiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0b3IiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImV2ZW50IiwiX3hociIsInRhcmdldCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJvbnRpbWVvdXQiLCJvcGVuIiwic2VuZCIsImxvZyIsIl92YWx1ZXMiLCJ0ZW1wbGF0ZXMiLCJqb2luIiwiX3RlbXBsYXRlIiwibWVkaXVtIiwib3BlbmVyIiwiaGVhZGVyIiwicG9zdHMiLCJjbG9zZXIiLCJwb3N0RXhjZXJwdExlbmd0aCIsIml0ZW1zIiwicG9zdCIsImV4Y2VycHQiLCJkYXRlIiwiZGVzY3JpcHRpb24iLCJzdWJzdHIiLCJtaW4iLCJsYXN0SW5kZXhPZiIsInB1YkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJwb3N0RGF0ZUxvY2FsIiwicG9zdERhdGVGb3JtYXQiLCJtZXJnZWQiLCJjb25jYXQiLCJfdW5pcUJ5IiwiaXRlbSIsImd1aWQiLCJfb3JkZXJCeSIsInRpdGxlIiwidGl0bGVVcmwiLCJwcm9maWxlSW1nIiwiZm9udFNpemUiLCJyYXRpb1Byb2ZpbGUiLCJwb3N0Qm9yZGVyQ29sb3IiLCJwb3N0SW1nSGVpZ2h0IiwicG9zdEV4Y2VycHRUcmFpbCIsInBvc3RDdGFUZXh0IiwieWVhciIsIm1vbnRoIiwiZGF5IiwicG9zdERhdGVUaXRsZSIsImNsYXNzZXMiLCJ3cmFwcGVyIiwiZmVlZEl0ZW0iLCJsaW5rIiwidGh1bWJuYWlsIiwiaXRlbUZvb3RlciIsImN0YSIsInVuaXF1ZSIsIlRvZ2dsZSIsIm5hbWVzcGFjZSIsImluYWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJtYXRjaGVzIiwicHJldmVudERlZmF1bHQiLCJfdG9nZ2xlIiwiZ2V0QXR0cmlidXRlIiwiZWxlbWVudFRvZ2dsZSIsImRhdGFzZXQiLCJ1bmRvIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsYXNzTGlzdCIsInRvZ2dsZSIsImkiLCJlbEFyaWFSb2xlcyIsInRhcmdldEFyaWFSb2xlcyIsImNvbnRhaW5zIiwiaGFzaCIsIlRyYWNrIiwidHJhY2tLZXkiLCJ0cmFja0RhdGEiLCJjbGljayIsImQiLCJwYXRobmFtZSIsInd0Iiwid2VidHJlbmRzIiwiZ2EiLCJndGFnIiwidmlldyIsImFwcCIsImd0YWdWaWV3IiwiYXNzaWduIiwid3RkIiwiYXJnc2EiLCJmbGF0TWFwIiwiayIsIldlYnRyZW5kcyIsIm11bHRpVHJhY2siLCJ1cmkiLCJmaW5kIiwiZWxlbWVudCIsImFwcF9uYW1lIiwic2NyZWVuX25hbWUiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJvYmoiLCJfdG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwicGFyc2VGbG9hdCIsImZsb29yIiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJjYXRjaCIsInN0cmluZ2lmeSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImxpc3QiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsImluZGV4T2YiLCJoYXNPd24iLCJjYWNoZWQiLCJmbiIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwidG9BcnJheSIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsImIiLCJubyIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwibSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiYXN5bmMiLCJfbGlmZWN5Y2xlSG9va3MiLCJ1bmljb2RlTGV0dGVycyIsImlzUmVzZXJ2ZWQiLCJkZWYiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImVudiIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJ3YXJuIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwiVk5vZGUiLCJjaGlsZHJlbiIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInBhcmVudCIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImRlZHVwZUhvb2tzIiwiaG9va3MiLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwibWV0aG9kcyIsImluamVjdCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsIkJvb2xlYW4iLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsImxlbiIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsIk51bWJlciIsImV4cGxpY2l0VHlwZXMiLCJzb21lIiwiZWxlbSIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsImhhbmRsZXIiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJwIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiX25vcm1hbGl6ZWQiLCIkc3RhYmxlIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJiaW5kRHluYW1pY0tleXMiLCJiYXNlT2JqIiwicHJlcGVuZE1vZGlmaWVyIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJfZCIsIl9wIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJsaXN0ZW5lcnMiLCJpbmplY3Rpb25zIiwic2NvcGVkU2xvdHMiLCJfc2NvcGVJZCIsIl9jIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiaW5zZXJ0IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGVzdHJveSIsIiRkZXN0cm95IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsIl9wYXJlbnRWbm9kZSIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiJHZub2RlIiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImNsYXNzIiwiaW5pdFJlbmRlciIsIl92bm9kZSIsInBhcmVudFZub2RlIiwiX3JlbmRlckNoaWxkcmVuIiwicGFyZW50RGF0YSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIlZ1ZSIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsIm93bmVyIiwib3duZXJzIiwic3luYyIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNyZWF0ZUdldHRlckludm9rZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJ1aWQkMyIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInNlbGVjdGVkIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWYiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJyYW5nZSIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiZHluYW1pYyIsInJhbmdlU2V0SXRlbSIsInBsYWluIiwiYWRkQXR0ciIsImR5bmFtaWNBdHRycyIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImlzRHluYW1pY0FyZyIsInByZXBlbmRNb2RpZmllck1hcmtlciIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwicmlnaHQiLCJtaWRkbGUiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0UmF3QmluZGluZ0F0dHIiLCJyYXdBdHRyc01hcCIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ0eXBlQmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsImVuZGVkIiwib25FbmQiLCJwcm9wQ291bnQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwiYXBwZWFyIiwic3RhcnRDbGFzcyIsImFwcGVhckNsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImJlZm9yZUFwcGVhciIsImJlZm9yZUVudGVyIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJhZnRlckFwcGVhciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZEhvb2siLCJhcHBlYXJDYW5jZWxsZWQiLCJlbnRlckNhbmNlbGxlZCIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJsZWF2ZUNhbmNlbGxlZCIsImFmdGVyTGVhdmUiLCJkZWxheUxlYXZlIiwicGVyZm9ybUxlYXZlIiwiYmVmb3JlTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJvdXRwdXRTb3VyY2VSYW5nZSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImR5bmFtaWNBcmdSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsInNsb3RSRSIsImxpbmVCcmVha1JFIiwid2hpdGVzcGFjZVJFJDEiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwid2hpdGVzcGFjZU9wdGlvbiIsIndoaXRlc3BhY2UiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJmb3IiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdFRhcmdldER5bmFtaWMiLCJzbG90QmluZGluZyIsImdldFNsb3ROYW1lIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwiZm5JbnZva2VSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwicHJlZml4Iiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiY29udGFpbnNTbG90Q2hpbGQiLCJnZW5TY29wZWRTbG90IiwiaXNMZWdhY3lTeW50YXgiLCJyZXZlcnNlUHJveHkiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJsaW5lTGVuZ3RoIiwicGFkIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiU2VsZWN0RGF0YSIsIlNlbGVjdCIsIlNlbGVjdENvbXBvbmVudCIsIl9jb25zdGFudHMiLCJkYXRhSGFuZGxlciIsIm5ld0RhdGEiLCJjaGFydCIsIl9jaGFydCIsIm5ld0RhdGFzZXRMYWJlbHMiLCJkYXRhc2V0cyIsIm9sZERhdGFzZXRMYWJlbHMiLCJvbGRMYWJlbHMiLCJuZXdMYWJlbHMiLCJvbGREYXRhc2V0S2V5cyIsIm5ld0RhdGFzZXRLZXlzIiwiZGVsZXRpb25LZXlzIiwiZGVsZXRpb25LZXkiLCJsYWJlbHMiLCJ4TGFiZWxzIiwieUxhYmVscyIsInJlbmRlckNoYXJ0IiwiY2hhcnREYXRhIiwicmVhY3RpdmVEYXRhIiwicmVhY3RpdmVQcm9wIiwiaG9va0NhbGxiYWNrIiwic2V0SG9va0NhbGxiYWNrIiwiaW5wdXQiLCJpc09iamVjdEVtcHR5IiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsImhhc093blByb3AiLCJjcmVhdGVVVEMiLCJmb3JtYXQiLCJsb2NhbGUiLCJzdHJpY3QiLCJjcmVhdGVMb2NhbE9yVVRDIiwidXRjIiwiZGVmYXVsdFBhcnNpbmdGbGFncyIsImVtcHR5IiwidW51c2VkVG9rZW5zIiwidW51c2VkSW5wdXQiLCJvdmVyZmxvdyIsImNoYXJzTGVmdE92ZXIiLCJudWxsSW5wdXQiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwiX3BmIiwiZnVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpbnZhbGlkV2Vla2RheSIsIl9zdHJpY3QiLCJiaWdIb3VyIiwiY3JlYXRlSW52YWxpZCIsIk5hTiIsIm1vbWVudFByb3BlcnRpZXMiLCJjb3B5Q29uZmlnIiwiX2lzQU1vbWVudE9iamVjdCIsIl90em0iLCJfaXNVVEMiLCJfb2Zmc2V0IiwiX2xvY2FsZSIsInVwZGF0ZUluUHJvZ3Jlc3MiLCJNb21lbnQiLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsImFic0Zsb29yIiwiY2VpbCIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJjb21wYXJlQXJyYXlzIiwiYXJyYXkxIiwiYXJyYXkyIiwiZG9udENvbnZlcnQiLCJsZW5ndGhEaWZmIiwiYWJzIiwiZGlmZnMiLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGUiLCJmaXJzdFRpbWUiLCJkZXByZWNhdGlvbkhhbmRsZXIiLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJfY29uZmlnIiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50IiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbFBhcnNlIiwibWVyZ2VDb25maWdzIiwicGFyZW50Q29uZmlnIiwiY2hpbGRDb25maWciLCJMb2NhbGUiLCJkZWZhdWx0Q2FsZW5kYXIiLCJzYW1lRGF5IiwibmV4dERheSIsIm5leHRXZWVrIiwibGFzdERheSIsImxhc3RXZWVrIiwic2FtZUVsc2UiLCJjYWxlbmRhciIsIm1vbSIsIm91dHB1dCIsIl9jYWxlbmRhciIsImRlZmF1bHRMb25nRGF0ZUZvcm1hdCIsIkxUUyIsIkxUIiwiTCIsIkxMIiwiTExMIiwiTExMTCIsImxvbmdEYXRlRm9ybWF0IiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJkZWZhdWx0SW52YWxpZERhdGUiLCJpbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJvcmRpbmFsIiwiX29yZGluYWwiLCJkZWZhdWx0UmVsYXRpdmVUaW1lIiwiZnV0dXJlIiwicGFzdCIsInNzIiwibW0iLCJoaCIsImRkIiwiTSIsIk1NIiwieSIsInl5IiwicmVsYXRpdmVUaW1lIiwid2l0aG91dFN1ZmZpeCIsImlzRnV0dXJlIiwiX3JlbGF0aXZlVGltZSIsInBhc3RGdXR1cmUiLCJkaWZmIiwiYWxpYXNlcyIsImFkZFVuaXRBbGlhcyIsInVuaXQiLCJzaG9ydGhhbmQiLCJsb3dlckNhc2UiLCJub3JtYWxpemVVbml0cyIsInVuaXRzIiwibm9ybWFsaXplT2JqZWN0VW5pdHMiLCJpbnB1dE9iamVjdCIsIm5vcm1hbGl6ZWRJbnB1dCIsIm5vcm1hbGl6ZWRQcm9wIiwicHJpb3JpdGllcyIsImFkZFVuaXRQcmlvcml0eSIsInByaW9yaXR5IiwiZ2V0UHJpb3JpdGl6ZWRVbml0cyIsInVuaXRzT2JqIiwidSIsInplcm9GaWxsIiwidGFyZ2V0TGVuZ3RoIiwiZm9yY2VTaWduIiwiYWJzTnVtYmVyIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsImxvY2FsZURhdGEiLCJyZW1vdmVGb3JtYXR0aW5nVG9rZW5zIiwibWFrZUZvcm1hdEZ1bmN0aW9uIiwiZm9ybWF0TW9tZW50IiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibWF0Y2gxIiwibWF0Y2gyIiwibWF0Y2gzIiwibWF0Y2g0IiwibWF0Y2g2IiwibWF0Y2gxdG8yIiwibWF0Y2gzdG80IiwibWF0Y2g1dG82IiwibWF0Y2gxdG8zIiwibWF0Y2gxdG80IiwibWF0Y2gxdG82IiwibWF0Y2hVbnNpZ25lZCIsIm1hdGNoU2lnbmVkIiwibWF0Y2hPZmZzZXQiLCJtYXRjaFNob3J0T2Zmc2V0IiwibWF0Y2hUaW1lc3RhbXAiLCJtYXRjaFdvcmQiLCJyZWdleGVzIiwiYWRkUmVnZXhUb2tlbiIsInN0cmljdFJlZ2V4IiwiaXNTdHJpY3QiLCJnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4iLCJ1bmVzY2FwZUZvcm1hdCIsInJlZ2V4RXNjYXBlIiwibWF0Y2hlZCIsInAxIiwicDIiLCJwMyIsInA0IiwiYWRkUGFyc2VUb2tlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwicGFyc2VUd29EaWdpdFllYXIiLCJkYXlzSW5ZZWFyIiwiaXNMZWFwWWVhciIsImdldFNldFllYXIiLCJtYWtlR2V0U2V0IiwiZ2V0SXNMZWFwWWVhciIsImtlZXBUaW1lIiwic2V0JDEiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwibW9kIiwieCIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TG9jYWxlTW9udGhzIiwibG9jYWxlTW9udGhzIiwiX21vbnRocyIsImlzRm9ybWF0IiwiZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0IiwibG9jYWxlTW9udGhzU2hvcnQiLCJfbW9udGhzU2hvcnQiLCJoYW5kbGVTdHJpY3RQYXJzZSIsIm1vbnRoTmFtZSIsImlpIiwibGxjIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJfbW9udGhzUGFyc2UiLCJfbG9uZ01vbnRoc1BhcnNlIiwiX3Nob3J0TW9udGhzUGFyc2UiLCJsb2NhbGVNb250aHNQYXJzZSIsIl9tb250aHNQYXJzZUV4YWN0Iiwic2V0TW9udGgiLCJkYXlPZk1vbnRoIiwiZ2V0U2V0TW9udGgiLCJnZXREYXlzSW5Nb250aCIsImRlZmF1bHRNb250aHNTaG9ydFJlZ2V4IiwiY29tcHV0ZU1vbnRoc1BhcnNlIiwiX21vbnRoc1Nob3J0U3RyaWN0UmVnZXgiLCJfbW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsIl9tb250aHNTdHJpY3RSZWdleCIsIl9tb250aHNSZWdleCIsImNtcExlblJldiIsInNob3J0UGllY2VzIiwibG9uZ1BpZWNlcyIsIm1peGVkUGllY2VzIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImxvY2FsZVdlZWtkYXlzIiwiX3dlZWtkYXlzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQiLCJsb2NhbGVXZWVrZGF5c1Nob3J0IiwiX3dlZWtkYXlzU2hvcnQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4iLCJsb2NhbGVXZWVrZGF5c01pbiIsIl93ZWVrZGF5c01pbiIsImhhbmRsZVN0cmljdFBhcnNlJDEiLCJ3ZWVrZGF5TmFtZSIsIl93ZWVrZGF5c1BhcnNlIiwiX3Nob3J0V2Vla2RheXNQYXJzZSIsIl9taW5XZWVrZGF5c1BhcnNlIiwibG9jYWxlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1BhcnNlRXhhY3QiLCJfZnVsbFdlZWtkYXlzUGFyc2UiLCJnZXRTZXREYXlPZldlZWsiLCJnZXREYXkiLCJnZXRTZXRMb2NhbGVEYXlPZldlZWsiLCJnZXRTZXRJU09EYXlPZldlZWsiLCJkZWZhdWx0V2Vla2RheXNSZWdleCIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsImRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRSZWdleCIsImRlZmF1bHRXZWVrZGF5c01pblJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwibG9jYWxlTWVyaWRpZW0iLCJpc0xvd2VyIiwiZ2V0U2V0SG91ciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwibG9hZExvY2FsZSIsIm9sZExvY2FsZSIsIl9hYmJyIiwiYWxpYXNlZFJlcXVpcmUiLCJnZXRTZXRHbG9iYWxMb2NhbGUiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwidXBkYXRlTG9jYWxlIiwidG1wTG9jYWxlIiwibGlzdExvY2FsZXMiLCJjaGVja092ZXJmbG93IiwiX292ZXJmbG93RGF5T2ZZZWFyIiwiX292ZXJmbG93V2Vla3MiLCJfb3ZlcmZsb3dXZWVrZGF5IiwiZGVmYXVsdHMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJfdXNlVVRDIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiY29uZmlnRnJvbUFycmF5IiwiY3VycmVudERhdGUiLCJleHBlY3RlZFdlZWtkYXkiLCJ5ZWFyVG9Vc2UiLCJkYXlPZlllYXJGcm9tV2Vla0luZm8iLCJfZGF5T2ZZZWFyIiwiX25leHREYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsInciLCJ3ZWVrWWVhciIsInRlbXAiLCJ3ZWVrZGF5T3ZlcmZsb3ciLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJjdXJXZWVrIiwiZ2ciLCJleHRlbmRlZElzb1JlZ2V4IiwiYmFzaWNJc29SZWdleCIsInR6UmVnZXgiLCJpc29EYXRlcyIsImlzb1RpbWVzIiwiYXNwTmV0SnNvblJlZ2V4IiwiY29uZmlnRnJvbUlTTyIsImFsbG93VGltZSIsImRhdGVGb3JtYXQiLCJ0aW1lRm9ybWF0IiwidHpGb3JtYXQiLCJjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IiwiZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyIsInllYXJTdHIiLCJtb250aFN0ciIsImRheVN0ciIsImhvdXJTdHIiLCJtaW51dGVTdHIiLCJzZWNvbmRTdHIiLCJ1bnRydW5jYXRlWWVhciIsInByZXByb2Nlc3NSRkMyODIyIiwiY2hlY2tXZWVrZGF5Iiwid2Vla2RheVN0ciIsInBhcnNlZElucHV0Iiwid2Vla2RheVByb3ZpZGVkIiwid2Vla2RheUFjdHVhbCIsIm9ic09mZnNldHMiLCJVVCIsIkdNVCIsIkVEVCIsIkVTVCIsIkNEVCIsIkNTVCIsIk1EVCIsIk1TVCIsIlBEVCIsIlBTVCIsImNhbGN1bGF0ZU9mZnNldCIsIm9ic09mZnNldCIsIm1pbGl0YXJ5T2Zmc2V0IiwibnVtT2Zmc2V0IiwiaG0iLCJjb25maWdGcm9tUkZDMjgyMiIsInBhcnNlZEFycmF5IiwiY29uZmlnRnJvbVN0cmluZyIsImNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrIiwiSVNPXzg2MDEiLCJSRkNfMjgyMiIsInNraXBwZWQiLCJzdHJpbmdMZW5ndGgiLCJ0b3RhbFBhcnNlZElucHV0TGVuZ3RoIiwibWVyaWRpZW1GaXhXcmFwIiwiaG91ciIsImlzUG0iLCJtZXJpZGllbUhvdXIiLCJjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkiLCJ0ZW1wQ29uZmlnIiwiYmVzdE1vbWVudCIsInNjb3JlVG9CZWF0IiwiY3VycmVudFNjb3JlIiwic2NvcmUiLCJjb25maWdGcm9tT2JqZWN0IiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJjcmVhdGVGcm9tQ29uZmlnIiwicHJlcGFyZUNvbmZpZyIsInByZXBhcnNlIiwiY29uZmlnRnJvbUlucHV0IiwiaXNVVEMiLCJwcm90b3R5cGVNaW4iLCJwcm90b3R5cGVNYXgiLCJwaWNrQnkiLCJtb21lbnRzIiwib3JkZXJpbmciLCJpc0R1cmF0aW9uVmFsaWQiLCJ1bml0SGFzRGVjaW1hbCIsImlzVmFsaWQkMSIsImNyZWF0ZUludmFsaWQkMSIsImNyZWF0ZUR1cmF0aW9uIiwiRHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfYnViYmxlIiwiaXNEdXJhdGlvbiIsImFic1JvdW5kIiwicm91bmQiLCJzZXBhcmF0b3IiLCJ1dGNPZmZzZXQiLCJvZmZzZXRGcm9tU3RyaW5nIiwiY2h1bmtPZmZzZXQiLCJtYXRjaGVyIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsInNldFRpbWUiLCJsb2NhbCIsImdldERhdGVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImdldFNldE9mZnNldCIsImtlZXBMb2NhbFRpbWUiLCJrZWVwTWludXRlcyIsImxvY2FsQWRqdXN0IiwiX2NoYW5nZUluUHJvZ3Jlc3MiLCJhZGRTdWJ0cmFjdCIsImdldFNldFpvbmUiLCJzZXRPZmZzZXRUb1VUQyIsInNldE9mZnNldFRvTG9jYWwiLCJzdWJ0cmFjdCIsInNldE9mZnNldFRvUGFyc2VkT2Zmc2V0IiwidFpvbmUiLCJoYXNBbGlnbmVkSG91ck9mZnNldCIsImlzRGF5bGlnaHRTYXZpbmdUaW1lIiwiaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkIiwiX2lzRFNUU2hpZnRlZCIsImlzTG9jYWwiLCJpc1V0Y09mZnNldCIsImlzVXRjIiwiYXNwTmV0UmVnZXgiLCJpc29SZWdleCIsImRpZmZSZXMiLCJwYXJzZUlzbyIsIm1vbWVudHNEaWZmZXJlbmNlIiwiaW52YWxpZCIsImlucCIsInBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsImlzQWRkaW5nIiwiZ2V0Q2FsZW5kYXJGb3JtYXQiLCJteU1vbWVudCIsImNhbGVuZGFyJDEiLCJ0aW1lIiwiZm9ybWF0cyIsInNvZCIsInN0YXJ0T2YiLCJjYWxlbmRhckZvcm1hdCIsImxvY2FsSW5wdXQiLCJlbmRPZiIsImlzQmV0d2VlbiIsImluY2x1c2l2aXR5IiwibG9jYWxGcm9tIiwibG9jYWxUbyIsImlzU2FtZSIsImlucHV0TXMiLCJpc1NhbWVPckFmdGVyIiwiaXNTYW1lT3JCZWZvcmUiLCJhc0Zsb2F0IiwidGhhdCIsInpvbmVEZWx0YSIsIm1vbnRoRGlmZiIsIndob2xlTW9udGhEaWZmIiwiYW5jaG9yIiwiYW5jaG9yMiIsImFkanVzdCIsImRlZmF1bHRGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0VXRjIiwidG9JU09TdHJpbmciLCJrZWVwT2Zmc2V0IiwidG9EYXRlIiwiaW5zcGVjdCIsInpvbmUiLCJkYXRldGltZSIsInN1ZmZpeCIsImlucHV0U3RyaW5nIiwicG9zdGZvcm1hdCIsImh1bWFuaXplIiwiZnJvbU5vdyIsInRvTm93IiwibmV3TG9jYWxlRGF0YSIsImxhbmciLCJNU19QRVJfU0VDT05EIiwiTVNfUEVSX01JTlVURSIsIk1TX1BFUl9IT1VSIiwiTVNfUEVSXzQwMF9ZRUFSUyIsIm1vZCQxIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibG9jYWxTdGFydE9mRGF0ZSIsInV0Y1N0YXJ0T2ZEYXRlIiwic3RhcnRPZkRhdGUiLCJpc29XZWVrZGF5IiwidW5peCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsImlzb1dlZWtZZWFyIiwiYWRkV2Vla1llYXJGb3JtYXRUb2tlbiIsImdldFNldFdlZWtZZWFyIiwiZ2V0U2V0V2Vla1llYXJIZWxwZXIiLCJnZXRTZXRJU09XZWVrWWVhciIsImdldElTT1dlZWtzSW5ZZWFyIiwiZ2V0V2Vla3NJblllYXIiLCJ3ZWVrSW5mbyIsIndlZWtzVGFyZ2V0Iiwic2V0V2Vla0FsbCIsImRheU9mWWVhckRhdGEiLCJnZXRTZXRRdWFydGVyIiwiZ2V0U2V0RGF5T2ZNb250aCIsImdldFNldERheU9mWWVhciIsImdldFNldE1pbnV0ZSIsImdldFNldFNlY29uZCIsInBhcnNlTXMiLCJnZXRTZXRNaWxsaXNlY29uZCIsImdldFpvbmVBYmJyIiwiZ2V0Wm9uZU5hbWUiLCJpc29XZWVrcyIsImlzb1dlZWtzSW5ZZWFyIiwicGFyc2Vab25lIiwiaXNEU1QiLCJ6b25lQWJiciIsInpvbmVOYW1lIiwiZGF0ZXMiLCJpc0RTVFNoaWZ0ZWQiLCJjcmVhdGVVbml4IiwiY3JlYXRlSW5ab25lIiwicHJlUGFyc2VQb3N0Rm9ybWF0IiwicHJvdG8kMSIsImZpcnN0RGF5T2ZZZWFyIiwiZmlyc3REYXlPZldlZWsiLCJnZXQkMSIsImZpZWxkIiwibGlzdE1vbnRoc0ltcGwiLCJvdXQiLCJsaXN0V2Vla2RheXNJbXBsIiwibG9jYWxlU29ydGVkIiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsInN1YnRyYWN0JDEiLCJhYnNDZWlsIiwiYnViYmxlIiwibW9udGhzRnJvbURheXMiLCJtb250aHNUb0RheXMiLCJkYXlzVG9Nb250aHMiLCJhcyIsInZhbHVlT2YkMSIsIm1ha2VBcyIsImFzTWlsbGlzZWNvbmRzIiwiYXNTZWNvbmRzIiwiYXNNaW51dGVzIiwiYXNIb3VycyIsImFzRGF5cyIsImFzV2Vla3MiLCJhc01vbnRocyIsImFzUXVhcnRlcnMiLCJhc1llYXJzIiwiY2xvbmUkMSIsImdldCQyIiwibWFrZUdldHRlciIsInRocmVzaG9sZHMiLCJzdWJzdGl0dXRlVGltZUFnbyIsInJlbGF0aXZlVGltZSQxIiwicG9zTmVnRHVyYXRpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJvdW5kaW5nRnVuY3Rpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndpdGhTdWZmaXgiLCJhYnMkMSIsInRvSVNPU3RyaW5nJDEiLCJZIiwiRCIsInRvRml4ZWQiLCJ0b3RhbCIsInRvdGFsU2lnbiIsInltU2lnbiIsImRheXNTaWduIiwiaG1zU2lnbiIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInJlbGF0aXZlVGltZVJvdW5kaW5nIiwicmVsYXRpdmVUaW1lVGhyZXNob2xkIiwiSFRNTDVfRk1UIiwiREFURVRJTUVfTE9DQUwiLCJEQVRFVElNRV9MT0NBTF9TRUNPTkRTIiwiREFURVRJTUVfTE9DQUxfTVMiLCJUSU1FIiwiVElNRV9TRUNPTkRTIiwiVElNRV9NUyIsInJlcXVpcmUkJDAiLCJtb21lbnQiLCJjb252ZXJzaW9ucyIsInJnYjJoc2wiLCJyZ2IyaHN2IiwicmdiMmh3YiIsInJnYjJjbXlrIiwicmdiMmtleXdvcmQiLCJyZ2IyeHl6IiwicmdiMmxhYiIsInJnYjJsY2giLCJoc2wycmdiIiwiaHNsMmhzdiIsImhzbDJod2IiLCJoc2wyY215ayIsImhzbDJrZXl3b3JkIiwiaHN2MnJnYiIsImhzdjJoc2wiLCJoc3YyaHdiIiwiaHN2MmNteWsiLCJoc3Yya2V5d29yZCIsImh3YjJyZ2IiLCJod2IyaHNsIiwiaHdiMmhzdiIsImh3YjJjbXlrIiwiaHdiMmtleXdvcmQiLCJjbXlrMnJnYiIsImNteWsyaHNsIiwiY215azJoc3YiLCJjbXlrMmh3YiIsImNteWsya2V5d29yZCIsImtleXdvcmQycmdiIiwia2V5d29yZDJoc2wiLCJrZXl3b3JkMmhzdiIsImtleXdvcmQyaHdiIiwia2V5d29yZDJjbXlrIiwia2V5d29yZDJsYWIiLCJrZXl3b3JkMnh5eiIsInh5ejJyZ2IiLCJ4eXoybGFiIiwieHl6MmxjaCIsImxhYjJ4eXoiLCJsYWIycmdiIiwibGFiMmxjaCIsImxjaDJsYWIiLCJsY2gyeHl6IiwibGNoMnJnYiIsInJnYiIsInIiLCJnIiwiZGVsdGEiLCJyZXZlcnNlS2V5d29yZHMiLCJ6IiwieHl6IiwiaHNsIiwidDEiLCJ0MiIsInQzIiwic3YiLCJoc3YiLCJoaSIsImYiLCJxIiwic2wiLCJod2IiLCJ3aCIsImJsIiwicmF0aW8iLCJjbXlrIiwibGFiIiwieTIiLCJociIsImF0YW4yIiwiUEkiLCJzcXJ0IiwibGNoIiwiY29zIiwic2luIiwia2V5d29yZCIsImNzc0tleXdvcmRzIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJDb252ZXJ0ZXIiLCJwYWlyIiwiY29udnMiLCJyb3V0ZVNwYWNlIiwiZ2V0VmFsdWVzIiwic2V0VmFsdWVzIiwidmFscyIsImZzcGFjZSIsImNvbG9yQ29udmVydCIsImNvbG9yTmFtZSIsImNvbG9yU3RyaW5nIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwiaGV4IiwicmdiYSIsInBlciIsImhleEFscGhhIiwic2NhbGUiLCJhbHBoYSIsImhzbGEiLCJoZXhEb3VibGUiLCJyZXZlcnNlTmFtZXMiLCJudW0iLCJDb2xvciIsImxpZ2h0bmVzcyIsIndoaXRlbmVzcyIsInNldFNwYWNlIiwicmdiQXJyYXkiLCJoc2xBcnJheSIsImhzdkFycmF5IiwiaHdiQXJyYXkiLCJjbXlrQXJyYXkiLCJyZ2JhQXJyYXkiLCJoc2xhQXJyYXkiLCJzZXRDaGFubmVsIiwiaHVlIiwic2F0dXJhdGlvbiIsInNhdHVyYXRpb252IiwiYmxhY2tuZXNzIiwicmdiTnVtYmVyIiwibHVtaW5vc2l0eSIsImx1bSIsImNoYW4iLCJjb250cmFzdCIsImNvbG9yMiIsImx1bTEiLCJsdW0yIiwibGV2ZWwiLCJjb250cmFzdFJhdGlvIiwiZGFyayIsInlpcSIsImxpZ2h0IiwibmVnYXRlIiwibGlnaHRlbiIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImJsYWNrZW4iLCJncmV5c2NhbGUiLCJjbGVhcmVyIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwidzEiLCJ3MiIsInNwYWNlcyIsIm1heGVzIiwiY2hhbnMiLCJjYXBwZWQiLCJzbmFtZSIsInN2YWx1ZXMiLCJjaGFydGpzQ29sb3IiLCJoZWxwZXJzIiwiaXNOdWxsT3JVbmRlZiIsInZhbHVlT3JEZWZhdWx0IiwidmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWFjaCIsImxvb3BhYmxlIiwicmV2ZXJzZSIsImFycmF5RXF1YWxzIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwia2xlbiIsIl9tZXJnZXIiLCJ0dmFsIiwic3ZhbCIsIl9tZXJnZXJJZiIsIm1lcmdlSWYiLCJtZXJnZXIiLCJzZXRGbiIsImluaGVyaXRzIiwiZXh0ZW5zaW9ucyIsIm1lIiwiQ2hhcnRFbGVtZW50IiwiU3Vycm9nYXRlIiwiX19zdXBlcl9fIiwiaGVscGVyc19jb3JlIiwiY2FsbENhbGxiYWNrIiwiZ2V0VmFsdWVPckRlZmF1bHQiLCJnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJoZWxwZXJzX2Vhc2luZyIsImVhc2luZ0VmZmVjdHMiLCJSQURfUEVSX0RFRyIsIkRPVUJMRV9QSSIsIkhBTEZfUEkiLCJRVUFSVEVSX1BJIiwiVFdPX1RISVJEU19QSSIsImV4cG9ydHMkMSIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmRlZFJlY3QiLCJyYWRpdXMiLCJib3R0b20iLCJtb3ZlVG8iLCJhcmMiLCJjbG9zZVBhdGgiLCJyZWN0IiwiZHJhd1BvaW50Iiwicm90YXRpb24iLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInJhZCIsImRyYXdJbWFnZSIsImJlZ2luUGF0aCIsImxpbmVUbyIsIlNRUlQxXzIiLCJmaWxsIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJwb2ludCIsImFyZWEiLCJlcHNpbG9uIiwiY2xpcEFyZWEiLCJzYXZlIiwiY2xpcCIsInVuY2xpcEFyZWEiLCJyZXN0b3JlIiwicHJldmlvdXMiLCJmbGlwIiwic3RlcHBlZCIsInN0ZXBwZWRMaW5lIiwibWlkcG9pbnQiLCJ0ZW5zaW9uIiwiYmV6aWVyQ3VydmVUbyIsImNvbnRyb2xQb2ludFByZXZpb3VzWCIsImNvbnRyb2xQb2ludE5leHRYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFkiLCJoZWxwZXJzX2NhbnZhcyIsImRyYXdSb3VuZGVkUmVjdGFuZ2xlIiwiX3NldCIsInNjb3BlIiwiZGVmYXVsdENvbG9yIiwiZGVmYXVsdEZvbnRDb2xvciIsImRlZmF1bHRGb250RmFtaWx5IiwiZGVmYXVsdEZvbnRTaXplIiwiZGVmYXVsdEZvbnRTdHlsZSIsImRlZmF1bHRMaW5lSGVpZ2h0Iiwic2hvd0xpbmVzIiwiY29yZV9kZWZhdWx0cyIsInRvRm9udFN0cmluZyIsImZvbnQiLCJmYW1pbHkiLCJoZWxwZXJzX29wdGlvbnMiLCJ0b0xpbmVIZWlnaHQiLCJ0b1BhZGRpbmciLCJfcGFyc2VGb250IiwiZ2xvYmFsRGVmYXVsdHMiLCJmb250RmFtaWx5IiwibGluZUhlaWdodCIsImZvbnRTdHlsZSIsImlucHV0cyIsImhlbHBlcnMkMSIsImVhc2luZyIsImNhbnZhcyIsImVhc2UiLCJvcmlnaW4iLCJjMCIsImMxIiwiRWxlbWVudCIsImNvbmZpZ3VyYXRpb24iLCJpbml0aWFsaXplIiwiaGlkZGVuIiwicGl2b3QiLCJfdmlldyIsIl9tb2RlbCIsIl9zdGFydCIsInRvb2x0aXBQb3NpdGlvbiIsImhhc1ZhbHVlIiwiY29yZV9lbGVtZW50IiwiZXhwb3J0cyQyIiwiY3VycmVudFN0ZXAiLCJudW1TdGVwcyIsIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCJvbkFuaW1hdGlvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb24iLCJhbmltYXRpb24iLCJvblByb2dyZXNzIiwib25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0IiwiYWRkQW5pbWF0aW9uIiwic3RhcnRUaW1lIiwiYW5pbWF0aW5nIiwiY2FuY2VsQW5pbWF0aW9uIiwiZmluZEluZGV4IiwicmVxdWVzdEFuaW1GcmFtZSIsInN0YXJ0RGlnZXN0IiwibmV4dFN0ZXAiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwiRGF0YXNldENvbnRyb2xsZXIiLCJkYXRhc2V0SW5kZXgiLCJkYXRhc2V0RWxlbWVudFR5cGUiLCJkYXRhRWxlbWVudFR5cGUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJ1cGRhdGVJbmRleCIsImdldE1ldGEiLCJnZXREYXRhc2V0IiwieEF4aXNJRCIsInNjYWxlcyIsInhBeGVzIiwieUF4aXNJRCIsInlBeGVzIiwiZ2V0RGF0YXNldE1ldGEiLCJnZXRTY2FsZUZvcklkIiwic2NhbGVJRCIsIl9nZXRWYWx1ZVNjYWxlSWQiLCJfZ2V0SW5kZXhTY2FsZUlkIiwiX2dldFZhbHVlU2NhbGUiLCJfZ2V0SW5kZXhTY2FsZSIsInJlc2V0IiwiY3JlYXRlTWV0YURhdGFzZXQiLCJfZGF0YXNldEluZGV4IiwiY3JlYXRlTWV0YURhdGEiLCJfaW5kZXgiLCJtZXRhRGF0YSIsImFkZEVsZW1lbnRBbmRSZXNldCIsInVwZGF0ZUVsZW1lbnQiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJyZXN5bmNFbGVtZW50cyIsImVhc2luZ1ZhbHVlIiwiZWxlbWVudHMiLCJkcmF3IiwicmVtb3ZlSG92ZXJTdHlsZSIsIiRwcmV2aW91c1N0eWxlIiwic2V0SG92ZXJTdHlsZSIsImN1c3RvbSIsImdldEhvdmVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJCb3JkZXJXaWR0aCIsIm51bU1ldGEiLCJudW1EYXRhIiwiaW5zZXJ0RWxlbWVudHMiLCJvbkRhdGFQdXNoIiwib25EYXRhUG9wIiwib25EYXRhU2hpZnQiLCJvbkRhdGFTcGxpY2UiLCJvbkRhdGFVbnNoaWZ0IiwiY29yZV9kYXRhc2V0Q29udHJvbGxlciIsImJvcmRlckFsaWduIiwiZWxlbWVudF9hcmMiLCJpbkxhYmVsUmFuZ2UiLCJtb3VzZVgiLCJob3ZlclJhZGl1cyIsImluUmFuZ2UiLCJjaGFydFgiLCJjaGFydFkiLCJwb2ludFJlbGF0aXZlUG9zaXRpb24iLCJnZXRBbmdsZUZyb21Qb2ludCIsImFuZ2xlIiwiZGlzdGFuY2UiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImdldENlbnRlclBvaW50IiwiaGFsZkFuZ2xlIiwiaGFsZlJhZGl1cyIsImdldEFyZWEiLCJjZW50cmVBbmdsZSIsInJhbmdlRnJvbUNlbnRyZSIsInNBIiwiZUEiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJzdHJva2VTdHlsZSIsInZhbHVlT3JEZWZhdWx0JDEiLCJsaW5lIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsImNhcEJlemllclBvaW50cyIsImVsZW1lbnRfbGluZSIsInNwYW5HYXBzIiwicG9pbnRzIiwiX2NoaWxkcmVuIiwiZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzIiwibGFzdERyYXduSW5kZXgiLCJjdXJyZW50Vk0iLCJfbG9vcCIsImxpbmVDYXAiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicHJldmlvdXNJdGVtIiwic2tpcCIsInZhbHVlT3JEZWZhdWx0JDIiLCJkZWZhdWx0Q29sb3IkMSIsInBvaW50U3R5bGUiLCJoaXRSYWRpdXMiLCJ4UmFuZ2UiLCJ5UmFuZ2UiLCJtb3VzZVkiLCJlbGVtZW50X3BvaW50IiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsInBhZGRpbmciLCJjaGFydEFyZWEiLCJkZWZhdWx0Q29sb3IkMiIsInJlY3RhbmdsZSIsImJvcmRlclNraXBwZWQiLCJpc1ZlcnRpY2FsIiwiZ2V0QmFyQm91bmRzIiwieDEiLCJ4MiIsInkxIiwiaGFsZiIsInN3YXAiLCJvcmlnIiwidjIiLCJwYXJzZUJvcmRlclNraXBwZWQiLCJlZGdlIiwiaG9yaXpvbnRhbCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJib3JkZXIiLCJpbm5lciIsInNraXBYIiwic2tpcFkiLCJlbGVtZW50X3JlY3RhbmdsZSIsInJlY3RzIiwiZmlsbFJlY3QiLCJBcmMiLCJMaW5lIiwiUG9pbnQiLCJSZWN0YW5nbGUiLCJyZXNvbHZlJDEiLCJob3ZlciIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsInBpeGVscyIsImlzSG9yaXpvbnRhbCIsInRpY2tzIiwiZ2V0VGlja3MiLCJjdXJyIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJzdGFja0NvdW50IiwiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsInBlcmNlbnQiLCJjb250cm9sbGVyX2JhciIsImJhciIsIl9ydWxlciIsImdldFJ1bGVyIiwiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsIl94U2NhbGUiLCJfeVNjYWxlIiwiZGF0YXNldExhYmVsIiwiX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInZzY2FsZSIsImdldEJhc2VQaXhlbCIsInZwaXhlbHMiLCJjYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJjYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImhlYWQiLCJjZW50ZXIiLCJfZ2V0U3RhY2tzIiwic3RhY2tzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImdldFN0YWNrQ291bnQiLCJnZXRTdGFja0luZGV4IiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJtaW5CYXJMZW5ndGgiLCJpbWV0YSIsIml2YWx1ZSIsImNvbnRyb2xsZXIiLCJzdGFja0luZGV4IiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJkYXRhSW5kZXgiLCJ2YWx1ZU9yRGVmYXVsdCQzIiwicmVzb2x2ZSQyIiwicG9zaXRpb24iLCJ0b29sdGlwcyIsImRhdGFQb2ludCIsInhMYWJlbCIsInlMYWJlbCIsImNvbnRyb2xsZXJfYnViYmxlIiwieFNjYWxlIiwieVNjYWxlIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIl9vcHRpb25zIiwicmVzb2x2ZSQzIiwidmFsdWVPckRlZmF1bHQkNCIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiZHMiLCJhcmNPcHRzIiwiYnciLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJjaXJjdW1mZXJlbmNlIiwidG9vbHRpcEl0ZW0iLCJkYXRhTGFiZWwiLCJjb250cm9sbGVyX2RvdWdobnV0IiwiZ2V0UmluZ0luZGV4IiwicmluZ0luZGV4IiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJtaW5TaXplIiwiYXJjcyIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJjb250YWluczAiLCJjb250YWluczkwIiwiY29udGFpbnMxODAiLCJjb250YWluczI3MCIsImN1dG91dCIsImdldE1heEJvcmRlcldpZHRoIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiaG92ZXJXaWR0aCIsInJpbmdXZWlnaHRPZmZzZXQiLCJkYXRhU2V0SW5kZXgiLCJheGlzIiwiY29udHJvbGxlcl9ob3Jpem9udGFsQmFyIiwidmFsdWVPckRlZmF1bHQkNSIsInJlc29sdmUkNCIsImlzUG9pbnRJbkFyZWEiLCJsaW5lRW5hYmxlZCIsInNob3dMaW5lIiwiY29udHJvbGxlcl9saW5lIiwibGluZVRlbnNpb24iLCJfc2NhbGUiLCJfcmVzb2x2ZUxpbmVPcHRpb25zIiwidXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImxpbmVNb2RlbCIsIl9yZXNvbHZlUG9pbnRPcHRpb25zIiwiY2FsY3VsYXRlUG9pbnRZIiwiRUxFTUVOVF9PUFRJT05TIiwiZWxlbWVudE9wdGlvbnMiLCJzdW1Qb3MiLCJzdW1OZWciLCJkc01ldGEiLCJzdGFja2VkUmlnaHRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJjb250cm9sUG9pbnRzIiwicHQiLCJjYXBDb250cm9sUG9pbnQiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwic3BsaW5lQ3VydmVNb25vdG9uZSIsInNwbGluZUN1cnZlIiwibmV4dEl0ZW0iLCJoYWxmQm9yZGVyV2lkdGgiLCJyZXNvbHZlJDUiLCJhbmdsZUxpbmVzIiwicG9pbnRMYWJlbHMiLCJiZWdpbkF0WmVybyIsImNvbnRyb2xsZXJfcG9sYXJBcmVhIiwic3RhcnRzIiwiX3N0YXJ0cyIsImFuZ2xlcyIsIl9hbmdsZXMiLCJfdXBkYXRlUmFkaXVzIiwiY291bnRWaXNpYmxlRWxlbWVudHMiLCJfY29tcHV0ZUFuZ2xlIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsInJlc2V0UmFkaXVzIiwiZG91Z2hudXQiLCJjb250cm9sbGVyX3BpZSIsInZhbHVlT3JEZWZhdWx0JDYiLCJyZXNvbHZlJDYiLCJjb250cm9sbGVyX3JhZGFyIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsImNvbnRyb2xsZXJfc2NhdHRlciIsImNvbnRyb2xsZXJzIiwiaG9yaXpvbnRhbEJhciIsInBvbGFyQXJlYSIsInBpZSIsInJhZGFyIiwic2NhdHRlciIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJwYXJzZVZpc2libGVJdGVtcyIsImpsZW4iLCJnZXRJbnRlcnNlY3RJdGVtcyIsImdldE5lYXJlc3RJdGVtcyIsImludGVyc2VjdCIsImRpc3RhbmNlTWV0cmljIiwibWluRGlzdGFuY2UiLCJQT1NJVElWRV9JTkZJTklUWSIsIm5lYXJlc3RJdGVtcyIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwicHQxIiwicHQyIiwiZGVsdGFYIiwiZGVsdGFZIiwiaW5kZXhNb2RlIiwiY29yZV9pbnRlcmFjdGlvbiIsIm1vZGVzIiwic2luZ2xlIiwibmVhcmVzdCIsImludGVyc2VjdHNJdGVtIiwiZmlsdGVyQnlQb3NpdGlvbiIsIndoZXJlIiwic29ydEJ5V2VpZ2h0IiwiX3RtcEluZGV4XyIsImZpbmRNYXhQYWRkaW5nIiwiYm94ZXMiLCJib3giLCJnZXRQYWRkaW5nIiwiYm94UGFkZGluZyIsImFkZFNpemVCeVBvc2l0aW9uIiwibGF5b3V0IiwiY29yZV9sYXlvdXRzIiwiYWRkQm94IiwiZnVsbFdpZHRoIiwicmVtb3ZlQm94IiwibGF5b3V0SXRlbSIsImNvbmZpZ3VyZSIsImxheW91dE9wdGlvbnMiLCJsZWZ0UGFkZGluZyIsInJpZ2h0UGFkZGluZyIsInRvcFBhZGRpbmciLCJib3R0b21QYWRkaW5nIiwibGVmdEJveGVzIiwicmlnaHRCb3hlcyIsInRvcEJveGVzIiwiYm90dG9tQm94ZXMiLCJjaGFydEFyZWFCb3hlcyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJvdXRlckJveGVzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiY2hhcnRBcmVhV2lkdGgiLCJ2ZXJ0aWNhbEJveFdpZHRoIiwibWF4Q2hhcnRBcmVhV2lkdGgiLCJtYXhDaGFydEFyZWFIZWlnaHQiLCJvdXRlckJveFNpemVzIiwibWluQm94U2l6ZXMiLCJtYXhQYWRkaW5nIiwiZ2V0TWluaW11bUJveFNpemUiLCJmaXRCb3giLCJtaW5Cb3hTaXplIiwiZmluZE5leHRXaGVyZSIsIm1pbkJveCIsInNjYWxlTWFyZ2luIiwiZmluYWxGaXRWZXJ0aWNhbEJveCIsImxlZnRQYWRkaW5nQWRkaXRpb24iLCJ0b3BQYWRkaW5nQWRkaXRpb24iLCJuZXdNYXhDaGFydEFyZWFIZWlnaHQiLCJuZXdNYXhDaGFydEFyZWFXaWR0aCIsInBsYWNlQm94IiwicGxhdGZvcm1fYmFzaWMiLCJhY3F1aXJlQ29udGV4dCIsImdldENvbnRleHQiLCJwbGF0Zm9ybV9kb20iLCJwbGF0Zm9ybV9kb20kMSIsImdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UiLCJzdHlsZXNoZWV0IiwiRVhQQU5ET19LRVkiLCJDU1NfUFJFRklYIiwiQ1NTX1NJWkVfTU9OSVRPUiIsIkNTU19SRU5ERVJfTU9OSVRPUiIsIkNTU19SRU5ERVJfQU5JTUFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJyZWFkVXNlZFNpemUiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwicmVuZGVyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJhc3BlY3RSYXRpbyIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJuYXRpdmVFdmVudCIsImZyb21OYXRpdmVFdmVudCIsInRocm90dGxlZCIsInRpY2tpbmciLCJjcmVhdGVEaXYiLCJjbGFzc05hbWUiLCJjcmVhdGVSZXNpemVyIiwibWF4U2l6ZSIsInJlc2l6ZXIiLCJleHBhbmQiLCJzaHJpbmsiLCJfcmVzZXQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25TY3JvbGwiLCJ3YXRjaEZvclJlbmRlciIsImV4cGFuZG8iLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJyZWZsb3ciLCJvZmZzZXRQYXJlbnQiLCJ1bndhdGNoRm9yUmVuZGVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwiY2xpZW50V2lkdGgiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImluamVjdENTUyIsIl9zdHlsZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicGxhdGZvcm1fZG9tJDIiLCJkaXNhYmxlQ1NTSW5qZWN0aW9uIiwiX2VuYWJsZWQiLCJfZW5zdXJlTG9hZGVkIiwiX2xvYWRlZCIsImdldEVsZW1lbnRCeUlkIiwicmVsZWFzZUNvbnRleHQiLCJwcm94aWVzIiwiYWRkRXZlbnQiLCJyZW1vdmVFdmVudCIsImltcGxlbWVudGF0aW9uIiwicGx1Z2lucyIsImNvcmVfcGx1Z2lucyIsIl9wbHVnaW5zIiwiX2NhY2hlSWQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJpZHgiLCJnZXRBbGwiLCJkZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCIkcGx1Z2lucyIsIl9pbnZhbGlkYXRlIiwiY29yZV9zY2FsZVNlcnZpY2UiLCJjb25zdHJ1Y3RvcnMiLCJyZWdpc3RlclNjYWxlVHlwZSIsInNjYWxlQ29uc3RydWN0b3IiLCJzY2FsZURlZmF1bHRzIiwiZ2V0U2NhbGVDb25zdHJ1Y3RvciIsImdldFNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiYWRkU2NhbGVzVG9MYXlvdXQiLCJ2YWx1ZU9yRGVmYXVsdCQ3IiwiZW5hYmxlZCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJhZnRlckxhYmVsIiwiYWZ0ZXJCb2R5IiwiYmVmb3JlRm9vdGVyIiwiZm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsInNwbGl0TmV3bGluZXMiLCJjcmVhdGVUb29sdGlwSXRlbSIsImluZGV4U2NhbGUiLCJ2YWx1ZVNjYWxlIiwiZ2V0TGFiZWxGb3JJbmRleCIsImdldEJhc2VNb2RlbCIsInRvb2x0aXBPcHRzIiwieEFsaWduIiwieUFsaWduIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsIm9wYWNpdHkiLCJsZWdlbmRDb2xvckJhY2tncm91bmQiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImFmdGVyIiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJtZWFzdXJlVGV4dCIsImZvbnRTdHJpbmciLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJsZiIsInJmIiwib2xmIiwib3JmIiwieWYiLCJtaWRYIiwibWlkWSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiYWxpZ24iLCJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsImV4cG9ydHMkMyIsIl9sYXN0QWN0aXZlIiwiZ2V0VGl0bGUiLCJnZXRCZWZvcmVCb2R5IiwiZ2V0Qm9keSIsImJvZHlJdGVtcyIsImdldEFmdGVyQm9keSIsImdldEZvb3RlciIsImNoYW5nZWQiLCJleGlzdGluZ01vZGVsIiwiX2FjdGl2ZSIsImJhY2tncm91bmRQb2ludCIsInRvb2x0aXBTaXplIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFRleHRDb2xvcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsImRyYXdUaXRsZSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0JvZHkiLCJkcmF3Q29sb3JCb3hlcyIsInhMaW5lUGFkZGluZyIsImNvbG9yWCIsInRleHRDb2xvciIsImZpbGxMaW5lT2ZUZXh0Iiwic3Ryb2tlUmVjdCIsImRyYXdGb290ZXIiLCJkcmF3QmFja2dyb3VuZCIsInF1YWRyYXRpY0N1cnZlVG8iLCJoYXNUb29sdGlwQ29udGVudCIsImdsb2JhbEFscGhhIiwiaGFuZGxlRXZlbnQiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwicG9zaXRpb25lcnNfMSIsImNvcmVfdG9vbHRpcCIsInZhbHVlT3JEZWZhdWx0JDgiLCJvbkhvdmVyIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJyZXNwb25zaXZlIiwicmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uIiwibWVyZ2VTY2FsZUNvbmZpZyIsInNsZW4iLCJtZXJnZUNvbmZpZyIsImluaXRDb25maWciLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsIkNoYXJ0IiwiY29uc3RydWN0IiwiX2J1ZmZlcmVkUmVuZGVyIiwiaW5zdGFuY2VzIiwicmV0aW5hU2NhbGUiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmluZEV2ZW50cyIsInJlc2l6ZSIsImluaXRUb29sVGlwIiwibmV3V2lkdGgiLCJnZXRNYXhpbXVtV2lkdGgiLCJuZXdIZWlnaHQiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwic2NhbGVzT3B0aW9ucyIsInNjYWxlT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsImR0eXBlIiwiZHBvc2l0aW9uIiwiaXNEZWZhdWx0Iiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsIm1lcmdlVGlja3NPcHRpb25zIiwiaGFzVXBkYXRlZCIsImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsIm5ld0NvbnRyb2xsZXJzIiwiZGVzdHJveURhdGFzZXRNZXRhIiwiQ29udHJvbGxlckNsYXNzIiwicmVzZXRFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwibGFzdEFjdGl2ZSIsIl9idWZmZXJlZFJlcXVlc3QiLCJ1cGRhdGVEYXRhc2V0IiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbk9iamVjdCIsImVhc2luZ0Z1bmN0aW9uIiwic3RlcERlY2ltYWwiLCJkcmF3RGF0YXNldHMiLCJfZHJhd1Rvb2x0aXAiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdFhBeGlzIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsIl9jaGFydEluc3RhbmNlIiwiX2xpc3RlbmVycyIsImV2ZW50SGFuZGxlciIsInVwZGF0ZUhvdmVyU3R5bGUiLCJidWZmZXJlZFJlcXVlc3QiLCJob3Zlck9wdGlvbnMiLCJjb3JlX2NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwiY29uZmlnTWVyZ2UiLCJzY2FsZU1lcmdlIiwiY29yZV9oZWxwZXJzIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImFycmF5VG9TZWFyY2giLCJzdGFydEluZGV4IiwiY3VycmVudEl0ZW0iLCJmaW5kUHJldmlvdXNXaGVyZSIsImFsbW9zdEVxdWFscyIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIk5FR0FUSVZFX0lORklOSVRZIiwibG9nMTAiLCJleHBvbmVudCIsIkxPRzEwRSIsInBvd2VyT2YxMCIsImlzUG93ZXJPZjEwIiwidG9SYWRpYW5zIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbGlhc1BpeGVsIiwicGl4ZWxXaWR0aCIsIl9hbGlnblBpeGVsIiwicGl4ZWwiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImhhbGZXaWR0aCIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwiRVBTSUxPTiIsInBvaW50c1dpdGhUYW5nZW50cyIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwicG9pbnRCZWZvcmUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwic2xvcGVEZWx0YVgiLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwibG9vcCIsIm5pY2VOdW0iLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImV2dCIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhcnNlTWF4U3R5bGUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJpc0NvbnN0cmFpbmVkVmFsdWUiLCJnZXRDb25zdHJhaW50RGltZW5zaW9uIiwiZG9tTm9kZSIsIm1heFN0eWxlIiwicGVyY2VudGFnZVByb3BlcnR5IiwiZGVmYXVsdFZpZXciLCJfZ2V0UGFyZW50Tm9kZSIsImNvbnN0cmFpbmVkTm9kZSIsImNvbnN0cmFpbmVkQ29udGFpbmVyIiwiaGFzQ05vZGUiLCJoYXNDQ29udGFpbmVyIiwiaW5maW5pdHkiLCJnZXRDb25zdHJhaW50V2lkdGgiLCJnZXRDb25zdHJhaW50SGVpZ2h0IiwiX2NhbGN1bGF0ZVBhZGRpbmciLCJwYXJlbnREaW1lbnNpb24iLCJob3N0IiwiY3ciLCJjbGllbnRIZWlnaHQiLCJjdXJyZW50U3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9yY2VSYXRpbyIsInBpeGVsUmF0aW8iLCJwaXhlbFNpemUiLCJsb25nZXN0VGV4dCIsImFycmF5T2ZUaGluZ3MiLCJnYyIsImdhcmJhZ2VDb2xsZWN0IiwibG9uZ2VzdCIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJnY0xlbiIsInRleHRXaWR0aCIsIm51bWJlck9mTGFiZWxMaW5lcyIsIm51bWJlck9mTGluZXMiLCJjb2xvciIsIkNhbnZhc0dyYWRpZW50IiwiY29sb3JWYWx1ZSIsIkNhbnZhc1BhdHRlcm4iLCJEYXRlQWRhcHRlciIsIl9jcmVhdGUiLCJvdmVycmlkZSIsIm1lbWJlcnMiLCJfZGF0ZSIsImNvcmVfYWRhcHRlcnMiLCJjb3JlX3RpY2tzIiwiZm9ybWF0dGVycyIsInRpY2tWYWx1ZSIsImxvZ0RlbHRhIiwidGlja1N0cmluZyIsIm1heFRpY2siLCJsb2dUaWNrIiwidG9FeHBvbmVudGlhbCIsIm51bURlY2ltYWwiLCJsb2dhcml0aG1pYyIsInJlbWFpbiIsInZhbHVlT3JEZWZhdWx0JDkiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja01hcmtMZW5ndGgiLCJ6ZXJvTGluZVdpZHRoIiwiemVyb0xpbmVDb2xvciIsInplcm9MaW5lQm9yZGVyRGFzaCIsInplcm9MaW5lQm9yZGVyRGFzaE9mZnNldCIsInNjYWxlTGFiZWwiLCJsYWJlbFN0cmluZyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImxhYmVsc0Zyb21UaWNrcyIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJsaW5lVmFsdWUiLCJjb21wdXRlVGV4dFNpemUiLCJ0aWNrIiwiY29yZV9zY2FsZSIsIl90aWNrcyIsImJlZm9yZVVwZGF0ZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWFyZ2lucyIsIl9tYXhMYWJlbExpbmVzIiwibG9uZ2VzdExhYmVsV2lkdGgiLCJsb25nZXN0VGV4dENhY2hlIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInRpY2tPcHRzIiwidXNlckNhbGxiYWNrIiwidGlja0ZvbnQiLCJsYWJlbFJvdGF0aW9uIiwib3JpZ2luYWxMYWJlbFdpZHRoIiwibGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrV2lkdGgiLCJhbmdsZVJhZGlhbnMiLCJzY2FsZUxhYmVsT3B0cyIsImdyaWRMaW5lT3B0cyIsIl9pc1Zpc2libGUiLCJwYXJzZUZvbnQiLCJpc0Z1bGxXaWR0aCIsInNjYWxlTGFiZWxGb250Iiwic2NhbGVMYWJlbFBhZGRpbmciLCJkZWx0YUhlaWdodCIsImxhcmdlc3RUZXh0V2lkdGgiLCJ0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzIiwibGluZVNwYWNlIiwidGlja1BhZGRpbmciLCJsYWJlbEhlaWdodCIsImZpcnN0TGFiZWxXaWR0aCIsImxhc3RMYWJlbFdpZHRoIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaGFuZGxlTWFyZ2lucyIsInJhd1ZhbHVlIiwiZ2V0VmFsdWVGb3JQaXhlbCIsImlubmVyV2lkdGgiLCJmaW5hbFZhbCIsImlubmVySGVpZ2h0IiwiZGVjaW1hbCIsInZhbHVlT2Zmc2V0IiwiZ2V0QmFzZVZhbHVlIiwiX2F1dG9Ta2lwIiwib3B0aW9uVGlja3MiLCJ0aWNrQ291bnQiLCJza2lwUmF0aW8iLCJtYXhUaWNrcyIsIm1heFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsIl90aWNrU2l6ZSIsImF4aXNMZW5ndGgiLCJQYWRkaW5nQm90dG9tIiwicm90Iiwib3B0aW9uTWFqb3JUaWNrcyIsImlzUm90YXRlZCIsImlzTWlycm9yZWQiLCJ0aWNrRm9udENvbG9yIiwiZm9udENvbG9yIiwibWFqb3JUaWNrRm9udENvbG9yIiwibWFqb3JUaWNrRm9udCIsInRsIiwic2NhbGVMYWJlbEZvbnRDb2xvciIsImxhYmVsUm90YXRpb25SYWRpYW5zIiwiaXRlbXNUb0RyYXciLCJheGlzV2lkdGgiLCJhbGlnblBpeGVsIiwiYm9yZGVyVmFsdWUiLCJ0aWNrU3RhcnQiLCJ0aWNrRW5kIiwibGluZUNvbG9yIiwiemVyb0xpbmVJbmRleCIsInR4MSIsInR5MSIsInR4MiIsInR5MiIsImxhYmVsWCIsImxhYmVsWSIsInRleHRPZmZzZXQiLCJsYWJlbFlPZmZzZXQiLCJsYWJlbFhPZmZzZXQiLCJnbFdpZHRoIiwiZ2xDb2xvciIsImdsQm9yZGVyRGFzaCIsImdsQm9yZGVyRGFzaE9mZnNldCIsIml0ZW1Ub0RyYXciLCJ0cmFuc2xhdGUiLCJzY2FsZUxhYmVsWCIsInNjYWxlTGFiZWxZIiwiaGFsZkxpbmVIZWlnaHQiLCJpc0xlZnQiLCJmaXJzdExpbmVXaWR0aCIsImxhc3RMaW5lV2lkdGgiLCJkZWZhdWx0Q29uZmlnIiwic2NhbGVfY2F0ZWdvcnkiLCJnZXRMYWJlbHMiLCJtaW5JbmRleCIsIm1heEluZGV4Iiwib2Zmc2V0QW10IiwidmFsdWVDYXRlZ29yeSIsInZhbHVlV2lkdGgiLCJ3aWR0aE9mZnNldCIsInZhbHVlSGVpZ2h0IiwiaGVpZ2h0T2Zmc2V0IiwiaG9yeiIsInZhbHVlRGltZW5zaW9uIiwiX2RlZmF1bHRzIiwiZ2VuZXJhdGVUaWNrcyIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwiTUlOX1NQQUNJTkciLCJzdGVwU2l6ZSIsIm1heE51bVNwYWNlcyIsInByZWNpc2lvbiIsInJtaW4iLCJybWF4Iiwic3BhY2luZyIsImZhY3RvciIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwic2NhbGVfbGluZWFyYmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsImdldFRpY2tMaW1pdCIsIl9jb21wdXRlVGlja0xpbWl0IiwiaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzIiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJmaXhlZFN0ZXBTaXplIiwidGlja3NBc051bWJlcnMiLCJkZWZhdWx0Q29uZmlnJDEiLCJzY2FsZV9saW5lYXIiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiSURNYXRjaGVzIiwiaGFzU3RhY2tzIiwidmFsdWVzUGVyU3RhY2siLCJwb3NpdGl2ZVZhbHVlcyIsIm5lZ2F0aXZlVmFsdWVzIiwicmVsYXRpdmVQb2ludHMiLCJ2YWx1ZXNGb3JUeXBlIiwibWluVmFsIiwibWF4VmFsIiwiaW5uZXJEaW1lbnNpb24iLCJfZGVmYXVsdHMkMSIsInZhbHVlT3JEZWZhdWx0JGEiLCJnZW5lcmF0ZVRpY2tzJDEiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsImRlZmF1bHRDb25maWckMiIsIm5vbk5lZ2F0aXZlT3JEZWZhdWx0Iiwic2NhbGVfbG9nYXJpdGhtaWMiLCJ0aWNrVmFsdWVzIiwiX2dldEZpcnN0VGlja1ZhbHVlIiwiZmlyc3RUaWNrVmFsdWUiLCJfZGVmYXVsdHMkMiIsInZhbHVlT3JEZWZhdWx0JGIiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMSIsInJlc29sdmUkNyIsImRlZmF1bHRDb25maWckMyIsImFuaW1hdGUiLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmdZIiwiYmFja2Ryb3BQYWRkaW5nWCIsImdldFZhbHVlQ291bnQiLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInRleHRTaXplIiwiX3BvaW50TGFiZWxTaXplcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJnZXRJbmRleEFuZ2xlIiwiaExpbWl0cyIsInZMaW1pdHMiLCJzZXRSZWR1Y3Rpb25zIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJhbmdsZUxpbmVPcHRzIiwicG9pbnRMYWJlbE9wdHMiLCJ0aWNrQmFja2Ryb3BIZWlnaHQiLCJvdXRlckRpc3RhbmNlIiwib3V0ZXJQb3NpdGlvbiIsImV4dHJhIiwicG9pbnRMYWJlbFBvc2l0aW9uIiwicG9pbnRMYWJlbEZvbnRDb2xvciIsImRyYXdSYWRpdXNMaW5lIiwibnVtYmVyT3JaZXJvIiwic2NhbGVfcmFkaWFsTGluZWFyIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInN0YXJ0QW5nbGVSYWRpYW5zIiwic2NhbGluZ0ZhY3RvciIsImRpc3RhbmNlRnJvbUNlbnRlciIsInRoaXNBbmdsZSIsImdldEJhc2VQb3NpdGlvbiIsInlDZW50ZXJPZmZzZXQiLCJfZGVmYXVsdHMkMyIsInZhbHVlT3JEZWZhdWx0JGMiLCJNSU5fSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIklOVEVSVkFMUyIsImNvbW1vbiIsInN0ZXBzIiwiVU5JVFMiLCJzb3J0ZXIiLCJhcnJheVVuaXF1ZSIsImJ1aWxkTG9va3VwVGFibGUiLCJ0aW1lc3RhbXBzIiwiZGlzdHJpYnV0aW9uIiwidGFibGUiLCJsb29rdXAiLCJsbyIsIm1pZCIsImkwIiwiaTEiLCJpbnRlcnBvbGF0ZSQxIiwic2tleSIsInRrZXkiLCJzcGFuIiwidG9UaW1lc3RhbXAiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJkZXRlcm1pbmVTdGVwU2l6ZSIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwidGltZU9wdHMiLCJ1bml0U3RlcFNpemUiLCJtYWpvclRpY2tzRW5hYmxlZCIsImZpcnN0IiwiY29tcHV0ZU9mZnNldHMiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwibWFqb3JVbml0IiwiZGVmYXVsdENvbmZpZyQ0IiwiYWRhcHRlcnMiLCJkaXNwbGF5Rm9ybWF0IiwiZGlzcGxheUZvcm1hdHMiLCJzY2FsZV90aW1lIiwidGltZXN0YW1wIiwiZGF0YUxhYmVscyIsIl9ob3Jpem9udGFsIiwiX3RhYmxlIiwiX3RpbWVzdGFtcHMiLCJnZXRMYWJlbENhcGFjaXR5IiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJ0b29sdGlwRm9ybWF0IiwidGlja0Zvcm1hdEZ1bmN0aW9uIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsIm1ham9yVGltZSIsIm1ham9yVGlja09wdHMiLCJmb3JtYXR0ZXIiLCJnZXRQaXhlbEZvck9mZnNldCIsImlzUmV2ZXJzZSIsImdldExhYmVsV2lkdGgiLCJ0aWNrc09wdHMiLCJ0aWNrTGFiZWxXaWR0aCIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwiX2RlZmF1bHRzJDQiLCJjYXRlZ29yeSIsInJhZGlhbExpbmVhciIsIkZPUk1BVFMiLCJfaWQiLCJhbW91bnQiLCJmaWxsZXIiLCJwcm9wYWdhdGUiLCJtYXBwZXJzIiwidmlzaWJsZSIsImJvdW5kYXJ5IiwiZGVjb2RlRmlsbCIsImNvbXB1dGVCb3VuZGFyeSIsInNjYWxlQm90dG9tIiwic2NhbGVUb3AiLCJzY2FsZVplcm8iLCJyZXNvbHZlVGFyZ2V0IiwidmlzaXRlZCIsImNyZWF0ZU1hcHBlciIsImlzRHJhd2FibGUiLCJkcmF3QXJlYSIsImN1cnZlMCIsImN1cnZlMSIsImxlbjAiLCJsZW4xIiwiZG9GaWxsIiwibWFwcGVyIiwicDAiLCJkMCIsImQxIiwicGx1Z2luX2ZpbGxlciIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCIkZmlsbGVyIiwiYmVmb3JlRGF0YXNldERyYXciLCJub29wJDEiLCJ2YWx1ZU9yRGVmYXVsdCRkIiwiY2kiLCJvbkxlYXZlIiwiYm94V2lkdGgiLCJsaW5lRGFzaCIsImdldEJveFdpZHRoIiwibGFiZWxPcHRzIiwidXNlUG9pbnRTdHlsZSIsIkxlZ2VuZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwiYmVmb3JlQnVpbGRMYWJlbHMiLCJidWlsZExhYmVscyIsImFmdGVyQnVpbGRMYWJlbHMiLCJsZWdlbmRJdGVtcyIsImxhYmVsRm9udCIsImhpdGJveGVzIiwibGluZVdpZHRocyIsInRvdGFsSGVpZ2h0IiwidlBhZGRpbmciLCJjb2x1bW5XaWR0aHMiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsIml0ZW1IZWlnaHQiLCJpdGVtV2lkdGgiLCJsaW5lRGVmYXVsdCIsImxlZ2VuZFdpZHRoIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsIlNRUlQyIiwiaGFsZkZvbnRTaXplIiwieExlZnQiLCJ5TWlkZGxlIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaG92ZXJlZEl0ZW0iLCJjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2giLCJsZWdlbmRPcHRzIiwicGx1Z2luX2xlZ2VuZCIsIl9lbGVtZW50IiwiYmVmb3JlSW5pdCIsImFmdGVyRXZlbnQiLCJub29wJDIiLCJUaXRsZSIsImxpbmVDb3VudCIsImZvbnRPcHRzIiwidGl0bGVYIiwidGl0bGVZIiwiY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaCIsInRpdGxlT3B0cyIsInRpdGxlQmxvY2siLCJwbHVnaW5fdGl0bGUiLCJfYWRhcHRlcnMiLCJBbmltYXRpb24iLCJhbmltYXRpb25TZXJ2aWNlIiwiSW50ZXJhY3Rpb24iLCJsYXlvdXRzIiwiU2NhbGUiLCJzY2FsZVNlcnZpY2UiLCJUaWNrcyIsIlRvb2x0aXAiLCJwbHVnaW5TZXJ2aWNlIiwiUGx1Z2luQmFzZSIsImNhbnZhc0hlbHBlcnMiLCJsYXlvdXRTZXJ2aWNlIiwiTGluZWFyU2NhbGVCYXNlIiwiY2ZnIiwiZ2VuZXJhdGVDaGFydCIsImNoYXJ0SWQiLCJjaGFydFR5cGUiLCJjc3NDbGFzc2VzIiwiX2RlZmF1bHQiLCJhZGRQbHVnaW4iLCJiZWZvcmVEZXN0cm95IiwiQmFyIiwiSG9yaXpvbnRhbEJhciIsIlBpZSIsImNoYXJ0TGFiZWxzIiwiY2hhcnREYXRhTGlzdCIsIkNoYXJ0RGF0YSIsIkNoYXJ0QmFyIiwiQ2hhcnRDb21wb25lbnQiLCJDaGFydEhvcml6b250YWxCYXIiLCJDaGFydExpbmUiLCJDaGFydFBpZSIsIm55Y29Db2xvcnMiLCJjb2xvcnMiLCJjb2xvckNvbWJpbmF0aW9ucyIsIm1hcENvbG9yQ29tYmluYXRpb25zIiwiTWFwRGF0YSIsImxheWVycyIsIkFQSUtleSIsImNvbnRhaW5lcklkIiwibGVnZW5kSWQiLCJ6b29tIiwiZGlzYWJsZVNjcm9sbCIsIm1hcFR5cGUiLCJtdWx0aSIsIkdlb0pTT04iLCJkb1Rocm93cyIsImludmFsaWRHZW9tZXRyeSIsIkludmFsaWRHZW9tZXRyeUVycm9yIiwiaXNHZW9tZXRyeVZhbGlkIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsIm9iamVjdHMiLCJnZW9qc29uIiwiYXBwbHlEZWZhdWx0cyIsInByb3BGdW5jIiwiZ2VvbUF0dHJzIiwic2V0R2VvbSIsImdldFByb3BGdW5jdGlvbiIsImZlYXR1cmVzIiwiZ2V0RmVhdHVyZSIsImFkZE9wdGlvbmFscyIsImdlb21zIiwic2V0dGluZyIsImNycyIsImNoZWNrQ1JTIiwiaXNQb3N0Z3JlcyIsImJib3giLCJleHRyYUdsb2JhbCIsInByb3BlcnRpZXMiLCJnZW9tIiwic2V0R2VvbUF0dHJMaXN0IiwiZmVhdHVyZSIsImJ1aWxkR2VvbSIsImlzTmVzdGVkIiwiZ3R5cGUiLCJuZXdJdGVtIiwicGF0aHMiLCJpdGVtQ2xvbmUiLCJhZGRFeHRyYSIsInJpbmdBcmVhIiwicG9seWdvbkFyZWEiLCJnZW9tZXRyaWVzIiwiY29vcmRzIiwibG93ZXJJbmRleCIsIm1pZGRsZUluZGV4IiwidXBwZXJJbmRleCIsImNvb3Jkc0xlbmd0aCIsIndnczg0IiwiUkFESVVTIiwicmV3aW5kIiwiZ2oiLCJjdXJyeU91dGVyIiwiY29ycmVjdCIsImNvcnJlY3RSaW5ncyIsIndpbmQiLCJnZW9qc29uQXJlYSIsInJpbmciLCJNYXBNdWx0aUxheWVyIiwiTWFwQ29tcG9uZW50IiwiZ2V0WmlwY29kZURhdGEiLCJnZXRCb3JvdWdoRGF0YSIsImdldE5laWdoYm9yaG9vZERhdGEiLCJmaWx0ZXJCeSIsImNvbnZlcnRUb0dlb0pTT04iLCJqc29uRGF0YSIsIk1hcFNpbmdsZUxheWVyIiwibGVnZW5kQ29sdW1uIiwiamFybyIsInMxIiwiczIiLCJzaG9ydGVyIiwibG9uZ2VyIiwibWF0Y2hpbmdXaW5kb3ciLCJzaG9ydGVyTWF0Y2hlcyIsImxvbmdlck1hdGNoZXMiLCJ3aW5kb3dTdGFydCIsIndpbmRvd0VuZCIsInNob3J0ZXJNYXRjaGVzU3RyaW5nIiwibG9uZ2VyTWF0Y2hlc1N0cmluZyIsIm51bU1hdGNoZXMiLCJ0cmFuc3Bvc2l0aW9ucyIsInByZWZpeFNjYWxpbmdGYWN0b3IiLCJqYXJvU2ltaWxhcml0eSIsImNvbW1vblByZWZpeExlbmd0aCIsIkF1dG9jb21wbGV0ZSIsImNsYXNzbmFtZSIsImxpc3RJdGVtIiwiZ2V0U2libGluZ0luZGV4Iiwic2NvcmVkT3B0aW9ucyIsInVsIiwiaGlnaGxpZ2h0ZWQiLCJzZWxlY3RvcnMiLCJTVFJJTkdTIiwiTUFYX0lURU1TIiwibWF4SXRlbXMiLCJrZXlkb3duRXZlbnQiLCJrZXl1cEV2ZW50IiwiaW5wdXRFdmVudCIsImZvY3VzRXZlbnQiLCJibHVyRXZlbnQiLCJrZXlFbnRlciIsImtleUVzY2FwZSIsImtleURvd24iLCJrZXlVcCIsImRyb3Bkb3duIiwicGVyc2lzdERyb3Bkb3duIiwiaGlnaGxpZ2h0Iiwic3lub255bXMiLCJjbG9zZXN0U3lub255bSIsInN5bm9ueW0iLCJzaW1pbGFyaXR5IiwiamFyb1dpbmtsZXIiLCJkaXNwbGF5VmFsdWUiLCJzY29yZWRPcHRpb24iLCJub3JtYWxpemVkSW5kZXgiLCJsaSIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJkb2N1bWVudEZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIm5ld1VsIiwiT1BUSU9OUyIsIm5ld0NvbnRhaW5lciIsIm5ld0luZGV4IiwiSElHSExJR0hUIiwiQUNUSVZFX0RFU0NFTkRBTlQiLCJzY3JvbGxJbnRvVmlldyIsIm1lc3NhZ2VzIiwiRElSRUNUSU9OU19UWVBFIiwiT1BUSU9OX0FWQUlMQUJMRSIsIkRJUkVDVElPTlNfUkVWSUVXIiwiT1BUSU9OX1NFTEVDVEVEIiwiSW5wdXRBdXRvY29tcGxldGUiLCJsaWJyYXJ5IiwibG9jYWxpemVkU3RyaW5ncyIsIm55Y28iLCJpY29ucyIsInRy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LENBakJRO01Ba0JoQkMsY0FBYyxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEJBO01BbUJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkJNO01Bb0JoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBcEJNO01BcUJoQkMsSUFBSSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBckJVO01Bc0JoQkMsUUFBUSxFQUFFLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLENBdEJNO01BdUJoQkMsUUFBUSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkJNO01Bd0JoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeEJBO01BeUJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekJNO01BMEJoQkMsU0FBUyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBMUJJO01BMkJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0JNO01BNEJoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUJJO01BNkJoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBN0JFO01BOEJoQkMsY0FBYyxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBOUJBO01BK0JoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBL0JJO01BZ0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaENJO01BaUNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBakNNO01Ba0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbENJO01BbUNoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkNFO01Bb0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBcENBO01BcUNoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBckNBO01Bc0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBdENBO01BdUNoQkMsYUFBYSxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkNBO01Bd0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBeENJO01BeUNoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBekNNO01BMENoQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBMUNFO01BMkNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0NNO01BNENoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUNNO01BNkNoQkMsVUFBVSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBN0NJO01BOENoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBOUNJO01BK0NoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0NFO01BZ0RoQkMsV0FBVyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBaERFO01BaURoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBakRNO01Ba0RoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbERJO01BbURoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkRJO01Bb0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERVO01BcURoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBckRJO01Bc0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdERVO01BdURoQkMsS0FBSyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBdkRRO01Bd0RoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeERFO01BeURoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekRVO01BMERoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMURNO01BMkRoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0RNO01BNERoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNURJO01BNkRoQkMsTUFBTSxFQUFFLENBQUMsRUFBRCxFQUFJLENBQUosRUFBTSxHQUFOLENBN0RRO01BOERoQkMsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOURRO01BK0RoQkMsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0RRO01BZ0VoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEVNO01BaUVoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakVBO01Ba0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBbEVJO01BbUVoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkVFO01Bb0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEVJO01BcUVoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckVJO01Bc0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEVJO01BdUVoQkMsb0JBQW9CLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0F2RU47TUF3RWhCQyxTQUFTLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0F4RUk7TUF5RWhCQyxVQUFVLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0F6RUk7TUEwRWhCQyxTQUFTLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0ExRUk7TUEyRWhCQyxTQUFTLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0EzRUk7TUE0RWhCQyxXQUFXLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0E1RUU7TUE2RWhCQyxhQUFhLEVBQUcsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsQ0E3RUE7TUE4RWhCQyxZQUFZLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0E5RUU7TUErRWhCQyxjQUFjLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0EvRUE7TUFnRmhCQyxjQUFjLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0FoRkE7TUFpRmhCQyxjQUFjLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0FqRkE7TUFrRmhCQyxXQUFXLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0FsRkU7TUFtRmhCQyxJQUFJLEVBQUUsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLENBQVAsQ0FuRlU7TUFvRmhCQyxTQUFTLEVBQUcsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEVBQVIsQ0FwRkk7TUFxRmhCQyxLQUFLLEVBQUcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsQ0FyRlE7TUFzRmhCQyxPQUFPLEVBQUcsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsQ0F0Rk07TUF1RmhCQyxNQUFNLEVBQUUsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLENBQVAsQ0F2RlE7TUF3RmhCQyxnQkFBZ0IsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXhGRjtNQXlGaEJDLFVBQVUsRUFBRSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssR0FBTCxDQXpGSTtNQTBGaEJDLFlBQVksRUFBRSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixDQTFGRTtNQTJGaEJDLFlBQVksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTNGRTtNQTRGaEJDLGNBQWMsRUFBRSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixDQTVGQTtNQTZGaEJDLGVBQWUsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTdGRjtNQThGaEJDLGlCQUFpQixFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBOUZKO01BK0ZoQkMsZUFBZSxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBL0ZGO01BZ0doQkMsZUFBZSxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaEdGO01BaUdoQkMsWUFBWSxFQUFFLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBakdFO01Ba0doQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEdJO01BbUdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkdJO01Bb0doQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEdNO01BcUdoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckdFO01Bc0doQkMsSUFBSSxFQUFFLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLENBdEdVO01BdUdoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdkdNO01Bd0doQkMsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBeEdRO01BeUdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBekdJO01BMEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBMUdRO01BMkdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxDQUFSLENBM0dJO01BNEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUdRO01BNkdoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0dBO01BOEdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOUdJO01BK0doQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0dBO01BZ0hoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEhBO01BaUhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakhJO01Ba0hoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEhJO01BbUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBbkhVO01Bb0hoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEhVO01BcUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckhVO01Bc0hoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEhJO01BdUhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBdkhRO01Bd0hoQkMsYUFBYSxFQUFFLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxHQUFWLENBeEhDO01BeUhoQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBekhVO01BMEhoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUhJO01BMkhoQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBM0hJO01BNEhoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNUhFO01BNkhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0hRO01BOEhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBOUhJO01BK0hoQkMsUUFBUSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBL0hNO01BZ0loQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaElNO01BaUloQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBaklRO01Ba0loQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbElRO01BbUloQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbklNO01Bb0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBcElJO01BcUloQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcklJO01Bc0loQkMsU0FBUyxFQUFHLENBQUMs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
