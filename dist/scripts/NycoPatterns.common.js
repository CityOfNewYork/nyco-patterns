'use strict';

/**
 * The Utility class
 * @class
 */

var Utility$1 = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility$1.debug = function () {
  return Utility$1.getUrlParameter(Utility$1.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility$1.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility$1.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility$1.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility$1.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility$1.debug()) {
        console.dir(response);
      }
  }).catch(function (error) {
    // eslint-disable-next-line no-console
    if (Utility$1.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.

  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$e.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/**
 *
 */

var Feed = function Feed(config) {
  this.default = Feed.default;
  this._settings = merge({}, Feed.default, config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts
    // items = _uniqBy(items, (item) => item.guid);

    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed.default = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$d = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$d.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-afd20650_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bzier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  extends: Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  extends: HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  extends: Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  extends: Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

//
//
var script$5 = {
  props: {
    'layers': {
      type: Array
    },
    'config': {
      type: Object
    }
  },
  data: function data() {
    return {
      map: null,
      mapPopup: null,
      mapFilter: null,
      activeLayer: null,
      mapLoaded: false,
      menuItems: [],
      selectedItems: []
    };
  },
  mounted: function mounted() {
    this.initializeMap();
  },
  destroyed: function destroyed() {
    this.map.remove();
  },
  watch: {
    'layers': function layers() {
      var layers = this.layers;

      if (this.config.mapType === 'multi') {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          this.trackLayer(layer.name);

          if (layer.default || this.layers.length === 1) {
            this.activeLayer = layer.name;
          }

          if (this.mapLoaded) {
            this.initializeLayer(layer);
          }
        }
      } else if (this.config.mapType === 'single') {
        var layer$1 = this.layers[0];
        this.activeLayer = layer$1.name;
        this.generateLegend(layer$1.data);

        if (this.mapLoaded) {
          this.initializeLayer(layer$1);
        }
      } else {
        throw new Error('mapType must be defined');
      }
    },
    'mapLoaded': function mapLoaded() {
      if (this.mapLoaded && this.layers.length) {
        var layers = this.layers;

        for (var i = 0; i < layers.length; i++) {
          this.initializeLayer(layers[i]);
        }
      }
    },
    'menuItems': function menuItems() {
      if (this.menuItems.length > 1) {
        this.initializeToggle(this.menuItems);
      }
    },
    'selectedItems': function selectedItems() {
      var layer = this.layers[0];
      var filter = ['in', layer.legendColumn];

      for (var i = 0; i < this.selectedItems.length; i++) {
        filter.push(this.selectedItems[i]);
      }

      if (this.selectedItems.length > 0) {
        var relatedFeatures = this.map.querySourceFeatures(layer.name, {
          sourceLayer: layer.name,
          filter: filter
        }); // set filter when legend item selected

        this.map.setFilter(layer.name + "-highlighted", filter);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'visible');
      }

      if (!this.selectedItems.length && !this.mapPopup) {
        this.map.setFilter(layer.name + "-highlighted", null);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'none');
      }
    }
  },
  methods: {
    initializeMap: function initializeMap() {
      var this$1 = this;
      var mapConfig = this.config;
      var options = {
        container: mapConfig.containerId
      };

      if (mapConfig.center) {
        options.center = mapConfig.center;
      }

      if (mapConfig.style) {
        options.style = mapConfig.style;
      }

      if (mapConfig.zoom) {
        options.zoom = mapConfig.zoom;
      }

      mapboxgl.accessToken = mapConfig.APIKey;
      this.map = new mapboxgl.Map(options);
      this.map.addControl(new mapboxgl.NavigationControl()); // disable map zoom when using scroll

      if (mapConfig.disableScroll) {
        this.map.scrollZoom.disable();
      }

      this.map.on('load', function () {
        return this$1.mapLoaded = true;
      });
    },
    initializeLayer: function initializeLayer(layer) {
      if (this.map.getLayer(layer.name) === undefined && Object.entries(layer.data).length !== 0) {
        var visibility = layer.name === this.activeLayer ? 'visible' : 'none';
        var filter = layer.filterBy ? ['in', layer.filterBy, ''] : [];
        var fill = this.config.colors ? this.generateFillColor(this.config.colors) : layer.fill;
        this.map.addSource(layer.name, {
          'type': 'geojson',
          'data': layer.data
        });
        this.map.addLayer({
          'id': layer.name,
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 0.7
          },
          'layout': {
            'visibility': visibility
          }
        });
        this.map.addLayer({
          'id': layer.name + "-highlighted",
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 1
          },
          'filter': filter,
          'layout': {
            'visibility': visibility
          }
        });
        this.initializeFilter(layer);
        this.updateCursorOnHover(layer.name);
      }
    },
    initializePopup: function initializePopup(event, layer) {
      this.config.mapType === 'multi' ? this.popupMultiLayer(event, layer) : this.popupSingleLayer(event, layer);
    },
    initializeToggle: function initializeToggle(toggleList) {
      this.config.mapType === 'multi' ? this.toggleMultiLayer(toggleList) : this.toggleSingleLayer(toggleList);
    },
    initializeFilter: function initializeFilter(layer) {
      this.config.mapType === 'multi' ? this.filterMultiLayer(layer) : this.filterSingleLayer(layer);
    },
    updateCursorOnHover: function updateCursorOnHover(layerId) {
      var map = this.map; // change the cursor to a pointer when the mouse is over the layer.

      map.on('mouseenter', layerId, function () {
        map.getCanvas().style.cursor = 'pointer';
      }); // change the cursor back to the default when it leaves the layer.

      map.on('mouseleave', layerId, function () {
        map.getCanvas().style.cursor = '';
      });
    },
    generateFillColor: function generateFillColor(colors) {
      return colors[Math.floor(Math.random() * colors.length)];
    },
    // multi layer
    trackLayer: function trackLayer(reference) {
      if (!this.menuItems.includes(reference)) {
        this.menuItems.push(reference);
      }
    },
    popupMultiLayer: function popupMultiLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted";
      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup;
        map.setLayoutProperty(layerName, 'visibility', 'visible');
        map.setFilter(layerName, $this.mapFilter);
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null;
          map.setFilter(layerName, null);
          map.setLayoutProperty(layerName, 'visibility', 'none');
        }
      });
    },
    filterMultiLayer: function filterMultiLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var filter = features.reduce(function (memo, feature) {
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleMultiLayer: function toggleMultiLayer(layersToToggle) {
      var $this = this;
      var map = $this.map;
      var activeLayer = $this.activeLayer;
      var linkContainer = document.getElementById(this.config.legendId); // clear all links before appending new ones to prevent duplicates

      while (linkContainer.firstChild) {
        linkContainer.removeChild(linkContainer.firstChild);
      }

      for (var i = 0; i < layersToToggle.length; i++) {
        var layerRef = layersToToggle[i];
        var link = document.createElement('a');
        link.href = '#';
        link.textContent = layerRef;

        if (layerRef === activeLayer) {
          link.classList.add('active');
        } // on click update link state, active layer reference, and layer visibility


        link.onclick = function (e) {
          e.preventDefault();
          e.stopPropagation();
          var selectedLayer = this.textContent;
          var links = linkContainer.getElementsByTagName('a'); // remove active popup

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          for (var i = 0; i < links.length; i++) {
            var currentLink = links[i];
            var currentLayer = currentLink.textContent;
            var currentLayerHighlight = currentLayer + "-highlighted";
            var layerVisibility = map.getLayoutProperty(currentLayer, 'visibility');

            if (currentLayer === selectedLayer) {
              // return if layer is already selected
              if (layerVisibility === 'visible' && currentLink.classList.contains('active')) {
                return;
              } // set our current layer as the global active layer,
              // add active class to link, set layer as visible


              $this.activeLayer = currentLayer;
              currentLink.classList.add('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'visible');
            } else {
              // remove links active class, set layer visibility to none and remove filters
              currentLink.classList.remove('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'none');
              map.setLayoutProperty(currentLayerHighlight, 'visibility', 'none');
              map.setFilter(currentLayerHighlight, null);
            }
          }
        };

        linkContainer.appendChild(link);
      }
    },
    // single layer
    generateLegend: function generateLegend(layerData) {
      var this$1 = this;
      layerData.features.forEach(function (feature) {
        var item = feature.properties[this$1.layers[0].legendColumn];

        if (!this$1.menuItems.includes(item) && item) {
          this$1.menuItems.push(item);
        }
      });
    },
    popupSingleLayer: function popupSingleLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted"; // check whether shape falls under current legend selection

      var inCurrentSelection = true;
      var columnFilter = event.features[0].properties[layer.legendColumn];

      if (!$this.selectedItems.includes(columnFilter)) {
        inCurrentSelection = false;
      }

      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup; // if there are no legend items selected, highlight selected map shape

        if (!$this.selectedItems.length) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter);
        } // if there are legend items selected and selected map shape isn't
        // within any of the selected legend items, highlight selected
        // map shape and clear legend


        if ($this.selectedItems.length > 0 && !inCurrentSelection) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter); // reset all checked legend items

          $this.selectedItems = [];
          var filterGroupInputs = document.getElementById(this.config.legendId).querySelectorAll('input:checked');

          for (var i = 0; i < filterGroupInputs.length; i++) {
            filterGroupInputs[i].checked = false;
          }
        }
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null; // if there are no legend items selected, reset all filters

          if (!$this.selectedItems.length) {
            map.setFilter(layerName, null);
            map.setLayoutProperty(layerName, 'visibility', 'none');
          }
        }
      });
    },
    filterSingleLayer: function filterSingleLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var legendColumnValue = null;
        var filter = features.reduce(function (memo, feature) {
          legendColumnValue = feature.properties[layer.legendColumn];
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleSingleLayer: function toggleSingleLayer(filtersToToggle) {
      var $this = this;
      var map = $this.map;
      var filterGroup = document.getElementById(this.config.legendId);
      var layer = $this.layers[0];
      var legendColumn = layer.legendColumn; // clear all links before appending new ones to prevent duplicates

      while (filterGroup.firstChild) {
        filterGroup.removeChild(filterGroup.firstChild);
      } // initilize an input element for each filter type


      for (var i = 0; i < filtersToToggle.length; i++) {
        var layerRef = filtersToToggle[i]; // checkbox

        var input = document.createElement('input');
        input.type = 'checkbox';
        input.id = layerRef;
        input.value = layerRef;
        filterGroup.appendChild(input); // checkbox label

        var label = document.createElement('label');
        label.setAttribute('for', layerRef);
        label.setAttribute('title', layerRef);
        label.textContent = layerRef;
        filterGroup.appendChild(label); // when the checkbox changes state, update the selected items array.

        input.addEventListener('change', function (e) {
          var item = e.target.value; // reset the checkboxes checked state

          e.target.checked ? 'visible' : 'none'; // remove popup if one exists

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          if (e.target.checked && !$this.selectedItems.includes(item)) {
            $this.selectedItems.push(item);
          }

          if (!e.target.checked && $this.selectedItems.includes(item)) {
            $this.selectedItems = $this.selectedItems.filter(function (val) {
              return val !== item;
            });
          }
        });
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div")
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var MapComponent = normalizeComponent_1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    undefined,
    undefined
  );

/**
 * Config
 */
var nycoColors = {
  colors: {
    'primary-navy': '#2F334F',
    'primary-navy-70t': '#6E7085',
    'primary-navy-50t': '#9698A7',
    'primary-navy-30t': '#C0C2CA',
    'primary-blue': '#3155A6',
    'primary-blue-70t': '#6C88C1',
    'primary-blue-50t': '#96ABD2',
    'primary-blue-30t': '#C0CCE3',
    'primary-red': '#F2695D',
    'primary-red-70t': '#F6958D',
    'primary-red-50t': '#F8B2AD',
    'primary-red-30t': '#FBD1CE',
    'secondary-grey': '#ACAEB9',
    'secondary-grey-70t': '#C4C6CD',
    'secondary-grey-50t': '#D5D6DC',
    'secondary-grey-30t': '#E8E7E9',
    'secondary-white': '#F3F3F3',
    'secondary-white-70t': '#F6F6F6',
    'secondary-white-50t': '#F9F9FA',
    'secondary-white-30t': '#FBFCFC',
    'secondary-orange': '#F9A137',
    'secondary-orange-70t': '#FFA133',
    'secondary-orange-50t': '#FED09A',
    'secondary-orange-30t': '#FFE3C2',
    'secondary-pink': '#EBBCD8',
    'secondary-pink-70t': '#F2D0E3',
    'secondary-pink-50t': '#F7DDEB',
    'secondary-pink-30t': '#FDEBF3',
    'base-black': '#000000',
    'base-white': '#FFFFFF'
  },
  colorCombinations: {
    'light-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'base-white',
      'border': 'secondary-grey',
      'placeholder': 'secondary-grey',
      'checkbox-background': 'primary-navy',
      'error': 'primary-red'
    },
    'mid-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'secondary-white'
    },
    'dark-background': {
      'color': 'base-white',
      'font-smooth': true,
      'headings': 'base-white',
      'hyperlinks': 'base-white',
      'visited': 'base-white',
      'hover': 'base-white',
      'background-color': 'primary-navy'
    },
    'primary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-blue'
    },
    'secondary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-red'
    }
  }
};
var color = nycoColors.colors;
var mapColorCombinations = [[color['primary-navy'], color['primary-navy-70t']], [color['base-black'], color['secondary-orange']], [color['primary-navy'], color['secondary-grey']], [color['primary-blue'], color['secondary-orange']]];
var colors = {
  nycoColors: nycoColors,
  mapColorCombinations: mapColorCombinations
};
var colors_2 = colors.mapColorCombinations;

var MapData = {
  single: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-sl',
      legendId: 'nyco-map-legend',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'single'
    }
  },
  multi: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-ml',
      legendId: 'nyco-map-menu',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'multi',
      colors: colors_2
    }
  }
};

var geojson = createCommonjsModule(function (module) {
  (function (GeoJSON) {
    GeoJSON.version = '0.5.0'; // Allow user to specify default parameters

    GeoJSON.defaults = {
      doThrows: {
        invalidGeometry: false
      }
    };

    function InvalidGeometryError() {
      var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      var item = args.shift();
      var params = args.shift();
      Error.apply(this, args);
      this.message = this.message || "Invalid Geometry: " + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);
    }

    InvalidGeometryError.prototype = Error;
    GeoJSON.errors = {
      InvalidGeometryError: InvalidGeometryError
    }; //exposing so this can be overriden maybe by geojson-validation or the like

    GeoJSON.isGeometryValid = function (geometry) {
      if (!geometry || !Object.keys(geometry).length) {
        return false;
      }

      return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;
    }; // The one and only public function.
    // Converts an array of objects into a GeoJSON feature collection


    GeoJSON.parse = function (objects, params, callback) {
      var geojson,
          settings = applyDefaults(params, this.defaults),
          propFunc;
      geomAttrs.length = 0; // Reset the list of geometry fields

      setGeom(settings);
      propFunc = getPropFunction(settings);

      if (Array.isArray(objects)) {
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        objects.forEach(function (item) {
          geojson.features.push(getFeature({
            item: item,
            params: settings,
            propFunc: propFunc
          }));
        });
        addOptionals(geojson, settings);
      } else {
        geojson = getFeature({
          item: objects,
          params: settings,
          propFunc: propFunc
        });
        addOptionals(geojson, settings);
      }

      if (callback && typeof callback === 'function') {
        callback(geojson);
      } else {
        return geojson;
      }
    }; // Helper functions


    var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],
        geomAttrs = []; // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify

    function applyDefaults(params, defaults) {
      var settings = params || {};

      for (var setting in defaults) {
        if (defaults.hasOwnProperty(setting) && !settings[setting]) {
          settings[setting] = defaults[setting];
        }
      }

      return settings;
    } // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified


    function addOptionals(geojson, settings) {
      if (settings.crs && checkCRS(settings.crs)) {
        if (settings.isPostgres) {
          geojson.geometry.crs = settings.crs;
        } else {
          geojson.crs = settings.crs;
        }
      }

      if (settings.bbox) {
        geojson.bbox = settings.bbox;
      }

      if (settings.extraGlobal) {
        geojson.properties = {};

        for (var key in settings.extraGlobal) {
          geojson.properties[key] = settings.extraGlobal[key];
        }
      }
    } // Verify that the structure of CRS object is valid


    function checkCRS(crs) {
      if (crs.type === 'name') {
        if (crs.properties && crs.properties.name) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "name" key');
        }
      } else if (crs.type === 'link') {
        if (crs.properties && crs.properties.href && crs.properties.type) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "href" and "type" key');
        }
      } else {
        throw new Error('Invald CRS. Type attribute must be "name" or "link"');
      }
    } // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access


    function setGeom(params) {
      params.geom = {};

      for (var param in params) {
        if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {
          params.geom[param] = params[param];
          delete params[param];
        }
      }

      setGeomAttrList(params.geom);
    } // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key


    function setGeomAttrList(params) {
      for (var param in params) {
        if (params.hasOwnProperty(param)) {
          if (typeof params[param] === 'string') {
            geomAttrs.push(params[param]);
          } else if (typeof params[param] === 'object') {
            // Array of coordinates for Point
            geomAttrs.push(params[param][0]);
            geomAttrs.push(params[param][1]);
          }
        }
      }

      if (geomAttrs.length === 0) {
        throw new Error('No geometry attributes specified');
      }
    } // Creates a feature object to be added
    // to the GeoJSON features array


    function getFeature(args) {
      var item = args.item,
          params = args.params,
          propFunc = args.propFunc;
      var feature = {
        "type": "Feature"
      };
      feature.geometry = buildGeom(item, params);
      feature.properties = propFunc.call(item);
      return feature;
    }

    function isNested(val) {
      return /^.+\..+$/.test(val);
    } // Assembles the `geometry` property
    // for the feature output


    function buildGeom(item, params) {
      var geom = {};

      for (var gtype in params.geom) {
        var val = params.geom[gtype]; // Geometry parameter specified as: {Point: 'coords'}

        if (typeof val === 'string' && item.hasOwnProperty(val)) {
          if (gtype === 'GeoJSON') {
            geom = item[val];
          } else {
            geom.type = gtype;
            geom.coordinates = item[val];
          }
        }
        /* Handle things like:
        Polygon: {
          northeast: ['lat', 'lng'],
          southwest: ['lat', 'lng']
        }
        */
        else if (typeof val === 'object' && !Array.isArray(val)) {
            /*jshint loopfunc: true */
            var points = Object.keys(val).map(function (key) {
              var order = val[key];
              var newItem = item[key];
              return buildGeom(newItem, {
                geom: {
                  Point: order
                }
              });
            });
            geom.type = gtype;
            /*jshint loopfunc: true */

            geom.coordinates = [].concat(points.map(function (p) {
              return p.coordinates;
            }));
          } // Geometry parameter specified as: {Point: ['lat', 'lng']}
          else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
              geom.type = gtype;
              geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];
            } // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                var coordinates = [];

                for (var i = 0; i < val.length; i++) {
                  // i.e. 0 and 1
                  var paths = val[i].split('.');
                  var itemClone = item;

                  for (var j = 0; j < paths.length; j++) {
                    if (!itemClone.hasOwnProperty(paths[j])) {
                      return false;
                    }

                    itemClone = itemClone[paths[j]]; // Iterate deeper into the object
                  }

                  coordinates[i] = itemClone;
                }

                geom.type = gtype;
                geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];
              }
      }

      if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {
        throw new InvalidGeometryError(item, params);
      }

      return geom;
    } // Returns the function to be used to
    // build the properties object for each feature


    function getPropFunction(params) {
      var func;

      if (!params.exclude && !params.include) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      } else if (params.include) {
        func = function (properties) {
          params.include.forEach(function (attr) {
            properties[attr] = this[attr];
          }, this);
        };
      } else if (params.exclude) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      }

      return function () {
        var properties = {};
        func.call(this, properties);

        if (params.extra) {
          addExtra(properties, params.extra);
        }

        return properties;
      };
    } // Adds data contained in the `extra`
    // parameter if it has been specified


    function addExtra(properties, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          properties[key] = extra[key];
        }
      }

      return properties;
    }
  })(module.exports);
});

var RADIUS = 6378137;
var FLATTENING = 1 / 298.257223563;
var POLAR_RADIUS = 6356752.3142;
var wgs84 = {
  RADIUS: RADIUS,
  FLATTENING: FLATTENING,
  POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
  var area = 0,
      i;

  switch (_.type) {
    case 'Polygon':
      return polygonArea(_.coordinates);

    case 'MultiPolygon':
      for (i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
      }

      return area;

    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
      return 0;

    case 'GeometryCollection':
      for (i = 0; i < _.geometries.length; i++) {
        area += geometry(_.geometries[i]);
      }

      return area;
  }
}

function polygonArea(coords) {
  var area = 0;

  if (coords && coords.length > 0) {
    area += Math.abs(ringArea(coords[0]));

    for (var i = 1; i < coords.length; i++) {
      area -= Math.abs(ringArea(coords[i]));
    }
  }

  return area;
}
/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */


function ringArea(coords) {
  var p1,
      p2,
      p3,
      lowerIndex,
      middleIndex,
      upperIndex,
      i,
      area = 0,
      coordsLength = coords.length;

  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        // i = N-2
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        // i = N-1
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        // i = 0 to N-3
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }

      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }

    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
  }

  return area;
}

function rad(_) {
  return _ * Math.PI / 180;
}

var geojsonArea = {
  geometry: geometry_1,
  ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
  switch (gj && gj.type || null) {
    case 'FeatureCollection':
      gj.features = gj.features.map(curryOuter(rewind, outer));
      return gj;

    case 'Feature':
      gj.geometry = rewind(gj.geometry, outer);
      return gj;

    case 'Polygon':
    case 'MultiPolygon':
      return correct(gj, outer);

    default:
      return gj;
  }
}

function curryOuter(a, b) {
  return function (_) {
    return a(_, b);
  };
}

function correct(_, outer) {
  if (_.type === 'Polygon') {
    _.coordinates = correctRings(_.coordinates, outer);
  } else if (_.type === 'MultiPolygon') {
    _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
  }

  return _;
}

function correctRings(_, outer) {
  outer = !!outer;
  _[0] = wind(_[0], outer);

  for (var i = 1; i < _.length; i++) {
    _[i] = wind(_[i], !outer);
  }

  return _;
}

function wind(_, dir) {
  return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
  return geojsonArea.ring(_) >= 0;
}

var MapMultiLayer = function MapMultiLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapMultiLayer.prototype.init = function init() {
  Vue.component('nyco-map-ml', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-ml"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.multi.layers,
        config: MapData.multi.config
      };
    },
    created: function created() {
      this.getZipcodeData();
      this.getBoroughData();
      this.getNeighborhoodData();
    },
    methods: {
      getZipcodeData: function getZipcodeData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/tiger-zcta.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.multi.layers.push({
            name: 'zipcodes',
            data: JSON.parse(data),
            default: true,
            filterBy: 'GEOID10'
          });
        });
      },
      getBoroughData: function getBoroughData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/7t3b-ywvw.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'boroughs',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'boro_name'
          });
        });
      },
      getNeighborhoodData: function getNeighborhoodData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/q2z5-ai38.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'neighborhoods',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'ntaname'
          });
        });
      },
      convertToGeoJSON: function convertToGeoJSON(jsonData) {
        // ensure geojson satisfies right-hand rule
        var data = geojsonRewind(geojson.parse(jsonData, {
          GeoJSON: 'the_geom'
        }));
        return data;
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapMultiLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

var MapSingleLayer = function MapSingleLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapSingleLayer.prototype.init = function init() {
  Vue.component('nyco-map-sl', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-sl"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.single.layers,
        config: MapData.single.config
      };
    },
    created: function created() {
      this.getData();
    },
    methods: {
      getData: function getData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/nyco-nyc_zipcodes.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.single.layers.push({
            name: 'nyco-nyc_zipcodes',
            data: JSON.parse(data),
            filterBy: 'ZCTA5CE10',
            legendColumn: 'BORO',
            fill: colors_2[3]
          });
        });
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapSingleLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};
/**
 * Method for the Map Module
 * @return{Object} Map Module
 */


nyco.prototype.map = function map(type) {
  if (type === 'multi') {
    return new MapMultiLayer();
  }

  if (type === 'single') {
    return new MapSingleLayer();
  }
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vc3JjL29iamVjdHMvZmVlZC9GZWVkLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90cmFjay9UcmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmJyb3dzZXIuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC52dWUiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5kYXRhLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvbWl4aW5zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9CYXNlQ2hhcnRzLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LmRhdGEuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL21hcC9tYXAudnVlIiwiLi4vLi4vY29uZmlnL2NvbG9ycy5qcyIsIi4uLy4uL3NyYy9qcy9tYXAuZGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nZW9qc29uL2dlb2pzb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hcGJveC9nZW9qc29uLWFyZWEvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvaW5kZXguanMiLCIuLi8uLi9zcmMvanMvTWFwLmpzIiwiLi4vLi4vc3JjL2pzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBVdGlsaXR5IGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVXRpbGl0eSB7XG4gIC8qKlxuICAgKiBUaGUgVXRpbGl0eSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBVdGlsaXR5IGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIEJvb2xlYW4gZm9yIGRlYnVnIG1vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciBvciBub3QgdGhlIGZyb250LWVuZCBpcyBpbiBkZWJ1ZyBtb2RlLlxuICovXG5VdGlsaXR5LmRlYnVnID0gKCkgPT4gKFV0aWxpdHkuZ2V0VXJsUGFyYW1ldGVyKFV0aWxpdHkuUEFSQU1TLkRFQlVHKSA9PT0gJzEnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGtleSBpbiBhIFVSTCBxdWVyeSBzdHJpbmcuIElmIG5vIFVSTCBxdWVyeVxuICogc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgY3VycmVudCBVUkwgbG9jYXRpb24gaXMgdXNlZC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAgICAgIC0gS2V5IG5hbWUuXG4gKiBAcGFyYW0gIHs/c3RyaW5nfSBxdWVyeVN0cmluZyAtIE9wdGlvbmFsIHF1ZXJ5IHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFF1ZXJ5IHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIgPSAobmFtZSwgcXVlcnlTdHJpbmcpID0+IHtcbiAgY29uc3QgcXVlcnkgPSBxdWVyeVN0cmluZyB8fCB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICBjb25zdCBwYXJhbSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpO1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScpO1xuICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyhxdWVyeSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyAnJyA6XG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xufTtcblxuLyoqXG4gKiBGb3IgdHJhbnNsYXRpbmcgc3RyaW5ncywgdGhlcmUgaXMgYSBnbG9iYWwgTE9DQUxJWkVEX1NUUklOR1MgYXJyYXkgdGhhdFxuICogaXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0ZW1wbGF0ZSBsZXZlbCBzbyB0aGF0IHRob3NlIHN0cmluZ3MgYXJlIGV4cG9zZWQgdG9cbiAqIFdQTUwgdHJhbnNsYXRpb24uIFRoZSBMT0NBTElaRURfU1RSSU5HUyBhcnJheSBpcyBjb21wb3NlZCBvZiBvYmplY3RzIHdpdGggYVxuICogYHNsdWdgIGtleSB3aG9zZSB2YWx1ZSBpcyBzb21lIGNvbnN0YW50LCBhbmQgYSBgbGFiZWxgIHZhbHVlIHdoaWNoIGlzIHRoZVxuICogdHJhbnNsYXRlZCBlcXVpdmFsZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgc2x1ZyBuYW1lIGFuZCByZXR1cm5zIHRoZVxuICogbGFiZWwuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNsdWdcbiAqIEByZXR1cm4ge3N0cmluZ30gbG9jYWxpemVkIHZhbHVlXG4gKi9cblV0aWxpdHkubG9jYWxpemUgPSBmdW5jdGlvbihzbHVnKSB7XG4gIGxldCB0ZXh0ID0gc2x1ZyB8fCAnJztcbiAgY29uc3Qgc3RyaW5ncyA9IHdpbmRvdy5MT0NBTElaRURfU1RSSU5HUyB8fCBbXTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmdzLmZpbHRlcihcbiAgICAocykgPT4gKHMuaGFzT3duUHJvcGVydHkoJ3NsdWcnKSAmJiBzWydzbHVnJ10gPT09IHNsdWcpID8gcyA6IGZhbHNlXG4gICk7XG4gIHJldHVybiAobWF0Y2hbMF0gJiYgbWF0Y2hbMF0uaGFzT3duUHJvcGVydHkoJ2xhYmVsJykpID8gbWF0Y2hbMF0ubGFiZWwgOiB0ZXh0O1xufTtcblxuLyoqXG4gKiBBcHBsaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlsaXR5LlBBUkFNUyA9IHtcbiAgREVCVUc6ICdkZWJ1Zydcbn07XG5cbi8qKlxuICogU2VsZWN0b3JzIGZvciB0aGUgVXRpbGl0eSBtb2R1bGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuU0VMRUNUT1JTID0ge1xuICBwYXJzZU1hcmtkb3duOiAnW2RhdGEtanM9XCJtYXJrZG93blwiXSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVdGlsaXR5IGZyb20gJy4uLy4uL2pzL21vZHVsZXMvdXRpbGl0eSc7XG5cbi8qKlxuICogVGhlIEljb24gbW9kdWxlXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgSWNvbnMge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgcGF0aCA9IChwYXRoKSA/IHBhdGggOiBJY29ucy5wYXRoO1xuXG4gICAgZmV0Y2gocGF0aClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzcHJpdGUuaW5uZXJIVE1MID0gZGF0YTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcHJpdGUpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIHBhdGggb2YgdGhlIGljb24gZmlsZSAqL1xuSWNvbnMucGF0aCA9ICdpY29ucy5zdmcnO1xuXG5leHBvcnQgZGVmYXVsdCBJY29ucztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25zdGFudDtcbiIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZXN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSXRlcmF0ZWVDYWxsO1xuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluV2l0aDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcnJvcjtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGF0dGVtcHQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcbiIsIi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlU3RyaW5nQ2hhcjtcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlSW50ZXJwb2xhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eU9mO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eU9mIGZyb20gJy4vX2Jhc2VQcm9wZXJ0eU9mLmpzJztcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZUh0bWxDaGFyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG4iLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG4iLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcbiIsImltcG9ydCBlc2NhcGUgZnJvbSAnLi9lc2NhcGUuanMnO1xuaW1wb3J0IHJlRXNjYXBlIGZyb20gJy4vX3JlRXNjYXBlLmpzJztcbmltcG9ydCByZUV2YWx1YXRlIGZyb20gJy4vX3JlRXZhbHVhdGUuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVTZXR0aW5ncztcbiIsImltcG9ydCBhc3NpZ25JbldpdGggZnJvbSAnLi9hc3NpZ25JbldpdGguanMnO1xuaW1wb3J0IGF0dGVtcHQgZnJvbSAnLi9hdHRlbXB0LmpzJztcbmltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGN1c3RvbURlZmF1bHRzQXNzaWduSW4gZnJvbSAnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nQ2hhciBmcm9tICcuL19lc2NhcGVTdHJpbmdDaGFyLmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHRlbXBsYXRlU2V0dGluZ3MgZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICB2YXIgc291cmNlVVJMID0gJ3NvdXJjZVVSTCcgaW4gb3B0aW9ucyA/ICcvLyMgc291cmNlVVJMPScgKyBvcHRpb25zLnNvdXJjZVVSTCArICdcXG4nIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG4iLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RGdW5jdGlvbjtcbiIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrU2V0O1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IHN0YWNrQ2xlYXIgZnJvbSAnLi9fc3RhY2tDbGVhci5qcyc7XG5pbXBvcnQgc3RhY2tEZWxldGUgZnJvbSAnLi9fc3RhY2tEZWxldGUuanMnO1xuaW1wb3J0IHN0YWNrR2V0IGZyb20gJy4vX3N0YWNrR2V0LmpzJztcbmltcG9ydCBzdGFja0hhcyBmcm9tICcuL19zdGFja0hhcy5qcyc7XG5pbXBvcnQgc3RhY2tTZXQgZnJvbSAnLi9fc3RhY2tTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQnVmZmVyO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IFVpbnQ4QXJyYXk7XG4iLCJpbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUFycmF5QnVmZmVyO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDcmVhdGU7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUdldDtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9QbGFpbk9iamVjdDtcbiIsImltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5pbXBvcnQgdG9QbGFpbk9iamVjdCBmcm9tICcuL3RvUGxhaW5PYmplY3QuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlSGFzO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcbmltcG9ydCBzZXRDYWNoZUFkZCBmcm9tICcuL19zZXRDYWNoZUFkZC5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVIYXMgZnJvbSAnLi9fc2V0Q2FjaGVIYXMuanMnO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvQXJyYXk7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgbWFwVG9BcnJheSBmcm9tICcuL19tYXBUb0FycmF5LmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVB1c2g7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJBcnJheTtcbiIsImltcG9ydCBhcnJheUZpbHRlciBmcm9tICcuL19hcnJheUZpbHRlci5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5cztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVZpZXc7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdlYWtNYXA7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVDYXBwZWQ7XG4iLCJpbXBvcnQgbWVtb2l6ZUNhcHBlZCBmcm9tICcuL19tZW1vaXplQ2FwcGVkLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb1BhdGg7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdFBhdGg7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0tleTtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VIYXNJbjtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcbiIsImltcG9ydCBiYXNlSGFzSW4gZnJvbSAnLi9fYmFzZUhhc0luLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcbmltcG9ydCBnZXQgZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTb3J0Qnk7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZUFzY2VuZGluZztcbiIsImltcG9ydCBjb21wYXJlQXNjZW5kaW5nIGZyb20gJy4vX2NvbXBhcmVBc2NlbmRpbmcuanMnO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlTXVsdGlwbGU7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgYmFzZVNvcnRCeSBmcm9tICcuL19iYXNlU29ydEJ5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjb21wYXJlTXVsdGlwbGUgZnJvbSAnLi9fY29tcGFyZU11bHRpcGxlLmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VPcmRlckJ5O1xuIiwiaW1wb3J0IGJhc2VPcmRlckJ5IGZyb20gJy4vX2Jhc2VPcmRlckJ5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqIF07XG4gKlxuICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqL1xuZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgfVxuICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3JkZXJCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEluZGV4O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmFOO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpY3RJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5leHBvcnQgZGVmYXVsdCBub29wO1xuIiwiaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBfdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gtZXMvZm9yRWFjaCc7XG5pbXBvcnQgX21lcmdlIGZyb20gJ2xvZGFzaC1lcy9tZXJnZSc7XG5pbXBvcnQgX3ZhbHVlcyBmcm9tICdsb2Rhc2gtZXMvdmFsdWVzJztcbmltcG9ydCBfb3JkZXJCeSBmcm9tICdsb2Rhc2gtZXMvb3JkZXJCeSc7XG5pbXBvcnQgX3VuaXFCeSBmcm9tICdsb2Rhc2gtZXMvdW5pcUJ5JztcblxuLyoqXG4gKlxuICovXG5jbGFzcyBGZWVkIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0ID0gRmVlZC5kZWZhdWx0O1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfbWVyZ2Uoe30sIEZlZWQuZGVmYXVsdCwgY29uZmlnKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgbGV0IGRhdGEgPSBbXTtcbiAgICBsZXQgZmVlZCA9IHRoaXMuX3NldHRpbmdzLmZlZWQ7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHJzc1RvSnNvbjogRmVlZC5yc3NUb0pzb24sXG4gICAgICByc3NVcmw6IChBcnJheS5pc0FycmF5KGZlZWQpKSA/IGZlZWQgOiBbZmVlZF1cbiAgICB9O1xuXG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIGZlZWRcbiAgICBfZm9yRWFjaChjb25maWcucnNzVXJsLCAodXJsLCBpbmRleCkgPT4ge1xuICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdFxuICAgICAgdGhpcy5fcmVxdWVzdChjb25maWcsIHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhXG4gICAgICAgICAgZGF0YS5wdXNoKHRoaXMuX3Byb2Nlc3MoSlNPTi5wYXJzZShyZXNwb25zZSksIHRoaXMuX3NldHRpbmdzKSk7XG4gICAgICAgICAgLy8gV2hlbiBhbGwgZmVlZHMgaGF2ZSBiZWVuIHJlcXVlc3RlZCwgbWVyZ2UgdGhlIGRhdGEgYW5kIGNvbXBpbGVcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGNvbmZpZy5yc3NVcmwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGxldCBjb21waWxlZCA9IHRoaXMuX3JlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5fbWVyZ2UoZGF0YSwgdGhpcy5fc2V0dGluZ3MpLFxuICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9zZXR0aW5ncy5zZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGNvbXBpbGVkO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0IGZvciB0aGUgZmVlZCBkYXRhXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnIFRoZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgVGhlIHJlcXVlc3QgdXJsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFJlc29sdmVzIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHJlYWR5LCByZWplY3RzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXQgb3IgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAqL1xuICBfcmVxdWVzdChjb25maWcsIHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbGV0IF94aHIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChfeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoX3hoci5zdGF0dXMgPj0gMjAwICYmIF94aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKF94aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF94aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgRmVlZCByZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgIH07XG4gICAgICB4aHIub3BlbignR0VUJywgYCR7Y29uZmlnLnJzc1RvSnNvbn0/cnNzX3VybD0ke3VybH1gLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICB4aHIgPSBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgcHJvY2Vzc2luZyBmdW5jdGlvbiBiYXNlZCBvbiB0eXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBwcm9jZXNzZWQgZGF0YVxuICAgKi9cbiAgX3Byb2Nlc3MoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gRmVlZC5wcm9jZXNzW3NldHRpbmdzLnR5cGVdKGRhdGEsIHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzIGRhdGEgdG8gdGhlIGFwcHJvcHJpYXRlIG1lcmdlIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIG1lcmdlZCBmZWVkIGRhdGFcbiAgICovXG4gIF9tZXJnZShkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLm1lcmdlW3NldHRpbmdzLnR5cGVdKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGVtcGxhdGUgY29tcG9uZW50cywgcGFzcyBkYXRhLCBhbmQgcmV0dXJuIGNvbXBpbGVkIHRlbWxhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgVGhlIGNvbXBsaWVkIGh0bWwgc3RyaW5nXG4gICAqL1xuICBfcmVuZGVyKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgaWYgKHNldHRpbmdzLmxvZylcbiAgICAgIGNvbnNvbGUuZGlyKGRhdGEpO1xuXG4gICAgbGV0IHRlbXBsYXRlID0gX3ZhbHVlcyhzZXR0aW5ncy50ZW1wbGF0ZXMpLmpvaW4oJycpO1xuICAgIGxldCBjb21waWxlZCA9IF90ZW1wbGF0ZShcbiAgICAgIHRlbXBsYXRlLFxuICAgICAge1xuICAgICAgICAnaW1wb3J0cyc6IHtcbiAgICAgICAgICAnX2VhY2gnOiBfZm9yRWFjaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29tcGlsZWQoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvcGVuIFJTUyB0byBKU09OIGFwaSwgc2VlIGh0dHBzOi8vcnNzMmpzb24uY29tXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5GZWVkLnJzc1RvSnNvbiA9ICdodHRwczovL2FwaS5yc3MyanNvbi5jb20vdjEvYXBpLmpzb24nO1xuXG4vKipcbiAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdpZGdldC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQudGVtcGxhdGVzID0ge1xuICBtZWRpdW06IHtcbiAgICBvcGVuZXI6IFtcbiAgICAgICc8c2VjdGlvbiBjbGFzcz1cIm8tZmVlZCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy53cmFwcGVyICU+XCIgc3R5bGU9XCInLFxuICAgICAgICAnPCUgaWYgKHNldHRpbmdzLmZvbnRTaXplKSB7ICU+Zm9udC1zaXplOiA8JS0gc2V0dGluZ3MuZm9udFNpemUgJT47PCUgfSAlPicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yKSB7ICU+Ym9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OzwlIH0gJT4nLFxuICAgICAgJ1wiPidcbiAgICBdLFxuICAgIGhlYWRlcjogW1xuICAgICAgJzxoZWFkZXIgY2xhc3M9XCJvLWZlZWRfX2hlYWRlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5oZWFkZXIgJT5cIj4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9fYXZhdGFyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmF2YXRhciAlPlwiPicsXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnByb2ZpbGVJbWcgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy5wcm9maWxlSW1nICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBmZWVkLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9ICU+XCIgJyxcbiAgICAgICAgICAgICAgICd3aWR0aD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMF0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ2hlaWdodD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMV0gJT5cIj4nLFxuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzxhIGNsYXNzPVwiby1mZWVkX191cmwgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCIgJyxcbiAgICAgICAgICAnaHJlZj1cIjwlIGlmIChzZXR0aW5ncy50aXRsZVVybCAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlVXJsICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnVybCAlPicsXG4gICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgJzwlIGlmIChzZXR0aW5ncy50aXRsZSAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSAlPicsXG4gICAgICAgICc8L2E+JyxcbiAgICAgICc8L2hlYWRlcj4nXG4gICAgXSxcbiAgICBwb3N0czogW1xuICAgICAgJzxkaXYgY2xhc3M9XCJvLWZlZWRfX2l0ZW1zXCIgc3R5bGU9XCInLFxuICAgICAgICAnYm9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OycsXG4gICAgICAnXCI+JyxcbiAgICAgICAgJzwlIF9lYWNoKGl0ZW1zLCBmdW5jdGlvbihwb3N0KSB7ICU+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmZlZWRJdGVtICU+XCI+JyxcbiAgICAgICAgICAgICc8aDQgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGl0bGUgPCUtIHNldHRpbmdzLmNsYXNzZXMudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJjLWZlZWQtaXRlbV9fbGluayA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5saW5rICU+XCInLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIicsXG4gICAgICAgICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIicsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHBvc3QudGl0bGUgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9oND4nLFxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2RhdGUgPCUtIHNldHRpbmdzLmNsYXNzZXMuZGF0ZSAlPlwiICcsXG4gICAgICAgICAgICAgICAgICAndGl0bGU9XCI8JS0gc2V0dGluZ3MucG9zdERhdGVUaXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8JS0gcG9zdC5kYXRlICU+JyxcbiAgICAgICAgICAgICc8L3NwYW4+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX3RodW1ibmFpbCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aHVtYm5haWwgJT5cIicsXG4gICAgICAgICAgICAgICAgICdzdHlsZT1cIicsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlOiB1cmwoPCUtIHBvc3QudGh1bWJuYWlsICU+KTsnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0OiA8JS0gc2V0dGluZ3MucG9zdEltZ0hlaWdodCAlPjtcIicsXG4gICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbj1cInRydWVcIj4nLFxuICAgICAgICAgICAgICAnPGltZyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgc3JjPVwiPCUtIHBvc3QudGh1bWJuYWlsICU+XCIgYWx0PVwiPCUtIHBvc3QudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPHAgY2xhc3M9XCJjLWZlZWQtaXRlbV9fZXhjZXJwdCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5leGNlcnB0ICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmV4Y2VycHQgJT48JS0gc2V0dGluZ3MucG9zdEV4Y2VycHRUcmFpbCAlPicsXG4gICAgICAgICAgICAnPC9wPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtX19mb290ZXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuaXRlbUZvb3RlciAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19jdGEgPCUtIHNldHRpbmdzLmNsYXNzZXMuY3RhICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ2hyZWY9XCI8JS0gcG9zdC5ndWlkICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnBvc3RDdGFUZXh0ICU+JyxcbiAgICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8JSB9KTsgJT4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLFxuICAgIGNsb3NlcjogW1xuICAgICAgJzwvc2VjdGlvbj4nXG4gICAgXVxuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgcHJvY2Vzc2luZyB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5wcm9jZXNzID0ge1xuICBtZWRpdW06IGZ1bmN0aW9uKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgbGV0IGxlbmd0aCA9IHNldHRpbmdzLnBvc3RFeGNlcnB0TGVuZ3RoO1xuXG4gICAgX2ZvckVhY2goZGF0YS5pdGVtcywgZnVuY3Rpb24ocG9zdCwgaW5kZXgpIHtcbiAgICAgIGxldCBleGNlcnB0ID0gJyc7XG4gICAgICBsZXQgZGF0ZSA9ICcnO1xuXG4gICAgICAvLyBSZW1vdmUgZmlndXJlcyBmaXJzdFxuICAgICAgZXhjZXJwdCA9IHBvc3QuZGVzY3JpcHRpb25cbiAgICAgICAgLnJlcGxhY2UoLzxmaWd1cmUuKj4uKj88XFwvZmlndXJlPi9nLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgdGFnc1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQucmVwbGFjZSgvPCgufFxcbikqPz4vZywgJycpO1xuXG4gICAgICAvLyBUcmltIHRoZSBleGNlcnB0XG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLFxuICAgICAgICBNYXRoLm1pbihleGNlcnB0Lmxlbmd0aCwgZXhjZXJwdC5sYXN0SW5kZXhPZignICcpKVxuICAgICAgKTtcblxuICAgICAgcG9zdC5leGNlcnB0ID0gZXhjZXJwdDtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlXG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShwb3N0LnB1YkRhdGUucmVwbGFjZSgnICcsICdUJykpKVxuICAgICAgICAudG9Mb2NhbGVEYXRlU3RyaW5nKHNldHRpbmdzLnBvc3REYXRlTG9jYWwsIHNldHRpbmdzLnBvc3REYXRlRm9ybWF0KTtcblxuICAgICAgcG9zdC5kYXRlID0gZGF0ZTtcblxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgbWVyZ2luZyB0aGUgZGF0YSBmZWVkcyB0b2dldGhlciwgYmFzZWQgb24gdGhlIGZlZWQgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQubWVyZ2UgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSkge1xuICAgIGxldCBtZXJnZWQgPSB7fTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIC8vIENvbWJpbmUgdGhlIHBvc3QgaXRlbXNcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KGZlZWQuaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGRhdGEsIHRoaXMgd2lsbCBvdmVycmlkZSB2YWx1ZXMsIGl0IHByb2JhYmx5IHdvbid0IGJlXG4gICAgLy8gcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZmVlZHMgdGhhdCBhcmUgdGhlIHNhbWUsIGJ1dCBwb3RlbnRpYWxseVxuICAgIC8vIGRpZmZlcmVudCBmZWVkIHR5cGVzIGNvdWxkIHVzZSB0aGlzIGFuZCBjb21iaW5lIHVuaXF1ZSBkYXRhXG4gICAgZGF0YS5mb3JFYWNoKChmZWVkKSA9PiB7XG4gICAgICBtZXJnZWQgPSBfbWVyZ2UobWVyZ2VkLCBmZWVkKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCB1bmlxdWUgcG9zdHNcbiAgICAvLyBpdGVtcyA9IF91bmlxQnkoaXRlbXMsIChpdGVtKSA9PiBpdGVtLmd1aWQpO1xuXG4gICAgbWVyZ2VkLml0ZW1zID0gX29yZGVyQnkoaXRlbXMsICdwdWJEYXRlJywgJ2Rlc2MnKTtcblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9yc3MyanNvbi5jb20vZG9jcyBmb3IgZGV0YWlscyBvbiBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQuZGVmYXVsdCA9IHtcbiAgZmVlZDogJycsXG4gIHNlbGVjdG9yOiAnI2pzLWZlZWQnLFxuICB0eXBlOiAnbWVkaXVtJyxcbiAgdGl0bGU6ICcnLFxuICB0aXRsZVVybDogJycsXG4gIHByb2ZpbGVJbWc6ICcnLFxuICBmb250U2l6ZTogJycsXG4gIHJhdGlvUHJvZmlsZTogWyc1MCcsICc1MCddLFxuICBwb3N0Qm9yZGVyQ29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gIHBvc3RJbWdIZWlnaHQ6ICcyMDBweCcsXG4gIHBvc3RFeGNlcnB0TGVuZ3RoOiAxMjAsXG4gIHBvc3RFeGNlcnB0VHJhaWw6ICfigKYnLFxuICBwb3N0Q3RhVGV4dDogJ1JlYWQgdGhlIGZ1bGwgcG9zdCcsXG4gIHBvc3REYXRlTG9jYWw6ICdlbi1VUycsXG4gIHBvc3REYXRlRm9ybWF0OiB7XG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYydcbiAgfSxcbiAgcG9zdERhdGVUaXRsZTogJ1B1Ymxpc2hlZCBEYXRlJyxcbiAgY2xhc3Nlczoge1xuICAgIHdyYXBwZXI6ICcnLFxuICAgIGhlYWRlcjogJycsXG4gICAgdXJsOiAnJyxcbiAgICBmZWVkSXRlbTogJycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGxpbms6ICcnLFxuICAgIHRodW1ibmFpbDogJycsXG4gICAgZXhjZXJwdDogJycsXG4gICAgaXRlbUZvb3RlcjogJycsXG4gICAgY3RhOiAnJyxcbiAgICBkYXRlOiAnJ1xuICB9LFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBvcGVuZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5vcGVuZXIuam9pbignJyksXG4gICAgaGVhZGVyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uaGVhZGVyLmpvaW4oJycpLFxuICAgIHBvc3RzOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0ucG9zdHMuam9pbignJyksXG4gICAgY2xvc2VyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uY2xvc2VyLmpvaW4oJycpXG4gIH0sXG4gIGxvZzogZmFsc2UsXG4gIHVuaXF1ZTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZlZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFNpbXBsZSBUb2dnbGUgY2xhc3MuIFRoaXMgd2lsbCB0b2dnbGUgdGhlIGNsYXNzICdhY3RpdmUnIGFuZCAnaGlkZGVuJ1xuICogb24gdGFyZ2V0IGVsZW1lbnRzLCBkZXRlcm1pbmVkIGJ5IGEgY2xpY2sgZXZlbnQgb24gYSBzZWxlY3RlZCBsaW5rIG9yXG4gKiBlbGVtZW50LiBUaGlzIHdpbGwgYWxzbyB0b2dnbGUgdGhlIGFyaWEtaGlkZGVuIGF0dHJpYnV0ZSBmb3IgdGFyZ2V0ZWRcbiAqIGVsZW1lbnRzIHRvIHN1cHBvcnQgc2NyZWVuIHJlYWRlcnMuIFRhcmdldCBzZXR0aW5ncyBhbmQgb3RoZXIgZnVuY3Rpb25hbGl0eVxuICogY2FuIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBkYXRhIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyB1c2VzIHRoZSAubWF0Y2hlcygpIG1ldGhvZCB3aGljaCB3aWxsIHJlcXVpcmUgYSBwb2x5ZmlsbCBmb3IgSUVcbiAqIGh0dHBzOi8vcG9seWZpbGwuaW8vdjIvZG9jcy9mZWF0dXJlcy8jRWxlbWVudF9wcm90b3R5cGVfbWF0Y2hlc1xuICpcbiAqIEJhc2ljIFVzYWdlO1xuICpcbiAqIGphdmFzY3JpcHQ6XG4gKiAgIG5ldyBUb2dnbGUoKS5pbml0KCk7XG4gKlxuICogVG9nZ2xpbmcgQW5jaG9yIGxpbmtzOlxuICogICA8YSBkYXRhLWpzPSd0b2dnbGUnIGhyZWY9JyNtYWluLW1lbnUnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogVG9nZ2xpbmcgYXJpYS1jb250cm9sIGVsZW1lbnRzOlxuICpcbiAqICAgPGJ1dHRvbiBkYXRhLWpzPSd0b2dnbGUnIGFyaWEtY29udHJvbHM9JyNtYWluLW1lbnUnIGFyaWEtcHJlc3NlZD0nZmFsc2UnPlxuICogICAgICBNZW51XG4gKiAgIDwvYnV0dG9uPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz4gLi4uIDwvZGl2PlxuICpcbiAqIENyZWF0ZSBcIlVuZG9cIiBFdmVudCAodG8gY2xvc2UgYSBkaWFsb2d1ZSk7XG4gKiAgIDxhIGhyZWY9JyNtYWluLW1lbnUnIGRhdGEtanM9J3RvZ2dsZScgZGF0YS10b2dnbGUtdW5kbz0nI2Nsb3NlJz5NZW51PC9hPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAqICAgICA8YSBpZD1cImNsb3NlXCI+Q2xvc2U8L2E+XG4gKiAgIDwvZGl2PlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRvZ2dsZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzIFNldHRpbmdzIGZvciB0aGlzIFRvZ2dsZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHMgPSAoIXMpID8ge30gOiBzO1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICBzZWxlY3RvcjogKHMuc2VsZWN0b3IpID8gcy5zZWxlY3RvciA6IFRvZ2dsZS5zZWxlY3RvcixcbiAgICAgIG5hbWVzcGFjZTogKHMubmFtZXNwYWNlKSA/IHMubmFtZXNwYWNlIDogVG9nZ2xlLm5hbWVzcGFjZSxcbiAgICAgIGluYWN0aXZlQ2xhc3M6IChzLmluYWN0aXZlQ2xhc3MpID8gcy5pbmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmluYWN0aXZlQ2xhc3MsXG4gICAgICBhY3RpdmVDbGFzczogKHMuYWN0aXZlQ2xhc3MpID8gcy5hY3RpdmVDbGFzcyA6IFRvZ2dsZS5hY3RpdmVDbGFzcyxcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGV2ZW50ICBUaGUgbWFpbiBjbGljayBldmVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgY2xhc3NcbiAgICovXG4gIF90b2dnbGUoZXZlbnQpIHtcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IHRhcmdldCA9IGZhbHNlO1xuXG4gICAgLyoqIEFuY2hvciBMaW5rcyAqL1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgOiB0YXJnZXQ7XG5cbiAgICAvKiogVG9nZ2xlIENvbnRyb2xzICovXG4gICAgLy8gY29uc29sZS5kaXIoZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7ZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyl9YCkgOiB0YXJnZXQ7XG5cbiAgICAvKiogTWFpbiBGdW5jdGlvbmFsaXR5ICovXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcblxuICAgIC8qKiBVbmRvICovXG4gICAgaWYgKGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXSkge1xuICAgICAgY29uc3QgdW5kbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXVxuICAgICAgKTtcblxuICAgICAgdW5kby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG4gICAgICAgIHVuZG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIHRvZ2dsaW5nIG1ldGhvZFxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsICAgICBUaGUgY3VycmVudCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmVcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmUvaGlkZGVuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzICE9PSAnJykge1xuICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgZWxlbWVudCBmb3IgZGVmaW5lZCBhcmlhIHJvbGVzIGFuZCB0b2dnbGUgdGhlbSBpZiB0aGV5IGV4aXN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUb2dnbGUuZWxBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS50YXJnZXRBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pKVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0sXG4gICAgICAgICAgISh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcykpXG4gICAge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdG9nZ2xpbmcgZnVuY3Rpb24gdG8gKi9cblRvZ2dsZS5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0b2dnbGVcIl0nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG5hbWVzcGFjZSBmb3Igb3VyIGRhdGEgYXR0cmlidXRlIHNldHRpbmdzICovXG5Ub2dnbGUubmFtZXNwYWNlID0gJ3RvZ2dsZSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgaGlkZSBjbGFzcyAqL1xuVG9nZ2xlLmluYWN0aXZlQ2xhc3MgPSAnaGlkZGVuJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBhY3RpdmUgY2xhc3MgKi9cblRvZ2dsZS5hY3RpdmVDbGFzcyA9ICdhY3RpdmUnO1xuXG4vKiogQHR5cGUge0FycmF5fSBBcmlhIHJvbGVzIHRvIHRvZ2dsZSB0cnVlL2ZhbHNlIG9uIHRoZSB0b2dnbGluZyBlbGVtZW50ICovXG5Ub2dnbGUuZWxBcmlhUm9sZXMgPSBbJ2FyaWEtcHJlc3NlZCcsICdhcmlhLWV4cGFuZGVkJ107XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRhcmdldCBlbGVtZW50ICovXG5Ub2dnbGUudGFyZ2V0QXJpYVJvbGVzID0gWydhcmlhLWhpZGRlbiddO1xuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbGl0eSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL3V0aWxpdHknO1xuXG4vKipcbiAqIFRyYWNraW5nIGJ1cyBmb3IgR29vZ2xlIGFuYWx5dGljcyBhbmQgV2VidHJlbmRzLlxuICovXG5jbGFzcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVHJhY2suc2VsZWN0b3IsXG4gICAgfTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCBrZXkgPSBldmVudC50YXJnZXQuZGF0YXNldC50cmFja0tleTtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuZGF0YXNldC50cmFja0RhdGEpO1xuXG4gICAgICB0aGlzLmNsaWNrKGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB3cmFwcGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIGZpbmFsIGRhdGEgb2JqZWN0XG4gICAqL1xuICBjbGljayhrZXksIGRhdGEpIHtcbiAgICAvLyBTZXQgdGhlIHBhdGggbmFtZSBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgICBjb25zdCBkID0gZGF0YS5tYXAoZWwgPT4ge1xuICAgICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSlcbiAgICAgICAgICBlbFtUcmFjay5rZXldID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfS8ke2VsW1RyYWNrLmtleV19YFxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcblxuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZCk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnKGtleSwgZCk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERhdGEgYnVzIGZvciB0cmFja2luZyB2aWV3cyBpbiBXZWJ0cmVuZHMgYW5kIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgU2luZ2xlIFBhZ2UgQXBwbGljYXRpb24gdG8gdHJhY2tcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHZpZXcoYXBwLCBrZXksIGRhdGEpIHtcbiAgICBsZXQgd3QgPSB0aGlzLndlYnRyZW5kcyhrZXksIGRhdGEpO1xuICAgIGxldCBnYSA9IHRoaXMuZ3RhZ1ZpZXcoYXBwLCBrZXkpO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpXG4gICAgICBjb25zb2xlLmRpcih7J1RyYWNrJzogW3d0LCBnYV19KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBFdmVudHMgdG8gV2VidHJlbmRzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICB3ZWJ0cmVuZHMoa2V5LCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50ID0gW3tcbiAgICAgICdXVC50aSc6IGtleVxuICAgIH1dO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKSB7XG4gICAgICBldmVudC5wdXNoKHtcbiAgICAgICAgJ0RDUy5kY3N1cmknOiBkYXRhWzBdW1RyYWNrLmtleV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgZGF0YSBmb3IgV2VidHJlbmRzXG4gICAgbGV0IHd0ZCA9IHthcmdzYTogZXZlbnQuZmxhdE1hcChlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mbGF0TWFwKGsgPT4gW2ssIGVba11dKTtcbiAgICB9KX07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgV2VidHJlbmRzICE9PSAndW5kZWZpbmVkJylcbiAgICAgIFdlYnRyZW5kcy5tdWx0aVRyYWNrKHd0ZCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ1dlYnRyZW5kcycsIHd0ZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggQ2xpY2sgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIGd0YWcoa2V5LCBkYXRhKSB7XG4gICAgbGV0IHVyaSA9IGRhdGEuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKTtcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgICdldmVudF9jYXRlZ29yeSc6IGtleVxuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgZ3RhZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBndGFnKFRyYWNrLmtleSwgdXJpW1RyYWNrLmtleV0sIGV2ZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIFNjcmVlbiBWaWV3IEV2ZW50cyB0byBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGFwcCAgVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKi9cbiAgZ3RhZ1ZpZXcoYXBwLCBrZXkpIHtcbiAgICBsZXQgdmlldyA9IHtcbiAgICAgIGFwcF9uYW1lOiBhcHAsXG4gICAgICBzY3JlZW5fbmFtZToga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoJ2V2ZW50JywgJ3NjcmVlbl92aWV3Jywgdmlldyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnZ3RhZycsIFRyYWNrLmtleSwgJ3NjcmVlbl92aWV3Jywgdmlld107XG4gIH07XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBzZWxlY3RvciB0byBhZGQgdGhlIHRyYWNraW5nIGZ1bmN0aW9uIHRvICovXG5UcmFjay5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0cmFja1wiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBldmVudCB0cmFja2luZyBrZXkgdG8gbWFwIHRvIFdlYnRyZW5kcyBEQ1MudXJpICovXG5UcmFjay5rZXkgPSAnZXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjazsiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjZcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbmNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IHZhbCA9PiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldXG4gICAgOiB2YWwgPT4gbWFwW3ZhbF1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xuY29uc3QgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IG5vID0gKGEsIGIsIGMpID0+IGZhbHNlO1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5jb25zdCBpZGVudGl0eSA9IChfKSA9PiBfO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZSgoa2V5cywgbSkgPT4ge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgY29uc3QgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIGNvbnN0IGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG5jb25zdCBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxuY29uc3QgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlTGV0dGVycyA9ICdhLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIGNvbnN0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xuY29uc3QgYmFpbFJFID0gbmV3IFJlZ0V4cChgW14ke3VuaWNvZGVMZXR0ZXJzfS4kX1xcXFxkXWApO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSByZXR1cm5cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5jb25zdCBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG5jb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG5jb25zdCB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbmNvbnN0IGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuY29uc3QgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbmNvbnN0IGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5jb25zdCBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuY29uc3QgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxuY29uc3QgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxubGV0IF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGNsYXNzIFNldCAgIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH1cbiAgICBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgd2FybiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICBjb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICBjb25zdCBjbGFzc2lmeSA9IHN0ciA9PiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5cbiAgd2FybiA9IChtc2csIHZtKSA9PiB7XG4gICAgY29uc3QgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtWdWUgd2Fybl06ICR7bXNnfSR7dHJhY2V9YCk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IChtc2csIHZtKSA9PiB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbVnVlIHRpcF06ICR7bXNnfWAgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSAodm0sIGluY2x1ZGVGaWxlKSA9PiB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIGNvbnN0IGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpXG4gICAgKVxuICB9O1xuXG4gIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgcmVzICs9IHN0cjtcbiAgICAgIGlmIChuID4gMSkgc3RyICs9IHN0cjtcbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gdm0gPT4ge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7XG4gICAgICAgICAgaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpXG4gICAgICAgIH0ke1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/IGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pfS4uLiAoJHt2bVsxXX0gcmVjdXJzaXZlIGNhbGxzKWBcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSlcbiAgICAgICAgfWApXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFxcblxcbihmb3VuZCBpbiAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSlgXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG5jbGFzcyBEZXAge1xuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmlkID0gdWlkKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH1cblxuICBhZGRTdWIgKHN1Yikge1xuICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gIH1cblxuICByZW1vdmVTdWIgKHN1Yikge1xuICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gIH1cblxuICBkZXBlbmQgKCkge1xuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnkgKCkge1xuICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbmNvbnN0IHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG5jbGFzcyBWTm9kZSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gICAvLyByZW5kZXJlZCBpbiB0aGlzIGNvbXBvbmVudCdzIHNjb3BlXG4gIFxuICBcbiAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgLy8gY29tcG9uZW50IHBsYWNlaG9sZGVyIG5vZGVcblxuICAvLyBzdHJpY3RseSBpbnRlcm5hbFxuICAgLy8gY29udGFpbnMgcmF3IEhUTUw/IChzZXJ2ZXIgb25seSlcbiAgIC8vIGhvaXN0ZWQgc3RhdGljIG5vZGVcbiAgIC8vIG5lY2Vzc2FyeSBmb3IgZW50ZXIgdHJhbnNpdGlvbiBjaGVja1xuICAgLy8gZW1wdHkgY29tbWVudCBwbGFjZWhvbGRlcj9cbiAgIC8vIGlzIGEgY2xvbmVkIG5vZGU/XG4gICAvLyBpcyBhIHYtb25jZSBub2RlP1xuICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAgXG4gIFxuICBcbiAgIC8vIHJlYWwgY29udGV4dCB2bSBmb3IgZnVuY3Rpb25hbCBub2Rlc1xuICAgLy8gZm9yIFNTUiBjYWNoaW5nXG4gICAvLyB1c2VkIHRvIHN0b3JlIGZ1bmN0aW9uYWwgcmVuZGVyIGNvbnRleHQgZm9yIGRldnRvb2xzXG4gICAvLyBmdW5jdGlvbmFsIHNjb3BlIGlkIHN1cHBvcnRcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgdGV4dCxcbiAgICBlbG0sXG4gICAgY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIGFzeW5jRmFjdG9yeVxuICApIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZWxtID0gZWxtO1xuICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBjaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICBjb25zdCBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbmNvbnN0IG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICBjb25zdCBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfXztcbiAgICBsZXQgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xubGV0IHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICBcbiAgXG4gICAvLyBudW1iZXIgb2Ygdm1zIHRoYXQgaGF2ZSB0aGlzIG9iamVjdCBhcyByb290ICRkYXRhXG5cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICB3YWxrIChvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKi9cbiAgb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICBjb25zdCBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICBjb25zdCBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgbGV0IGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSByZXR1cm5cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yIChsZXQgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbmNvbnN0IHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBvcHRpb24gXCIke2tleX1cIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBgICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvXG4gIGxldCBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICBjb25zdCBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICBjb25zdCByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGhvb2sgPT4ge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5jb25zdCBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoYF5bYS16QS1aXVtcXFxcLVxcXFwuMC05XyR7dW5pY29kZUxldHRlcnN9XSokYCkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgbGV0IGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwicHJvcHNcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHByb3BzKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHJldHVyblxuICBjb25zdCBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3QpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcImluamVjdFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUoaW5qZWN0KX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgY29uc3QgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkaXJzKSB7XG4gICAgICBjb25zdCBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcIiR7bmFtZX1cIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHZhbHVlKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge307XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICBjb25zdCBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHJldHVybiBhc3NldHNbaWRdXG4gIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXVxuICBjb25zdCBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgY29uc3QgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIGxldCB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICBjb25zdCBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHR5cGUgPSBwcm9wLnR5cGU7XG4gIGxldCB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIGNvbnN0IG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJyl9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICBsZXQgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSByZXR1cm5cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKGBFcnJvciBpbiAke2luZm99OiBcIiR7ZXJyLnRvU3RyaW5nKCl9XCJgLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xubGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIGNvbnN0IGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG5sZXQgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHNldFRpbWVvdXQobm9vcCk7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICBsZXQgY291bnRlciA9IDE7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIGxldCBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBtYXJrO1xubGV0IG1lYXN1cmU7XG5cbntcbiAgY29uc3QgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gdGFnID0+IHBlcmYubWFyayh0YWcpO1xuICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxubGV0IGluaXRQcm94eTtcblxue1xuICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgb3IgbWV0aG9kIFwiJHtrZXl9XCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBgICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYFByb3BlcnR5IFwiJHtrZXl9XCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFwiJGRhdGEuJHtrZXl9XCIgYmVjYXVzZSBgICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgY29uc3QgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKGBBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC4ke2tleX1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIGxldCBpLCBrZXlzO1xuICBjb25zdCBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIGNvbnN0IGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBub3JtYWxpemVFdmVudCA9IGNhY2hlZCgobmFtZSkgPT4ge1xuICBjb25zdCBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3Qgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmUsXG4gICAgcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIGNvbnN0IGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYClcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIGxldCBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcIiR7ZXZlbnQubmFtZX1cIjogZ290IGAgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICBsZXQgaW52b2tlcjtcbiAgY29uc3Qgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICBjb25zdCBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IHsgYXR0cnMsIHByb3BzIH0gPSBkYXRhO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBjb25zdCBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBgUHJvcCBcIiR7a2V5SW5Mb3dlckNhc2V9XCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpfSwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNgICtcbiAgICAgICAgICAgIGAgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBgICtcbiAgICAgICAgICAgIGBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIGAgK1xuICAgICAgICAgICAgYHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2FsdEtleX1cIiBpbnN0ZWFkIG9mIFwiJHtrZXl9XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgY29udGludWVcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsIGAke25lc3RlZEluZGV4IHx8ICcnfV8ke2l9YCk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IGBfX3ZsaXN0JHtuZXN0ZWRJbmRleH1fJHtpfV9fYDtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIGNvbnN0IHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgKCkgPT4ge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgYGluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgY29udGludWVcbiAgICAgIGNvbnN0IHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgbGV0IHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihgSW5qZWN0aW9uIFwiJHtrZXl9XCIgbm90IGZvdW5kYCwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICBjb25zdCBzbG90cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3QgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICBjb25zdCBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIGxldCByZXM7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIHNsb3RzLiRzdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleV0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6IHRydWUpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gKCkgPT4gc2xvdHNba2V5XVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICBsZXQgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGxldCBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIGNvbnN0IHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIGNvbnN0IG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBsZXQgaGFzaDtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtjYW1lbGl6ZWRLZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIGxldCB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX29uY2VfXyR7aW5kZXh9JHtrZXkgPyBgXyR7a2V5fWAgOiBgYH1gLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBgJHtrZXl9XyR7aX1gLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgY29uc3Qgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICBoYXNEeW5hbWljS2V5cyxcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIGhhc0R5bmFtaWNLZXlzLCByZXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6ICR7a2V5fWAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICBsZXQgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICBjb25zdCBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgY29uc3QgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiB7XG4gICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XG4gIH1cblxuICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICBjb25zdCB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIGNvbnN0IGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuY29uc3QgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICBjb25zdCBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydCAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveSAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybihgSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogJHtTdHJpbmcoQ3Rvcil9YCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGxldCBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIGNvbnN0IGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICBjb25zdCBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIGNvbnN0IG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIGB2dWUtY29tcG9uZW50LSR7Q3Rvci5jaWR9JHtuYW1lID8gYC0ke25hbWV9YCA6ICcnfWAsXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3IsIHByb3BzRGF0YSwgbGlzdGVuZXJzLCB0YWcsIGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIGNvbnN0IGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICBjb25zdCB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIGNvbnN0IG1lcmdlZCA9IChhLCBiKSA9PiB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICBjb25zdCBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICBjb25zdCBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBTSU1QTEVfTk9STUFMSVpFID0gMTtcbmNvbnN0IEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICBsZXQgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgYXBwbHlOUyh2bm9kZSwgbnMpO1xuICAgIGlmIChpc0RlZihkYXRhKSkgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIGNvbnN0IHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgY29uc3QgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgeyByZW5kZXIsIF9wYXJlbnRWbm9kZSB9ID0gdm0uJG9wdGlvbnM7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICBsZXQgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlcmApO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyRXJyb3JgKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGNvbnN0IG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIGxldCBzeW5jID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0gKHJlbmRlckNvbXBsZXRlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXNvbHZlID0gb25jZSgocmVzKSA9PiB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVqZWN0ID0gb25jZShyZWFzb24gPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJHtTdHJpbmcoZmFjdG9yeSl9YCArXG4gICAgICAgIChyZWFzb24gPyBgXFxuUmVhc29uOiAke3JlYXNvbn1gIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBgdGltZW91dCAoJHtyZXMudGltZW91dH1tcylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICBjb25zdCBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbmxldCB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgY29uc3QgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIGNvbnN0IGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgbGV0IGNiO1xuICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xuICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgY29uc3QgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIGxldCBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHByZXZFbCA9IHZtLiRlbDtcbiAgICBjb25zdCBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgY29uc3QgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgbGV0IGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgY29uc3QgaWQgPSB2bS5fdWlkO1xuICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHtpZH1gO1xuICAgICAgY29uc3QgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke2lkfWA7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcGF0Y2hgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzICYmICFwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIXZtLiRzY29wZWRTbG90cy4kc3RhYmxlKVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICBjb25zdCBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBjb25zdCBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIGNvbnN0IHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgY29uc3Qgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgY29uc3QgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuY29uc3QgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbmxldCBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbmlmIChpbkJyb3dzZXIgJiYgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcbiAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcbiAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXG4gIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgbGV0IHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IGBpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYFxuICAgICAgICAgICAgICA6IGBpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uYFxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgY29uc3QgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICBjb25zdCB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgbGV0IGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgY29uc3Qgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIGNvbnN0IGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxubGV0IHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXCIke2V4cE9yRm59XCIgYCArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICBwdXNoVGFyZ2V0KHRoaXMpO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGFkZERlcCAoZGVwKSB7XG4gICAgY29uc3QgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgY2xlYW51cERlcHMgKCkge1xuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0bXAgPSB0aGlzLmRlcElkcztcbiAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgdG1wID0gdGhpcy5kZXBzO1xuICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICB0aGlzLmRlZXBcbiAgICAgICkge1xuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIGBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgZXZhbHVhdGUgKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIGRlcGVuZCAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7XG4gIGlmIChvcHRzLm1ldGhvZHMpIGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpO1xuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTtcbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICBjb25zdCBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICBjb25zdCBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIGNvbnN0IGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFwiJHtoeXBoZW5hdGVkS2V5fVwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgYCArXG4gICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIGAgK1xuICAgICAgICAgICAgYHZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgbGV0IGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGNvbnN0IG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIGAgK1xuICAgICAgICBgVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLmAsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5jb25zdCBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBjb25zdCB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgY29uc3QgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgY29uc3QgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgY29uc3QgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIGNvbnN0IHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kc1trZXldfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gYCArXG4gICAgICAgICAgYEF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHdhdGNoKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgY29uc3QgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgY29uc3QgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oYCRwcm9wcyBpcyByZWFkb25seS5gLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCBgY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICBsZXQgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke3ZtLl9uYW1lfSBpbml0YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIGNvbnN0IHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICBjb25zdCBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG1vZGlmaWVkO1xuICBjb25zdCBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgbW9kaWZpZWQgPSB7fTtcbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICBsZXQgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICBjb25zdCBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICBjb25zdCBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgYF9wcm9wc2AsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgY29uc3QgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUgfSA9IGtlZXBBbGl2ZUluc3RhbmNlO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIGNvbnN0IGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxuY29uc3QgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+ICFtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgY29uc3Qgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSB9ID0gdGhpcztcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBjYWNoZSwga2V5cyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gYDo6JHtjb21wb25lbnRPcHRpb25zLnRhZ31gIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgY29uc3QgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gIHtcbiAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2FybixcbiAgICBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IChvYmopID0+IHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjYnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuY29uc3QgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG5jb25zdCBtdXN0VXNlUHJvcCA9ICh0YWcsIHR5cGUsIGF0dHIpID0+IHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG5jb25zdCBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbmNvbnN0IGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuY29uc3QgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxuY29uc3QgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbmNvbnN0IGlzWGxpbmsgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG5jb25zdCBnZXRYbGlua1Byb3AgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbmNvbnN0IGlzRmFsc3lBdHRyVmFsdWUgPSAodmFsKSA9PiB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgbGV0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IHN0cmluZ2lmaWVkO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxuY29uc3QgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5jb25zdCBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5jb25zdCBpc1ByZVRhZyA9ICh0YWcpID0+IHRhZyA9PT0gJ3ByZSc7XG5cbmNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSAodGFnKSA9PiB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG5jb25zdCB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuY29uc3QgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgY29uc3Qga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgcmV0dXJuXG5cbiAgY29uc3Qgdm0gPSB2bm9kZS5jb250ZXh0O1xuICBjb25zdCByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuY29uc3QgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgcmV0dXJuIHRydWVcbiAgbGV0IGk7XG4gIGNvbnN0IHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgY29uc3QgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgbGV0IGksIGtleTtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIGxldCBpLCBqO1xuICBjb25zdCBjYnMgPSB7fTtcblxuICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICBsZXQgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgY29uc3QgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgbGV0IGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIGxldCBpLCBqO1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY29uc3QgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGxldCBvbGRTdGFydElkeCA9IDA7XG4gICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICBjb25zdCBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICcke2tleX0nLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuYCxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIGNvbnN0IGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgdGFnLCBkYXRhLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBsZXQgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIGNvbnN0IHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICBjb25zdCBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIGNvbnN0IGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICBjb25zdCBkaXJzV2l0aEluc2VydCA9IFtdO1xuICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIGxldCBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICBjb25zdCBjYWxsSW5zZXJ0ID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICBsZXQgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCBgJHtkaXIubmFtZX0uJHtPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJyl9YFxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCBgZGlyZWN0aXZlICR7ZGlyLm5hbWV9ICR7aG9va30gaG9va2ApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1ciwgb2xkO1xuICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgbGV0IGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIGNvbnN0IGJsb2NrZXIgPSBlID0+IHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgbGV0IGluU2luZ2xlID0gZmFsc2U7XG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICBsZXQgaW5SZWdleCA9IGZhbHNlO1xuICBsZXQgY3VybHkgPSAwO1xuICBsZXQgc3F1YXJlID0gMDtcbiAgbGV0IHBhcmVuID0gMDtcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSBpblJlZ2V4ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gYF9mKFwiJHtuYW1lfVwiKSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWBcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKGBbVnVlIGNvbXBpbGVyXTogJHttc2d9YCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAobSA9PiBtW2tleV0pLmZpbHRlcihfID0+IF8pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYFxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gYCgke25hbWV9KT09PSdjbGljayc/J2NvbnRleHRtZW51JzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICBsZXQgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgY29uc3QgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICBjb25zdCBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIGxldCB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuXG4gIGNvbnN0IGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIGAodHlwZW9mICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0gPT09ICdzdHJpbmcnYCArXG4gICAgICBgPyAke2Jhc2VWYWx1ZUV4cHJlc3Npb259LnRyaW0oKWAgK1xuICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgX24oJHt2YWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiBgKCR7dmFsdWV9KWAsXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIGNvbnN0IHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt2YWx1ZX09JHthc3NpZ25tZW50fWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCRzZXQoJHtyZXMuZXhwfSwgJHtyZXMua2V5fSwgJHthc3NpZ25tZW50fSlgXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICBsZXQgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIGluQnJhY2tldCsrO1xuICAgIGlmIChjaHIgPT09IDB4NUQpIGluQnJhY2tldC0tO1xuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICBjb25zdCBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmxldCB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG5jb25zdCBSQU5HRV9UT0tFTiA9ICdfX3InO1xuY29uc3QgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICBjb25zdCB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgY29uc3QgdGFnID0gZWwudGFnO1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgYEZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgd2FybiQxKFxuICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgIGB2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIGAgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBjb25zdCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICBjb25zdCBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgYEFycmF5LmlzQXJyYXkoJHt2YWx1ZX0pYCArXG4gICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IGA6KCR7dmFsdWV9KWBcbiAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYFxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgYHZhciAkJGE9JHt2YWx1ZX0sYCArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIGAkJGM9JCRlbC5jaGVja2VkPygke3RydWVWYWx1ZUJpbmRpbmd9KTooJHtmYWxzZVZhbHVlQmluZGluZ30pO2AgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgYHZhciAkJHY9JHtudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZ30sYCArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIGBpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJyl9KX1gICtcbiAgICAgIGBlbHNleyQkaT4tMSYmKCR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpfSl9YCArXG4gICAgYH1lbHNleyR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKX19YCxcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gYF9uKCR7dmFsdWVCaW5kaW5nfSlgIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIGBfcSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pYCk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHNlbGVjdGVkVmFsID0gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgICtcbiAgICBgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlgICtcbiAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgIGByZXR1cm4gJHtudW1iZXIgPyAnX24odmFsKScgOiAndmFsJ319KWA7XG5cbiAgY29uc3QgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gIGNvZGUgPSBgJHtjb2RlfSAke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KX1gO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICBjb25zdCBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIGNvbnN0IGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGAkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuXG4gIGxldCBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBgaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuOyR7Y29kZX1gO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgYCgke3ZhbHVlfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG5sZXQgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbmNvbnN0IHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICBjb25zdCBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vICM5NDYyIGJhaWwgZm9yIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgZS50aW1lU3RhbXAgPT09IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlLCBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5sZXQgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQga2V5LCBjdXI7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICBsZXQgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSBjb250aW51ZVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAvLyB0aGUgb25seSBleGNlcHRpb24gaXMgYHZhbHVlYCB3aGVyZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgLy8gVGhpcyBhbHNvIGNvdmVycyAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmIGN1ciA9PT0gb2xkUHJvcHNba2V5XSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgY29uc3Qgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxzdmc+JHtjdXJ9PC9zdmc+YDtcbiAgICAgIGNvbnN0IHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgbGV0IG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgY29uc3QgdmFsdWUgPSBlbG0udmFsdWU7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBjb25zdCBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgY29uc3Qgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmNvbnN0IGNzc1ZhclJFID0gL14tLS87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuY29uc3Qgc2V0UHJvcCA9IChlbCwgbmFtZSwgdmFsKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG5sZXQgZW1wdHlTdHlsZTtcbmNvbnN0IG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGN1ciwgbmFtZTtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgY29uc3Qgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICBjb25zdCBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgY29uc3QgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgZW50ZXJUb0NsYXNzOiBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgbGVhdmVUb0NsYXNzOiBgJHtuYW1lfS1sZWF2ZS10b2AsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogYCR7bmFtZX0tbGVhdmUtYWN0aXZlYFxuICB9XG59KTtcblxuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmxldCB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbmxldCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xubGV0IGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5jb25zdCByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuID0+IGZuKCk7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKCgpID0+IHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkgcmV0dXJuIGNiKClcbiAgY29uc3QgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4ge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGVudGVyQ2xhc3MsXG4gICAgZW50ZXJUb0NsYXNzLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVFbnRlcixcbiAgICBlbnRlcixcbiAgICBhZnRlckVudGVyLFxuICAgIGVudGVyQ2FuY2VsbGVkLFxuICAgIGJlZm9yZUFwcGVhcixcbiAgICBhcHBlYXIsXG4gICAgYWZ0ZXJBcHBlYXIsXG4gICAgYXBwZWFyQ2FuY2VsbGVkLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICBsZXQgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICBsZXQgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICBjb25zdCB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIGNvbnN0IGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIGNvbnN0IGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgY29uc3QgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICBjb25zdCBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIGNvbnN0IGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGxlYXZlQ2xhc3MsXG4gICAgbGVhdmVUb0NsYXNzLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MsXG4gICAgYmVmb3JlTGVhdmUsXG4gICAgbGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZSxcbiAgICBsZWF2ZUNhbmNlbGxlZCxcbiAgICBkZWxheUxlYXZlLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIGNvbnN0IGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5jb25zdCBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbmNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHMsIG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICBjb25zdCBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIGNvbnN0IGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKChvLCBpKSA9PiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSkpKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIGNvbnN0IG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUodiA9PiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpKVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCIke2JpbmRpbmcuZXhwcmVzc2lvbn1cIj4gYCArXG4gICAgICBgZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbiAgICAgIH1gLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShvID0+ICFsb29zZUVxdWFsKG8sIHZhbHVlKSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHJldHVyblxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQgKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGUgKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3dcbn07XG5cbi8qICAqL1xuXG5jb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIGNvbnN0IGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIGNvbnN0IGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuY29uc3QgaXNOb3RUZXh0Tm9kZSA9IChjKSA9PiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7XG5cbmNvbnN0IGlzVlNob3dEaXJlY3RpdmUgPSBkID0+IGQubmFtZSA9PT0gJ3Nob3cnO1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXIgKGgpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIGNvbnN0IGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICBjb25zdCBpZCA9IGBfX3RyYW5zaXRpb24tJHt0aGlzLl91aWR9LWA7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgY29uc3QgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIGNvbnN0IG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4geyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wcyxcblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9ICh2bm9kZSwgaHlkcmF0aW5nKSA9PiB7XG4gICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgICB0aGlzLl92bm9kZSxcbiAgICAgICAgdGhpcy5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPCR7bmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBrZXB0ID0gW107XG4gICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYy5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgY29uc3QgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsbTtcbiAgICAgICAgY29uc3QgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgY29uc3QgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICBjb25zdCBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICBjb25zdCBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgY29uc3QgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIGBZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuYCArXG4gICAgICAgIGBNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuYCArXG4gICAgICAgIGBTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbGBcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmNvbnN0IGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuY29uc3QgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbmNvbnN0IGJ1aWxkUmVnZXggPSBjYWNoZWQoZGVsaW1pdGVycyA9PiB7XG4gIGNvbnN0IG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICBjb25zdCBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICBjb25zdCB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcmF3VG9rZW5zID0gW107XG4gIGxldCBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICBsZXQgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBjb25zdCBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaChgX3MoJHtleHB9KWApO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBjbGFzcz1cIiR7c3RhdGljQ2xhc3N9XCI6IGAgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgY29uc3QgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBgc3RhdGljQ2xhc3M6JHtlbC5zdGF0aWNDbGFzc30sYDtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgY2xhc3M6JHtlbC5jbGFzc0JpbmRpbmd9LGA7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBzdHlsZT1cIiR7c3RhdGljU3R5bGV9XCI6IGAgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBgc3RhdGljU3R5bGU6JHtlbC5zdGF0aWNTdHlsZX0sYDtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgc3R5bGU6KCR7ZWwuc3R5bGVCaW5kaW5nfSksYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmxldCBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5jb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbmNvbnN0IGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5jb25zdCBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBuY25hbWUgPSBgW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHt1bmljb2RlTGV0dGVyc31dKmA7XG5jb25zdCBxbmFtZUNhcHR1cmUgPSBgKCg/OiR7bmNuYW1lfVxcXFw6KT8ke25jbmFtZX0pYDtcbmNvbnN0IHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoYF48JHtxbmFtZUNhcHR1cmV9YCk7XG5jb25zdCBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5jb25zdCBlbmRUYWcgPSBuZXcgUmVnRXhwKGBePFxcXFwvJHtxbmFtZUNhcHR1cmV9W14+XSo+YCk7XG5jb25zdCBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG5jb25zdCBjb21tZW50ID0gL148IVxcLS0vO1xuY29uc3QgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuY29uc3QgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCByZUNhY2hlID0ge307XG5cbmNvbnN0IGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbmNvbnN0IGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xuY29uc3QgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxuY29uc3QgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSAodGFnLCBodG1sKSA9PiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICBjb25zdCByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIG1hdGNoID0+IGRlY29kaW5nTWFwW21hdGNoXSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIGNvbnN0IGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIGNvbnN0IGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIGxldCB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICBjb25zdCBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgY29uc3QgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0LCByZXN0LCBuZXh0O1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSBicmVha1xuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgY29uc3Qgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgY29uc3QgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oYE1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXCIke2h0bWx9XCJgLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICBjb25zdCBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICBsZXQgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIGNvbnN0IHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgY29uc3QgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSBpbmRleDtcbiAgICBpZiAoZW5kID09IG51bGwpIGVuZCA9IGluZGV4O1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKGkgPiBwb3MgfHwgIXRhZ05hbWUgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgb25SRSA9IC9eQHxedi1vbjovO1xuY29uc3QgZGlyUkUgPSAvXnYtfF5AfF46LztcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmNvbnN0IGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxuY29uc3Qgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbmNvbnN0IGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbmNvbnN0IHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxuY29uc3QgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxuY29uc3QgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbmxldCB3YXJuJDI7XG5sZXQgZGVsaW1pdGVycztcbmxldCB0cmFuc2Zvcm1zO1xubGV0IHByZVRyYW5zZm9ybXM7XG5sZXQgcG9zdFRyYW5zZm9ybXM7XG5sZXQgcGxhdGZvcm1Jc1ByZVRhZztcbmxldCBwbGF0Zm9ybU11c3RVc2VQcm9wO1xubGV0IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xubGV0IG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gKGVsKSA9PiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgY29uc3Qgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBjdXJyZW50UGFyZW50O1xuICBsZXQgaW5WUHJlID0gZmFsc2U7XG4gIGxldCBpblByZSA9IGZhbHNlO1xuICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgYCArXG4gICAgICAgICAgYHVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLmAsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGMgPT4gIShjKS5zbG90U2NvcGUpO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihgW2ApLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIGA8JHt0YWd9PmAgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQgKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgdGV4dCBcIiR7dGV4dH1cIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIGNvbnN0IGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLmAsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIGAgK1xuICAgICAgICAgICAgYHRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuYCxcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIGNvbnN0IHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICBsZXQgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246ICR7ZXhwfWAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBjb25zdCBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDIoXG4gICAgICBgdi0ke2VsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJ30gYCArXG4gICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgYHRleHQgXCIke2NoaWxkcmVuW2ldLnRleHQudHJpbSgpfVwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgYCArXG4gICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgY29uc3Qgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIGxldCBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgYHJlcGxhY2VkIGJ5IFwic2xvdC1zY29wZVwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcInNsb3Qtc2NvcGVcIiBhdHRyaWJ1dGUgYCArXG4gICAgICAgIGBjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gYCArXG4gICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgYCh2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBgICtcbiAgICAgICAgYHNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgY29uc3Qgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICBgdGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50YCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZHluYW1pYyB9ID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIGNvbnN0IHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5gLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIGAgK1xuICAgICAgICAgICAgICBgPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGNvbnN0IHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgbGV0IG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBcXGBrZXlcXGAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBgICtcbiAgICAgICAgYGFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIGAgK1xuICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCxcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgbGV0IGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGxldCBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXCJ2LWJpbmQ6JHtuYW1lfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBgJGV2ZW50YCk7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtjYW1lbGl6ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6XCIrKCR7bmFtZX0pYCxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgY29uc3QgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICBsZXQgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2gobSA9PiB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbmNvbnN0IGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG5jb25zdCBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIGxldCBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgYFlvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBgICtcbiAgICAgICAgYFRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIGAgK1xuICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgIGBDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgY29uc3QgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGAoJHttYXBbJ3YtYmluZCddfSkudHlwZWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyBgJiYoJHtpZkNvbmRpdGlvbn0pYCA6IGBgO1xuICAgICAgY29uc3QgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgY29uc3QgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIGNvbnN0IGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IGAoJHt0eXBlQmluZGluZ30pPT09J2NoZWNrYm94J2AgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgY29uc3QgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYCgke3R5cGVCaW5kaW5nfSk9PT0ncmFkaW8nYCArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsLFxuICB0ZXh0LFxuICBodG1sXG59O1xuXG4vKiAgKi9cblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxubGV0IGlzU3RhdGljS2V5O1xubGV0IGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHJldHVyblxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG5jb25zdCBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG5jb25zdCBnZW5HdWFyZCA9IGNvbmRpdGlvbiA9PiBgaWYoJHtjb25kaXRpb259KXJldHVybiBudWxsO2A7XG5cbmNvbnN0IG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoYCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0YCksXG4gIGN0cmw6IGdlbkd1YXJkKGAhJGV2ZW50LmN0cmxLZXlgKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gIGFsdDogZ2VuR3VhcmQoYCEkZXZlbnQuYWx0S2V5YCksXG4gIG1ldGE6IGdlbkd1YXJkKGAhJGV2ZW50Lm1ldGFLZXlgKSxcbiAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gIG1pZGRsZTogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxYCksXG4gIHJpZ2h0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJgKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICBsZXQgc3RhdGljSGFuZGxlcnMgPSBgYDtcbiAgbGV0IGR5bmFtaWNIYW5kbGVycyA9IGBgO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgY29uc3QgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IGBcIiR7bmFtZX1cIjoke2hhbmRsZXJDb2RlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGBbJHtoYW5kbGVyLm1hcChoYW5kbGVyID0+IGdlbkhhbmRsZXIoaGFuZGxlcikpLmpvaW4oJywnKX1dYFxuICB9XG5cbiAgY29uc3QgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICBjb25zdCBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtcbiAgICAgIGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9YCA6IGhhbmRsZXIudmFsdWVcbiAgICB9fWAgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIGxldCBjb2RlID0gJyc7XG4gICAgbGV0IGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAubWFwKGtleU1vZGlmaWVyID0+IGAkZXZlbnQuJHtrZXlNb2RpZmllcn1LZXlgKVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX0oJGV2ZW50KWBcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KSgkZXZlbnQpYFxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske2NvZGV9JHtoYW5kbGVyQ29kZX19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBgaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZgICtcbiAgICBgJHtrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpfSlyZXR1cm4gbnVsbDtgXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIGNvbnN0IGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIGAkZXZlbnQua2V5Q29kZSE9PSR7a2V5VmFsfWBcbiAgfVxuICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgY29uc3Qga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgYF9rKCRldmVudC5rZXlDb2RlLGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleSl9LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICBgJGV2ZW50LmtleSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXlOYW1lKX1gICtcbiAgICBgKWBcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IChjb2RlKSA9PiBgX2coJHtjb2RlfSwke2Rpci52YWx1ZX0pYDtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IChjb2RlKSA9PiB7XG4gICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke1xuICAgICAgZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgfSR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJ1xuICAgIH0pYFxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxuY2xhc3MgQ29kZWdlblN0YXRlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICBjb25zdCBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIHRoaXMubWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG4gICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gICAgdGhpcy5wcmUgPSBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIGNvbnN0IGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IGB3aXRoKHRoaXMpe3JldHVybiAke2NvZGV9fWAsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIGxldCBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IGBfYygnJHtlbC50YWd9JyR7XG4gICAgICAgIGRhdGEgPyBgLCR7ZGF0YX1gIDogJycgLy8gZGF0YVxuICAgICAgfSR7XG4gICAgICAgIGNoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgfSlgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goYHdpdGgodGhpcyl7cmV0dXJuICR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfX1gKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIGBfbSgke1xuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxXG4gIH0ke1xuICAgIGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnXG4gIH0pYFxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICBsZXQga2V5ID0gJyc7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgIGB2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIGNvbnN0IGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5leHB9KT8ke1xuICAgICAgZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spXG4gICAgfToke1xuICAgICAgZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICAgIH1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2dlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKX1gXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgY29uc3QgYWxpYXMgPSBlbC5hbGlhcztcbiAgY29uc3QgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gYCwke2VsLml0ZXJhdG9yMX1gIDogJyc7XG4gIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuXG4gIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIGA8JHtlbC50YWd9IHYtZm9yPVwiJHthbGlhc30gaW4gJHtleHB9XCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBgICtcbiAgICAgIGB2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBgICtcbiAgICAgIGBTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gYCR7YWx0SGVscGVyIHx8ICdfbCd9KCgke2V4cH0pLGAgK1xuICAgIGBmdW5jdGlvbigke2FsaWFzfSR7aXRlcmF0b3IxfSR7aXRlcmF0b3IyfSl7YCArXG4gICAgICBgcmV0dXJuICR7KGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfWAgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgbGV0IGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgY29uc3QgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIGRhdGEgKz0gZGlycyArICcsJztcblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gYGtleToke2VsLmtleX0sYDtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gYHJlZjoke2VsLnJlZn0sYDtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IGByZWZJbkZvcjp0cnVlLGA7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IGBwcmU6dHJ1ZSxgO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IGBhdHRyczoke2dlblByb3BzKGVsLmF0dHJzKX0sYDtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSl9LGA7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKX0sYDtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IGBtb2RlbDp7dmFsdWU6JHtcbiAgICAgIGVsLm1vZGVsLnZhbHVlXG4gICAgfSxjYWxsYmFjazoke1xuICAgICAgZWwubW9kZWwuY2FsbGJhY2tcbiAgICB9LGV4cHJlc3Npb246JHtcbiAgICAgIGVsLm1vZGVsLmV4cHJlc3Npb25cbiAgICB9fSxgO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGAke2lubGluZVRlbXBsYXRlfSxgO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgcmV0dXJuXG4gIGxldCByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgbGV0IGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIGNvbnN0IGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IGB7bmFtZTpcIiR7ZGlyLm5hbWV9XCIscmF3TmFtZTpcIiR7ZGlyLnJhd05hbWV9XCIke1xuICAgICAgICBkaXIudmFsdWUgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5hcmcgPyBgLGFyZzoke2Rpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogYFwiJHtkaXIuYXJnfVwiYH1gIDogJydcbiAgICAgIH0ke1xuICAgICAgICBkaXIubW9kaWZpZXJzID8gYCxtb2RpZmllcnM6JHtKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKX1gIDogJydcbiAgICAgIH19LGA7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIGBpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7JHtcbiAgICAgIGlubGluZVJlbmRlckZucy5yZW5kZXJcbiAgICB9fSxzdGF0aWNSZW5kZXJGbnM6WyR7XG4gICAgICBpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IGBmdW5jdGlvbigpeyR7Y29kZX19YCkuam9pbignLCcpXG4gICAgfV19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgbGV0IG5lZWRzRm9yY2VVcGRhdGUgPSBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgIGNvbnN0IHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90ICh0aGUgcmVhY3Rpdml0eSBpcyBkaXNjb25uZWN0ZWQpXG4gIC8vICM5NDM4XG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBzY29wZWRTbG90czpfdShbJHtcbiAgICBPYmplY3Qua2V5cyhzbG90cykubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJylcbiAgfV0ke25lZWRzRm9yY2VVcGRhdGUgPyBgLHRydWVgIDogYGB9KWBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgY29uc3Qgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBgYFxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgYHJldHVybiAke2VsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfX1gO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgcmV0dXJuIGB7a2V5OiR7ZWwuc2xvdFRhcmdldCB8fCBgXCJkZWZhdWx0XCJgfSxmbjoke2ZufSR7cmV2ZXJzZVByb3h5fX1gXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbC5mb3IgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpID8gYCwxYCA6IGAsMGBcbiAgICAgICAgOiBgYDtcbiAgICAgIHJldHVybiBgJHsoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfSR7bm9ybWFsaXphdGlvblR5cGV9YFxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiBgWyR7Y2hpbGRyZW4ubWFwKGMgPT4gZ2VuKGMsIHN0YXRlKSkuam9pbignLCcpfV0ke1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPyBgLCR7bm9ybWFsaXphdGlvblR5cGV9YCA6ICcnXG4gICAgfWBcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoYyA9PiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gYF92KCR7dGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIGNvbnN0IGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgbGV0IHJlcyA9IGBfdCgke3Nsb3ROYW1lfSR7Y2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnfWA7XG4gIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChhdHRyID0+ICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KSkpXG4gICAgOiBudWxsO1xuICBjb25zdCBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBgLG51bGxgO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBgLCR7YXR0cnN9YDtcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kJCQxfWA7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEkMihlbCwgc3RhdGUpfSR7XG4gICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gIGxldCBkeW5hbWljUHJvcHMgPSBgYDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gYCR7cHJvcC5uYW1lfSwke3ZhbHVlfSxgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBgXCIke3Byb3AubmFtZX1cIjoke3ZhbHVlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IGB7JHtzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gYF9kKCR7c3RhdGljUHJvcHN9LFske2R5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCBgdi1mb3I9XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNvbnN0IHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIGNvbnN0IGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiIGluIGV4cHJlc3Npb24gJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBpbnZhbGlkICR7dHlwZX0gXCIke2lkZW50fVwiIGluIGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oYHJldHVybiAke2V4cH1gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBpbnZhbGlkIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICBgICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1cXG5gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0ID0gMCxcbiAgZW5kID0gc291cmNlLmxlbmd0aFxuKSB7XG4gIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZVxuICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGAgYCwgcGFkKSArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgbikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gICAgbiA+Pj49IDE7XG4gICAgaWYgKG4gPD0gMCkgYnJlYWtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVyciwgY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIGNvbnN0IGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke3RlbXBsYXRlfVxcblxcbmAgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChlID0+IGAtICR7ZX1gKS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2gobXNnID0+IHRpcChtc2csIHZtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYCkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdGlwcyA9IFtdO1xuXG4gICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgY29uc3QgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5sZXQgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBgPGEgaHJlZj1cIlxcblwiLz5gIDogYDxkaXYgYT1cIlxcblwiLz5gO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gIGNvbnN0IGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2FybihcbiAgICAgIGBEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoYHZ1ZSAke3RoaXMuX25hbWV9IGNvbXBpbGVgLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHNlbGVjdCBjbGFzcz0nc2VsZWN0JyB2LW1vZGVsPSdzZWxlY3RlZCcgQGlucHV0PSdldmVudCA9PiB7ICRlbWl0KFwiaW5wdXRcIiwgZXZlbnQudGFyZ2V0LnZhbHVlKSB9Jz5cbiAgICAgIDxvcHRpb24gdi1mb3I9J29wdGlvbiBpbiBvcHRpb25zJyA6a2V5PSdvcHRpb24udmFsdWUnIDp2YWx1ZT0nb3B0aW9uLnZhbHVlJz5cbiAgICAgICAge3sgb3B0aW9uLnRleHQgfX1cbiAgICAgIDwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnb3B0aW9ucycsICd2YWx1ZSddLFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZDogbnVsbCxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTZWxlY3REYXRhID0gW1xuICB7IHRleHQ6ICdBbGwgQm9yb3VnaHMnLCB2YWx1ZTogJ2FsbCcgfSxcbiAgeyB0ZXh0OiAnQnJvb2tseW4nLCB2YWx1ZTogJ2Jyb29rbHluJyB9LFxuICB7IHRleHQ6ICdRdWVlbnMnLCB2YWx1ZTogJ3F1ZWVucycgfSxcbiAgeyB0ZXh0OiAnTWFuaGF0dGFuJywgdmFsdWU6ICdtYW5oYXR0YW4nIH0sXG4gIHsgdGV4dDogJ1N0YXRlbiBJc2xhbmQnLCB2YWx1ZTogJ3N0YXRlbiBpc2xhbmQnIH0sXG4gIHsgdGV4dDogJ1RoZSBCcm9ueCcsIHZhbHVlOiAnYnJvbngnIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7IC8vXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4vc2VsZWN0LnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBTZWxlY3REYXRhIGZyb20gJy4vc2VsZWN0LmRhdGEuanMnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY2xhc3MgU2VsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLXNlbGVjdCcsIFNlbGVjdENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJhcHBcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IFNlbGVjdC5kYXRhLFxuICAgICAgICAgIHNlbGVjdGVkOiAnYWxsJyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5TZWxlY3QuZGF0YSA9IFNlbGVjdERhdGE7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDsiLCJmdW5jdGlvbiBkYXRhSGFuZGxlcihuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGlmIChvbGREYXRhKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy4kZGF0YS5fY2hhcnQ7XG4gICAgdmFyIG5ld0RhdGFzZXRMYWJlbHMgPSBuZXdEYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZERhdGFzZXRMYWJlbHMgPSBvbGREYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZExhYmVscyA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGFzZXRMYWJlbHMpO1xuICAgIHZhciBuZXdMYWJlbHMgPSBKU09OLnN0cmluZ2lmeShuZXdEYXRhc2V0TGFiZWxzKTtcblxuICAgIGlmIChuZXdMYWJlbHMgPT09IG9sZExhYmVscyAmJiBvbGREYXRhLmRhdGFzZXRzLmxlbmd0aCA9PT0gbmV3RGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIG5ld0RhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCwgaSkge1xuICAgICAgICB2YXIgb2xkRGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhLmRhdGFzZXRzW2ldKTtcbiAgICAgICAgdmFyIG5ld0RhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoZGF0YXNldCk7XG4gICAgICAgIHZhciBkZWxldGlvbktleXMgPSBvbGREYXRhc2V0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgIT09ICdfbWV0YScgJiYgbmV3RGF0YXNldEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChkZWxldGlvbktleSkge1xuICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2RlbGV0aW9uS2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGRhdGFzZXQpIHtcbiAgICAgICAgICBpZiAoZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2F0dHJpYnV0ZV0gPSBkYXRhc2V0W2F0dHJpYnV0ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ2xhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEubGFiZWxzID0gbmV3RGF0YS5sYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2xhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3hMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnhMYWJlbHMgPSBuZXdEYXRhLnhMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3hsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCd5TGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS55TGFiZWxzID0gbmV3RGF0YS55TGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCd5bGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnVwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhcnQpIHtcbiAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFydDpkZXN0cm95Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDpyZW5kZXInKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICB9XG59XG5cbmV4cG9ydCB2YXIgcmVhY3RpdmVEYXRhID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydERhdGE6IG51bGxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IHZhciByZWFjdGl2ZVByb3AgPSB7XG4gIHByb3BzOiB7XG4gICAgY2hhcnREYXRhOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hhcnREYXRhJzogZGF0YUhhbmRsZXJcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVhY3RpdmVEYXRhOiByZWFjdGl2ZURhdGEsXG4gIHJlYWN0aXZlUHJvcDogcmVhY3RpdmVQcm9wXG59OyIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohXG4gKiBDaGFydC5qcyB2Mi44LjBcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAxOSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KGdsb2JhbC5tb21lbnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5tb21lbnQgPSBtb21lbnQgJiYgbW9tZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBtb21lbnRbJ2RlZmF1bHQnXSA6IG1vbWVudDtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxudmFyIGNvbnZlcnNpb25zID0ge1xuICByZ2IyaHNsOiByZ2IyaHNsLFxuICByZ2IyaHN2OiByZ2IyaHN2LFxuICByZ2IyaHdiOiByZ2IyaHdiLFxuICByZ2IyY215azogcmdiMmNteWssXG4gIHJnYjJrZXl3b3JkOiByZ2Iya2V5d29yZCxcbiAgcmdiMnh5ejogcmdiMnh5eixcbiAgcmdiMmxhYjogcmdiMmxhYixcbiAgcmdiMmxjaDogcmdiMmxjaCxcblxuICBoc2wycmdiOiBoc2wycmdiLFxuICBoc2wyaHN2OiBoc2wyaHN2LFxuICBoc2wyaHdiOiBoc2wyaHdiLFxuICBoc2wyY215azogaHNsMmNteWssXG4gIGhzbDJrZXl3b3JkOiBoc2wya2V5d29yZCxcblxuICBoc3YycmdiOiBoc3YycmdiLFxuICBoc3YyaHNsOiBoc3YyaHNsLFxuICBoc3YyaHdiOiBoc3YyaHdiLFxuICBoc3YyY215azogaHN2MmNteWssXG4gIGhzdjJrZXl3b3JkOiBoc3Yya2V5d29yZCxcblxuICBod2IycmdiOiBod2IycmdiLFxuICBod2IyaHNsOiBod2IyaHNsLFxuICBod2IyaHN2OiBod2IyaHN2LFxuICBod2IyY215azogaHdiMmNteWssXG4gIGh3YjJrZXl3b3JkOiBod2Iya2V5d29yZCxcblxuICBjbXlrMnJnYjogY215azJyZ2IsXG4gIGNteWsyaHNsOiBjbXlrMmhzbCxcbiAgY215azJoc3Y6IGNteWsyaHN2LFxuICBjbXlrMmh3YjogY215azJod2IsXG4gIGNteWsya2V5d29yZDogY215azJrZXl3b3JkLFxuXG4gIGtleXdvcmQycmdiOiBrZXl3b3JkMnJnYixcbiAga2V5d29yZDJoc2w6IGtleXdvcmQyaHNsLFxuICBrZXl3b3JkMmhzdjoga2V5d29yZDJoc3YsXG4gIGtleXdvcmQyaHdiOiBrZXl3b3JkMmh3YixcbiAga2V5d29yZDJjbXlrOiBrZXl3b3JkMmNteWssXG4gIGtleXdvcmQybGFiOiBrZXl3b3JkMmxhYixcbiAga2V5d29yZDJ4eXo6IGtleXdvcmQyeHl6LFxuXG4gIHh5ejJyZ2I6IHh5ejJyZ2IsXG4gIHh5ejJsYWI6IHh5ejJsYWIsXG4gIHh5ejJsY2g6IHh5ejJsY2gsXG5cbiAgbGFiMnh5ejogbGFiMnh5eixcbiAgbGFiMnJnYjogbGFiMnJnYixcbiAgbGFiMmxjaDogbGFiMmxjaCxcblxuICBsY2gybGFiOiBsY2gybGFiLFxuICBsY2gyeHl6OiBsY2gyeHl6LFxuICBsY2gycmdiOiBsY2gycmdiXG59O1xuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufTtcblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9O1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG52YXIgY29sb3JTdHJpbmcgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59O1xuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszLDR9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KFthLWZBLUYwLTldezJ9KT8pJC9pLFxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIGtleXdvcmQgPSAvKFxcdyspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSxcbiAgICAgICBoZXhBbHBoYSA9IFwiXCI7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFsyXTtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiYSwgYSkge1xuICAgdmFyIGEgPSAoYSAhPT0gdW5kZWZpbmVkICYmIHJnYmEubGVuZ3RoID09PSAzKSA/IGEgOiByZ2JhWzNdO1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pIFxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzJdKVxuICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgKGEgPj0gMCAmJiBhIDwgMSlcbiAgICAgICAgICAgICAgICAgPyBoZXhEb3VibGUoTWF0aC5yb3VuZChhICogMjU1KSlcbiAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVbbmFtZV1dID0gbmFtZTtcbn1cblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gY29sb3JTdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb2xvckNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxudmFyIGNoYXJ0anNDb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG52YXIgaGVscGVycyA9IHtcblx0LyoqXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG5cdCAqL1xuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0dWlkOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaWQrKztcblx0XHR9O1xuXHR9KCkpLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzTnVsbE9yVW5kZWY6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNGaW5pdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IGhlbHBlcnMuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XG5cblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRtZXJnZSA9IG9wdGlvbnMubWVyZ2VyIHx8IGhlbHBlcnMuX21lcmdlcjtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIG9iamVjdHMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBzZXRGbiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMSwgaWxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGhlbHBlcnMuZWFjaChhcmd1bWVudHNbaV0sIHNldEZuKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogQmFzaWMgamF2YXNjcmlwdCBpbmhlcml0YW5jZSBiYXNlZCBvbiB0aGUgbW9kZWwgY3JlYXRlZCBpbiBCYWNrYm9uZS5qc1xuXHQgKi9cblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBDaGFydEVsZW1lbnQgPSAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSA/IGV4dGVuc2lvbnMuY29uc3RydWN0b3IgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gQ2hhcnRFbGVtZW50O1xuXHRcdH07XG5cblx0XHRTdXJyb2dhdGUucHJvdG90eXBlID0gbWUucHJvdG90eXBlO1xuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG5cblx0XHRpZiAoZXh0ZW5zaW9ucykge1xuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XG5cdFx0fVxuXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuaW5kZXhPZlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSwgZnJvbUluZGV4KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xudmFyIGVmZmVjdHMgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0O1xuXHR9LFxuXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLU1hdGguY29zKHQgKiAoTWF0aC5QSSAvIDIpKSArIDE7XG5cdH0sXG5cblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0fSxcblxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdH0sXG5cblx0ZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjQ1O1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRpZiAodCA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHR9LFxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuXHR9LFxuXG5cdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0fSxcblxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XG5cdFx0fVxuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzU7XG5cdH0sXG5cblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAwLjUpIHtcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0fVxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xuXHRlZmZlY3RzOiBlZmZlY3RzXG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHMgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5lYXNpbmdFZmZlY3RzID0gZWZmZWN0cztcblxudmFyIFBJID0gTWF0aC5QSTtcbnZhciBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xudmFyIERPVUJMRV9QSSA9IFBJICogMjtcbnZhciBIQUxGX1BJID0gUEkgLyAyO1xudmFyIFFVQVJURVJfUEkgPSBQSSAvIDQ7XG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xuICovXG52YXIgZXhwb3J0cyQxID0ge1xuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXG5cdCAqIGdpdmVuIHNpemUgKHdpZHRoLCBoZWlnaHQpIGFuZCB0aGUgc2FtZSBgcmFkaXVzYCBmb3IgYWxsIGNvcm5lcnMuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJvdW5kZWQgYW1vdW50IChpbiBwaXhlbHMpIGZvciB0aGUgZm91ciBjb3JuZXJzLlxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XG5cdCAqL1xuXHRyb3VuZGVkUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcblx0XHRcdHZhciBsZWZ0ID0geCArIHI7XG5cdFx0XHR2YXIgdG9wID0geSArIHI7XG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xuXHRcdFx0dmFyIGJvdHRvbSA9IHkgKyBoZWlnaHQgLSByO1xuXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XG5cdFx0XHRpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAtSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgUEkpO1xuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhsZWZ0LCB5KTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xuXHRcdFx0fSBlbHNlIGlmICh0b3AgPCBib3R0b20pIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCBQSSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKSB7XG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcblx0XHR2YXIgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShzdHlsZSwgeCAtIHN0eWxlLndpZHRoIC8gMiwgeSAtIHN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRzd2l0Y2ggKHN0eWxlKSB7XG5cdFx0Ly8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIERPVUJMRV9QSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0cmlhbmdsZSc6XG5cdFx0XHRjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxuXHRcdFx0Ly8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG5cdFx0XHQvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuXHRcdFx0Ly8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcblx0XHRcdC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcblx0XHRcdGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcblx0XHRcdGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdGlmICghcm90YXRpb24pIHtcblx0XHRcdFx0c2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ3JlY3RSb3QnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Nyb3NzUm90Jzpcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ2Nyb3NzJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJlYSAtIFRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXG5cdFx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBlcHNpbG9uICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIGVwc2lsb247XG5cdH0sXG5cblx0Y2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCwgYXJlYSkge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuXHRcdGN0eC5jbGlwKCk7XG5cdH0sXG5cblx0dW5jbGlwQXJlYTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuXHRcdHZhciBzdGVwcGVkID0gdGFyZ2V0LnN0ZXBwZWRMaW5lO1xuXHRcdGlmIChzdGVwcGVkKSB7XG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcblx0XHRcdFx0dmFyIG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyB0YXJnZXQueSA6IHByZXZpb3VzLnkpO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSBpZiAoKHN0ZXBwZWQgPT09ICdhZnRlcicgJiYgIWZsaXApIHx8IChzdGVwcGVkICE9PSAnYWZ0ZXInICYmIGZsaXApKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXQudGVuc2lvbikge1xuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWCA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRYLFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWSA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRZLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRZIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWSxcblx0XHRcdHRhcmdldC54LFxuXHRcdFx0dGFyZ2V0LnkpO1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jYW52YXMgPSBleHBvcnRzJDE7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jbGVhclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5kcmF3Um91bmRlZFJlY3RhbmdsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0ZXhwb3J0cyQxLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMkMSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0OiBmdW5jdGlvbihzY29wZSwgdmFsdWVzKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnNfY29yZS5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XG5cdH1cbn07XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZGVmYXVsdENvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRkZWZhdWx0Rm9udFNpemU6IDEyLFxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcblx0c2hvd0xpbmVzOiB0cnVlXG59KTtcblxudmFyIGNvcmVfZGVmYXVsdHMgPSBkZWZhdWx0cztcblxudmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVyc19jb3JlLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG5cdGlmICghZm9udCB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdCwgciwgYiwgbDtcblxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogdCxcblx0XHRcdHJpZ2h0OiByLFxuXHRcdFx0Ym90dG9tOiBiLFxuXHRcdFx0bGVmdDogbCxcblx0XHRcdGhlaWdodDogdCArIGIsXG5cdFx0XHR3aWR0aDogbCArIHJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gVGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAdG9kbyBTdXBwb3J0IGZvbnQuKiBvcHRpb25zIGFuZCByZW5hbWVkIHRvIHRvRm9udCgpLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BhcnNlRm9udDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udCA9IHtcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRsaW5lSGVpZ2h0OiBoZWxwZXJzX2NvcmUub3B0aW9ucy50b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0TGluZUhlaWdodCksIHNpemUpLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHR3ZWlnaHQ6IG51bGwsXG5cdFx0XHRzdHJpbmc6ICcnXG5cdFx0fTtcblxuXHRcdGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuXHRcdHJldHVybiBmb250O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcblx0ICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCkge1xuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzJDEgPSBoZWxwZXJzX2NvcmU7XG52YXIgZWFzaW5nID0gaGVscGVyc19lYXNpbmc7XG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XG52YXIgb3B0aW9ucyA9IGhlbHBlcnNfb3B0aW9ucztcbmhlbHBlcnMkMS5lYXNpbmcgPSBlYXNpbmc7XG5oZWxwZXJzJDEuY2FudmFzID0gY2FudmFzO1xuaGVscGVycyQxLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2RlbCk7XG5cdHZhciBpLCBpbGVuLCBrZXksIGFjdHVhbCwgb3JpZ2luLCB0YXJnZXQsIHR5cGUsIGMwLCBjMTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRrZXkgPSBrZXlzW2ldO1xuXG5cdFx0dGFyZ2V0ID0gbW9kZWxba2V5XTtcblxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xuXHRcdC8vIGRvZXNuJ3QgY29udGFpbiBpdCwgc28gbGV0J3MgaW5pdGlhbGl6ZSB0aGUgdmlldyB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuXHRcdGlmICghdmlldy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xuXG5cdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHN0YXJ0W2tleV0gPSBhY3R1YWw7XG5cdFx0fVxuXG5cdFx0b3JpZ2luID0gc3RhcnRba2V5XTtcblxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xuXG5cdFx0aWYgKHR5cGUgPT09IHR5cGVvZiBvcmlnaW4pIHtcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjMCA9IGNoYXJ0anNDb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdGlmIChjMS52YWxpZCkge1xuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0fVxufVxuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0fSxcblxuXHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5jbG9uZShtZS5fbW9kZWwpO1xuXHRcdH1cblx0XHRtZS5fc3RhcnQgPSB7fTtcblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xuXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcblx0XHRcdG1lLl92aWV3ID0gbW9kZWw7XG5cdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH1cblxuXHRcdGlmICghdmlldykge1xuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0c3RhcnQgPSBtZS5fc3RhcnQgPSB7fTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0fTtcblx0fSxcblxuXHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XG5cdH1cbn0pO1xuXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZWxlbWVudCA9IEVsZW1lbnQ7XG5cbnZhciBleHBvcnRzJDIgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxuXHRjdXJyZW50U3RlcDogMCwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXBcblx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cblx0cmVuZGVyOiBudWxsLCAvLyByZW5kZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgYW5pbWF0aW9uIHNlcnZpY2VcblxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzXG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9uID0gZXhwb3J0cyQyO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnYW5pbWF0aW9uT2JqZWN0Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jY2hhcnRJbnN0YW5jZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQyLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQ7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNoYXJ0ID0gdmFsdWU7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0Jyxcblx0XHRvblByb2dyZXNzOiBoZWxwZXJzJDEubm9vcCxcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzJDEubm9vcFxuXHR9XG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcblx0YW5pbWF0aW9uczogW10sXG5cdHJlcXVlc3Q6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcblx0ICovXG5cdGFkZEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0aWYgKCFsYXp5KSB7XG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuXHRcdC8vIElmIHRoZXJlIGFyZSBubyBhbmltYXRpb25zIHF1ZXVlZCwgbWFudWFsbHkga2lja3N0YXJ0IGEgZGlnZXN0LCBmb3IgbGFjayBvZiBhIGJldHRlciB3b3JkXG5cdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGluZGV4ID0gaGVscGVycyQxLmZpbmRJbmRleCh0aGlzLmFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcHJvY2Vzc2luZyBtb3VzZSBldmVudHMsIGUuZy4gJ21vdXNlbW92ZSdcblx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRtZS5zdGFydERpZ2VzdCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhcnREaWdlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRtZS5hZHZhbmNlKCk7XG5cblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cblx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uLCBjaGFydCwgbnVtU3RlcHMsIG5leHRTdGVwO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdC8vIDEgYW5pbWF0aW9uIHBlciBjaGFydCwgc28gd2UgYXJlIGxvb3BpbmcgY2hhcnRzIGhlcmVcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb25zW2ldO1xuXHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY3VycmVudFN0ZXAgc3RhcnRzIGF0IDFcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XG5cdFx0XHRuZXh0U3RlcCA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBhbmltYXRpb24uc3RhcnRUaW1lKSAvIGFuaW1hdGlvbi5kdXJhdGlvbiAqIG51bVN0ZXBzKSArIDE7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihuZXh0U3RlcCwgbnVtU3RlcHMpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdGlmIChhbmltYXRpb24uY3VycmVudFN0ZXAgPj0gbnVtU3RlcHMpIHtcblx0XHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0YW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgcmVzb2x2ZSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiB7XG5cdFx0XHRsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cblx0XHR9XG5cdH0pO1xuXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIG1ldGhvZCA9ICdvbkRhdGEnICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9iamVjdFttZXRob2RdLmFwcGx5KG9iamVjdCwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRpZiAoIXN0dWIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG5cdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRkZWxldGUgYXJyYXlba2V5XTtcblx0fSk7XG5cblx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdHRoaXMuaW5pdGlhbGl6ZShjaGFydCwgZGF0YXNldEluZGV4KTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZSkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhc2V0RWxlbWVudFR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnQpLlxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHQgKi9cblx0ZGF0YUVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdG1lLmFkZEVsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdH0sXG5cblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLmlkO1xuXHRcdH1cblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIG1lLmNoYXJ0LnNjYWxlcykpIHtcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcblx0fSxcblxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcblx0fSxcblxuXHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldFZhbHVlU2NhbGVJZCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkge1xuXHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0YWRkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YSB8fCBbXTtcblx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0fVxuXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XG5cdH0sXG5cblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVNZXRhRGF0YShpbmRleCk7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHQvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbiB0aHVzIHNpbXVsYXRlXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG5cdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRpZiAobWUuX2RhdGEgIT09IGRhdGEpIHtcblx0XHRcdGlmIChtZS5fZGF0YSkge1xuXHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKG1lLl9kYXRhLCBtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xuXHRcdFx0fVxuXHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRtZS5yZXN5bmNFbGVtZW50cygpO1xuXHR9LFxuXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0bWV0YS5kYXRhc2V0LnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdH1cblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRoZWxwZXJzJDEubWVyZ2UoZWxlbWVudC5fbW9kZWwsIGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgfHwge30pO1xuXHRcdGRlbGV0ZSBlbGVtZW50LiRwcmV2aW91c1N0eWxlO1xuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJDb2xvciwgZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJvcmRlckNvbG9yKV0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGgsIGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgbW9kZWwuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0dmFyIG51bU1ldGEgPSBtZXRhLmRhdGEubGVuZ3RoO1xuXHRcdHZhciBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG5cblx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcblx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHR0aGlzLmFkZEVsZW1lbnRBbmRSZXNldChzdGFydCArIGkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyh0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdH1cbn0pO1xuXG5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQgPSBoZWxwZXJzJDEuaW5oZXJpdHM7XG5cbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGFyYzoge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXJcdGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xuXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gdm0uZW5kQW5nbGU7XG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXG5cdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRyZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXG5cdFx0XHR5OiB2bS55ICsgKE1hdGguc2luKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSlcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgc0EgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdHZhciBlQSA9IHZtLmVuZEFuZ2xlO1xuXHRcdHZhciBwaXhlbE1hcmdpbiA9ICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcblx0XHR2YXIgYW5nbGVNYXJnaW47XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksIHNBLCBlQSk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGlmICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykge1xuXHRcdFx0XHQvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG5cdFx0XHRcdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIHZtLm91dGVyUmFkaXVzO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSAtIGFuZ2xlTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luKTtcblx0XHRcdFx0aWYgKHZtLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcblx0XHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0uaW5uZXJSYWRpdXM7XG5cdFx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luLCBzQSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHBpeGVsTWFyZ2luLCBlQSArIE1hdGguUEkgLyAyLCBzQSAtIE1hdGguUEkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5jbGlwKCk7XG5cblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSwgZUEpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoICogMjtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwLjQsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAzLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRcdGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcblx0XHRcdGNhcEJlemllclBvaW50czogdHJ1ZSxcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2xpbmUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHR2YXIgc3BhbkdhcHMgPSB2bS5zcGFuR2Fwcztcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XG5cdFx0dmFyIGluZGV4LCBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFZNO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRpZiAobWUuX2xvb3AgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmUgT3B0aW9uc1xuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdH1cblxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdGN0eC5saW5lSm9pbiA9IHZtLmJvcmRlckpvaW5TdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVySm9pblN0eWxlO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGgpO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblxuXHRcdC8vIFN0cm9rZSBMaW5lXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGxhc3REcmF3bkluZGV4ID0gLTE7XG5cblx0XHRmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG5cdFx0XHRjdXJyZW50ID0gcG9pbnRzW2luZGV4XTtcblx0XHRcdHByZXZpb3VzID0gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdGN1cnJlbnRWTSA9IGN1cnJlbnQuX3ZpZXc7XG5cblx0XHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRpZiAoKGxhc3REcmF3bkluZGV4ICE9PSAoaW5kZXggLSAxKSAmJiAhc3BhbkdhcHMpIHx8IGxhc3REcmF3bkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQyID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yJDEgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHBvaW50OiB7XG5cdFx0XHRyYWRpdXM6IDMsXG5cdFx0XHRwb2ludFN0eWxlOiAnY2lyY2xlJyxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdC8vIEhvdmVyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXG5cdFx0XHRob3ZlclJhZGl1czogNCxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiB4UmFuZ2UobW91c2VYKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VZIC0gdm0ueSkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbnZhciBlbGVtZW50X3BvaW50ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0gPyAoKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikpIDwgTWF0aC5wb3codm0uaGl0UmFkaXVzICsgdm0ucmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0aW5YUmFuZ2U6IHhSYW5nZSxcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRwYWRkaW5nOiB2bS5yYWRpdXMgKyB2bS5ib3JkZXJXaWR0aFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcblx0XHR2YXIgcmFkaXVzID0gdm0ucmFkaXVzO1xuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblxuXHRcdGlmICh2bS5za2lwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpcHBpbmcgZm9yIFBvaW50cy5cblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDIodm0uYm9yZGVyV2lkdGgsIGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBwb2ludFN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbG9yJDIgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKHZtKSB7XG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XG5cdHZhciB4MSwgeDIsIHkxLCB5MiwgaGFsZjtcblxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRoYWxmID0gdm0ud2lkdGggLyAyO1xuXHRcdHgxID0gdm0ueCAtIGhhbGY7XG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcblx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFsZiA9IHZtLmhlaWdodCAvIDI7XG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xuXHRcdHkxID0gdm0ueSAtIGhhbGY7XG5cdFx0eTIgPSB2bS55ICsgaGFsZjtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogeDEsXG5cdFx0dG9wOiB5MSxcblx0XHRyaWdodDogeDIsXG5cdFx0Ym90dG9tOiB5MlxuXHR9O1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuXHRyZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclNraXBwZWQodm0pIHtcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xuXHR2YXIgcmVzID0ge307XG5cblx0aWYgKCFlZGdlKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGlmICh2bS5ob3Jpem9udGFsKSB7XG5cdFx0aWYgKHZtLmJhc2UgPiB2bS54KSB7XG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh2bS5iYXNlIDwgdm0ueSkge1xuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XG5cdH1cblxuXHRyZXNbZWRnZV0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKHZtLCBtYXhXLCBtYXhIKSB7XG5cdHZhciB2YWx1ZSA9IHZtLmJvcmRlcldpZHRoO1xuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XG5cdHZhciB0LCByLCBiLCBsO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0fSBlbHNlIHtcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHQ6IHNraXAudG9wIHx8ICh0IDwgMCkgPyAwIDogdCA+IG1heEggPyBtYXhIIDogdCxcblx0XHRyOiBza2lwLnJpZ2h0IHx8IChyIDwgMCkgPyAwIDogciA+IG1heFcgPyBtYXhXIDogcixcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXG5cdFx0bDogc2tpcC5sZWZ0IHx8IChsIDwgMCkgPyAwIDogbCA+IG1heFcgPyBtYXhXIDogbFxuXHR9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKHZtKSB7XG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xuXHR2YXIgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcblx0dmFyIGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuXHRyZXR1cm4ge1xuXHRcdG91dGVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCxcblx0XHRcdHk6IGJvdW5kcy50b3AsXG5cdFx0XHR3OiB3aWR0aCxcblx0XHRcdGg6IGhlaWdodFxuXHRcdH0sXG5cdFx0aW5uZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG5cdFx0XHR5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG5cdFx0XHRoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iXG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XG5cdHZhciBza2lwWCA9IHggPT09IG51bGw7XG5cdHZhciBza2lwWSA9IHkgPT09IG51bGw7XG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcblxuXHRyZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXG5cdFx0JiYgKHNraXBZIHx8IHkgPj0gYm91bmRzLnRvcCAmJiB5IDw9IGJvdW5kcy5ib3R0b20pO1xufVxuXG52YXIgZWxlbWVudF9yZWN0YW5nbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xuXHRcdHZhciBvdXRlciA9IHJlY3RzLm91dGVyO1xuXHRcdHZhciBpbm5lciA9IHJlY3RzLmlubmVyO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguZmlsbFJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cblx0XHRpZiAob3V0ZXIudyA9PT0gaW5uZXIudyAmJiBvdXRlci5oID09PSBpbm5lci5oKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LnJlY3QoaW5uZXIueCwgaW5uZXIueSwgaW5uZXIudywgaW5uZXIuaCk7XG5cdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcblx0XHRcdDogaW5SYW5nZSh2bSwgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRpblhSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBudWxsKTtcblx0fSxcblxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgeCwgeTtcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRcdHggPSB2bS54O1xuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gKHZtLnggKyB2bS5iYXNlKSAvIDI7XG5cdFx0XHR5ID0gdm0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcblx0XHRcdDogdm0uaGVpZ2h0ICogTWF0aC5hYnModm0ueCAtIHZtLmJhc2UpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIGVsZW1lbnRzID0ge307XG52YXIgQXJjID0gZWxlbWVudF9hcmM7XG52YXIgTGluZSA9IGVsZW1lbnRfbGluZTtcbnZhciBQb2ludCA9IGVsZW1lbnRfcG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2JhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0fV1cblx0fVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XG5cdHZhciBtaW4gPSBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xuXHR2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuXHR2YXIgcHJldiwgY3VyciwgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMocGl4ZWxzW2ldIC0gcGl4ZWxzW2kgLSAxXSkpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG5cdFx0bWluID0gaSA+IDAgPyBNYXRoLm1pbihtaW4sIGN1cnIgLSBwcmV2KSA6IG1pbjtcblx0XHRwcmV2ID0gY3Vycjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XG5cdHZhciBjdXJyID0gcnVsZXIucGl4ZWxzW2luZGV4XTtcblx0dmFyIHNpemUsIHJhdGlvO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG5cdFx0c2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcblx0XHQvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcblx0XHRyYXRpbyA9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gY291bnQsXG5cdFx0cmF0aW86IHJhdGlvLFxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxuXHR9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuXHR2YXIgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHR2YXIgc3RhcnQsIHNpemU7XG5cblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHQvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG5cdH1cblxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG5cdH1cblxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXG5cdFx0cmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcblx0XHRzdGFydDogc3RhcnRcblx0fTtcbn1cblxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGE7XG5cblx0XHRjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuXHRcdG1ldGEuYmFyID0gdHJ1ZTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHJlY3RzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XG5cblx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXG5cdFx0fTtcblxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpO1xuXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCk7XG5cdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyKTtcblxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xuXHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBpbGVuID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggOiBsYXN0ICsgMTtcblx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0dmFyIGksIG1ldGE7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRpZiAobWV0YS5iYXIgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJlxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gZmFsc2UgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIChtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSkpKSB7XG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzdGFja3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIG5hbWUpIHtcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCk7XG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcblx0XHRcdD8gc3RhY2tzLmluZGV4T2YobmFtZSlcblx0XHRcdDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cblx0XHRyZXR1cm4gKGluZGV4ID09PSAtMSlcblx0XHRcdD8gc3RhY2tzLmxlbmd0aCAtIDFcblx0XHRcdDogaW5kZXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHN0YXJ0ID0gaXNIb3Jpem9udGFsID8gc2NhbGUubGVmdCA6IHNjYWxlLnRvcDtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaXNIb3Jpem9udGFsID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQpO1xuXHRcdHZhciBwaXhlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbWluO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBkYXRhc2V0SW5kZXgpKTtcblx0XHR9XG5cblx0XHRtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzY2FsZS5vcHRpb25zLmJhclRoaWNrbmVzcylcblx0XHRcdD8gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscylcblx0XHRcdDogLTE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiBtaW4sXG5cdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGVuZDogZW5kLFxuXHRcdFx0c3RhY2tDb3VudDogc3RhY2tDb3VudCxcblx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJWYWx1ZVBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgdmFsdWUgPSArc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgbWluQmFyTGVuZ3RoID0gc2NhbGUub3B0aW9ucy5taW5CYXJMZW5ndGg7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIHN0YWNrID0gbWV0YS5zdGFjaztcblx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdHZhciBpLCBpbWV0YSwgaXZhbHVlLCBiYXNlLCBoZWFkLCBzaXplO1xuXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRcdGltZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cblx0XHRcdFx0aWYgKGltZXRhLmJhciAmJlxuXHRcdFx0XHRcdGltZXRhLnN0YWNrID09PSBzdGFjayAmJlxuXHRcdFx0XHRcdGltZXRhLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBzY2FsZS5pZCAmJlxuXHRcdFx0XHRcdGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblxuXHRcdFx0XHRcdGl2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2ldLmRhdGFbaW5kZXhdKTtcblx0XHRcdFx0XHRpZiAoKHZhbHVlIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUgPj0gMCAmJiBpdmFsdWUgPiAwKSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XG5cblx0XHRpZiAobWluQmFyTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XG5cdFx0XHRpZiAodmFsdWUgPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IHZhbHVlIDwgMCAmJiBpc0hvcml6b250YWwpIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWFkID0gYmFzZSArIG1pbkJhckxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGJhc2U6IGJhc2UsXG5cdFx0XHRoZWFkOiBoZWFkLFxuXHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHJ1bGVyLnNjYWxlLm9wdGlvbnM7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcblx0XHRcdDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucyk7XG5cblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xuXHRcdHZhciBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcblx0XHRcdGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpLFxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG5cdFx0XHRoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0c2l6ZTogc2l6ZVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBpbGVuID0gcmVjdHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmICghaXNOYU4oc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0LmRhdGFbaV0pKSkge1xuXHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5yZWN0YW5nbGU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJTa2lwcGVkJyxcblx0XHRcdCdib3JkZXJXaWR0aCdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDEoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQyID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YXNldExhYmVsID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdHZhciBkYXRhUG9pbnQgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5kYXRhW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpbmRleCwgcmVzZXQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcblx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdH07XG5cblx0XHRwb2ludC5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdFx0J2hpdFJhZGl1cycsXG5cdFx0XHQncG9pbnRTdHlsZScsXG5cdFx0XHQncm90YXRpb24nXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQyKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG5cdFx0dmFsdWVzLnJhZGl1cyA9IHJlc29sdmUkMihbXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxuXHRcdFx0ZGF0YSA/IGRhdGEuciA6IHVuZGVmaW5lZCxcblx0XHRcdGRhdGFzZXQucmFkaXVzLFxuXHRcdFx0b3B0aW9ucy5yYWRpdXNcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdkb3VnaG51dCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0fSxcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjICYmIGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDMoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDMoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0aWYgKG1ldGEuZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHQvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuXHRyb3RhdGlvbjogTWF0aC5QSSAqIC0wLjUsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBNYXRoLlBJICogMi4wLFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFMYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9kb3VnaG51dCA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nSW5kZXggPSAwO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHQrK3JpbmdJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ0luZGV4O1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdHZhciBhdmFpbGFibGVIZWlnaHQgPSBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcDtcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuXHRcdHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH07XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGN1dG91dFBlcmNlbnRhZ2UgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2U7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgbWluU2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgTWF0aC5QSSAqIDIuMCkge1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyLjApO1xuXHRcdFx0c3RhcnRBbmdsZSArPSBNYXRoLlBJICogMi4wICogKHN0YXJ0QW5nbGUgPj0gTWF0aC5QSSA/IC0xIDogc3RhcnRBbmdsZSA8IC1NYXRoLlBJID8gMSA6IDApO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG5cdFx0XHR2YXIgc3RhcnQgPSB7eDogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpfTtcblx0XHRcdHZhciBlbmQgPSB7eDogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBNYXRoLnNpbihlbmRBbmdsZSl9O1xuXHRcdFx0dmFyIGNvbnRhaW5zMCA9IChzdGFydEFuZ2xlIDw9IDAgJiYgZW5kQW5nbGUgPj0gMCkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuMCAmJiBNYXRoLlBJICogMi4wIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDAuNSAmJiBNYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi41ICYmIE1hdGguUEkgKiAyLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgJiYgLU1hdGguUEkgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgJiYgTWF0aC5QSSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAqIDAuNSAmJiAtTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDEuNSAmJiBNYXRoLlBJICogMS41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjdXRvdXQgPSBjdXRvdXRQZXJjZW50YWdlIC8gMTAwLjA7XG5cdFx0XHR2YXIgbWluID0ge3g6IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydC54ICogKHN0YXJ0LnggPCAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54IDwgMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnkgKiAoc3RhcnQueSA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPCAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBtYXggPSB7eDogY29udGFpbnMwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnggKiAoc3RhcnQueCA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPiAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnkgKiAoc3RhcnQueSA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPiAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBzaXplID0ge3dpZHRoOiAobWF4LnggLSBtaW4ueCkgKiAwLjUsIGhlaWdodDogKG1heC55IC0gbWluLnkpICogMC41fTtcblx0XHRcdG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHNpemUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0XHRcdG9mZnNldCA9IHt4OiAobWF4LnggKyBtaW4ueCkgKiAtMC41LCB5OiAobWF4LnkgKyBtaW4ueSkgKiAtMC41fTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdH1cblxuXHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKTtcblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChjdXRvdXRQZXJjZW50YWdlKSA6IDAsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIChtZS5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHx8IDEpO1xuXHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXQueCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXQueSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXG5cdFx0bWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gTWF0aC5tYXgobWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gMCA6IGFyYy5oaWRkZW4gPyAwIDogbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKSAqIChvcHRzLmNpcmN1bWZlcmVuY2UgLyAoMi4wICogTWF0aC5QSSkpO1xuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuXHRcdHZhciBvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcblx0XHRcdFx0eTogY2VudGVyWSArIGNoYXJ0Lm9mZnNldFksXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcblx0XHRcdFx0Y2lyY3VtZmVyZW5jZTogY2lyY3VtZmVyZW5jZSxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQubGFiZWwsIGluZGV4LCBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXG5cdFx0Ly8gU2V0IGNvcnJlY3QgYW5nbGVzIGlmIG5vdCByZXNldHRpbmdcblx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcblx0XHR9XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0dmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIGlmICh0b3RhbCA9PT0gMCkge1xuXHRcdFx0dG90YWwgPSBOYU47XG5cdFx0fSovXG5cblx0XHRyZXR1cm4gdG90YWw7XG5cdH0sXG5cblx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcblx0XHRpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAoTWF0aC5QSSAqIDIuMCkgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXggPSAwO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhLCBhcmMsIGNvbnRyb2xsZXIsIG9wdGlvbnMsIGJvcmRlcldpZHRoLCBob3ZlcldpZHRoO1xuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmMgPSBhcmNzW2ldO1xuXHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjLCBpKSA6IGFyYy5fb3B0aW9ucztcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0aG92ZXJXaWR0aCA9IG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aDtcblxuXHRcdFx0XHRtYXggPSBib3JkZXJXaWR0aCA+IG1heCA/IGJvcmRlcldpZHRoIDogbWF4O1xuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1heDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJBbGlnbicsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMyhbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQkNCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YVNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XVxuXHR9LFxuXG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnbGVmdCdcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ1ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgaXNQb2ludEluQXJlYSA9IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWE7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucykge1xuXHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XG59XG5cbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNob3dMaW5lID0gbGluZUVuYWJsZWQoZGF0YXNldCwgbWUuY2hhcnQub3B0aW9ucyk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBVcGRhdGUgTGluZVxuXHRcdGlmIChzaG93TGluZSkge1xuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0Ly8gRGF0YVxuXHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0XHQvLyBNb2RlbFxuXHRcdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCwgeTtcblxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblxuXHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ1KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXHRcdFx0c3RlcHBlZExpbmU6IGxpbmVNb2RlbCA/IGxpbmVNb2RlbC5zdGVwcGVkTGluZSA6IGZhbHNlLFxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gb3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnLFxuXHRcdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0ZWxlbWVudE9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xuXHRcdC8vIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDM1I2lzc3VlY29tbWVudC0yMTY3MTgxNThcblx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LmxpbmVUZW5zaW9uLCBlbGVtZW50T3B0aW9ucy50ZW5zaW9uKTtcblx0XHR2YWx1ZXMuc3RlcHBlZExpbmUgPSByZXNvbHZlJDQoW2N1c3RvbS5zdGVwcGVkTGluZSwgZGF0YXNldC5zdGVwcGVkTGluZSwgZWxlbWVudE9wdGlvbnMuc3RlcHBlZF0pO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBzdW1Qb3MgPSAwO1xuXHRcdHZhciBzdW1OZWcgPSAwO1xuXHRcdHZhciBpLCBkcywgZHNNZXRhO1xuXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7IGkrKykge1xuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV07XG5cdFx0XHRcdGRzTWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHR2YXIgc3RhY2tlZFJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pKTtcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciByaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0aWYgKGxpbmVNb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGhhbGZCb3JkZXJXaWR0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobGluZUVuYWJsZWQobWUuZ2V0RGF0YXNldCgpLCBjaGFydC5vcHRpb25zKSkge1xuXHRcdFx0aGFsZkJvcmRlcldpZHRoID0gKG1ldGEuZGF0YXNldC5fbW9kZWwuYm9yZGVyV2lkdGggfHwgMCkgLyAyO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xuXHRcdFx0XHRsZWZ0OiBhcmVhLmxlZnQsXG5cdFx0XHRcdHJpZ2h0OiBhcmVhLnJpZ2h0LFxuXHRcdFx0XHR0b3A6IGFyZWEudG9wIC0gaGFsZkJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3R0b206IGFyZWEuYm90dG9tICsgaGFsZkJvcmRlcldpZHRoXG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblxuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB0aGUgcG9pbnRzXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9LFxufSk7XG5cbnZhciByZXNvbHZlJDUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BvbGFyQXJlYScsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRhbmdsZUxpbmVzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdH0sXG5cdFx0cG9pbnRMYWJlbHM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHR0aWNrczoge1xuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XG5cdGFuaW1hdGlvbjoge1xuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXG5cdH0sXG5cblx0c3RhcnRBbmdsZTogLTAuNSAqIE1hdGguUEksXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gcmVzb2x2ZSQ1KFtjdXN0b20uYmFja2dyb3VuZENvbG9yLCBkcy5iYWNrZ3JvdW5kQ29sb3IsIGFyY09wdHMuYmFja2dyb3VuZENvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJDb2xvciwgZHMuYm9yZGVyQ29sb3IsIGFyY09wdHMuYm9yZGVyQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gcmVzb2x2ZSQ1KFtjdXN0b20uYm9yZGVyV2lkdGgsIGRzLmJvcmRlcldpZHRoLCBhcmNPcHRzLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1tpdGVtLmluZGV4XSArICc6ICcgKyBpdGVtLnlMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9wb2xhckFyZWEgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IG1lLl9zdGFydHMgPSBbXTtcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuLCBhbmdsZTtcblxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcblxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXQuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xuXHRcdFx0YW5nbGVzW2ldID0gYW5nbGU7XG5cdFx0XHRzdGFydCArPSBhbmdsZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VwZGF0ZVJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGg7XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBzY2FsZSA9IGNoYXJ0LnNjYWxlO1xuXHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcblxuXHRcdHZhciBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcblx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG5cblx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XG5cdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBtZS5fc3RhcnRzW2luZGV4XTtcblx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogbWUuX2FuZ2xlc1tpbmRleF0pO1xuXG5cdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYLFxuXHRcdFx0XHR5OiBjZW50ZXJZLFxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IHJlc2V0ID8gcmVzZXRSYWRpdXMgOiBkaXN0YW5jZSxcblx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ1KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21wdXRlQW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY291bnQgPSB0aGlzLmdldE1ldGEoKS5jb3VudDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblxuXHRcdGlmIChpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogbWUuY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc29sdmUkNShbXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcblx0XHRcdCgyICogTWF0aC5QSSkgLyBjb3VudFxuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywgaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZG91Z2hudXQpKTtcbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywge1xuXHRjdXRvdXRQZXJjZW50YWdlOiAwXG59KTtcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbnZhciBjb250cm9sbGVyX3BpZSA9IGNvbnRyb2xsZXJfZG91Z2hudXQ7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcblx0fSxcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwIC8vIG5vIGJlemllciBpbiByYWRhclxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0fVxuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0Ly8gRGF0YVxuXHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xuXHRcdC8vIE1vZGVsXG5cdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0bGluZS5waXZvdCgpO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcblx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWUuZ2V0TWV0YSgpLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsIC8vIHZhbHVlIG5vdCB1c2VkIGluIGRhdGFzZXQgc2NhbGUsIGJ1dCB3ZSB3YW50IGEgY29uc2lzdGVudCBBUEkgYmV0d2VlbiBzY2FsZXNcblx0XHRcdHk6IHksXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNihjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcblxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJDYXBTdHlsZScsXG5cdFx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHRcdCdmaWxsJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ2KGRhdGFzZXQubGluZVRlbnNpb24sIG9wdGlvbnMudGVuc2lvbik7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdCk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJlemllciBnb2luZyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0c2hvd0xpbmVzOiBmYWxzZSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7ICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2UgZGF0YSBhcmUgZm9ybWF0dGVkIGFzIGEgcG9pbnRcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gJygnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcbnZhciBjb250cm9sbGVyX3NjYXR0ZXIgPSBjb250cm9sbGVyX2xpbmU7XG5cbi8vIE5PVEUgZXhwb3J0IGEgbWFwIGluIHdoaWNoIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgY29udHJvbGxlciB0eXBlLCBub3Rcbi8vIHRoZSBjbGFzcywgYW5kIHNvIG11c3QgYmUgQ2FtZWxDYXNlIGluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSByZXRyaWV2ZWRcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cblxudmFyIGNvbnRyb2xsZXJzID0ge1xuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxuXHRidWJibGU6IGNvbnRyb2xsZXJfYnViYmxlLFxuXHRkb3VnaG51dDogY29udHJvbGxlcl9kb3VnaG51dCxcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxuXHRsaW5lOiBjb250cm9sbGVyX2xpbmUsXG5cdHBvbGFyQXJlYTogY29udHJvbGxlcl9wb2xhckFyZWEsXG5cdHBpZTogY29udHJvbGxlcl9waWUsXG5cdHJhZGFyOiBjb250cm9sbGVyX3JhZGFyLFxuXHRzY2F0dGVyOiBjb250cm9sbGVyX3NjYXR0ZXJcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgYW4gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBldmVudCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG5cdGlmIChlLm5hdGl2ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBlLngsXG5cdFx0XHR5OiBlLnlcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcblx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmICghY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0RWxlbWVudFtdfSBpdGVtcyAtIGVsZW1lbnRzIHRvIGZpbHRlclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VNZXRyaWMgLSBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpIHtcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcblx0dmFyIHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0dmFyIGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG5cdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtpdGVtc1swXS5faW5kZXhdO1xuXG5cdFx0XHQvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBJSW50ZXJhY3Rpb25PcHRpb25zXG4gKi9cbi8qKlxuICogSWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9pbnRcbiAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbnZhciBjb3JlX2ludGVyYWN0aW9uID0ge1xuXHQvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuXHRtb2Rlczoge1xuXHRcdHNpbmdsZTogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmxhYmVsXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGxhYmVsOiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRpbmRleDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLngtYXhpc1xuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAuIFVzZSBpbmRleCBtb2RlIGFuZCBpbnRlcnNlY3QgPT0gdHJ1ZVxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0cmV0dXJuIGluZGV4TW9kZShjaGFydCwgZSwge2ludGVyc2VjdDogZmFsc2V9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5YUmFuZ2UocG9zaXRpb24ueCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR5OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pbllSYW5nZShwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcblx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG5cdFx0di5fdG1wSW5kZXhfID0gaTtcblx0XHRyZXR1cm4gdjtcblx0fSk7XG5cdGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cblx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcblx0fSk7XG5cdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdGRlbGV0ZSB2Ll90bXBJbmRleF87XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kTWF4UGFkZGluZyhib3hlcykge1xuXHR2YXIgdG9wID0gMDtcblx0dmFyIGxlZnQgPSAwO1xuXHR2YXIgYm90dG9tID0gMDtcblx0dmFyIHJpZ2h0ID0gMDtcblx0aGVscGVycyQxLmVhY2goYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdGlmIChib3guZ2V0UGFkZGluZykge1xuXHRcdFx0dmFyIGJveFBhZGRpbmcgPSBib3guZ2V0UGFkZGluZygpO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRsZWZ0ID0gTWF0aC5tYXgobGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcblx0XHRcdGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuXHRcdFx0cmlnaHQgPSBNYXRoLm1heChyaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHtcblx0XHR0b3A6IHRvcCxcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdGJvdHRvbTogYm90dG9tLFxuXHRcdHJpZ2h0OiByaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTaXplQnlQb3NpdGlvbihib3hlcywgc2l6ZSkge1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0c2l6ZVtib3gucG9zaXRpb25dICs9IGJveC5pc0hvcml6b250YWwoKSA/IGJveC5oZWlnaHQgOiBib3gud2lkdGg7XG5cdH0pO1xufVxuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbnZhciBjb3JlX2xheW91dHMgPSB7XG5cdGRlZmF1bHRzOiB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdCAqL1xuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG5cdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0Y2hhcnQuYm94ZXMucHVzaChpdGVtKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xuXHRcdHZhciBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG5cdGNvbmZpZ3VyZTogZnVuY3Rpb24oY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHByb3A7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0aXRlbVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoIWNoYXJ0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcblx0XHR2YXIgcGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhsYXlvdXRPcHRpb25zLnBhZGRpbmcpO1xuXHRcdHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmcubGVmdDtcblx0XHR2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZy5yaWdodDtcblx0XHR2YXIgdG9wUGFkZGluZyA9IHBhZGRpbmcudG9wO1xuXHRcdHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZy5ib3R0b207XG5cblx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHR2YXIgcmlnaHRCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdyaWdodCcpO1xuXHRcdHZhciB0b3BCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICd0b3AnKTtcblx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0dmFyIGNoYXJ0QXJlYUJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2NoYXJ0QXJlYScpO1xuXG5cdFx0Ly8gU29ydCBib3hlcyBieSB3ZWlnaHQuIEEgaGlnaGVyIHdlaWdodCBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChyaWdodEJveGVzLCBmYWxzZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHRvcEJveGVzLCB0cnVlKTtcblx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdHZhciB2ZXJ0aWNhbEJveGVzID0gbGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKTtcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gdG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKTtcblx0XHR2YXIgb3V0ZXJCb3hlcyA9IHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyk7XG5cblx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0Ly8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcblx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHQvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcblx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cblx0XHQvL1xuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vXG5cdFx0Ly8gV2hhdCB3ZSBkbyB0byBmaW5kIHRoZSBiZXN0IHNpemluZywgd2UgZG8gdGhlIGZvbGxvd2luZ1xuXHRcdC8vIDEuIERldGVybWluZSB0aGUgbWluaW11bSBzaXplIG9mIHRoZSBjaGFydCBhcmVhLlxuXHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdC8vIDMuIFNwbGl0IHRoZSByZW1haW5pbmcgaGVpZ2h0IGVxdWFsbHkgYmV0d2VlbiBlYWNoIGhvcml6b250YWwgYXhpc1xuXHRcdC8vIDQuIEdpdmUgZWFjaCBsYXlvdXQgdGhlIG1heGltdW0gc2l6ZSBpdCBjYW4gYmUuIFRoZSBsYXlvdXQgd2lsbCByZXR1cm4gaXQncyBtaW5pbXVtIHNpemVcblx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHQvLyA2LiBSZWZpdCBlYWNoIGF4aXNcblx0XHQvLyA3LiBQb3NpdGlvbiBlYWNoIGF4aXMgaW4gdGhlIGZpbmFsIGxvY2F0aW9uXG5cdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0Ly8gOS4gVGVsbCBhbnkgYXhlcyB0aGF0IG92ZXJsYXkgdGhlIGNoYXJ0IGFyZWEgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY2hhcnQgYXJlYVxuXG5cdFx0Ly8gU3RlcCAxXG5cdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdHZhciBjaGFydEhlaWdodCA9IGhlaWdodCAtIHRvcFBhZGRpbmcgLSBib3R0b21QYWRkaW5nO1xuXHRcdHZhciBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGggLyAyOyAvLyBtaW4gNTAlXG5cblx0XHQvLyBTdGVwIDJcblx0XHR2YXIgdmVydGljYWxCb3hXaWR0aCA9ICh3aWR0aCAtIGNoYXJ0QXJlYVdpZHRoKSAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCAzXG5cdFx0Ly8gVE9ETyByZS1saW1pdCBob3Jpem9udGFsIGF4aXMgaGVpZ2h0ICh0aGlzIGxpbWl0IGhhcyBhZmZlY3RlZCBvbmx5IHBhZGRpbmcgY2FsY3VsYXRpb24gc2luY2UgUFIgMTgzNylcblx0XHQvLyB2YXIgaG9yaXpvbnRhbEJveEhlaWdodCA9IChoZWlnaHQgLSBjaGFydEFyZWFIZWlnaHQpIC8gaG9yaXpvbnRhbEJveGVzLmxlbmd0aDtcblxuXHRcdC8vIFN0ZXAgNFxuXHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0dmFyIG1heENoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0O1xuXHRcdHZhciBvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0dmFyIG1pbkJveFNpemVzID0gW107XG5cdFx0dmFyIG1heFBhZGRpbmc7XG5cblx0XHRmdW5jdGlvbiBnZXRNaW5pbXVtQm94U2l6ZShib3gpIHtcblx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IGJveC5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZSh2ZXJ0aWNhbEJveFdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRtaW5Cb3hTaXplcy5wdXNoKHtcblx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHR3aWR0aDogbWluU2l6ZS53aWR0aCxcblx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChvdXRlckJveGVzLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHQvLyBJZiBhIGhvcml6b250YWwgYm94IGhhcyBwYWRkaW5nLCB3ZSBtb3ZlIHRoZSBsZWZ0IGJveGVzIG92ZXIgdG8gYXZvaWQgdWdseSBjaGFydHMgKHNlZSBpc3N1ZSAjMjQ3OClcblx0XHRtYXhQYWRkaW5nID0gZmluZE1heFBhZGRpbmcob3V0ZXJCb3hlcyk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdC8vIGJlIGlmIHRoZSBheGVzIGFyZSBkcmF3biBhdCB0aGVpciBtaW5pbXVtIHNpemVzLlxuXHRcdC8vIFN0ZXBzIDUgJiA2XG5cblx0XHQvLyBGdW5jdGlvbiB0byBmaXQgYSBib3hcblx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0cmV0dXJuIG1pbkJveC5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRpZiAobWluQm94U2l6ZS5ob3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5sZWZ0LCBtYXhQYWRkaW5nLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KG91dGVyQm94U2l6ZXMucmlnaHQsIG1heFBhZGRpbmcucmlnaHQpLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0Ym90dG9tOiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHQvLyBvbiB0aGUgbWFyZ2luLiBTb21ldGltZXMgdGhleSBuZWVkIHRvIGluY3JlYXNlIGluIHNpemUgc2xpZ2h0bHlcblx0XHRcdFx0XHRib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMiwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC51cGRhdGUobWluQm94U2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKHZlcnRpY2FsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZml0Qm94KTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbihob3Jpem9udGFsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0cmV0dXJuIG1pblNpemUuYm94ID09PSBib3g7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiBvdXRlckJveFNpemVzLnRvcCxcblx0XHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLmJvdHRvbVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQsIHNjYWxlTWFyZ2luKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMZXQgdGhlIGxlZnQgbGF5b3V0IGtub3cgdGhlIGZpbmFsIG1hcmdpblxuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpbmFsRml0VmVydGljYWxCb3gpO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgc2l6ZSBvZiBlYWNoIGxheW91dCBtaWdodCBoYXZlIGNoYW5nZWQgc2xpZ2h0bHkgZHVlIHRvIHRoZSBtYXJnaW5zIChsYWJlbCByb3RhdGlvbiBmb3IgaW5zdGFuY2UpXG5cdFx0b3V0ZXJCb3hTaXplcyA9IHt0b3A6IHRvcFBhZGRpbmcsIGxlZnQ6IGxlZnRQYWRkaW5nLCBib3R0b206IGJvdHRvbVBhZGRpbmcsIHJpZ2h0OiByaWdodFBhZGRpbmd9O1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKG91dGVyQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0dmFyIGxlZnRQYWRkaW5nQWRkaXRpb24gPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQgLSBvdXRlckJveFNpemVzLmxlZnQsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMubGVmdCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMucmlnaHQgKz0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCAtIG91dGVyQm94U2l6ZXMucmlnaHQsIDApO1xuXG5cdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wIC0gb3V0ZXJCb3hTaXplcy50b3AsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMudG9wICs9IHRvcFBhZGRpbmdBZGRpdGlvbjtcblx0XHRvdXRlckJveFNpemVzLmJvdHRvbSArPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSAtIG91dGVyQm94U2l6ZXMuYm90dG9tLCAwKTtcblxuXHRcdC8vIEZpZ3VyZSBvdXQgaWYgb3VyIGNoYXJ0IGFyZWEgY2hhbmdlZC4gVGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgZGF0YXNldCBsYXlvdXQgbGFiZWwgcm90YXRpb25cblx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHQvLyB3aXRob3V0IGNhbGxpbmcgYGZpdGAgYWdhaW5cblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ID0gaGVpZ2h0IC0gb3V0ZXJCb3hTaXplcy50b3AgLSBvdXRlckJveFNpemVzLmJvdHRvbTtcblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhV2lkdGggPSB3aWR0aCAtIG91dGVyQm94U2l6ZXMubGVmdCAtIG91dGVyQm94U2l6ZXMucmlnaHQ7XG5cblx0XHRpZiAobmV3TWF4Q2hhcnRBcmVhV2lkdGggIT09IG1heENoYXJ0QXJlYVdpZHRoIHx8IG5ld01heENoYXJ0QXJlYUhlaWdodCAhPT0gbWF4Q2hhcnRBcmVhSGVpZ2h0KSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChob3Jpem9udGFsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdG1heENoYXJ0QXJlYVdpZHRoID0gbmV3TWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0fVxuXG5cdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0dmFyIGxlZnQgPSBsZWZ0UGFkZGluZyArIGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0dmFyIHRvcCA9IHRvcFBhZGRpbmcgKyB0b3BQYWRkaW5nQWRkaXRpb247XG5cblx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gbGVmdFBhZGRpbmcgOiBvdXRlckJveFNpemVzLmxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyB3aWR0aCAtIHJpZ2h0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRib3gudG9wID0gdG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0dG9wID0gYm94LmJvdHRvbTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3gubGVmdCA9IGxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGxlZnQgKyBib3gud2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSBvdXRlckJveFNpemVzLnRvcDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRsZWZ0ID0gYm94LnJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKGxlZnRCb3hlcy5jb25jYXQodG9wQm94ZXMpLCBwbGFjZUJveCk7XG5cblx0XHQvLyBBY2NvdW50IGZvciBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHR0b3AgKz0gbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0aGVscGVycyQxLmVhY2gocmlnaHRCb3hlcywgcGxhY2VCb3gpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvdHRvbUJveGVzLCBwbGFjZUJveCk7XG5cblx0XHQvLyBTdGVwIDhcblx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRsZWZ0OiBvdXRlckJveFNpemVzLmxlZnQsXG5cdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0cmlnaHQ6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoLFxuXHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLnRvcCArIG1heENoYXJ0QXJlYUhlaWdodFxuXHRcdH07XG5cblx0XHQvLyBTdGVwIDlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3gubGVmdCA9IGNoYXJ0LmNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0LmNoYXJ0QXJlYS50b3A7XG5cdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRib3guYm90dG9tID0gY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTtcblxuXHRcdFx0Ym94LnVwZGF0ZShtYXhDaGFydEFyZWFXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcblx0fVxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxuICovXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxufVxcblxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxufVxcblxcbi8qXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXG4gKi9cXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxuXFx0cmlnaHQ6IDA7XFxuXFx0Ym90dG9tOiAwO1xcblxcdG92ZXJmbG93OiBoaWRkZW47XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcblxcdHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAyMDAlO1xcblxcdGhlaWdodDogMjAwJTtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbmRlZmF1bHQ6IHBsYXRmb3JtX2RvbVxufSk7XG5cbmZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcblx0cmV0dXJuIG4gJiYgbi5kZWZhdWx0IHx8IG47XG59XG5cbnZhciBzdHlsZXNoZWV0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShwbGF0Zm9ybV9kb20kMSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3JlbmRlci1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge1xuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcblx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcblx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuXHRwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN1cHBvcnRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuXHR9XG5cdHJldHVybiBzdXBwb3J0cztcbn0oKSk7XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xuXHRyZXR1cm4gZWw7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXG5cdC8vIE5PVEUoU0IpIERvbid0IHVzZSBpbm5lckhUTUwgYmVjYXVzZSBpdCBjb3VsZCBiZSBjb25zaWRlcmVkIHVuc2FmZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XG5cdHZhciBleHBhbmQgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctZXhwYW5kJyk7XG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XG5cblx0ZXhwYW5kLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblxuXHRyZXNpemVyLmFwcGVuZENoaWxkKGV4cGFuZCk7XG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRMaXN0ZW5lcihzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKHNocmluaywgJ3NocmluaycpKTtcblxuXHRyZXR1cm4gcmVzaXplcjtcbn1cblxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5mdW5jdGlvbiB3YXRjaEZvclJlbmRlcihub2RlLCBoYW5kbGVyKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IENTU19SRU5ERVJfQU5JTUFUSU9OKSB7XG5cdFx0XHRoYW5kbGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdH0pO1xuXG5cdC8vICM0NzM3OiBDaHJvbWUgbWlnaHQgc2tpcCB0aGUgQ1NTIGFuaW1hdGlvbiB3aGVuIHRoZSBDU1NfUkVOREVSX01PTklUT1IgY2xhc3Ncblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYSNib3gtbWV0cmljc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcblx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuXHRcdFx0XHQvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG5cdFx0XHRcdC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcblx0XHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbmplY3RDU1MocGxhdGZvcm0sIGNzcykge1xuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxuXHR2YXIgc3R5bGUgPSBwbGF0Zm9ybS5fc3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0aWYgKCFwbGF0Zm9ybS5fc3R5bGUpIHtcblx0XHRwbGF0Zm9ybS5fc3R5bGUgPSBzdHlsZTtcblx0XHRjc3MgPSAnLyogQ2hhcnQuanMgKi9cXG4nICsgY3NzO1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG59XG5cbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcblx0LyoqXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xuXHQgKiBzd2l0Y2ggaGFzIGJlZW4gYWRkZWQgdG8gYWxsb3cgZXh0ZXJuYWwgc3R5bGVzaGVldCAoYGRpc3QvQ2hhcnQoLm1pbik/LmpzYClcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHQgKi9cblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Vuc3VyZUxvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XG5cdFx0XHRpbmplY3RDU1ModGhpcywgc3R5bGVzaGVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG5cdFx0fSBlbHNlIGlmIChpdGVtLmxlbmd0aCkge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcblx0XHR9XG5cblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIHBvc3NpYmxlIHRvIGNoYW5nZVxuXHRcdC8vIHBsYXRmb3JtIG9wdGlvbnMgYWZ0ZXIgaW1wb3J0aW5nIHRoZSBsaWJyYXJ5IChlLmcuIGBkaXNhYmxlQ1NTSW5qZWN0aW9uYCkuXG5cdFx0dGhpcy5fZW5zdXJlTG9hZGVkKCk7XG5cblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG5cdFx0Ly8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3Ncblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xuXHRcdFx0aW5pdENhbnZhcyhpdGVtLCBjb25maWcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdGNhbnZhcy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcblx0XHQvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG5cdFx0ZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwgKGxpc3RlbmVyW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCAoZXhwYW5kby5wcm94aWVzID0ge30pO1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCB7fTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XG5cdFx0aWYgKCFwcm94eSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9XG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5hZGRFdmVudCA9IGFkZExpc3RlbmVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5yZW1vdmVFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHBsYXRmb3JtX2RvbSQyLl9lbmFibGVkID8gcGxhdGZvcm1fZG9tJDIgOiBwbGF0Zm9ybV9iYXNpYztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXG4gKiBAc2luY2UgMi40LjBcbiAqL1xudmFyIHBsYXRmb3JtID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdCAqL1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG5cbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHt9XG59KTtcblxuLyoqXG4gKiBUaGUgcGx1Z2luIHNlcnZpY2Ugc2luZ2xldG9uXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcbiAqIEBzaW5jZSAyLjEuMFxuICovXG52YXIgY29yZV9wbHVnaW5zID0ge1xuXHQvKipcblx0ICogR2xvYmFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BsdWdpbnM6IFtdLFxuXG5cdC8qKlxuXHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xuXHQgKiBpbmNyZW1lbnRlZCBhbmQgZGVzY3JpcHRvcnMgYXJlIHJlZ2VuZXJhdGVkIGR1cmluZyBmb2xsb3dpbmcgQVBJIGNhbGxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NhY2hlSWQ6IDAsXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0cC5wdXNoKHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgb25seSBpZiByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVnaXN0ZXJlZCBwbHVnaW5zP1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuXHRub3RpZnk6IGZ1bmN0aW9uKGNoYXJ0LCBob29rLCBhcmdzKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0dmFyIGksIGRlc2NyaXB0b3IsIHBsdWdpbiwgcGFyYW1zLCBtZXRob2Q7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG5cdFx0XHRwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBjYWNoZSA9IGNoYXJ0LiRwbHVnaW5zIHx8IChjaGFydC4kcGx1Z2lucyA9IHt9KTtcblx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcblx0XHR9XG5cblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuXHRcdHZhciBjb25maWcgPSAoY2hhcnQgJiYgY2hhcnQuY29uZmlnKSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcblxuXHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xuXHRcdFx0aWYgKG9wdHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0ZGVzY3JpcHRvcnMucHVzaCh7XG5cdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNhY2hlLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XG5cdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcblx0fSxcblxuXHQvKipcblx0ICogSW52YWxpZGF0ZXMgY2FjaGUgZm9yIHRoZSBnaXZlbiBjaGFydDogZGVzY3JpcHRvcnMgaG9sZCBhIHJlZmVyZW5jZSBvbiBwbHVnaW4gb3B0aW9uLFxuXHQgKiBidXQgaW4gc29tZSBjYXNlcywgdGhpcyByZWZlcmVuY2UgY2FuIGJlIGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiB1cGRhdGluZyBvcHRpb25zLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRkZWxldGUgY2hhcnQuJHBsdWdpbnM7XG5cdH1cbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcblx0Ly8gU2NhbGUgcmVnaXN0cmF0aW9uIG9iamVjdC4gRXh0ZW5zaW9ucyBjYW4gcmVnaXN0ZXIgbmV3IHNjYWxlIHR5cGVzIChzdWNoIGFzIGxvZyBvciBEQiBzY2FsZXMpIGFuZCB0aGVuXG5cdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxuXHQvLyBVc2UgYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gbW92ZSB0byBhbiBFUzYgbWFwIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gc3VwcG9ydFxuXHQvLyBvbGQgYnJvd3NlcnNcblxuXHQvLyBTY2FsZSBjb25maWcgZGVmYXVsdHNcblx0ZGVmYXVsdHM6IHt9LFxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xuXHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xuXHR9LFxuXHRnZXRTY2FsZUNvbnN0cnVjdG9yOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XG5cdH0sXG5cdGdldFNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKHt9LCBbY29yZV9kZWZhdWx0cy5zY2FsZSwgdGhpcy5kZWZhdWx0c1t0eXBlXV0pIDoge307XG5cdH0sXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0fVxuXHR9LFxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHQvLyBBZGRzIGVhY2ggc2NhbGUgdG8gdGhlIGNoYXJ0LmJveGVzIGFycmF5IHRvIGJlIHNpemVkIGFjY29yZGluZ2x5XG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgc2NhbGUpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRvb2x0aXBzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycyQxLm5vb3AsXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cdFx0XHRcdFx0aWYgKGl0ZW0ubGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS5sYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ueExhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRvb2x0aXBJdGVtLnZhbHVlKSkge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxDb2xvcjogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGFjdGl2ZUVsZW1lbnQgPSBtZXRhLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmlldyA9IGFjdGl2ZUVsZW1lbnQuX3ZpZXc7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IHZpZXcuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiB2aWV3LmJhY2tncm91bmRDb2xvclxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsVGV4dENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcblx0XHRcdH0sXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0YWZ0ZXJGb290ZXI6IGhlbHBlcnMkMS5ub29wXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIHBvc2l0aW9uZXJzID0ge1xuXHQvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0RWxlbWVudFtdfSB0aGUgZWxlbWVudHMgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaSwgbGVuO1xuXHRcdHZhciB4ID0gMDtcblx0XHR2YXIgeSA9IDA7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0eSArPSBwb3MueTtcblx0XHRcdFx0Kytjb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCAvIGNvdW50LFxuXHRcdFx0eTogeSAvIGNvdW50XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSBldmVudFBvc2l0aW9uIHtvYmplY3R9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0b29sdGlwIHBvc2l0aW9uXG5cdCAqL1xuXHRuZWFyZXN0OiBmdW5jdGlvbihlbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuXHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0XHR2YXIgZCA9IGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdFx0XHRpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmVhcmVzdEVsZW1lbnQpIHtcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0eCA9IHRwLng7XG5cdFx0XHR5ID0gdHAueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG5cdGlmICh0b1B1c2gpIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xuXHRcdFx0Ly8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiYXNlLnB1c2godG9QdXNoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XG5cdHZhciB4U2NhbGUgPSBlbGVtZW50Ll94U2NhbGU7XG5cdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHR2YXIgZGF0YXNldEluZGV4ID0gZWxlbWVudC5fZGF0YXNldEluZGV4O1xuXHR2YXIgY29udHJvbGxlciA9IGVsZW1lbnQuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XG5cdHZhciB2YWx1ZVNjYWxlID0gY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZSgpO1xuXG5cdHJldHVybiB7XG5cdFx0eExhYmVsOiB4U2NhbGUgPyB4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdHlMYWJlbDogeVNjYWxlID8geVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0dmFsdWU6IHZhbHVlU2NhbGUgPyAnJyArIHZhbHVlU2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGluZGV4OiBpbmRleCxcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHR4OiBlbGVtZW50Ll9tb2RlbC54LFxuXHRcdHk6IGVsZW1lbnQuX21vZGVsLnlcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB0b29sdGlwT3B0cyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxuXHRcdHlQYWRkaW5nOiB0b29sdGlwT3B0cy55UGFkZGluZyxcblx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcblxuXHRcdC8vIEJvZHlcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRib2R5Rm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcblxuXHRcdC8vIFRpdGxlXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X3RpdGxlRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXG5cdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdGZvb3RlclNwYWNpbmc6IHRvb2x0aXBPcHRzLmZvb3RlclNwYWNpbmcsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0b3BhY2l0eTogMCxcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHR2YXIgaGVpZ2h0ID0gbW9kZWwueVBhZGRpbmcgKiAyOyAvLyBUb29sdGlwIFBhZGRpbmdcblx0dmFyIHdpZHRoID0gMDtcblxuXHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0fSwgMCk7XG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcblx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0Ly8gVGl0bGUgd2lkdGhcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0fTtcblxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdH0pO1xuXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdC8vIEZvb3RlciB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBBZGQgcGFkZGluZ1xuXHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0cmV0dXJuIHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdHlBbGlnbiA9ICd0b3AnO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdH1cblxuXHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0fTtcblx0fVxuXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcblx0fTtcblx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XG5cdH07XG5cdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHR9O1xuXG5cdGlmIChsZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRyZXR1cm4ge1xuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHR2YXIgeCA9IHZtLng7XG5cdHZhciB5ID0gdm0ueTtcblxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggLT0gc2l6ZS53aWR0aDtcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XG5cdFx0XHR4ID0gY2hhcnQud2lkdGggLSBzaXplLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoeCA8IDApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR4OiB4LFxuXHRcdHk6IHlcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodm0sIGFsaWduKSB7XG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcblx0XHQ6IGFsaWduID09PSAncmlnaHQnXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG5cdHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxudmFyIGV4cG9ydHMkMyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9sYXN0QWN0aXZlID0gW107XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSB0aXRsZVxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0bGluZXM6IFtdLFxuXHRcdFx0XHRhZnRlcjogW11cblx0XHRcdH07XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBib2R5SXRlbXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHQvLyB3aGljaCBicmVha3MgYW55IGFuaW1hdGlvbnMuXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdHZhciBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcblx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0fTtcblx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcblx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0fTtcblxuXHRcdHZhciBpLCBsZW47XG5cblx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XG5cblx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwueSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0bW9kZWwubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXG5cdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxuXHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50LCBtZS5fY2hhcnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHR9XG5cblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblxuXHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcblxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XG5cblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcblx0fSxcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0fSxcblxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cblx0XHRpZiAodGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl90aXRsZUFsaWduO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHR2YXIgdGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XG5cdFx0XHR2YXIgdGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0udGl0bGVGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIHZtLl90aXRsZUZvbnRTdHlsZSwgdm0uX3RpdGxlRm9udEZhbWlseSk7XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aXRsZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGl0bGVbaV0sIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0aWYgKGkgKyAxID09PSB0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBib2R5Rm9udFNpemUgPSB2bS5ib2R5Rm9udFNpemU7XG5cdFx0dmFyIGJvZHlTcGFjaW5nID0gdm0uYm9keVNwYWNpbmc7XG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XG5cdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XG5cdFx0dmFyIGxhYmVsQ29sb3JzID0gdm0ubGFiZWxDb2xvcnM7XG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0dmFyIGNvbG9yWCA9IGRyYXdDb2xvckJveGVzID8gZ2V0QWxpZ25lZFgodm0sICdsZWZ0JykgOiAwO1xuXHRcdHZhciB0ZXh0Q29sb3I7XG5cblx0XHRjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XG5cblx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIGJvZHlBbGlnbik7XG5cblx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdHB0LnkgKz0gYm9keUZvbnRTaXplICsgYm9keVNwYWNpbmc7XG5cdFx0fTtcblxuXHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvZHlGb250Q29sb3I7XG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgJiYgYm9keUFsaWduICE9PSAncmlnaHQnXG5cdFx0XHQ/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm9keUZvbnRTaXplIC8gMiArIDEpIDogKGJvZHlGb250U2l6ZSArIDIpXG5cdFx0XHQ6IDA7XG5cblx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0Ly8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdm0ubGVnZW5kQ29sb3JCYWNrZ3JvdW5kO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclgsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIEJvcmRlclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gSW5uZXIgc3F1YXJlXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29sb3JYICsgMSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG5cdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcblx0fSxcblxuXHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRpZiAoZm9vdGVyLmxlbmd0aCkge1xuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xuXHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpIHtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHggPSBwdC54O1xuXHRcdHZhciB5ID0gcHQueTtcblx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHZtLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHB0ID0ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXG5cdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHQvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcblx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKTtcblxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxuXHRcdFx0cHQueSArPSB2bS55UGFkZGluZztcblxuXHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEJvZHlcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBGb290ZXJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuX2FjdGl2ZSwgbWUuX2xhc3RBY3RpdmUpO1xuXG5cdFx0Ly8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG5cdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBlLngsXG5cdFx0XHRcdFx0eTogZS55XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG59KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAqL1xudmFyIHBvc2l0aW9uZXJzXzEgPSBwb3NpdGlvbmVycztcblxudmFyIGNvcmVfdG9vbHRpcCA9IGV4cG9ydHMkMztcbmNvcmVfdG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzXzE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHt9LFxuXHRldmVudHM6IFtcblx0XHQnbW91c2Vtb3ZlJyxcblx0XHQnbW91c2VvdXQnLFxuXHRcdCdjbGljaycsXG5cdFx0J3RvdWNoc3RhcnQnLFxuXHRcdCd0b3VjaG1vdmUnXG5cdF0sXG5cdGhvdmVyOiB7XG5cdFx0b25Ib3ZlcjogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA0MDBcblx0fSxcblx0b25DbGljazogbnVsbCxcblx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0cmVzcG9uc2l2ZTogdHJ1ZSxcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXG59KTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVzYCBvcHRpb25cbiAqIGJ5IGluY29ycG9yYXRpbmcgc2NhbGUgZGVmYXVsdHMgaW4gYHhBeGVzYCBhbmQgYHlBeGVzYCBhcnJheSBpdGVtcywgdGhlblxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XG5cdFx0XHRcdHZhciBzbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuXHRcdFx0XHR2YXIgaSwgdHlwZSwgc2NhbGU7XG5cblx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcblx0XHRcdFx0XHR0eXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZS50eXBlLCBrZXkgPT09ICd4QXhlcycgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcicpO1xuXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XS5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldW2ldLnR5cGUgfHwgKHNjYWxlLnR5cGUgJiYgc2NhbGUudHlwZSAhPT0gdGFyZ2V0W2tleV1baV0udHlwZSkpIHtcblx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHR5cGUpLCBzY2FsZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgc2NhbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xuICogZGVmYXVsdCBzY2FsZSBvcHRpb25zIGZvciB0aGUgYHNjYWxlc2AgYW5kIGBzY2FsZWAgcHJvcGVydGllcywgdGhlbiByZXR1cm5zXG4gKiBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcblx0XHRcdFx0Ly8gc2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlU2NhbGVDb25maWcodHZhbCwgc3ZhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuXHRcdFx0XHQvLyB1c2VkIGluIHBvbGFyIGFyZWEgJiByYWRhciBjaGFydHMgc2luY2UgdGhlcmUgaXMgb25seSBvbmUgc2NhbGVcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzJDEubWVyZ2UodHZhbCwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIERvIE5PVCB1c2UgbWVyZ2VDb25maWcgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxuXHR2YXIgZGF0YSA9IGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdGNvbmZpZy5vcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjb25maWcudHlwZV0sXG5cdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xuXG5cdHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhjaGFydCkge1xuXHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cblx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHNjYWxlKTtcblx0fSk7XG5cblx0bmV3T3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY2hhcnQuY29uZmlnLnR5cGVdLFxuXHRcdG5ld09wdGlvbnMpO1xuXG5cdGNoYXJ0Lm9wdGlvbnMgPSBjaGFydC5jb25maWcub3B0aW9ucyA9IG5ld09wdGlvbnM7XG5cdGNoYXJ0LmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXG5cdC8vIFRvb2x0aXBcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XG5cdGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbn1cblxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdG1lLmlkID0gaGVscGVycyQxLnVpZCgpO1xuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcblx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdCAqIEBwcm9wIENoYXJ0I2NoYXJ0XG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0bWUuY29udHJvbGxlciA9IG1lOyAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cblxuXHRcdC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XG5cblx0XHQvLyBEZWZpbmUgYWxpYXMgdG8gdGhlIGNvbmZpZyBkYXRhOiBgY2hhcnQuZGF0YSA9PT0gY2hhcnQuY29uZmlnLmRhdGFgXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtZS5jb25maWcuZGF0YTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdG1lLmNvbmZpZy5kYXRhID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG5cdFx0XHQvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuXHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5pbml0aWFsaXplKCk7XG5cdFx0bWUudXBkYXRlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVJbml0Jyk7XG5cblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRtZS5iaW5kRXZlbnRzKCk7XG5cblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0bWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRcdG1lLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblx0XHRtZS5pbml0VG9vbFRpcCgpO1xuXG5cdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFN0b3BzIGFueSBjdXJyZW50IGFuaW1hdGlvbiBsb29wIG9jY3VycmluZ1xuXHRcdGNvcmVfYW5pbWF0aW9ucy5jYW5jZWxBbmltYXRpb24odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBhc3BlY3RSYXRpbyA9IChvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbWUuYXNwZWN0UmF0aW8pIHx8IG51bGw7XG5cblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XG5cdFx0Ly8gdGhlIGNhbnZhcyBkaXNwbGF5IHN0eWxlIHVzZXMgdGhlIHNhbWUgaW50ZWdlciB2YWx1ZXMgdG8gYXZvaWQgYmx1cnJpbmcgZWZmZWN0LlxuXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXG5cdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoKGNhbnZhcykpKTtcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XG5cblx0XHRpZiAobWUud2lkdGggPT09IG5ld1dpZHRoICYmIG1lLmhlaWdodCA9PT0gbmV3SGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdGlmICghc2lsZW50KSB7XG5cdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcblxuXHRcdFx0Ly8gTm90aWZ5IG9mIHJlc2l6ZVxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0b3B0aW9ucy5vblJlc2l6ZShtZSwgbmV3U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdG1lLnVwZGF0ZSh7XG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnhBeGVzLCBmdW5jdGlvbih4QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHR4QXhpc09wdGlvbnMuaWQgPSB4QXhpc09wdGlvbnMuaWQgfHwgKCd4LWF4aXMtJyArIGluZGV4KTtcblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IHlBeGlzT3B0aW9ucy5pZCB8fCAoJ3ktYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHR2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgaWQpIHtcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSwge30pO1xuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGVzKSB7XG5cdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB4QXhpc09wdGlvbnMsIGR0eXBlOiAnY2F0ZWdvcnknLCBkcG9zaXRpb246ICdib3R0b20nfTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeUF4aXNPcHRpb25zLCBkdHlwZTogJ2xpbmVhcicsIGRwb3NpdGlvbjogJ2xlZnQnfTtcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLnNjYWxlLFxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdGlzRGVmYXVsdDogdHJ1ZSxcblx0XHRcdFx0ZHBvc2l0aW9uOiAnY2hhcnRBcmVhJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG5cdFx0XHR2YXIgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cblx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcblx0XHRcdHZhciBzY2FsZSA9IG51bGw7XG5cdFx0XHRpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcblx0XHRcdFx0c2NhbGUub3B0aW9ucyA9IHNjYWxlT3B0aW9ucztcblx0XHRcdFx0c2NhbGUuY3R4ID0gbWUuY3R4O1xuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlQ2xhc3MgPSBjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdFx0dHlwZTogc2NhbGVUeXBlLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcblx0XHRcdFx0XHRjdHg6IG1lLmN0eCxcblx0XHRcdFx0XHRjaGFydDogbWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcblx0XHRcdH1cblxuXHRcdFx0c2NhbGUubWVyZ2VUaWNrc09wdGlvbnMoKTtcblxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHQvLyBhbmQgY29uc2lkZXIgaXQgYXMgYSByZWd1bGFyIHNjYWxlIHBhcnQgb2YgdGhlIFwic2NhbGVzXCJcIiBtYXAgb25seSEgVGhpcyB3b3VsZFxuXHRcdFx0Ly8gbWFrZSB0aGUgbG9naWMgZWFzaWVyIGFuZCByZW1vdmUgc29tZSB1c2VsZXNzPyBjdXN0b20gY29kZS5cblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRtZS5zY2FsZSA9IHNjYWxlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh1cGRhdGVkLCBmdW5jdGlvbihoYXNVcGRhdGVkLCBpZCkge1xuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBzY2FsZXNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bWUuc2NhbGVzID0gc2NhbGVzO1xuXG5cdFx0Y29yZV9zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcblxuXHRcdFx0aWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblxuXHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBDb250cm9sbGVyQ2xhc3MgPSBjb250cm9sbGVyc1ttZXRhLnR5cGVdO1xuXHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuXHRcdFx0fVxuXHRcdH0sIG1lKTtcblxuXHRcdHJldHVybiBuZXdDb250cm9sbGVycztcblx0fSxcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuXHRcdH0sIG1lKTtcblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXQncyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlc2V0RWxlbWVudHMoKTtcblx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dXBkYXRlQ29uZmlnKG1lKTtcblxuXHRcdC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdG1lLnRvb2x0aXAuX2RhdGEgPSBtZS5kYXRhO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcblx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLnVwZGF0ZUxheW91dCgpO1xuXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0aWYgKG1lLm9wdGlvbnMuYW5pbWF0aW9uICYmIG1lLm9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxuXHRcdC8vIGFmdGVyIHVwZGF0ZS5cblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcblxuXHRcdC8vIExhc3QgYWN0aXZlIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluIHRoZSB0b29sdGlwLlxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XG5cblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXG5cdFx0XHRcdGxhenk6IGNvbmZpZy5sYXp5XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5yZW5kZXIoY29uZmlnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGF5b3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb3JlX2xheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxuXHRcdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclNjYWxlVXBkYXRlXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1ldGEuY29udHJvbGxlci51cGRhdGUoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ4KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyUmVuZGVyJyk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XG5cdFx0fTtcblxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcblx0XHRcdFx0bnVtU3RlcHM6IGR1cmF0aW9uIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHR2YXIgc3RlcERlY2ltYWwgPSBjdXJyZW50U3RlcCAvIGFuaW1hdGlvbk9iamVjdC5udW1TdGVwcztcblxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcblx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvcmVfYW5pbWF0aW9ucy5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmNsZWFyKCk7XG5cblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoZWFzaW5nVmFsdWUpKSB7XG5cdFx0XHRlYXNpbmdWYWx1ZSA9IDE7XG5cdFx0fVxuXG5cdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRpZiAobWUud2lkdGggPD0gMCB8fCBtZS5oZWlnaHQgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgYWxsIHRoZSBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cdFx0bWUuX2RyYXdUb29sdGlwKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRmb3IgKHZhciBpID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5kcmF3RGF0YXNldChpLCBlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmF3RGF0YXNldDogZnVuY3Rpb24oaW5kZXgsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLmRyYXcoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyB0b29sdGlwIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVUb29sdGlwRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyVG9vbHRpcERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RyYXdUb29sdGlwOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVRvb2x0aXBEcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b29sdGlwLmRyYXcoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclRvb2x0aXBEcmF3JywgW2FyZ3NdKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XG5cdCAqL1xuXHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdFhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XG5cdFx0XHRkYXRhc2V0Ll9tZXRhID0ge307XG5cdFx0fVxuXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXTtcblx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXG5cdFx0XHRcdGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcblx0XHRcdFx0eUF4aXNJRDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YTtcblx0fSxcblxuXHRnZXRWaXNpYmxlRGF0YXNldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0aXNEYXRhc2V0VmlzaWJsZTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuXHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICF0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5oaWRkZW47XG5cdH0sXG5cblx0Z2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGEgJiYgZGF0YXNldC5fbWV0YVtpZF07XG5cblx0XHRpZiAobWV0YSkge1xuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuc3RvcCgpO1xuXG5cdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoaSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhbnZhcykge1xuXHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcblx0XHRcdHBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KG1lLmN0eCk7XG5cdFx0XHRtZS5jYW52YXMgPSBudWxsO1xuXHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xuXG5cdFx0ZGVsZXRlIENoYXJ0Lmluc3RhbmNlc1ttZS5pZF07XG5cdH0sXG5cblx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS50b29sdGlwID0gbmV3IGNvcmVfdG9vbHRpcCh7XG5cdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0X2NoYXJ0SW5zdGFuY2U6IG1lLCAvLyBkZXByZWNhdGVkLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRfZGF0YTogbWUuZGF0YSxcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xuXHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0fSk7XG5cblx0XHQvLyBFbGVtZW50cyB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZSBzaG91bGQgbm90IGJlIGluamVjdGVkIGZvciBub24gcmVzcG9uc2l2ZSBjaGFydHMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0bGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcblx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50cywgbW9kZSwgZW5hYmxlZCkge1xuXHRcdHZhciBtZXRob2QgPSBlbmFibGVkID8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbbWV0aG9kXShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBhbnkgdXBkYXRlIGNhbGxzIHNvIHRoYXQgcmVuZGVycyBkbyBub3Qgb2NjdXJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxuXHRcdC8vIHRoZSB0b29sdGlwIHNob3VsZCBiZSB0aGUgc291cmNlIG9mIGNoYW5nZVxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcblx0XHRcdFx0OiBjaGFuZ2VkIHwgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcblx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcblx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRtZS5yZW5kZXIoe1xuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0bGF6eTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0dmFyIGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIEludm9rZSBvbkhvdmVyIGhvb2tcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdH1cblxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxuICogd291bGQgbmVlZCB0byB3b3JrIG9uIG11bHRpcGxlIGNoYXJ0cz8hXG4gKi9cbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuY29uZmlnTWVyZ2UgPSBtZXJnZUNvbmZpZztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5zY2FsZU1lcmdlID0gbWVyZ2VTY2FsZUNvbmZpZztcblxudmFyIGNvcmVfaGVscGVycyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xuXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgYXJyYXlUb1NlYXJjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycyQxLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgoKHJvdW5kZWQgLSBlcHNpbG9uKSA8IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID4geCkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLmxvZzEwID0gTWF0aC5sb2cxMCA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTsgLy8gTWF0aC5MT0cxMEUgPSAxIC8gTWF0aC5MTjEwLlxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHdob2xlIHBvd2VycyBvZiAxMCxcblx0XHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxuXHRcdFx0dmFyIHBvd2VyT2YxMCA9IE1hdGgucm91bmQoZXhwb25lbnQpO1xuXHRcdFx0dmFyIGlzUG93ZXJPZjEwID0geCA9PT0gTWF0aC5wb3coMTAsIHBvd2VyT2YxMCk7XG5cblx0XHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xuXHRcdH07XG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdH07XG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQSBudW1iZXIuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGUgPSAxO1xuXHRcdHZhciBwID0gMDtcblx0XHR3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG5cdFx0XHRlICo9IDEwO1xuXHRcdFx0cCsrO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fTtcblxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuXHRoZWxwZXJzJDEuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG5cdFx0dmFyIHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbmdsZTogYW5nbGUsXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hbGlhc1BpeGVsXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XG5cdFx0cmV0dXJuIChwaXhlbFdpZHRoICUgMiA9PT0gMCkgPyAwIDogMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcblx0XHR2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuXHRcdHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcblx0fTtcblxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuXHRcdC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcblx0XHR2YXIgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuXG5cdFx0dmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50LnggLSBwcmV2aW91cy54LCAyKSArIE1hdGgucG93KGN1cnJlbnQueSAtIHByZXZpb3VzLnksIDIpKTtcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcblxuXHRcdHZhciBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cblx0XHQvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcblx0XHR2YXIgZmIgPSB0ICogczEyO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZXZpb3VzOiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHtcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLkVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRBZnRlci5tSyA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG5cdFx0XHRwb2ludEN1cnJlbnQubUsgPSBhbHBoYUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcblx0XHR2YXIgZGVsdGFYO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRDdXJyZW50Lm1vZGVsLnggLSBwb2ludEJlZm9yZS5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggKyBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcblx0XHRpZiAobG9vcCkge1xuXHRcdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdH07XG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzJDEubmljZU51bSA9IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHJhbmdlKSk7XG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHRcdHZhciBuaWNlRnJhY3Rpb247XG5cblx0XHRpZiAocm91bmQpIHtcblx0XHRcdGlmIChmcmFjdGlvbiA8IDEuNSkge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCA3KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDEuMCkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmljZUZyYWN0aW9uICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0fTtcblx0Ly8gUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGwgLSBodHRwczovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSgpKTtcblx0Ly8gLS0gRE9NIG1ldGhvZHNcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XG5cdFx0dmFyIG1vdXNlWCwgbW91c2VZO1xuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xuXHRcdHZhciBib3VuZGluZ1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcblx0XHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSBlLmNsaWVudFk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgbW91c2UgY29vcmRpbmF0ZXMgaW50byBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWxlZnQnKSk7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXRvcCcpKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctYm90dG9tJykpO1xuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcblx0XHRtb3VzZVggPSBNYXRoLnJvdW5kKChtb3VzZVggLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0KSAvICh3aWR0aCkgKiBjYW52YXMud2lkdGggLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IG1vdXNlWCxcblx0XHRcdHk6IG1vdXNlWVxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcblx0XHR2YXIgdmFsdWVJblBpeGVscztcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuXHRcdFx0XHR2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZUluUGl4ZWxzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXggd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBnaXZlbiBET00gbm9kZSBpbiBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSBmYXNoaW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbU5vZGUgLSB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwZXJjZW50YWdlUHJvcGVydHkgLSBwcm9wZXJ0eSBvZiBwYXJlbnQgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgd2lkdGggYXMgYSBwZXJjZW50YWdlXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3Nlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgbWF4U3R5bGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkge1xuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0dmFyIGNvbnN0cmFpbmVkTm9kZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcblx0XHR2YXIgaGFzQ0NvbnRhaW5lciA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZENvbnRhaW5lcik7XG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc0NOb2RlIHx8IGhhc0NDb250YWluZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbihcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxuXHRcdFx0XHRoYXNDQ29udGFpbmVyID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC13aWR0aCcsICdjbGllbnRXaWR0aCcpO1xuXHR9O1xuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG4gXHQgKi9cblx0aGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYWRkaW5nLCBwYXJlbnREaW1lbnNpb24pIHtcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XG5cblx0XHRyZXR1cm4gcGFkZGluZy5pbmRleE9mKCclJykgPiAtMSA/IHBhcmVudERpbWVuc2lvbiAqIHBhcnNlSW50KHBhZGRpbmcsIDEwKSAvIDEwMCA6IHBhcnNlSW50KHBhZGRpbmcsIDEwKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5ob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyZW50O1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1yaWdodCcsIGNsaWVudFdpZHRoKTtcblxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgY3cgPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoKGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjdykgPyB3IDogTWF0aC5taW4odywgY3cpO1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy10b3AnLCBjbGllbnRIZWlnaHQpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcblxuXHRcdHZhciBoID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGNoKSA/IGggOiBNYXRoLm1pbihoLCBjaCk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycyQxLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG5cdFx0aWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2hhcnQud2lkdGg7XG5cblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuXHRcdGlmICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSB7XG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHR9XG5cdH07XG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXG5cdGhlbHBlcnMkMS5mb250U3RyaW5nID0gZnVuY3Rpb24ocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXHR9O1xuXHRoZWxwZXJzJDEubG9uZ2VzdFRleHQgPSBmdW5jdGlvbihjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuXHRcdHZhciBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuXHRcdFx0ZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xuXHRcdH1cblxuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHR2YXIgbG9uZ2VzdCA9IDA7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0XHQvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKHRoaW5nLCBmdW5jdGlvbihuZXN0ZWRUaGluZykge1xuXHRcdFx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzJDEuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xuXHRcdFx0fVxuXHRcdFx0Z2Muc3BsaWNlKDAsIGdjTGVuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG5cdFx0aWYgKCF0ZXh0V2lkdGgpIHtcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5jb2xvciA9ICFjaGFydGpzQ29sb3IgP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xuXHRcdFx0Y29sb3JWYWx1ZSA6XG5cdFx0XHRoZWxwZXJzJDEuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXG5cdCk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxuICogQHR5cGVkZWYgeygnbWlsbGlzZWNvbmQnfCdzZWNvbmQnfCdtaW51dGUnfCdob3VyJ3wnZGF5J3wnd2Vlayd8J21vbnRoJ3wncXVhcnRlcid8J3llYXInKX1cbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBuYW1lIFVuaXRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIERhdGVBZGFwdGVyICovIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuXHQgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cblx0ICovXG5cdGZvcm1hdHM6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcblx0ICogQHJldHVybnMgeyhudW1iZXJ8bnVsbCl9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0cGFyc2U6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGZvcm1hdDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRhZGQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSB0aGUgdGltZXN0YW1wIHRvIHN1YnN0cmFjdFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGRpZmY6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcblx0ICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRzdGFydE9mOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGVuZE9mOiBhYnN0cmFjdCxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcblxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xudmFyIGNvcmVfdGlja3MgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3Ncblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHR2YXIgdGlja1N0cmluZyA9ICcnO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHZhciBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0pLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChNYXRoLmZsb29yKGxvZ1RpY2spIC0gTWF0aC5mbG9vcihsb2dEZWx0YSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2tTdHJpbmcgPSAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XG5cdFx0fSxcblxuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJzAnO1xuXHRcdFx0fSBlbHNlIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ5ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhbGUnLCB7XG5cdGRpc3BsYXk6IHRydWUsXG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cdG9mZnNldDogZmFsc2UsXG5cblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXG5cdGdyaWRMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcblx0XHRkcmF3VGlja3M6IHRydWUsXG5cdFx0dGlja01hcmtMZW5ndGg6IDEwLFxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXG5cdFx0emVyb0xpbmVDb2xvcjogJ3JnYmEoMCwwLDAsMC4yNSknLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0b2Zmc2V0R3JpZExpbmVzOiBmYWxzZSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHQvLyBzY2FsZSBsYWJlbFxuXHRzY2FsZUxhYmVsOiB7XG5cdFx0Ly8gZGlzcGxheSBwcm9wZXJ0eVxuXHRcdGRpc3BsYXk6IGZhbHNlLFxuXG5cdFx0Ly8gYWN0dWFsIGxhYmVsXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxuXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiA0LFxuXHRcdFx0Ym90dG9tOiA0XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxuXHRcdG1pblJvdGF0aW9uOiAwLFxuXHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRtaXJyb3I6IGZhbHNlLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRhdXRvU2tpcDogdHJ1ZSxcblx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG5cdFx0bWlub3I6IHt9LFxuXHRcdG1ham9yOiB7fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGFiZWxzRnJvbVRpY2tzKHRpY2tzKSB7XG5cdHZhciBsYWJlbHMgPSBbXTtcblx0dmFyIGksIGlsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxhYmVscy5wdXNoKHRpY2tzW2ldLmxhYmVsKTtcblx0fVxuXG5cdHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCk7XG5cblx0aWYgKG9mZnNldEdyaWRMaW5lcykge1xuXHRcdGlmIChzY2FsZS5nZXRUaWNrcygpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGluZVZhbHVlIC09IHNjYWxlLmlzSG9yaXpvbnRhbCgpID9cblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUubGVmdCwgc2NhbGUucmlnaHQgLSBsaW5lVmFsdWUpIDpcblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUudG9wLCBzY2FsZS5ib3R0b20gLSBsaW5lVmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4IC0gMSkpIC8gMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRleHRTaXplKGNvbnRleHQsIHRpY2ssIGZvbnQpIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHRpY2spID9cblx0XHRoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgZm9udCwgdGljaykgOlxuXHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG59XG5cbnZhciBjb3JlX3NjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtQYWRkaW5nfSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICovXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXG5cdFx0XHR0b3A6IG1lLnBhZGRpbmdUb3AgfHwgMCxcblx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cblx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90aWNrcztcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWxlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0aWYgKHRpY2tzLm1pbm9yID09PSBmYWxzZSkge1xuXHRcdFx0dGlja3MubWlub3IgPSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAodGlja3MubWFqb3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5tYWpvciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiB0aWNrcykge1xuXHRcdFx0aWYgKGtleSAhPT0gJ21ham9yJyAmJiBrZXkgIT09ICdtaW5vcicpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5taW5vcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1pbm9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWFqb3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aWNrcy5tYWpvcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBpbGVuLCBsYWJlbHMsIGxhYmVsLCB0aWNrcywgdGljaztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRib3R0b206IDBcblx0XHR9LCBtYXJnaW5zKTtcblxuXHRcdG1lLl9tYXhMYWJlbExpbmVzID0gMDtcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XG5cdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdC8vIERhdGEgbWluL21heFxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG5cblx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcblx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXG5cblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcblxuXHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxuXHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xuXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcblxuXHRcdC8vIElNUE9SVEFOVDogZnJvbSB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuXHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHR0aWNrID0gdGlja3NbaV07XG5cdFx0XHRpZiAoIXRpY2spIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aWNrID0ge1xuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRtYWpvcjogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuX3RpY2tzID0gdGlja3M7XG5cblx0XHQvLyBUaWNrIFJvdGF0aW9uXG5cdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBEYXRhIGxpbWl0c1xuXHRiZWZvcmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckRhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cdGJlZm9yZUJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQnVpbGRUaWNrcywgW3RoaXNdKTtcblx0fSxcblx0YnVpbGRUaWNrczogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIHRpY2tzIGlzIGVtcHR5IGZvciBvbGQgYXhpcyBpbXBsZW1lbnRhdGlvbnMgaGVyZVxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIHRpY2tzXSk7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcblx0XHRtZS50aWNrcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCBtZS50aWNrc10pIHx8IG1lLnRpY2tzO1xuXHRcdHJldHVybiB0aWNrcztcblx0fSxcblxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XG5cdH0sXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2Vcblx0XHQvLyBiZXR3ZWVuIHggb2Zmc2V0cyBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0Y29udGV4dC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGggJiYgbWUub3B0aW9ucy5kaXNwbGF5ICYmIG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxMYWJlbFdpZHRoID0gaGVscGVycyQxLmxvbmdlc3RUZXh0KGNvbnRleHQsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciBsYWJlbFdpZHRoID0gb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uLCBzaW5Sb3RhdGlvbjtcblxuXHRcdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcblx0XHRcdHZhciB0aWNrV2lkdGggPSBtZS5nZXRQaXhlbEZvclRpY2soMSkgLSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSA2O1xuXG5cdFx0XHQvLyBNYXggbGFiZWwgcm90YXRpb24gY2FuIGJlIHNldCBvciBkZWZhdWx0IHRvIDkwIC0gYWxzbyBhY3QgYXMgYSBsb29wIGNvdW50ZXJcblx0XHRcdHdoaWxlIChsYWJlbFdpZHRoID4gdGlja1dpZHRoICYmIGxhYmVsUm90YXRpb24gPCB0aWNrT3B0cy5tYXhSb3RhdGlvbikge1xuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhsYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0Y29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0aWYgKHNpblJvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoID4gbWUubWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0Ly8gZ28gYmFjayBvbmUgc3RlcFxuXHRcdFx0XHRcdGxhYmVsUm90YXRpb24tLTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxhYmVsUm90YXRpb24rKztcblx0XHRcdFx0bGFiZWxXaWR0aCA9IGNvc1JvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuXHR9LFxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG5cdH0sXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBSZXNldFxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblxuXHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5faXNWaXNpYmxlKCk7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbjtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgcGFyc2VGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udDtcblx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnQodGlja09wdHMpO1xuXHRcdHZhciB0aWNrTWFya0xlbmd0aCA9IG9wdHMuZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoO1xuXG5cdFx0Ly8gV2lkdGhcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgbWFyZ2lucyB0byBsaW5lIHVwIHdpdGggdGhlIGNoYXJ0QXJlYSBpZiB3ZSBhcmUgYSBmdWxsIHdpZHRoIHNjYWxlXG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1heFdpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodCA6IG1lLm1heFdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH1cblxuXHRcdC8vIGhlaWdodFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEFyZSB3ZSBzaG93aW5nIGEgdGl0bGUgZm9yIHRoZSBzY2FsZT9cblx0XHRpZiAoc2NhbGVMYWJlbE9wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnQoc2NhbGVMYWJlbE9wdHMpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0dmFyIGRlbHRhSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLmhlaWdodDtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG5cdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0dmFyIGxhcmdlc3RUZXh0V2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5zdHJpbmcsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHR2YXIgdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyA9IGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMobGFiZWxzKTtcblx0XHRcdHZhciBsaW5lU3BhY2UgPSB0aWNrRm9udC5zaXplICogMC41O1xuXHRcdFx0dmFyIHRpY2tQYWRkaW5nID0gbWUub3B0aW9ucy50aWNrcy5wYWRkaW5nO1xuXG5cdFx0XHQvLyBTdG9yZSBtYXggbnVtYmVyIG9mIGxpbmVzIGFuZCB3aWRlc3QgbGFiZWwgZm9yIF9hdXRvU2tpcFxuXHRcdFx0bWUuX21heExhYmVsTGluZXMgPSB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzO1xuXHRcdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSBsYXJnZXN0VGV4dFdpZHRoO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdC8vIFRPRE8gLSBpbXByb3ZlIHRoaXMgY2FsY3VsYXRpb25cblx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHQrICh0aWNrRm9udC5saW5lSGVpZ2h0ICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcylcblx0XHRcdFx0XHQrIGxpbmVTcGFjZTsgLy8gcGFkZGluZ1xuXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuXG5cdFx0XHRcdG1lLmN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXHRcdFx0XHR2YXIgZmlyc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzWzBdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgbGFzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGxhYmVscy5sZW5ndGggLSAxKTtcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG5cdFx0XHRcdGlmIChtZS5sYWJlbFJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBmaXJzdExhYmVsV2lkdGgpIDogKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKTtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpIDogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gZmlyc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQsIDApICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0LCAwKSArIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcblx0XHRcdFx0aWYgKHRpY2tPcHRzLm1pcnJvcikge1xuXHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVzZSBsaW5lU3BhY2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCArPSB0aWNrUGFkZGluZyArIGxpbmVTcGFjZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5tYXJnaW5zKSB7XG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0IC0gbWUubWFyZ2lucy5sZWZ0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wIC0gbWUubWFyZ2lucy50b3AsIDApO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0IC0gbWUubWFyZ2lucy5yaWdodCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSAtIG1lLm1hcmdpbnMuYm90dG9tLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3Rcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHQvLyBOdWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZpcnN0XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdGlmICgodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyB8fCByYXdWYWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRpZiAocmF3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLngpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFZhbHVlIGlzIGdvb2QsIHJldHVybiBpdFxuXHRcdHJldHVybiByYXdWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldFBpeGVsRm9yVmFsdWU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHBpeGVsXG5cdCAqL1xuXHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdFx0dmFyIHBpeGVsID0gKHRpY2tXaWR0aCAqIGluZGV4KSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHBpeGVsICs9IHRpY2tXaWR0aCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBwaXhlbDtcblx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdH1cblx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xuXHRcdHJldHVybiBtZS50b3AgKyAoaW5kZXggKiAoaW5uZXJIZWlnaHQgLyAobWUuX3RpY2tzLmxlbmd0aCAtIDEpKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yRGVjaW1hbDogZnVuY3Rpb24oZGVjaW1hbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChpbm5lcldpZHRoICogZGVjaW1hbCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHZhbHVlT2Zmc2V0O1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHJldHVybiBtZS50b3AgKyAoZGVjaW1hbCAqIG1lLmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcblx0fSxcblxuXHRnZXRCYXNlVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYXV0b1NraXA6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgdGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuXHRcdHZhciBza2lwUmF0aW8gPSBmYWxzZTtcblx0XHR2YXIgbWF4VGlja3MgPSBvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0O1xuXG5cdFx0Ly8gVG90YWwgc3BhY2UgbmVlZGVkIHRvIGRpc3BsYXkgYWxsIHRpY2tzLiBGaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmVcblx0XHQvLyBkcmF3biBhcyB0aGVpciBjZW50ZXIgYXQgZW5kIG9mIGF4aXMsIHNvIHRpY2tDb3VudC0xXG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gbWUuX3RpY2tTaXplKCkgKiAodGlja0NvdW50IC0gMSk7XG5cblx0XHQvLyBBeGlzIGxlbmd0aFxuXHRcdHZhciBheGlzTGVuZ3RoID0gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KVxuXHRcdFx0OiBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLlBhZGRpbmdCb3R0b20pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpLCB0aWNrO1xuXG5cdFx0aWYgKHRpY2tzTGVuZ3RoID4gYXhpc0xlbmd0aCkge1xuXHRcdFx0c2tpcFJhdGlvID0gMSArIE1hdGguZmxvb3IodGlja3NMZW5ndGggLyBheGlzTGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGV5IGRlZmluZWQgYSBtYXggbnVtYmVyIG9mIG9wdGlvblRpY2tzLFxuXHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRpZiAodGlja0NvdW50ID4gbWF4VGlja3MpIHtcblx0XHRcdHNraXBSYXRpbyA9IE1hdGgubWF4KHNraXBSYXRpbywgMSArIE1hdGguZmxvb3IodGlja0NvdW50IC8gbWF4VGlja3MpKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblxuXHRcdFx0aWYgKHNraXBSYXRpbyA+IDEgJiYgaSAlIHNraXBSYXRpbyA+IDApIHtcblx0XHRcdFx0Ly8gbGVhdmUgdGljayBpbiBwbGFjZSBidXQgbWFrZSBzdXJlIGl0J3Mgbm90IGRpc3BsYXllZCAoIzQ2MzUpXG5cdFx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2godGljayk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdGlja1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHZhciByb3QgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdHZhciBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuXHRcdHZhciB3ID0gKG1lLmxvbmdlc3RMYWJlbFdpZHRoICsgcGFkZGluZykgfHwgMDtcblxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9uVGlja3MpO1xuXHRcdHZhciBoID0gKG1lLl9tYXhMYWJlbExpbmVzICogdGlja0ZvbnQubGluZUhlaWdodCArIHBhZGRpbmcpIHx8IDA7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0cmV0dXJuIGlzSG9yaXpvbnRhbFxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuXHRcdFx0cmV0dXJuICEhZGlzcGxheTtcblx0XHR9XG5cblx0XHQvLyBXaGVuICdhdXRvJywgdGhlIHNjYWxlIGlzIHZpc2libGUgaWYgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgZGF0YXNldCBpcyB2aXNpYmxlLlxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFjdHVhbGx5IGRyYXcgdGhlIHNjYWxlIG9uIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYSAtIHRoZSBhcmVhIG9mIHRoZSBjaGFydCB0byBkcmF3IGZ1bGwgZ3JpZCBsaW5lcyBvblxuXHQgKi9cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Rm9udENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcjtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBvcHRpb25NYWpvclRpY2tzID0gb3B0aW9ucy50aWNrcy5tYWpvciB8fCBvcHRpb25UaWNrcztcblx0XHR2YXIgZ3JpZExpbmVzID0gb3B0aW9ucy5ncmlkTGluZXM7XG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuXHRcdHZhciBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrcyA9IG9wdGlvblRpY2tzLmRpc3BsYXkgJiYgb3B0aW9uVGlja3MuYXV0b1NraXAgPyBtZS5fYXV0b1NraXAobWUuZ2V0VGlja3MoKSkgOiBtZS5nZXRUaWNrcygpO1xuXHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShvcHRpb25UaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuXHRcdHZhciBtYWpvclRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvbk1ham9yVGlja3MuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgbWFqb3JUaWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25NYWpvclRpY2tzKTtcblx0XHR2YXIgdGlja1BhZGRpbmcgPSBvcHRpb25UaWNrcy5wYWRkaW5nO1xuXHRcdHZhciBsYWJlbE9mZnNldCA9IG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuXG5cdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHR2YXIgc2NhbGVMYWJlbEZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGVMYWJlbC5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsKTtcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHR2YXIgbGFiZWxSb3RhdGlvblJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0dmFyIGl0ZW1zVG9EcmF3ID0gW107XG5cblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xuXHRcdHZhciBib3JkZXJWYWx1ZSwgdGlja1N0YXJ0LCB0aWNrRW5kO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gYm9yZGVyVmFsdWUgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0dGlja0VuZCA9IG1lLnRvcCArIHRsO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR0aWNrRW5kID0gYm9yZGVyVmFsdWUgLSBheGlzV2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUubGVmdCArIHRsO1xuXHRcdH1cblxuXHRcdHZhciBlcHNpbG9uID0gMC4wMDAwMDAxOyAvLyAwLjAwMDAwMDEgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgQWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRoZWxwZXJzJDEuZWFjaCh0aWNrcywgZnVuY3Rpb24odGljaywgaW5kZXgpIHtcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aWNrLmxhYmVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYWJlbCA9IHRpY2subGFiZWw7XG5cdFx0XHR2YXIgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRpZiAoaW5kZXggPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIGluZGV4KTtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoIHx8IFtdO1xuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gcHJvcGVydGllc1xuXHRcdFx0dmFyIHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTIsIGxhYmVsWCwgbGFiZWxZLCB0ZXh0T2Zmc2V0LCB0ZXh0QWxpZ247XG5cdFx0XHR2YXIgbGFiZWxDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG5cdFx0XHR2YXIgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBsYWJlbFlPZmZzZXQgPSB0bCArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS5sZWZ0IC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cdFx0XHRcdHR5MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHkyID0gdGlja0VuZDtcblx0XHRcdFx0bGFiZWxYID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0OyAvLyB4IHZhbHVlcyBmb3Igb3B0aW9uVGlja3MgKG5lZWQgdG8gY29uc2lkZXIgb2Zmc2V0TGFiZWwgb3B0aW9uKVxuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHR5MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS50b3AsIGF4aXNXaWR0aCkgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCghaXNSb3RhdGVkID8gMC41IDogMSkgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ2xlZnQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLmJvdHRvbSAtIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5MSA9IGNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEuYm90dG9tLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCFpc1JvdGF0ZWQgPyAwLjUgOiAwKSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsYWJlbFhPZmZzZXQgPSAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRpZiAobGluZVZhbHVlIDwgbWUudG9wIC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHgyID0gdGlja0VuZDtcblx0XHRcdFx0dHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0bGFiZWxZID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0O1xuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEubGVmdCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eDIgPSBjaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcblx0XHRcdFx0XHR4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5yaWdodCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUubGVmdCArIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpdGVtc1RvRHJhdy5wdXNoKHtcblx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0bGFiZWxYOiBsYWJlbFgsXG5cdFx0XHRcdGxhYmVsWTogbGFiZWxZLFxuXHRcdFx0XHRnbFdpZHRoOiBsaW5lV2lkdGgsXG5cdFx0XHRcdGdsQ29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0Z2xCb3JkZXJEYXNoOiBib3JkZXJEYXNoLFxuXHRcdFx0XHRnbEJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdHJvdGF0aW9uOiAtMSAqIGxhYmVsUm90YXRpb25SYWRpYW5zLFxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdG1ham9yOiB0aWNrLm1ham9yLFxuXHRcdFx0XHR0ZXh0T2Zmc2V0OiB0ZXh0T2Zmc2V0LFxuXHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGljayBsYWJlbHMsIHRpY2sgbWFya3MsIGFuZCBncmlkIGxpbmVzIGF0IHRoZSBjb3JyZWN0IHBsYWNlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGl0ZW1zVG9EcmF3LCBmdW5jdGlvbihpdGVtVG9EcmF3KSB7XG5cdFx0XHR2YXIgZ2xXaWR0aCA9IGl0ZW1Ub0RyYXcuZ2xXaWR0aDtcblx0XHRcdHZhciBnbENvbG9yID0gaXRlbVRvRHJhdy5nbENvbG9yO1xuXG5cdFx0XHRpZiAoZ3JpZExpbmVzLmRpc3BsYXkgJiYgZ2xXaWR0aCAmJiBnbENvbG9yKSB7XG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGdsV2lkdGg7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnbENvbG9yO1xuXHRcdFx0XHRpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0TGluZURhc2goaXRlbVRvRHJhdy5nbEJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LnR4MSwgaXRlbVRvRHJhdy50eTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcudHgyLCBpdGVtVG9EcmF3LnR5Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcueDEsIGl0ZW1Ub0RyYXcueTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcueDIsIGl0ZW1Ub0RyYXcueTIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdGNvbnRleHQucm90YXRlKGl0ZW1Ub0RyYXcucm90YXRpb24pO1xuXHRcdFx0XHRjb250ZXh0LmZvbnQgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udC5zdHJpbmcgOiB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnRDb2xvciA6IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0dmFyIGxhYmVsID0gaXRlbVRvRHJhdy5sYWJlbDtcblx0XHRcdFx0dmFyIHkgPSBpdGVtVG9EcmF3LnRleHRPZmZzZXQ7XG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KCcnICsgbGFiZWxbaV0sIDAsIHkpO1xuXHRcdFx0XHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCB5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChzY2FsZUxhYmVsLmRpc3BsYXkpIHtcblx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHR2YXIgc2NhbGVMYWJlbFg7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFk7XG5cdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0dmFyIGhhbGZMaW5lSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCAvIDI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgKChtZS5yaWdodCAtIG1lLmxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHRzY2FsZUxhYmVsWSA9IHBvc2l0aW9uID09PSAnYm90dG9tJ1xuXHRcdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cblx0XHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XG5cdFx0XHRcdFx0PyBtZS5sZWZ0ICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3Bcblx0XHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgKChtZS5ib3R0b20gLSBtZS50b3ApIC8gMik7XG5cdFx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XG5cdFx0XHRjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gc2NhbGVMYWJlbEZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjb250ZXh0LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5zdHJpbmc7XG5cdFx0XHRjb250ZXh0LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xuXHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZSBhdCB0aGUgZWRnZSBvZiB0aGUgYXhpc1xuXHRcdFx0dmFyIGZpcnN0TGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgdGlja3MubGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkxID0geTIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkyID0gYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG5cdFx0XHRjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0cG9zaXRpb246ICdib3R0b20nXG59O1xuXG52YXIgc2NhbGVfY2F0ZWdvcnkgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdC8qKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHQqIGVsc2UgZmFsbCBiYWNrIHRvIGRhdGEubGFiZWxzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0bWUubWluSW5kZXggPSAwO1xuXHRcdG1lLm1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG5cdFx0dmFyIGZpbmRJbmRleDtcblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWluKTtcblx0XHRcdG1lLm1pbkluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1pbkluZGV4O1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtYXggdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWF4KTtcblx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGxhYmVsc1ttZS5taW5JbmRleF07XG5cdFx0bWUubWF4ID0gbGFiZWxzW21lLm1heEluZGV4XTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuXHRcdG1lLnRpY2tzID0gKG1lLm1pbkluZGV4ID09PSAwICYmIG1lLm1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWUubWluSW5kZXgsIG1lLm1heEluZGV4ICsgMSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cblx0XHRpZiAoY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gbWUuaWQpIHtcblx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lLnRpY2tzW2luZGV4IC0gbWUubWluSW5kZXhdO1xuXHR9LFxuXG5cdC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiAgVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHQvLyAxIGlzIGFkZGVkIGJlY2F1c2Ugd2UgbmVlZCB0aGUgbGVuZ3RoIGJ1dCB3ZSBoYXZlIHRoZSBpbmRleGVzXG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblxuXHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxuXHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHR2YWx1ZUNhdGVnb3J5ID0gbWUuaXNIb3Jpem9udGFsKCkgPyB2YWx1ZS54IDogdmFsdWUueTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHR2YXIgaWR4ID0gbGFiZWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgdmFsdWVXaWR0aCA9IG1lLndpZHRoIC8gb2Zmc2V0QW10O1xuXHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHdpZHRoT2Zmc2V0ICs9ICh2YWx1ZVdpZHRoIC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS5sZWZ0ICsgd2lkdGhPZmZzZXQ7XG5cdFx0fVxuXHRcdHZhciB2YWx1ZUhlaWdodCA9IG1lLmhlaWdodCAvIG9mZnNldEFtdDtcblx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKHZhbHVlSGVpZ2h0ICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdGhlaWdodE9mZnNldCArPSAodmFsdWVIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudG9wICsgaGVpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwpO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHR2YXIgaG9yeiA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciB2YWx1ZURpbWVuc2lvbiA9IChob3J6ID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gb2Zmc2V0QW10O1xuXG5cdFx0cGl4ZWwgLT0gaG9yeiA/IG1lLmxlZnQgOiBtZS50b3A7XG5cblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRwaXhlbCAtPSAodmFsdWVEaW1lbnNpb24gLyAyKTtcblx0XHR9XG5cblx0XHRpZiAocGl4ZWwgPD0gMCkge1xuXHRcdFx0dmFsdWUgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlICsgbWUubWluSW5kZXg7XG5cdH0sXG5cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMgPSBkZWZhdWx0Q29uZmlnO1xuc2NhbGVfY2F0ZWdvcnkuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuXG52YXIgbm9vcCA9IGhlbHBlcnMkMS5ub29wO1xudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3Ncblx0Ly8gZm9yIGRldGFpbHMuXG5cblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XG5cdHZhciBzdGVwU2l6ZSA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XG5cdHZhciBtaW4gPSBnZW5lcmF0aW9uT3B0aW9ucy5taW47XG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XG5cdHZhciBybWluID0gZGF0YVJhbmdlLm1pbjtcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdHZhciBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuXHQvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZihtaW4pICYmIGlzTnVsbE9yVW5kZWYobWF4KSkge1xuXHRcdHJldHVybiBbcm1pbiwgcm1heF07XG5cdH1cblxuXHRudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcblx0XHQvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuXHRcdHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuXHR9XG5cblx0aWYgKHN0ZXBTaXplIHx8IGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuXHRcdC8vIElmIGEgcHJlY2lzaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmYWN0b3IgYmFzZWQgb24gc3BhY2luZ1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0bmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1pbikgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1pbiAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1pbiA9IG1pbjtcblx0XHR9XG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1heCkgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1heCAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1heCA9IG1heDtcblx0XHR9XG5cdH1cblxuXHRudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuXHR9IGVsc2Uge1xuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xuXHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XG5cdH1cblx0dGlja3MucHVzaChpc051bGxPclVuZGVmKG1heCkgPyBuaWNlTWF4IDogbWF4KTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBzY2FsZV9saW5lYXJiYXNlID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XG5cdFx0Ly8gYXhpcywgdGhleSBjYW4gbWFudWFsbHkgb3ZlcnJpZGUgaXRcblx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcblx0XHRcdHZhciBtYXhTaWduID0gaGVscGVycyQxLnNpZ24obWUubWF4KTtcblxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIHRvcCB1cCB0byAwXG5cdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIGJvdHRvbSBkb3duIHRvIDBcblx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHNldE1heCA9IHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5taW47XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5zdWdnZXN0ZWRNaW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIHRpY2tPcHRzLnN1Z2dlc3RlZE1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNldE1pbiAhPT0gc2V0TWF4KSB7XG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cblx0XHRcdC8vIFNvIGVuc3VyZSB0aGF0IG91ciByYW5nZSBpcyBnb29kXG5cdFx0XHQvLyBJbnZlcnRlZCBvciAwIGxlbmd0aCByYW5nZSBjYW4gaGFwcGVuIHdoZW5cblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxuXHRcdFx0aWYgKG1lLm1pbiA+PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKHNldE1pbikge1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWF4IC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdGlmICghdGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0bWUubWluLS07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBzdGVwU2l6ZSA9IHRpY2tPcHRzLnN0ZXBTaXplO1xuXHRcdHZhciBtYXhUaWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdDtcblx0XHR2YXIgbWF4VGlja3M7XG5cblx0XHRpZiAoc3RlcFNpemUpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF4VGlja3MgPSBtZS5fY29tcHV0ZVRpY2tMaW1pdCgpO1xuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXhUaWNrcztcblx0fSxcblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0fSxcblxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuXHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuXHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuXHRcdHZhciBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuXHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0dmFyIG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuXHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRtYXg6IHRpY2tPcHRzLm1heCxcblx0XHRcdHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgbWUpO1xuXG5cdFx0bWUuaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzKCk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRtZS56ZXJvTGluZUluZGV4ID0gbWUudGlja3MuaW5kZXhPZigwKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9XG59O1xuXG52YXIgc2NhbGVfbGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxO1xuXG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBGaXJzdCBDYWxjdWxhdGUgdGhlIHJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlczogW10sXG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlc2UgcGVyIHR5cGVcblx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0dmFyIG5lZ2F0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5uZWdhdGl2ZVZhbHVlcztcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gcG9zaXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gPSBuZWdhdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gMTAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc0ZvclR5cGUucG9zaXRpdmVWYWx1ZXMuY29uY2F0KHZhbHVlc0ZvclR5cGUubmVnYXRpdmVWYWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycyQxLm1heCh2YWx1ZXMpO1xuXHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5taW4gPSBpc0Zpbml0ZShtZS5taW4pICYmICFpc05hTihtZS5taW4pID8gbWUubWluIDogREVGQVVMVF9NSU47XG5cdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tGb250O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xuXHRcdH1cblx0XHR0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobWUub3B0aW9ucy50aWNrcyk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcblx0fSxcblxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHQvLyBVdGlsc1xuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0Ly8gdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5yaWdodCwgYW5kIHRoaXMuYm90dG9tIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdHZhciByaWdodFZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdHZhciBwaXhlbDtcblx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKG1lLndpZHRoIC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgb2Zmc2V0ID0gKGlzSG9yaXpvbnRhbCA/IHBpeGVsIC0gbWUubGVmdCA6IG1lLmJvdHRvbSAtIHBpeGVsKSAvIGlubmVyRGltZW5zaW9uO1xuXHRcdHJldHVybiBtZS5zdGFydCArICgobWUuZW5kIC0gbWUuc3RhcnQpICogb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMSA9IGRlZmF1bHRDb25maWckMTtcbnNjYWxlX2xpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cblx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWF4KSk7XG5cdHZhciBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuXHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcblxuXHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW5Ob3RaZXJvIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSBlbHNlIHtcblx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdH1cblx0dmFyIHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuXG5cdGRvIHtcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0KytzaWduaWZpY2FuZDtcblx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHQrK2V4cDtcblx0XHRcdHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcblx0XHR9XG5cblx0XHR0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQkYShnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDIgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdH1cbn07XG5cbi8vIFRPRE8odjMpOiBjaGFuZ2UgdGhpcyB0byBwb3NpdGl2ZU9yRGVmYXVsdFxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gfHwgdmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc0ZvclR5cGUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gMCAmJiAobWUubWluTm90WmVybyA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1lLm1pbk5vdFplcm8pKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4XG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBERUZBVUxUX01JTiA9IDE7XG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XG5cblx0XHRtZS5taW4gPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4sIG1lLm1pbik7XG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgLSAxKTtcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcblx0XHRcdFx0bWUubWF4ID0gREVGQVVMVF9NQVg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSAtIDEpO1xuXHRcdH1cblx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcblx0XHRcdFx0PyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgKyAxKVxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xuXHRcdH1cblx0XHRpZiAobWUubWluTm90WmVybyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSBpZiAobWUubWF4IDwgMSkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIGdlbmVyYXRpb25PcHRpb25zID0ge1xuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHJldmVyc2UgPSAhcmV2ZXJzZTtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tWYWx1ZXNbaW5kZXhdKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRpY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIG5vdCB6ZXJvIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh2YWx1ZSkpO1xuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHRyZXR1cm4gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHBpeGVsLCBzdGFydCwgZW5kLCBzaWduO1xuXG5cdFx0dmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0XHRzaWduID0gMTtcblx0XHR9XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0cGl4ZWwgPSByZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHNpZ24gKj0gLTE7IC8vIGludmVydCwgc2luY2UgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMgaXMgYXQgcGl4ZWwgKDAsIDApXG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS50b3AgOiBtZS5ib3R0b207XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHRvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyRGltZW5zaW9uIC8gKGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCkpICogKGxvZzEwKHZhbHVlKSAtIGxvZzEwKHN0YXJ0KSk7XG5cdFx0XHR9XG5cdFx0XHRwaXhlbCArPSBzaWduICogb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHRcdHZhciBsb2cxMCA9IGhlbHBlcnMkMS5sb2cxMDtcblx0XHR2YXIgZmlyc3RUaWNrVmFsdWUgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uLCBzdGFydCwgZW5kLCB2YWx1ZTtcblxuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRzdGFydCA9IG1lLmVuZDtcblx0XHRcdGVuZCA9IG1lLnN0YXJ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0ZW5kID0gbWUuZW5kO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHR2YWx1ZSA9IHJldmVyc2UgPyBtZS5yaWdodCAtIHBpeGVsIDogcGl4ZWwgLSBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IHBpeGVsIC0gbWUudG9wIDogbWUuYm90dG9tIC0gcGl4ZWw7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYSh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFsdWUgLT0gb2Zmc2V0O1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSAqPSBsb2cxMChlbmQpIC0gbG9nMTAoc3RhcnQpO1xuXHRcdFx0dmFsdWUgLz0gaW5uZXJEaW1lbnNpb247XG5cdFx0XHR2YWx1ZSA9IE1hdGgucG93KDEwLCBsb2cxMChzdGFydCkgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQyID0gZGVmYXVsdENvbmZpZyQyO1xuc2NhbGVfbG9nYXJpdGhtaWMuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDI7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRiID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDcgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xuXHRkaXNwbGF5OiB0cnVlLFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG5cdGFuaW1hdGU6IHRydWUsXG5cdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuXHRhbmdsZUxpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdGdyaWRMaW5lczoge1xuXHRcdGNpcmN1bGFyOiBmYWxzZVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcblx0XHRzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXG5cdFx0YmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC43NSknLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWTogMixcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdYOiAyLFxuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0fSxcblxuXHRwb2ludExhYmVsczoge1xuXHRcdC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHQvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG5cdFx0Zm9udFNpemU6IDEwLFxuXG5cdFx0Ly8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUNvdW50KHNjYWxlKSB7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0cmV0dXJuIG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSA/IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG5cdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG5cdFx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSkgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMjtcblx0fVxuXHRyZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGxpbmVIZWlnaHQsIGxhYmVsKSB7XG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogaGVscGVycyQxLmxvbmdlc3RUZXh0KGN0eCwgY3R4LmZvbnQsIGxhYmVsKSxcblx0XHRcdGg6IGxhYmVsLmxlbmd0aCAqIGxpbmVIZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR3OiBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxuXHRcdGg6IGxpbmVIZWlnaHRcblx0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG5cdGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG5cdFx0XHRlbmQ6IHBvcyArIChzaXplIC8gMilcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplLFxuXHRcdFx0ZW5kOiBwb3Ncblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdGFydDogcG9zLFxuXHRcdGVuZDogcG9zICsgc2l6ZVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcblx0Ly8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG5cdC8vXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcblx0Ly9cblx0Ly8gU29sdXRpb246XG5cdC8vXG5cdC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuXHQvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuXHQvL1xuXHQvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuXHQvL1xuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcblx0Ly8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuXHQvL1xuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuXHQvLyBhbG9uZyB3aXRoIGxhYmVscy5cblx0Ly9cblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuXHQvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cblx0Ly9cblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG5cdC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG5cdC8vXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMpO1xuXG5cdC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuXHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xuXHRcdGw6IDAsXG5cdFx0cjogc2NhbGUud2lkdGgsXG5cdFx0dDogMCxcblx0XHRiOiBzY2FsZS5oZWlnaHQgLSBzY2FsZS5wYWRkaW5nVG9wXG5cdH07XG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuXHR2YXIgaSwgdGV4dFNpemUsIHBvaW50UG9zaXRpb247XG5cblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xuXHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzID0gW107XG5cblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgNSk7XG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnKTtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cdH1cblxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdHJldHVybiAnY2VudGVyJztcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdHJldHVybiAnbGVmdCc7XG5cdH1cblxuXHRyZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xuXHR2YXIgeSA9IHBvc2l0aW9uLnkgKyBsaW5lSGVpZ2h0IC8gMjtcblx0dmFyIGksIGlsZW47XG5cblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCB5KTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRwb3NpdGlvbi55IC09ICh0ZXh0U2l6ZS5oIC8gMik7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0fVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgYW5nbGVMaW5lT3B0cyA9IG9wdHMuYW5nbGVMaW5lcztcblx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHR2YXIgcG9pbnRMYWJlbE9wdHMgPSBvcHRzLnBvaW50TGFiZWxzO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkYihhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aCwgZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCk7XG5cdHZhciBsaW5lQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMuY29sb3IsIGdyaWRMaW5lT3B0cy5jb2xvcik7XG5cdHZhciB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG5cblx0Y3R4LnNhdmUoKTtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKHJlc29sdmUkNyhbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoLCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaCwgW11dKSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcblx0fVxuXG5cdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHQvLyBQb2ludCBMYWJlbCBGb250XG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHBvaW50TGFiZWxPcHRzKTtcblxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRmb3IgKHZhciBpID0gZ2V0VmFsdWVDb3VudChzY2FsZSkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmIChhbmdsZUxpbmVPcHRzLmRpc3BsYXkgJiYgbGluZVdpZHRoICYmIGxpbmVDb2xvcikge1xuXHRcdFx0dmFyIG91dGVyUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyKTtcblx0XHRcdGN0eC5saW5lVG8ob3V0ZXJQb3NpdGlvbi54LCBvdXRlclBvc2l0aW9uLnkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHQvLyBFeHRyYSBwaXhlbHMgb3V0IGZvciBzb21lIGxhYmVsIHNwYWNpbmdcblx0XHRcdHZhciBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuXHRcdFx0dmFyIHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgNSk7XG5cblx0XHRcdC8vIEtlZXAgdGhpcyBpbiBsb29wIHNpbmNlIHdlIG1heSBzdXBwb3J0IGFycmF5IHByb3BlcnRpZXMgaGVyZVxuXHRcdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcblx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycsIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xuXHRcdH1cblx0fVxuXHRjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdHZhciBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cdHZhciBwb2ludFBvc2l0aW9uO1xuXG5cdGlmICgoIWNpcmN1bGFyICYmICF2YWx1ZUNvdW50KSB8fCAhbGluZUNvbG9yIHx8ICFsaW5lV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHguc2F2ZSgpO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYgKGNpcmN1bGFyKSB7XG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuXHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cblxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cdFx0bWUucGFkZGluZ1RvcCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChtZS5vcHRpb25zKSAvIDI7XG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3AsIG1lLndpZHRoKSAvIDI7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBtZSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0fSxcblxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG5cdH0sXG5cblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gKE1hdGguUEkgKiAyKSAvIGdldFZhbHVlQ291bnQodGhpcyk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgdGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgP1xuXHRcdFx0dGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgOlxuXHRcdFx0MDtcblxuXHRcdHZhciBzdGFydEFuZ2xlUmFkaWFucyA9IHN0YXJ0QW5nbGUgKiBNYXRoLlBJICogMiAvIDM2MDtcblxuXHRcdC8vIFN0YXJ0IGZyb20gdGhlIHRvcCBpbnN0ZWFkIG9mIHJpZ2h0LCBzbyByZW1vdmUgYSBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblx0XHRyZXR1cm4gaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlUmFkaWFucztcblx0fSxcblxuXHRnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gMDsgLy8gbnVsbCBhbHdheXMgaW4gY2VudGVyXG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fVxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcblx0XHRcdHk6IE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0fSxcblxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLFxuXHRcdFx0bWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MCk7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblxuXHRcdFx0aWYgKG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdC8vIERvbid0IGRyYXcgYSBjZW50cmUgdmFsdWUgKGlmIGl0IGlzIG1pbmltdW0pXG5cdFx0XHRcdGlmIChpbmRleCA+IDAgfHwgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHZhciB5Q2VudGVyT2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0XHRcdC8vIERyYXcgY2lyY3VsYXIgbGluZXMgYXJvdW5kIHRoZSBzY2FsZVxuXHRcdFx0XHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSAmJiBpbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG5cblx0XHRcdFx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrT3B0cy5iYWNrZHJvcENvbG9yO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoXG5cdFx0XHRcdFx0XHRcdFx0LWxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHQteUNlbnRlck9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFdpZHRoICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCAqIDIsXG5cdFx0XHRcdFx0XHRcdFx0dGlja0ZvbnQuc2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCAwLCAteUNlbnRlck9mZnNldCk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDMgPSBkZWZhdWx0Q29uZmlnJDM7XG5zY2FsZV9yYWRpYWxMaW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRjID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbnZhciBJTlRFUlZBTFMgPSB7XG5cdG1pbGxpc2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIDI1MCwgNTAwXVxuXHR9LFxuXHRzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMTAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdG1pbnV0ZToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdGhvdXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMzYwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDYsIDEyXVxuXHR9LFxuXHRkYXk6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHR9LFxuXHR3ZWVrOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA2MDQ4MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHRtb250aDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAyLjYyOGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgM11cblx0fSxcblx0cXVhcnRlcjoge1xuXHRcdGNvbW1vbjogZmFsc2UsXG5cdFx0c2l6ZTogNy44ODRlOSxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdHllYXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcbiAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cbiAqIGFuZCBtYXggcmFuZ2UsIHNvIGJhc2ljYWxseSwgdGhlIHRhYmxlIHdpbGwgY29udGFpbnMgb25seSB0d28gaXRlbXM6IHttaW4sIDB9IGFuZCB7bWF4LCAxfS5cbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxuICogYmVzdCBjYXNlLCBhbGwgdGltZXN0YW1wcyBhcmUgbGluZWFyLCB0aGUgdGFibGUgY29udGFpbnMgb25seSBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XG5cdGlmIChkaXN0cmlidXRpb24gPT09ICdsaW5lYXInIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxuXHRcdFx0e3RpbWU6IG1heCwgcG9zOiAxfVxuXHRcdF07XG5cdH1cblxuXHR2YXIgdGFibGUgPSBbXTtcblx0dmFyIGl0ZW1zID0gW21pbl07XG5cdHZhciBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XG5cdFx0fVxuXHR9XG5cblx0aXRlbXMucHVzaChtYXgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRuZXh0ID0gaXRlbXNbaSArIDFdO1xuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xuXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuXHRcdFx0dGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWJsZTtcbn1cblxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuYW51amdha2hhci5jb20vMjAxNC8wMy8wMS9iaW5hcnktc2VhcmNoLWluLWphdmFzY3JpcHQvXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcblx0dmFyIGxvID0gMDtcblx0dmFyIGhpID0gdGFibGUubGVuZ3RoIC0gMTtcblx0dmFyIG1pZCwgaTAsIGkxO1xuXG5cdHdoaWxlIChsbyA+PSAwICYmIGxvIDw9IGhpKSB7XG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XG5cdFx0aTAgPSB0YWJsZVttaWQgLSAxXSB8fCBudWxsO1xuXHRcdGkxID0gdGFibGVbbWlkXTtcblxuXHRcdGlmICghaTApIHtcblx0XHRcdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGJlZm9yZSBmaXJzdCBpdGVtKVxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcblx0XHR9IGVsc2UgaWYgKGkxW2tleV0gPCB2YWx1ZSkge1xuXHRcdFx0bG8gPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XG5cdFx0XHRoaSA9IG1pZCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xuXHRcdH1cblx0fVxuXG5cdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGFmdGVyIGxhc3QgaXRlbSlcblx0cmV0dXJuIHtsbzogaTEsIGhpOiBudWxsfTtcbn1cblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxuICogcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBgdGtleWAgdmFsdWUuIEZvciBleGFtcGxlLCBpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCA0MiwgJ3BvcycpXG4gKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBmb3IgYSB0aW1lc3RhbXAgZXF1YWwgdG8gNDIuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlcyBhdFxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XG5cblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xuXHR2YXIgbmV4dCA9ICFyYW5nZS5sbyA/IHRhYmxlWzFdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMV0gOiByYW5nZS5oaTtcblxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xuXHR2YXIgcmF0aW8gPSBzcGFuID8gKHN2YWwgLSBwcmV2W3NrZXldKSAvIHNwYW4gOiAwO1xuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xuXG5cdHJldHVybiBwcmV2W3RrZXldICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzY2FsZSwgaW5wdXQpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciBwYXJzZXIgPSBvcHRpb25zLnBhcnNlcjtcblx0dmFyIGZvcm1hdCA9IHBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcblx0dmFyIHZhbHVlID0gaW5wdXQ7XG5cblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG5cdH1cblxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuXHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHR2YWx1ZSA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcblx0XHRcdDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAodmFsdWUgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gK3ZhbHVlO1xuXHR9XG5cblx0Ly8gTGFiZWxzIGFyZSBpbiBhbiBpbmNvbXBhdGlibGUgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cblx0aWYgKCFwYXJzZXIgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gZm9ybWF0KGlucHV0KTtcblxuXHRcdC8vIGBmb3JtYXRgIGNvdWxkIHJldHVybiBzb21ldGhpbmcgZWxzZSB0aGFuIGEgdGltZXN0YW1wLCBpZiBzbywgcGFyc2UgaXRcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGlucHV0KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciB2YWx1ZSA9IHRvVGltZXN0YW1wKHNjYWxlLCBzY2FsZS5nZXRSaWdodFZhbHVlKGlucHV0KSk7XG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XG5cdFx0dmFsdWUgPSArc2NhbGUuX2FkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgb3B0aW9ucy5yb3VuZCk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXQgdG8gc2tpcCB0byBiZSBhYmxlIHRvIGRpc3BsYXkgdXAgdG8gYGNhcGFjaXR5YCBudW1iZXIgb2YgdGlja3NcbiAqIGluIGB1bml0YCBmb3IgdGhlIGdpdmVuIGBtaW5gIC8gYG1heGAgcmFuZ2UgYW5kIHJlc3BlY3RpbmcgdGhlIGludGVydmFsIHN0ZXBzIGNvbnN0cmFpbnRzLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgY2FwYWNpdHkpIHtcblx0dmFyIHJhbmdlID0gbWF4IC0gbWluO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbdW5pdF07XG5cdHZhciBtaWxsaXNlY29uZHMgPSBpbnRlcnZhbC5zaXplO1xuXHR2YXIgc3RlcHMgPSBpbnRlcnZhbC5zdGVwcztcblx0dmFyIGksIGlsZW4sIGZhY3RvcjtcblxuXHRpZiAoIXN0ZXBzKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChyYW5nZSAvIChjYXBhY2l0eSAqIG1pbGxpc2Vjb25kcykpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHN0ZXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGZhY3RvciA9IHN0ZXBzW2ldO1xuXHRcdGlmIChNYXRoLmNlaWwocmFuZ2UgLyAobWlsbGlzZWNvbmRzICogZmFjdG9yKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWN0b3I7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcblxuXHRmb3IgKGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcblx0XHRmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzW2ludGVydmFsLnN0ZXBzLmxlbmd0aCAtIDFdIDogTUFYX0lOVEVHRVI7XG5cblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgdGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgdW5pdDtcblxuXHRmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcblx0XHR1bml0ID0gVU5JVFNbaV07XG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcbiAqIGBtaW5vcmAgdW5pdCwgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0IGFuZCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG4gKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHNjYWxlLCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xuXHR2YXIgbWFqb3IgPSBkZXRlcm1pbmVNYWpvclVuaXQobWlub3IpO1xuXHR2YXIgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUpO1xuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG5cdHZhciBtYWpvclRpY2tzRW5hYmxlZCA9IG9wdGlvbnMudGlja3MubWFqb3IuZW5hYmxlZDtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW21pbm9yXTtcblx0dmFyIGZpcnN0ID0gbWluO1xuXHR2YXIgbGFzdCA9IG1heDtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciB0aW1lO1xuXG5cdGlmICghc3RlcFNpemUpIHtcblx0XHRzdGVwU2l6ZSA9IGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCBtaW5vciwgY2FwYWNpdHkpO1xuXHR9XG5cblx0Ly8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuXHRpZiAod2Vla2RheSkge1xuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcblx0XHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QvbGFzdCB0aWNrcyBvbiB1bml0XG5cdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhc3QgdGljayBpbmNsdWRlIG1heFxuXHRpZiAobGFzdCA8IG1heCkge1xuXHRcdGxhc3QgPSArYWRhcHRlci5hZGQobGFzdCwgMSwgbWlub3IpO1xuXHR9XG5cblx0dGltZSA9IGZpcnN0O1xuXG5cdGlmIChtYWpvclRpY2tzRW5hYmxlZCAmJiBtYWpvciAmJiAhd2Vla2RheSAmJiAhdGltZU9wdHMucm91bmQpIHtcblx0XHQvLyBBbGlnbiB0aGUgZmlyc3QgdGljayBvbiB0aGUgcHJldmlvdXMgYG1pbm9yYCB1bml0IGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdDpcblx0XHQvLyB3ZSBmaXJzdCBhbGlnbmVkIHRpbWUgb24gdGhlIHByZXZpb3VzIGBtYWpvcmAgdW5pdCB0aGVuIGFkZCB0aGUgbnVtYmVyIG9mIGZ1bGxcblx0XHQvLyBzdGVwU2l6ZSB0aGVyZSBpcyBiZXR3ZWVuIGZpcnN0IGFuZCB0aGUgcHJldmlvdXMgbWFqb3IgdGltZS5cblx0XHR0aW1lID0gK2FkYXB0ZXIuc3RhcnRPZih0aW1lLCBtYWpvcik7XG5cdFx0dGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCB+figoZmlyc3QgLSB0aW1lKSAvIChpbnRlcnZhbC5zaXplICogc3RlcFNpemUpKSAqIHN0ZXBTaXplLCBtaW5vcik7XG5cdH1cblxuXHRmb3IgKDsgdGltZSA8IGxhc3Q7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSkge1xuXHRcdHRpY2tzLnB1c2goK3RpbWUpO1xuXHR9XG5cblx0dGlja3MucHVzaCgrdGltZSk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBlbmQgPSAwO1xuXHR2YXIgZmlyc3QsIGxhc3Q7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGlmICghb3B0aW9ucy50aW1lLm1pbikge1xuXHRcdFx0Zmlyc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzBdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhcnQgPSAoaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1sxXSwgJ3BvcycpIC0gZmlyc3QpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWF4KSB7XG5cdFx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xuXHRcdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRlbmQgPSBsYXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xufVxuXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIGksIGlsZW4sIHZhbHVlLCBtYWpvcjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdG1ham9yID0gbWFqb3JVbml0ID8gdmFsdWUgPT09ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBtYWpvclVuaXQpIDogZmFsc2U7XG5cblx0XHR0aWNrcy5wdXNoKHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdG1ham9yOiBtYWpvclxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyQ0ID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0LyoqXG5cdCAqIERhdGEgZGlzdHJpYnV0aW9uIGFsb25nIHRoZSBzY2FsZTpcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxuXHQgKiAtICdzZXJpZXMnOiBkYXRhIGFyZSBzcHJlYWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGRpc3RyaWJ1dGlvbjogJ2xpbmVhcicsXG5cblx0LyoqXG5cdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG5cdCAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGJvdW5kczogJ2RhdGEnLFxuXG5cdGFkYXB0ZXJzOiB7fSxcblx0dGltZToge1xuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdGZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURUQgZmFsc2UgPT0gZGF0ZSBvYmplY3RzLCBtb21lbnQgb2JqZWN0LCBjYWxsYmFjayBvciBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRkaXNwbGF5Rm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuXHRcdGRpc3BsYXlGb3JtYXRzOiB7fVxuXHR9LFxuXHR0aWNrczoge1xuXHRcdGF1dG9Ta2lwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdHNvdXJjZTogJ2F1dG8nLFxuXG5cdFx0bWFqb3I6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fVxuXHR9XG59O1xuXG52YXIgc2NhbGVfdGltZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lID0gb3B0aW9ucy50aW1lIHx8IChvcHRpb25zLnRpbWUgPSB7fSk7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XG5cblx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0aWYgKHRpbWUuZm9ybWF0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ29wdGlvbnMudGltZS5mb3JtYXQgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgb3B0aW9ucy50aW1lLnBhcnNlci4nKTtcblx0XHR9XG5cblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcblx0XHQvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuXHRcdC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcblx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXG5cdCAqL1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCByYXdWYWx1ZSk7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHR2YXIgdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgJ2RheSc7XG5cdFx0dmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciBkYXRhc2V0cyA9IFtdO1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wO1xuXHRcdHZhciBkYXRhTGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG5cblx0XHQvLyBDb252ZXJ0IGxhYmVscyB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFMYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGRhdGEgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGE7XG5cblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdChkYXRhWzBdKSkge1xuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKG1lLCBkYXRhW2pdKTtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV1bal0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2gobGFiZWxzW2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGgpIHtcblx0XHRcdC8vIFNvcnQgbGFiZWxzICoqYWZ0ZXIqKiBkYXRhIGhhdmUgYmVlbiBjb252ZXJ0ZWRcblx0XHRcdGxhYmVscyA9IGFycmF5VW5pcXVlKGxhYmVscykuc29ydChzb3J0ZXIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4obWluLCBsYWJlbHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcblx0XHR9XG5cblx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdHRpbWVzdGFtcHMgPSBhcnJheVVuaXF1ZSh0aW1lc3RhbXBzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdG1pbiA9IHBhcnNlKG1lLCB0aW1lT3B0cy5taW4pIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgdGltZU9wdHMubWF4KSB8fCBtYXg7XG5cblx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIHNldCBsaW1pdHMgYmFzZWQgb24gdW5pdCB0aW1lIG9wdGlvblxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcblx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl9ob3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0bWUuX3RhYmxlID0gW107XG5cdFx0bWUuX3RpbWVzdGFtcHMgPSB7XG5cdFx0XHRkYXRhOiB0aW1lc3RhbXBzLFxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxuXHRcdFx0bGFiZWxzOiBsYWJlbHNcblx0XHR9O1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xuXG5cdFx0c3dpdGNoIChvcHRpb25zLnRpY2tzLnNvdXJjZSkge1xuXHRcdGNhc2UgJ2RhdGEnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmRhdGE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbHMnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmxhYmVscztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2F1dG8nOlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWUsIG1pbiwgbWF4LCBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbiksIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0bWluID0gdGltZXN0YW1wc1swXTtcblx0XHRcdG1heCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcblx0XHR9XG5cblx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbWluO1xuXHRcdG1lLm1heCA9IG1heDtcblxuXHRcdC8vIFBSSVZBVEVcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCk7XG5cdFx0bWUuX21ham9yVW5pdCA9IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgb3B0aW9ucy5kaXN0cmlidXRpb24pO1xuXHRcdG1lLl9vZmZzZXRzID0gY29tcHV0ZU9mZnNldHMobWUuX3RhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpO1xuXG5cdFx0aWYgKG9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCB0aWNrcywgbWUuX21ham9yVW5pdCk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XG5cdFx0dmFyIHZhbHVlID0gZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5mb3JtYXQodG9UaW1lc3RhbXAobWUsIGxhYmVsKSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja0Zvcm1hdEZ1bmN0aW9uOiBmdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XG5cdFx0dmFyIG1ham9yVW5pdCA9IG1lLl9tYWpvclVuaXQ7XG5cdFx0dmFyIG1ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xuXHRcdHZhciBtYWpvclRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yVW5pdCk7XG5cdFx0dmFyIG1ham9yVGlja09wdHMgPSBvcHRpb25zLnRpY2tzLm1ham9yO1xuXHRcdHZhciBtYWpvciA9IG1ham9yVGlja09wdHMuZW5hYmxlZCAmJiBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGltZSA9PT0gbWFqb3JUaW1lO1xuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWFqb3IgPyBtYWpvclRpY2tPcHRzIDogb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgZm9ybWF0dGVyID0gdmFsdWVPckRlZmF1bHQkYyh0aWNrT3B0cy5jYWxsYmFjaywgdGlja09wdHMudXNlckNhbGxiYWNrKTtcblxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbih0aWNrc1tpXS52YWx1ZSwgaSwgdGlja3MpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc1JldmVyc2UgPSBtZS5vcHRpb25zLnRpY2tzLnJldmVyc2U7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gaXNSZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0IDogaXNSZXZlcnNlID8gbWUuYm90dG9tIDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XG5cdFx0dmFyIG9mZnNldCA9IHNpemUgKiAobWUuX29mZnNldHMuc3RhcnQgKyBwb3MpIC8gKG1lLl9vZmZzZXRzLnN0YXJ0ICsgMSArIG1lLl9vZmZzZXRzLmVuZCk7XG5cblx0XHRyZXR1cm4gaXNSZXZlcnNlID8gc3RhcnQgLSBvZmZzZXQgOiBzdGFydCArIG9mZnNldDtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHR9XG5cblx0XHRpZiAodGltZSA9PT0gbnVsbCkge1xuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldCh0aW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblx0XHRyZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCA/XG5cdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxuXHRcdFx0bnVsbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gbWUubGVmdCA6IG1lLnRvcDtcblx0XHR2YXIgcG9zID0gKHNpemUgPyAocGl4ZWwgLSBzdGFydCkgLyBzaXplIDogMCkgKiAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuc3RhcnQpIC0gbWUuX29mZnNldHMuZW5kO1xuXHRcdHZhciB0aW1lID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XG5cblx0XHQvLyBERVBSRUNBVElPTiwgd2Ugc2hvdWxkIHJldHVybiB0aW1lIGRpcmVjdGx5XG5cdFx0cmV0dXJuIG1lLl9hZGFwdGVyLl9jcmVhdGUodGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b1JhZGlhbnModGlja3NPcHRzLm1heFJvdGF0aW9uKTtcblx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblxuXHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXN0aW1hdGlvblxuXHRcdHZhciBmb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG5cdFx0dmFyIGV4YW1wbGVMYWJlbCA9IG1lLnRpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgW10sIGZvcm1hdCk7XG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuZ2V0TGFiZWxXaWR0aChleGFtcGxlTGFiZWwpO1xuXHRcdHZhciBpbm5lcldpZHRoID0gbWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKGlubmVyV2lkdGggLyB0aWNrTGFiZWxXaWR0aCk7XG5cblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDQgPSBkZWZhdWx0Q29uZmlnJDQ7XG5zY2FsZV90aW1lLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQ0O1xuXG52YXIgc2NhbGVzID0ge1xuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXG5cdGxpbmVhcjogc2NhbGVfbGluZWFyLFxuXHRsb2dhcml0aG1pYzogc2NhbGVfbG9nYXJpdGhtaWMsXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxuXHR0aW1lOiBzY2FsZV90aW1lXG59O1xuXG52YXIgRk9STUFUUyA9IHtcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcblx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJyxcblx0c2Vjb25kOiAnaDptbTpzcyBhJyxcblx0bWludXRlOiAnaDptbSBhJyxcblx0aG91cjogJ2hBJyxcblx0ZGF5OiAnTU1NIEQnLFxuXHR3ZWVrOiAnbGwnLFxuXHRtb250aDogJ01NTSBZWVlZJyxcblx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJyxcblx0eWVhcjogJ1lZWVknXG59O1xuXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG5cdF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRk9STUFUUztcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcblx0XHR9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuXHR9LFxuXG5cdGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihtb21lbnQobWF4KS5kaWZmKG1vbWVudChtaW4pKSkuYXModW5pdCk7XG5cdH0sXG5cblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xuXHRcdHRpbWUgPSBtb21lbnQodGltZSk7XG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xuXHR9LFxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBtYXBwZXJzID0ge1xuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0fTtcblx0fSxcblxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGJvdW5kYXJ5ID0gc291cmNlLmJvdW5kYXJ5O1xuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHR9XG5cblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdHN3aXRjaCAoZmlsbCkge1xuXHQvLyBjb21wYXRpYmlsaXR5XG5cdGNhc2UgJ2JvdHRvbSc6XG5cdFx0cmV0dXJuICdzdGFydCc7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0cmV0dXJuICdlbmQnO1xuXHRjYXNlICd6ZXJvJzpcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdGNhc2UgJ29yaWdpbic6XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0Y2FzZSAnZW5kJzpcblx0XHRyZXR1cm4gZmlsbDtcblx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0YXJnZXQgPSBudWxsO1xuXHR2YXIgaG9yaXpvbnRhbDtcblxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKCk7XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdH1cblxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmICghcHJvcGFnYXRlKSB7XG5cdFx0cmV0dXJuIGZpbGw7XG5cdH1cblxuXHR3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRmaWxsID0gdGFyZ2V0LmZpbGw7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpc0RyYXdhYmxlKHBvaW50KSB7XG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xuXHR2YXIgaTtcblxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdGN0eC5tb3ZlVG8oY3VydmUwWzBdLngsIGN1cnZlMFswXS55KTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2kgLSAxXSwgY3VydmUwW2ldKTtcblx0fVxuXG5cdC8vIGpvaW5pbmcgdGhlIHR3byBhcmVhIGN1cnZlc1xuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGxvb3ApIHtcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHR2YXIgY3VydmUwID0gW107XG5cdHZhciBjdXJ2ZTEgPSBbXTtcblx0dmFyIGxlbjAgPSAwO1xuXHR2YXIgbGVuMSA9IDA7XG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDE7XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoY291bnQgKyAhIWxvb3ApOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aW5kZXggPSBpICUgY291bnQ7XG5cdFx0cDAgPSBwb2ludHNbaW5kZXhdLl92aWV3O1xuXHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcblx0XHRkMSA9IGlzRHJhd2FibGUocDEpO1xuXG5cdFx0aWYgKGQwICYmIGQxKSB7XG5cdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcblx0XHR9IGVsc2UgaWYgKGxlbjAgJiYgbGVuMSkge1xuXHRcdFx0aWYgKCFzcGFuKSB7XG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXHRcdFx0XHRsZW4wID0gbGVuMSA9IDA7XG5cdFx0XHRcdGN1cnZlMCA9IFtdO1xuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkMCkge1xuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZDEpIHtcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0Y3R4LmZpbGwoKTtcbn1cblxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG5cdGlkOiAnZmlsbGVyJyxcblxuXHRhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xuXHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHRzb3VyY2UgPSBudWxsO1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xuXHRcdFx0XHRzb3VyY2UgPSB7XG5cdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXG5cdFx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRcdGVsOiBlbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG5cdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgcHJvcGFnYXRlKTtcblx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVEYXRhc2V0RHJhdzogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcblx0XHR2YXIgbWV0YSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIGVsID0gbWV0YS5lbDtcblx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdHZhciBwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0dmFyIG1hcHBlciA9IG1ldGEubWFwcGVyO1xuXHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuXHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMSA9IGhlbHBlcnMkMS5ub29wO1xudmFyIHZhbHVlT3JEZWZhdWx0JGQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsZWdlbmQ6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0d2VpZ2h0OiAxMDAwLFxuXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxuXHRcdFx0bWV0YS5oaWRkZW4gPSBtZXRhLmhpZGRlbiA9PT0gbnVsbCA/ICFjaS5kYXRhLmRhdGFzZXRzW2luZGV4XS5oaWRkZW4gOiBudWxsO1xuXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcblx0XHRcdGNpLnVwZGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG9uTGVhdmU6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkoZGF0YS5kYXRhc2V0cykgPyBkYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbihkYXRhc2V0LCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6ICghaGVscGVycyQxLmlzQXJyYXkoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IpID8gZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgOiBkYXRhc2V0LmJhY2tncm91bmRDb2xvclswXSksXG5cdFx0XHRcdFx0XHRoaWRkZW46ICFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdFx0bGluZUNhcDogZGF0YXNldC5ib3JkZXJDYXBTdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBkYXRhc2V0LmJvcmRlckRhc2gsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogZGF0YXNldC5ib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRcdFx0bGluZUpvaW46IGRhdGFzZXQuYm9yZGVySm9pblN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBkYXRhc2V0LmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IGRhdGFzZXQuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBkYXRhc2V0LnBvaW50U3R5bGUsXG5cblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IGlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LCB0aGlzKSA6IFtdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3IgKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0aWYgKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpIHtcblx0XHRcdFx0dGV4dC5wdXNoKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdH1cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSB0aGUgbGFiZWwgZm9udCBzaXplXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxuICovXG5mdW5jdGlvbiBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKSB7XG5cdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSAmJiBsYWJlbE9wdHMuYm94V2lkdGggPiBmb250U2l6ZSA/XG5cdFx0Zm9udFNpemUgOlxuXHRcdGxhYmVsT3B0cy5ib3hXaWR0aDtcbn1cblxuLyoqXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXG4gKi9cbnZhciBMZWdlbmQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHR0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHQvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG5cdFx0dGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG5cdFx0Ly8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuXHRcdHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMSxcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXHR9LFxuXHRhZnRlclVwZGF0ZTogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXG5cdGJ1aWxkTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcblx0XHR2YXIgbGVnZW5kSXRlbXMgPSBoZWxwZXJzJDEuY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG5cblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuXHRcdFx0bGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuXHR9LFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXG5cdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblxuXHRcdC8vIFJlc2V0IGhpdCBib3hlc1xuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuXHRcdFx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG5cdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IDA7XG5cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0aWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gdG90YWxIZWlnaHQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgY29sdW1uV2lkdGhzID0gbWUuY29sdW1uV2lkdGhzID0gW107XG5cdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHR2YXIgY3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdHZhciBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCA+IG1pblNpemUuaGVpZ2h0IC0gdlBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcblxuXHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuXHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQxLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSBsZWdlbmQgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZChsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblx0XHRcdHZhciBjdXJzb3I7XG5cblx0XHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBmb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG5cdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5sYWJlbHMgJiYgb3B0cy5sYWJlbHMudXNlUG9pbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHR2YXIgcmFkaXVzID0gYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBib3hXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dmFyIGNlbnRlclkgPSB5ICsgZm9udFNpemUgLyAyO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0XHR2YXIgeExlZnQgPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHg7XG5cdFx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0XHRjdHguZmlsbFRleHQobGVnZW5kSXRlbS50ZXh0LCB4TGVmdCwgeU1pZGRsZSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZEl0ZW0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4TGVmdCArIHRleHRXaWR0aCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbMF0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xuXHRcdFx0XHR2YXIgeCA9IGN1cnNvci54O1xuXHRcdFx0XHR2YXIgeSA9IGN1cnNvci55O1xuXG5cdFx0XHRcdC8vIFVzZSAobWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIGFuZCAobWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgbWUucmlnaHQgYW5kIG1lLmJvdHRvbSBiZWNhdXNlIG1lLndpZHRoIGFuZCBtZS5oZWlnaHRcblx0XHRcdFx0Ly8gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIHNpbmNlIG1lLm1pblNpemUgd2FzIGNhbGN1bGF0ZWRcblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBpdGVtSGVpZ2h0ID4gbWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSB4ICsgbWUuY29sdW1uV2lkdGhzW2N1cnNvci5saW5lXSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3TGVnZW5kQm94KHgsIHksIGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRoaXRib3hlc1tpXS50b3AgPSB5O1xuXG5cdFx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuXHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XG5cblx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdHZhciBob3ZlcmVkSXRlbTtcblxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0cy5vbkxlYXZlICYmIGhvdmVyZWRJdGVtICE9PSBtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xufVxuXG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcblx0aWQ6ICdsZWdlbmQnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBMZWdlbmQsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcblxuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDIgPSBoZWxwZXJzJDEubm9vcDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDIsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDIsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xuXHRcdHZhciBsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHR2YXIgdGV4dFNpemUgPSBkaXNwbGF5ID8gKGxpbmVDb3VudCAqIGZvbnRPcHRzLmxpbmVIZWlnaHQpICsgKG9wdHMucGFkZGluZyAqIDIpIDogMDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gdGV4dFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSB0ZXh0U2l6ZTtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDIsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgdG9wID0gbWUudG9wO1xuXHRcdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xuXHRcdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcblx0XHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xuXHRcdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR0aXRsZVggPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG5cdFx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGl0bGVYID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gbGVmdCArIG9mZnNldCA6IHJpZ2h0IC0gb2Zmc2V0O1xuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdFx0bWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG5cdFx0XHRcdHJvdGF0aW9uID0gTWF0aC5QSSAqIChvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyAtMC41IDogMC41KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xuXHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHRcdHZhciB5ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcblx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdHZhciB0aXRsZSA9IG5ldyBUaXRsZSh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG5cdGlkOiAndGl0bGUnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIHRpdGxlIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBUaXRsZSxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpdGxlT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBwbHVnaW5zID0ge307XG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcbnZhciBsZWdlbmQgPSBwbHVnaW5fbGVnZW5kO1xudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cblxuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycyA9IGhlbHBlcnMkMTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxuY29yZV9oZWxwZXJzKGNvcmVfY29udHJvbGxlcik7XG5cbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xuY29yZV9jb250cm9sbGVyLkFuaW1hdGlvbiA9IGNvcmVfYW5pbWF0aW9uO1xuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmNvcmVfY29udHJvbGxlci5EYXRhc2V0Q29udHJvbGxlciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXI7XG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XG5jb3JlX2NvbnRyb2xsZXIuZWxlbWVudHMgPSBlbGVtZW50cztcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xuY29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZSA9IGNvcmVfc2NhbGVTZXJ2aWNlO1xuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xuXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlLCB0eXBlKSB7XG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XG59KTtcblxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxuXG5cbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xuXG5mb3IgKHZhciBrIGluIHBsdWdpbnMpIHtcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcblx0fVxufVxuXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcbn1cblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5sYXlvdXRTZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxpbmVhclNjYWxlQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcbiAqIGJ5IHNldHRpbmcgdGhlIHR5cGUgaW4gdGhlIGNvbmZpZyAoYG5ldyBDaGFydChpZCwge3R5cGU6ICd7Y2hhcnQtdHlwZX0nfWApLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxuXHRbXG5cdFx0J0JhcicsXG5cdFx0J0J1YmJsZScsXG5cdFx0J0RvdWdobnV0Jyxcblx0XHQnTGluZScsXG5cdFx0J1BvbGFyQXJlYScsXG5cdFx0J1JhZGFyJyxcblx0XHQnU2NhdHRlcidcblx0XSxcblx0ZnVuY3Rpb24oa2xhc3MpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXJba2xhc3NdID0gZnVuY3Rpb24oY3R4LCBjZmcpIHtcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcblx0XHRcdH0pKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5yZXR1cm4gc3JjO1xuXG59KSkpO1xuIiwiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJ0KGNoYXJ0SWQsIGNoYXJ0VHlwZSkge1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgY2xhc3M6IHRoaXMuY3NzQ2xhc3Nlc1xuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5jaGFydElkLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnY2FudmFzJ1xuICAgICAgfSldKTtcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGFydElkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGNoYXJ0SWQsXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgY3NzQ2xhc3Nlczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9jaGFydDogbnVsbCxcbiAgICAgICAgX3BsdWdpbnM6IHRoaXMucGx1Z2luc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGFkZFBsdWdpbjogZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgICB0aGlzLiRkYXRhLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24gZ2VuZXJhdGVMZWdlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRkYXRhLl9jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uIHJlbmRlckNoYXJ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuJHJlZnMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHtcbiAgICAgICAgICB0eXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgIHBsdWdpbnM6IHRoaXMuJGRhdGEuX3BsdWdpbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgdmFyIEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2Jhci1jaGFydCcsICdiYXInKTtcbmV4cG9ydCB2YXIgSG9yaXpvbnRhbEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2hvcml6b250YWxiYXItY2hhcnQnLCAnaG9yaXpvbnRhbEJhcicpO1xuZXhwb3J0IHZhciBEb3VnaG51dCA9IGdlbmVyYXRlQ2hhcnQoJ2RvdWdobnV0LWNoYXJ0JywgJ2RvdWdobnV0Jyk7XG5leHBvcnQgdmFyIExpbmUgPSBnZW5lcmF0ZUNoYXJ0KCdsaW5lLWNoYXJ0JywgJ2xpbmUnKTtcbmV4cG9ydCB2YXIgUGllID0gZ2VuZXJhdGVDaGFydCgncGllLWNoYXJ0JywgJ3BpZScpO1xuZXhwb3J0IHZhciBQb2xhckFyZWEgPSBnZW5lcmF0ZUNoYXJ0KCdwb2xhci1jaGFydCcsICdwb2xhckFyZWEnKTtcbmV4cG9ydCB2YXIgUmFkYXIgPSBnZW5lcmF0ZUNoYXJ0KCdyYWRhci1jaGFydCcsICdyYWRhcicpO1xuZXhwb3J0IHZhciBCdWJibGUgPSBnZW5lcmF0ZUNoYXJ0KCdidWJibGUtY2hhcnQnLCAnYnViYmxlJyk7XG5leHBvcnQgdmFyIFNjYXR0ZXIgPSBnZW5lcmF0ZUNoYXJ0KCdzY2F0dGVyLWNoYXJ0JywgJ3NjYXR0ZXInKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmFyOiBCYXIsXG4gIEhvcml6b250YWxCYXI6IEhvcml6b250YWxCYXIsXG4gIERvdWdobnV0OiBEb3VnaG51dCxcbiAgTGluZTogTGluZSxcbiAgUGllOiBQaWUsXG4gIFBvbGFyQXJlYTogUG9sYXJBcmVhLFxuICBSYWRhcjogUmFkYXIsXG4gIEJ1YmJsZTogQnViYmxlLFxuICBTY2F0dGVyOiBTY2F0dGVyXG59OyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjaGFydExhYmVscyA9IFsnMTk4MCcsICcxOTkwJywgJzIwMDAnLCAnMjAxMCcsICcyMDIwJ107XG5cbmNvbnN0IGNoYXJ0RGF0YUxpc3QgPSBbNjU0MjU2NCwgNzMyMjU2NCwgODAwODI3OCwgODE3NTEzMywgNTQ3NTEzM107XG5cbmNvbnN0IENoYXJ0RGF0YSA9IHtcbiAgZGF0YToge1xuICAgIGxhYmVsczogY2hhcnRMYWJlbHMsXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtcbiAgICAgICAgZGF0YTogY2hhcnREYXRhTGlzdCxcbiAgICAgICAgZmlsbDogZmFsc2UsIC8vIHVzZWQgYnkgbGluZSBjaGFydFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAnIzJGMzM0RicsXG4gICAgICAgICAgJyMzMTU1QTYnLFxuICAgICAgICAgICcjRjI2OTVEJyxcbiAgICAgICAgICAnI0VCQkNEOCcsXG4gICAgICAgICAgJyNGOUExMzcnLFxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgICcjQUNBRUI5J1xuICAgICAgICBdLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSxcbiAgICBdXG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWxCYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1llYXJzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAyNSxcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2Jhcic7XG5cbmNsYXNzIENoYXJ0QmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSG9yaXpvbnRhbEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogSG9yaXpvbnRhbEJhcixcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWhvcml6b250YWwtYmFyLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdob3Jpem9udGFsLWJhcic7XG5cbmNsYXNzIENoYXJ0SG9yaXpvbnRhbEJhciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5ob3Jpem9udGFsQmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEhvcml6b250YWxCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgTGluZSwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogTGluZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWxpbmUudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2xpbmUnO1xuXG5jbGFzcyBDaGFydExpbmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydExpbmU7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgUGllLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBQaWUsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLXBpZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAncGllJztcblxuY2xhc3MgQ2hhcnRQaWUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEucGllLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydFBpZTsiLCI8dGVtcGxhdGU+PC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiB7XG4gICAgICAnbGF5ZXJzJzoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgICdjb25maWcnOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgbWFwUG9wdXA6IG51bGwsXG4gICAgICAgIG1hcEZpbHRlcjogbnVsbCxcbiAgICAgICAgYWN0aXZlTGF5ZXI6IG51bGwsXG4gICAgICAgIG1hcExvYWRlZDogZmFsc2UsXG4gICAgICAgIG1lbnVJdGVtczogW10sXG4gICAgICAgIHNlbGVjdGVkSXRlbXM6IFtdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVNYXAoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgIHRoaXMubWFwLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICdsYXllcnMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgdGhpcy50cmFja0xheWVyKGxheWVyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXIuZGVmYXVsdCB8fCB0aGlzLmxheWVycy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGF5ZXIgPSBsYXllci5uYW1lO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpXG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuXG4gICAgICAgICAgdGhpcy5hY3RpdmVMYXllciA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUxlZ2VuZChsYXllci5kYXRhKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZClcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWFwTG9hZGVkJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQgJiYgdGhpcy5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5ZXIobGF5ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWVudUl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51SXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVUb2dnbGUodGhpcy5tZW51SXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdzZWxlY3RlZEl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBbJ2luJywgbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbHRlci5wdXNoKHRoaXMuc2VsZWN0ZWRJdGVtc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCByZWxhdGVkRmVhdHVyZXMgPSB0aGlzLm1hcC5xdWVyeVNvdXJjZUZlYXR1cmVzKGxheWVyLm5hbWUsIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHNldCBmaWx0ZXIgd2hlbiBsZWdlbmQgaXRlbSBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMubWFwLnNldEZpbHRlcihgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsIGZpbHRlcik7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggJiYgIXRoaXMubWFwUG9wdXApIHtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRGaWx0ZXIoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCBudWxsKTtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGluaXRpYWxpemVNYXAoKSB7XG4gICAgICAgIGNvbnN0IG1hcENvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogbWFwQ29uZmlnLmNvbnRhaW5lcklkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBDb25maWcuY2VudGVyKVxuICAgICAgICAgIG9wdGlvbnMuY2VudGVyID0gbWFwQ29uZmlnLmNlbnRlcjtcblxuICAgICAgICBpZiAobWFwQ29uZmlnLnN0eWxlKVxuICAgICAgICAgIG9wdGlvbnMuc3R5bGUgPSBtYXBDb25maWcuc3R5bGU7XG5cbiAgICAgICAgaWYgKG1hcENvbmZpZy56b29tKVxuICAgICAgICAgIG9wdGlvbnMuem9vbSA9IG1hcENvbmZpZy56b29tO1xuXG4gICAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gbWFwQ29uZmlnLkFQSUtleTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgbWFwYm94Z2wuTWFwKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5OYXZpZ2F0aW9uQ29udHJvbCgpKTtcblxuICAgICAgICAvLyBkaXNhYmxlIG1hcCB6b29tIHdoZW4gdXNpbmcgc2Nyb2xsXG4gICAgICAgIGlmIChtYXBDb25maWcuZGlzYWJsZVNjcm9sbClcbiAgICAgICAgICB0aGlzLm1hcC5zY3JvbGxab29tLmRpc2FibGUoKTtcblxuICAgICAgICB0aGlzLm1hcC5vbignbG9hZCcsICgpID0+IHRoaXMubWFwTG9hZGVkID0gdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcC5nZXRMYXllcihsYXllci5uYW1lKSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5lbnRyaWVzKGxheWVyLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBsYXllci5uYW1lID09PSB0aGlzLmFjdGl2ZUxheWVyID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGxheWVyLmZpbHRlckJ5ID8gWydpbicsIGxheWVyLmZpbHRlckJ5LCAnJ10gOiBbXTtcbiAgICAgICAgICBjb25zdCBmaWxsID0gdGhpcy5jb25maWcuY29sb3JzID8gdGhpcy5nZW5lcmF0ZUZpbGxDb2xvcih0aGlzLmNvbmZpZy5jb2xvcnMpIDogbGF5ZXIuZmlsbDtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZFNvdXJjZShsYXllci5uYW1lLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdnZW9qc29uJyxcbiAgICAgICAgICAgICdkYXRhJzogbGF5ZXIuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLjdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IHZpc2liaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IGZpbHRlcixcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogdmlzaWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplRmlsdGVyKGxheWVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnNvck9uSG92ZXIobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplUG9wdXAoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnBvcHVwTXVsdGlMYXllcihldmVudCwgbGF5ZXIpIDogdGhpcy5wb3B1cFNpbmdsZUxheWVyKGV2ZW50LCBsYXllcik7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZVRvZ2dsZSh0b2dnbGVMaXN0KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnRvZ2dsZU11bHRpTGF5ZXIodG9nZ2xlTGlzdCkgOiB0aGlzLnRvZ2dsZVNpbmdsZUxheWVyKHRvZ2dsZUxpc3QpO1xuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVGaWx0ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ211bHRpJyA/IHRoaXMuZmlsdGVyTXVsdGlMYXllcihsYXllcikgOiB0aGlzLmZpbHRlclNpbmdsZUxheWVyKGxheWVyKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDdXJzb3JPbkhvdmVyKGxheWVySWQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5tYXA7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgdG8gYSBwb2ludGVyIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGxheWVyLlxuICAgICAgICBtYXAub24oJ21vdXNlZW50ZXInLCBsYXllcklkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgZGVmYXVsdCB3aGVuIGl0IGxlYXZlcyB0aGUgbGF5ZXIuXG4gICAgICAgIG1hcC5vbignbW91c2VsZWF2ZScsIGxheWVySWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlRmlsbENvbG9yKGNvbG9ycykge1xuICAgICAgICByZXR1cm4gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbiAgICAgIH0sXG4gICAgICAvLyBtdWx0aSBsYXllclxuICAgICAgdHJhY2tMYXllcihyZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhyZWZlcmVuY2UpKVxuICAgICAgICAgIHRoaXMubWVudUl0ZW1zLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgIH0sXG4gICAgICBwb3B1cE11bHRpTGF5ZXIoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBsYXllck5hbWUgPSBgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGA7XG4gICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRMbmdMYXQoZXZlbnQubG5nTGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEhUTUwoZXZlbnQuZmVhdHVyZXNbMF0ucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVG8obWFwKTtcblxuICAgICAgICBpZiAocG9wdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IHBvcHVwO1xuICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsIG51bGwpO1xuICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyTXVsdGlMYXllcihsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcblxuICAgICAgICBtYXAub24oJ2NsaWNrJywgbGF5ZXIubmFtZSwgKGUpID0+IHtcbiAgICAgICAgICAvLyBzZXQgYmJveCBhcyByZWFjdGFuZ2xlIGFyZWEgYXJvdW5kIGNsaWNrZWQgcG9pbnRcbiAgICAgICAgICBsZXQgYmJveCA9IFtbZS5wb2ludC54LCBlLnBvaW50LnldLCBbZS5wb2ludC54LCBlLnBvaW50LnldXTtcbiAgICAgICAgICBsZXQgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHsgbGF5ZXJzOiBbbGF5ZXIubmFtZV0gfSk7XG5cbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZmVhdHVyZSkge1xuICAgICAgICAgICAgbWVtby5wdXNoKGZlYXR1cmUucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgWydpbicsIGAke2xheWVyLmZpbHRlckJ5fWBdKTtcblxuICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAkdGhpcy5pbml0aWFsaXplUG9wdXAoZSwgbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVNdWx0aUxheWVyKGxheWVyc1RvVG9nZ2xlKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBhY3RpdmVMYXllciA9ICR0aGlzLmFjdGl2ZUxheWVyO1xuICAgICAgICBjb25zdCBsaW5rQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcubGVnZW5kSWQpO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBsaW5rcyBiZWZvcmUgYXBwZW5kaW5nIG5ldyBvbmVzIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICB3aGlsZSAobGlua0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgbGlua0NvbnRhaW5lci5yZW1vdmVDaGlsZChsaW5rQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnNUb1RvZ2dsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVmID0gbGF5ZXJzVG9Ub2dnbGVbaV07XG4gICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICAgIGxpbmsuaHJlZiA9ICcjJztcbiAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gbGF5ZXJSZWY7XG5cbiAgICAgICAgICBpZiAobGF5ZXJSZWYgPT09IGFjdGl2ZUxheWVyKVxuICAgICAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgICAgICAgIC8vIG9uIGNsaWNrIHVwZGF0ZSBsaW5rIHN0YXRlLCBhY3RpdmUgbGF5ZXIgcmVmZXJlbmNlLCBhbmQgbGF5ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIGxpbmsub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZExheWVyID0gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gbGlua0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgYWN0aXZlIHBvcHVwXG4gICAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXApXG4gICAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5rID0gbGlua3NbaV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IGN1cnJlbnRMaW5rLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5ZXJIaWdobGlnaHQgPSBgJHtjdXJyZW50TGF5ZXJ9LWhpZ2hsaWdodGVkYDtcbiAgICAgICAgICAgICAgY29uc3QgbGF5ZXJWaXNpYmlsaXR5ID0gbWFwLmdldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknKTtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyID09PSBzZWxlY3RlZExheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGlmIGxheWVyIGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJWaXNpYmlsaXR5ID09PSAndmlzaWJsZScgJiYgY3VycmVudExpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBvdXIgY3VycmVudCBsYXllciBhcyB0aGUgZ2xvYmFsIGFjdGl2ZSBsYXllcixcbiAgICAgICAgICAgICAgICAvLyBhZGQgYWN0aXZlIGNsYXNzIHRvIGxpbmssIHNldCBsYXllciBhcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgJHRoaXMuYWN0aXZlTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaW5rcyBhY3RpdmUgY2xhc3MsIHNldCBsYXllciB2aXNpYmlsaXR5IHRvIG5vbmUgYW5kIHJlbW92ZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXJIaWdobGlnaHQsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGN1cnJlbnRMYXllckhpZ2hsaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGlua0NvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHNpbmdsZSBsYXllclxuICAgICAgZ2VuZXJhdGVMZWdlbmQobGF5ZXJEYXRhKSB7XG4gICAgICAgIGxheWVyRGF0YS5mZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGZlYXR1cmUucHJvcGVydGllc1t0aGlzLmxheWVyc1swXS5sZWdlbmRDb2x1bW5dO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhpdGVtKSAmJiBpdGVtKVxuICAgICAgICAgICAgdGhpcy5tZW51SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcG9wdXBTaW5nbGVMYXllcihldmVudCwgbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYDtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHNoYXBlIGZhbGxzIHVuZGVyIGN1cnJlbnQgbGVnZW5kIHNlbGVjdGlvblxuICAgICAgICBsZXQgaW5DdXJyZW50U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IGNvbHVtbkZpbHRlciA9IGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoY29sdW1uRmlsdGVyKSlcbiAgICAgICAgICBpbkN1cnJlbnRTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0TG5nTGF0KGV2ZW50LmxuZ0xhdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRIVE1MKGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRvKG1hcCk7XG5cbiAgICAgICAgaWYgKHBvcHVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBwb3B1cDtcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBsZWdlbmQgaXRlbXMgc2VsZWN0ZWQsIGhpZ2hsaWdodCBzZWxlY3RlZCBtYXAgc2hhcGVcbiAgICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbGVnZW5kIGl0ZW1zIHNlbGVjdGVkIGFuZCBzZWxlY3RlZCBtYXAgc2hhcGUgaXNuJ3RcbiAgICAgICAgICAvLyB3aXRoaW4gYW55IG9mIHRoZSBzZWxlY3RlZCBsZWdlbmQgaXRlbXMsIGhpZ2hsaWdodCBzZWxlY3RlZFxuICAgICAgICAgIC8vIG1hcCBzaGFwZSBhbmQgY2xlYXIgbGVnZW5kXG4gICAgICAgICAgaWYgKCR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCAmJiAhaW5DdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGNoZWNrZWQgbGVnZW5kIGl0ZW1zXG4gICAgICAgICAgICAkdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJHcm91cElucHV0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29uZmlnLmxlZ2VuZElkKS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpjaGVja2VkJyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyR3JvdXBJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZmlsdGVyR3JvdXBJbnB1dHNbaV0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbGVnZW5kIGl0ZW1zIHNlbGVjdGVkLCByZXNldCBhbGwgZmlsdGVyc1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlclNpbmdsZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuXG4gICAgICAgIG1hcC5vbignY2xpY2snLCBsYXllci5uYW1lLCAoZSkgPT4ge1xuICAgICAgICAgIC8vIHNldCBiYm94IGFzIHJlYWN0YW5nbGUgYXJlYSBhcm91bmQgY2xpY2tlZCBwb2ludFxuICAgICAgICAgIGxldCBiYm94ID0gW1tlLnBvaW50LngsIGUucG9pbnQueV0sIFtlLnBvaW50LngsIGUucG9pbnQueV1dO1xuICAgICAgICAgIGxldCBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCwgeyBsYXllcnM6IFtsYXllci5uYW1lXSB9KTtcbiAgICAgICAgICBsZXQgbGVnZW5kQ29sdW1uVmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbHVtblZhbHVlID0gZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmxlZ2VuZENvbHVtbl07XG4gICAgICAgICAgICBtZW1vLnB1c2goZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCBbJ2luJywgYCR7bGF5ZXIuZmlsdGVyQnl9YF0pO1xuXG4gICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICR0aGlzLmluaXRpYWxpemVQb3B1cChlLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVNpbmdsZUxheWVyKGZpbHRlcnNUb1RvZ2dsZSkge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgZmlsdGVyR3JvdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5sZWdlbmRJZCk7XG5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSAkdGhpcy5sYXllcnNbMF07XG4gICAgICAgIGNvbnN0IGxlZ2VuZENvbHVtbiA9IGxheWVyLmxlZ2VuZENvbHVtbjtcblxuICAgICAgICAvLyBjbGVhciBhbGwgbGlua3MgYmVmb3JlIGFwcGVuZGluZyBuZXcgb25lcyB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgd2hpbGUgKGZpbHRlckdyb3VwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBmaWx0ZXJHcm91cC5yZW1vdmVDaGlsZChmaWx0ZXJHcm91cC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpbGl6ZSBhbiBpbnB1dCBlbGVtZW50IGZvciBlYWNoIGZpbHRlciB0eXBlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyc1RvVG9nZ2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJSZWYgPSBmaWx0ZXJzVG9Ub2dnbGVbaV07XG5cbiAgICAgICAgICAvLyBjaGVja2JveFxuICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICBpbnB1dC5pZCA9IGxheWVyUmVmO1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gbGF5ZXJSZWY7XG4gICAgICAgICAgZmlsdGVyR3JvdXAuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgLy8gY2hlY2tib3ggbGFiZWxcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBsYXllclJlZik7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxheWVyUmVmKTtcbiAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGxheWVyUmVmO1xuICAgICAgICAgIGZpbHRlckdyb3VwLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICAgIC8vIHdoZW4gdGhlIGNoZWNrYm94IGNoYW5nZXMgc3RhdGUsIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgaXRlbXMgYXJyYXkuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgY2hlY2tib3hlcyBjaGVja2VkIHN0YXRlXG4gICAgICAgICAgICBlLnRhcmdldC5jaGVja2VkID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgcG9wdXAgaWYgb25lIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwKVxuICAgICAgICAgICAgICAkdGhpcy5tYXBQb3B1cC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQgJiYgISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpXG4gICAgICAgICAgICAgICR0aGlzLnNlbGVjdGVkSXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5jaGVja2VkICYmICR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgJHRoaXMuc2VsZWN0ZWRJdGVtcyA9ICR0aGlzLnNlbGVjdGVkSXRlbXMuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSBpdGVtO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbjwvc2NyaXB0PiIsIi8qKlxuICogQ29uZmlnXG4gKi9cblxuY29uc3Qgbnljb0NvbG9ycyA9IHtcbiAgY29sb3JzOiB7XG4gICAgJ3ByaW1hcnktbmF2eSc6ICcjMkYzMzRGJyxcbiAgICAncHJpbWFyeS1uYXZ5LTcwdCc6ICcjNkU3MDg1JyxcbiAgICAncHJpbWFyeS1uYXZ5LTUwdCc6ICcjOTY5OEE3JyxcbiAgICAncHJpbWFyeS1uYXZ5LTMwdCc6ICcjQzBDMkNBJyxcbiAgICAncHJpbWFyeS1ibHVlJzogJyMzMTU1QTYnLFxuICAgICdwcmltYXJ5LWJsdWUtNzB0JzogJyM2Qzg4QzEnLFxuICAgICdwcmltYXJ5LWJsdWUtNTB0JzogJyM5NkFCRDInLFxuICAgICdwcmltYXJ5LWJsdWUtMzB0JzogJyNDMENDRTMnLFxuICAgICdwcmltYXJ5LXJlZCc6ICcjRjI2OTVEJyxcbiAgICAncHJpbWFyeS1yZWQtNzB0JzogJyNGNjk1OEQnLFxuICAgICdwcmltYXJ5LXJlZC01MHQnOiAnI0Y4QjJBRCcsXG4gICAgJ3ByaW1hcnktcmVkLTMwdCc6ICcjRkJEMUNFJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXknOiAnI0FDQUVCOScsXG4gICAgJ3NlY29uZGFyeS1ncmV5LTcwdCc6ICcjQzRDNkNEJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXktNTB0JzogJyNENUQ2REMnLFxuICAgICdzZWNvbmRhcnktZ3JleS0zMHQnOiAnI0U4RTdFOScsXG4gICAgJ3NlY29uZGFyeS13aGl0ZSc6ICcjRjNGM0YzJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTcwdCc6ICcjRjZGNkY2JyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTUwdCc6ICcjRjlGOUZBJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTMwdCc6ICcjRkJGQ0ZDJyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZSc6ICcjRjlBMTM3JyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZS03MHQnOiAnI0ZGQTEzMycsXG4gICAgJ3NlY29uZGFyeS1vcmFuZ2UtNTB0JzogJyNGRUQwOUEnLFxuICAgICdzZWNvbmRhcnktb3JhbmdlLTMwdCc6ICcjRkZFM0MyJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmsnOiAnI0VCQkNEOCcsXG4gICAgJ3NlY29uZGFyeS1waW5rLTcwdCc6ICcjRjJEMEUzJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmstNTB0JzogJyNGN0RERUInLFxuICAgICdzZWNvbmRhcnktcGluay0zMHQnOiAnI0ZERUJGMycsXG4gICAgJ2Jhc2UtYmxhY2snOiAnIzAwMDAwMCcsXG4gICAgJ2Jhc2Utd2hpdGUnOiAnI0ZGRkZGRidcbiAgfSxcbiAgY29sb3JDb21iaW5hdGlvbnM6IHtcbiAgICAnbGlnaHQtYmFja2dyb3VuZCc6IHtcbiAgICAgICdjb2xvcic6ICdiYXNlLWJsYWNrJyxcbiAgICAgICdoZWFkaW5ncyc6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2h5cGVybGlua3MnOiAncHJpbWFyeS1ibHVlJyxcbiAgICAgICd2aXNpdGVkJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAnaG92ZXInOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2JvcmRlcic6ICdzZWNvbmRhcnktZ3JleScsXG4gICAgICAncGxhY2Vob2xkZXInOiAnc2Vjb25kYXJ5LWdyZXknLFxuICAgICAgJ2NoZWNrYm94LWJhY2tncm91bmQnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdlcnJvcic6ICdwcmltYXJ5LXJlZCcsXG4gICAgfSxcbiAgICAnbWlkLWJhY2tncm91bmQnOiB7XG4gICAgICAnY29sb3InOiAnYmFzZS1ibGFjaycsXG4gICAgICAnaGVhZGluZ3MnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAndmlzaXRlZCc6ICdwcmltYXJ5LWJsdWUnLFxuICAgICAgJ2hvdmVyJzogJ3ByaW1hcnktbmF2eScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdzZWNvbmRhcnktd2hpdGUnXG4gICAgfSxcbiAgICAnZGFyay1iYWNrZ3JvdW5kJzoge1xuICAgICAgJ2NvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2ZvbnQtc21vb3RoJzogdHJ1ZSxcbiAgICAgICdoZWFkaW5ncyc6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ3Zpc2l0ZWQnOiAnYmFzZS13aGl0ZScsXG4gICAgICAnaG92ZXInOiAnYmFzZS13aGl0ZScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdwcmltYXJ5LW5hdnknXG4gICAgfSxcbiAgICAncHJpbWFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1ibHVlJ1xuICAgIH0sXG4gICAgJ3NlY29uZGFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1yZWQnXG4gICAgfVxuICB9LFxufTtcblxuY29uc3QgY29sb3IgPSBueWNvQ29sb3JzLmNvbG9ycztcbmNvbnN0IG1hcENvbG9yQ29tYmluYXRpb25zID0gW1xuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsncHJpbWFyeS1uYXZ5LTcwdCddXSxcbiAgW2NvbG9yWydiYXNlLWJsYWNrJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsnc2Vjb25kYXJ5LWdyZXknXV0sXG4gIFtjb2xvclsncHJpbWFyeS1ibHVlJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG55Y29Db2xvcnMsXG4gIG1hcENvbG9yQ29tYmluYXRpb25zXG59OyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgbWFwQ29sb3JDb21iaW5hdGlvbnMgfSBmcm9tICcuLi8uLi9jb25maWcvY29sb3JzJztcblxuY29uc3QgTWFwRGF0YSA9IHtcbiAgc2luZ2xlOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1zbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLWxlZ2VuZCcsXG4gICAgICBjZW50ZXI6IFstNzMuOTg2NzEwLCA0MC42OTMzOTFdLFxuICAgICAgem9vbTogOSxcbiAgICAgIGRpc2FibGVTY3JvbGw6IHRydWUsXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ3NpbmdsZSdcbiAgICB9XG4gIH0sXG4gIG11bHRpOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1tbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLW1lbnUnLFxuICAgICAgY2VudGVyOiBbLTczLjk4NjcxMCwgNDAuNjkzMzkxXSxcbiAgICAgIHpvb206IDksXG4gICAgICBkaXNhYmxlU2Nyb2xsOiB0cnVlLFxuICAgICAgc3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbnljby1wcm9kdWN0cy9janY2d2pxODgxMnlzMWdwMzltbnZ1azJ3JyxcbiAgICAgIG1hcFR5cGU6ICdtdWx0aScsXG4gICAgICBjb2xvcnM6IG1hcENvbG9yQ29tYmluYXRpb25zXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcERhdGE7IiwiKGZ1bmN0aW9uKEdlb0pTT04pIHtcbiAgR2VvSlNPTi52ZXJzaW9uID0gJzAuNS4wJztcblxuICAvLyBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gIEdlb0pTT04uZGVmYXVsdHMgPSB7XG4gICAgZG9UaHJvd3M6IHtcbiAgICAgIGludmFsaWRHZW9tZXRyeTogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSW52YWxpZEdlb21ldHJ5RXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICB2YXIgaXRlbSA9IGFyZ3Muc2hpZnQoKTtcbiAgICB2YXIgcGFyYW1zID0gYXJncy5zaGlmdCgpO1xuXG4gICAgRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlIHx8IFwiSW52YWxpZCBHZW9tZXRyeTogXCIgKyAnaXRlbTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pICsgJywgcGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgfVxuXG4gIEludmFsaWRHZW9tZXRyeUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG5cbiAgR2VvSlNPTi5lcnJvcnMgPSB7XG4gICAgSW52YWxpZEdlb21ldHJ5RXJyb3I6IEludmFsaWRHZW9tZXRyeUVycm9yXG4gIH07XG5cbiAgLy9leHBvc2luZyBzbyB0aGlzIGNhbiBiZSBvdmVycmlkZW4gbWF5YmUgYnkgZ2VvanNvbi12YWxpZGF0aW9uIG9yIHRoZSBsaWtlXG4gIEdlb0pTT04uaXNHZW9tZXRyeVZhbGlkID0gZnVuY3Rpb24oZ2VvbWV0cnkpe1xuICAgIGlmKCFnZW9tZXRyeSB8fCAhT2JqZWN0LmtleXMoZ2VvbWV0cnkpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiAhIWdlb21ldHJ5LnR5cGUgJiYgISFnZW9tZXRyeS5jb29yZGluYXRlcyAmJiBBcnJheS5pc0FycmF5KGdlb21ldHJ5LmNvb3JkaW5hdGVzKSAmJiAhIWdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgfTtcblxuICAvLyBUaGUgb25lIGFuZCBvbmx5IHB1YmxpYyBmdW5jdGlvbi5cbiAgLy8gQ29udmVydHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgR2VvSlNPTiBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgR2VvSlNPTi5wYXJzZSA9IGZ1bmN0aW9uKG9iamVjdHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2VvanNvbixcbiAgICAgICAgc2V0dGluZ3MgPSBhcHBseURlZmF1bHRzKHBhcmFtcywgdGhpcy5kZWZhdWx0cyksXG4gICAgICAgIHByb3BGdW5jO1xuXG4gICAgZ2VvbUF0dHJzLmxlbmd0aCA9IDA7IC8vIFJlc2V0IHRoZSBsaXN0IG9mIGdlb21ldHJ5IGZpZWxkc1xuICAgIHNldEdlb20oc2V0dGluZ3MpO1xuICAgIHByb3BGdW5jID0gZ2V0UHJvcEZ1bmN0aW9uKHNldHRpbmdzKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdHMpKSB7XG4gICAgICBnZW9qc29uID0ge1widHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIFwiZmVhdHVyZXNcIjogW119O1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goZ2V0RmVhdHVyZSh7aXRlbTppdGVtLCBwYXJhbXM6IHNldHRpbmdzLCBwcm9wRnVuYzpwcm9wRnVuY30pKTtcbiAgICAgIH0pO1xuICAgICAgYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvanNvbiA9IGdldEZlYXR1cmUoe2l0ZW06b2JqZWN0cywgcGFyYW1zOiBzZXR0aW5ncywgcHJvcEZ1bmM6cHJvcEZ1bmN9KTtcbiAgICAgIGFkZE9wdGlvbmFscyhnZW9qc29uLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2soZ2VvanNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW9qc29uO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIHZhciBnZW9tcyA9IFsnUG9pbnQnLCAnTXVsdGlQb2ludCcsICdMaW5lU3RyaW5nJywgJ011bHRpTGluZVN0cmluZycsICdQb2x5Z29uJywgJ011bHRpUG9seWdvbicsICdHZW9KU09OJ10sXG4gICAgICBnZW9tQXR0cnMgPSBbXTtcblxuICAvLyBBZGRzIGRlZmF1bHQgc2V0dGluZ3MgdG8gdXNlci1zcGVjaWZpZWQgcGFyYW1zXG4gIC8vIERvZXMgbm90IG92ZXJ3cml0ZSBhbnkgc2V0dGluZ3MtLW9ubHkgYWRkcyBkZWZhdWx0c1xuICAvLyB0aGUgdGhlIHVzZXIgZGlkIG5vdCBzcGVjaWZ5XG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMocGFyYW1zLCBkZWZhdWx0cykge1xuICAgIHZhciBzZXR0aW5ncyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGZvcih2YXIgc2V0dGluZyBpbiBkZWZhdWx0cykge1xuICAgICAgaWYoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoc2V0dGluZykgJiYgIXNldHRpbmdzW3NldHRpbmddKSB7XG4gICAgICAgIHNldHRpbmdzW3NldHRpbmddID0gZGVmYXVsdHNbc2V0dGluZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG5cbiAgLy8gQWRkcyB0aGUgb3B0aW9uYWwgR2VvSlNPTiBwcm9wZXJ0aWVzIGNycyBhbmQgYmJveFxuICAvLyBpZiB0aGV5IGhhdmUgYmVlbiBzcGVjaWZpZWRcbiAgZnVuY3Rpb24gYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKXtcbiAgICBpZihzZXR0aW5ncy5jcnMgJiYgY2hlY2tDUlMoc2V0dGluZ3MuY3JzKSkge1xuICAgICAgaWYoc2V0dGluZ3MuaXNQb3N0Z3JlcylcbiAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jcnMgPSBzZXR0aW5ncy5jcnM7XG4gICAgICBlbHNlXG4gICAgICAgIGdlb2pzb24uY3JzID0gc2V0dGluZ3MuY3JzO1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MuYmJveCkge1xuICAgICAgZ2VvanNvbi5iYm94ID0gc2V0dGluZ3MuYmJveDtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmV4dHJhR2xvYmFsKSB7XG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzZXR0aW5ncy5leHRyYUdsb2JhbCkge1xuICAgICAgICBnZW9qc29uLnByb3BlcnRpZXNba2V5XSA9IHNldHRpbmdzLmV4dHJhR2xvYmFsW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cnVjdHVyZSBvZiBDUlMgb2JqZWN0IGlzIHZhbGlkXG4gIGZ1bmN0aW9uIGNoZWNrQ1JTKGNycykge1xuICAgIGlmIChjcnMudHlwZSA9PT0gJ25hbWUnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDUlMuIFByb3BlcnRpZXMgbXVzdCBjb250YWluIFwibmFtZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChjcnMudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5ocmVmICYmIGNycy5wcm9wZXJ0aWVzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENSUy4gUHJvcGVydGllcyBtdXN0IGNvbnRhaW4gXCJocmVmXCIgYW5kIFwidHlwZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgQ1JTLiBUeXBlIGF0dHJpYnV0ZSBtdXN0IGJlIFwibmFtZVwiIG9yIFwibGlua1wiJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZXMgdGhlIHVzZXItc3BlY2lmaWVkIGdlb21ldHJ5IHBhcmFtZXRlcnNcbiAgLy8gdW5kZXIgdGhlIGBnZW9tYCBrZXkgaW4gcGFyYW0gZm9yIGVhc2llciBhY2Nlc3NcbiAgZnVuY3Rpb24gc2V0R2VvbShwYXJhbXMpIHtcbiAgICBwYXJhbXMuZ2VvbSA9IHt9O1xuXG4gICAgZm9yKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkgJiYgZ2VvbXMuaW5kZXhPZihwYXJhbSkgIT09IC0xKXtcbiAgICAgICAgcGFyYW1zLmdlb21bcGFyYW1dID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgZGVsZXRlIHBhcmFtc1twYXJhbV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0R2VvbUF0dHJMaXN0KHBhcmFtcy5nZW9tKTtcbiAgfVxuXG4gIC8vIEFkZHMgZmllbGRzIHdoaWNoIGNvbnRhaW4gZ2VvbWV0cnkgZGF0YVxuICAvLyB0byBnZW9tQXR0cnMuIFRoaXMgbGlzdCBpcyB1c2VkIHdoZW4gYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gdGhlIGZlYXR1cmVzIHNvIHRoYXQgbm8gZ2VvbWV0cnlcbiAgLy8gZmllbGRzIGFyZSBhZGRlZCB0aGUgcHJvcGVydGllcyBrZXlcbiAgZnVuY3Rpb24gc2V0R2VvbUF0dHJMaXN0KHBhcmFtcykge1xuICAgIGZvcih2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgIGlmKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGdlb21BdHRycy5wdXNoKHBhcmFtc1twYXJhbV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnb2JqZWN0JykgeyAvLyBBcnJheSBvZiBjb29yZGluYXRlcyBmb3IgUG9pbnRcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzBdKTtcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGdlb21BdHRycy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyeSBhdHRyaWJ1dGVzIHNwZWNpZmllZCcpOyB9XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgZmVhdHVyZSBvYmplY3QgdG8gYmUgYWRkZWRcbiAgLy8gdG8gdGhlIEdlb0pTT04gZmVhdHVyZXMgYXJyYXlcbiAgZnVuY3Rpb24gZ2V0RmVhdHVyZShhcmdzKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzLml0ZW0sXG4gICAgICBwYXJhbXMgPSBhcmdzLnBhcmFtcyxcbiAgICAgIHByb3BGdW5jID0gYXJncy5wcm9wRnVuYztcblxuICAgIHZhciBmZWF0dXJlID0geyBcInR5cGVcIjogXCJGZWF0dXJlXCIgfTtcblxuICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBidWlsZEdlb20oaXRlbSwgcGFyYW1zKTtcbiAgICBmZWF0dXJlLnByb3BlcnRpZXMgPSBwcm9wRnVuYy5jYWxsKGl0ZW0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc05lc3RlZCh2YWwpe1xuICAgIHJldHVybiAoL14uK1xcLi4rJC8udGVzdCh2YWwpKTtcbiAgfVxuXG4gIC8vIEFzc2VtYmxlcyB0aGUgYGdlb21ldHJ5YCBwcm9wZXJ0eVxuICAvLyBmb3IgdGhlIGZlYXR1cmUgb3V0cHV0XG4gIGZ1bmN0aW9uIGJ1aWxkR2VvbShpdGVtLCBwYXJhbXMpIHtcbiAgICB2YXIgZ2VvbSA9IHt9LFxuICAgICAgICBhdHRyO1xuXG4gICAgZm9yKHZhciBndHlwZSBpbiBwYXJhbXMuZ2VvbSkge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtcy5nZW9tW2d0eXBlXTtcblxuICAgICAgLy8gR2VvbWV0cnkgcGFyYW1ldGVyIHNwZWNpZmllZCBhczoge1BvaW50OiAnY29vcmRzJ31cbiAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsKSkge1xuICAgICAgICBpZihndHlwZSA9PT0gJ0dlb0pTT04nKSB7XG4gICAgICAgICAgZ2VvbSA9IGl0ZW1bdmFsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gaXRlbVt2YWxdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIEhhbmRsZSB0aGluZ3MgbGlrZTpcbiAgICAgIFBvbHlnb246IHtcbiAgICAgICAgbm9ydGhlYXN0OiBbJ2xhdCcsICdsbmcnXSxcbiAgICAgICAgc291dGh3ZXN0OiBbJ2xhdCcsICdsbmcnXVxuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGVsc2UgaWYodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgcG9pbnRzID0gT2JqZWN0LmtleXModmFsKS5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgICB2YXIgb3JkZXIgPSB2YWxba2V5XTtcbiAgICAgICAgICB2YXIgbmV3SXRlbSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgICByZXR1cm4gYnVpbGRHZW9tKG5ld0l0ZW0sIHtnZW9tOnsgUG9pbnQ6IG9yZGVyfX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbXS5jb25jYXQocG9pbnRzLm1hcChmdW5jdGlvbihwKXtcbiAgICAgICAgICByZXR1cm4gcC5jb29yZGluYXRlcztcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW9tZXRyeSBwYXJhbWV0ZXIgc3BlY2lmaWVkIGFzOiB7UG9pbnQ6IFsnbGF0JywgJ2xuZyddfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHZhbCkgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSh2YWxbMF0pICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsWzFdKSl7XG4gICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gW051bWJlcihpdGVtW3ZhbFsxXV0pLCBOdW1iZXIoaXRlbVt2YWxbMF1dKV07XG4gICAgICB9XG5cbiAgICAgIC8vIEdlb21ldHJ5IHBhcmFtZXRlciBzcGVjaWZpZWQgYXM6IHtQb2ludDogWydjb250YWluZXIubGF0JywgJ2NvbnRhaW5lci5sbmcnXX1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2YWwpICYmIGlzTmVzdGVkKHZhbFswXSkgJiYgaXNOZXN0ZWQodmFsWzFdKSl7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1x0Ly8gaS5lLiAwIGFuZCAxXG4gICAgICAgICAgdmFyIHBhdGhzID0gdmFsW2ldLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGl0ZW1DbG9uZSA9IGl0ZW07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFpdGVtQ2xvbmUuaGFzT3duUHJvcGVydHkocGF0aHNbal0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1DbG9uZSA9IGl0ZW1DbG9uZVtwYXRoc1tqXV07XHQvLyBJdGVyYXRlIGRlZXBlciBpbnRvIHRoZSBvYmplY3RcbiAgICAgICAgICB9XG4gICAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBpdGVtQ2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSwgTnVtYmVyKGNvb3JkaW5hdGVzWzBdKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYocGFyYW1zLmRvVGhyb3dzICYmIHBhcmFtcy5kb1Rocm93cy5pbnZhbGlkR2VvbWV0cnkgJiYgIUdlb0pTT04uaXNHZW9tZXRyeVZhbGlkKGdlb20pKXtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkR2VvbWV0cnlFcnJvcihpdGVtLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW9tO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZnVuY3Rpb24gdG8gYmUgdXNlZCB0b1xuICAvLyBidWlsZCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGVhY2ggZmVhdHVyZVxuICBmdW5jdGlvbiBnZXRQcm9wRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGZ1bmM7XG5cbiAgICBpZighcGFyYW1zLmV4Y2x1ZGUgJiYgIXBhcmFtcy5pbmNsdWRlKSB7XG4gICAgICBmdW5jID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBmb3IodmFyIGF0dHIgaW4gdGhpcykge1xuICAgICAgICAgIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgKGdlb21BdHRycy5pbmRleE9mKGF0dHIpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbYXR0cl0gPSB0aGlzW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmluY2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHBhcmFtcy5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XG4gICAgICAgICAgcHJvcGVydGllc1thdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmV4Y2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvcih2YXIgYXR0ciBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiAoZ2VvbUF0dHJzLmluZGV4T2YoYXR0cikgPT09IC0xKSAmJiAocGFyYW1zLmV4Y2x1ZGUuaW5kZXhPZihhdHRyKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2F0dHJdID0gdGhpc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgZnVuYy5jYWxsKHRoaXMsIHByb3BlcnRpZXMpO1xuXG4gICAgICBpZihwYXJhbXMuZXh0cmEpIHsgYWRkRXh0cmEocHJvcGVydGllcywgcGFyYW1zLmV4dHJhKTsgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEFkZHMgZGF0YSBjb250YWluZWQgaW4gdGhlIGBleHRyYWBcbiAgLy8gcGFyYW1ldGVyIGlmIGl0IGhhcyBiZWVuIHNwZWNpZmllZFxuICBmdW5jdGlvbiBhZGRFeHRyYShwcm9wZXJ0aWVzLCBleHRyYSkge1xuICAgIGZvcih2YXIga2V5IGluIGV4dHJhKXtcbiAgICAgIGlmKGV4dHJhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0gZXh0cmFba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG59KHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgPyBtb2R1bGUuZXhwb3J0cyA6IHdpbmRvdy5HZW9KU09OID0ge30pKTtcbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwidmFyIHdnczg0ID0gcmVxdWlyZSgnd2dzODQnKTtcblxubW9kdWxlLmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbm1vZHVsZS5leHBvcnRzLnJpbmcgPSByaW5nQXJlYTtcblxuZnVuY3Rpb24gZ2VvbWV0cnkoXykge1xuICAgIHZhciBhcmVhID0gMCwgaTtcbiAgICBzd2l0Y2ggKF8udHlwZSkge1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgKz0gZ2VvbWV0cnkoXy5nZW9tZXRyaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9seWdvbkFyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBhcmVhIG9mIHRoZSBwb2x5Z29uIHdlcmUgaXQgcHJvamVjdGVkIG9udG9cbiAqICAgICB0aGUgZWFydGguICBOb3RlIHRoYXQgdGhpcyBhcmVhIHdpbGwgYmUgcG9zaXRpdmUgaWYgcmluZyBpcyBvcmllbnRlZFxuICogICAgIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiAgICAgUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogICAgIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3IGh0dHA6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9kc3BhY2UvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBSZXR1cm5zOlxuICoge2Zsb2F0fSBUaGUgYXBwcm94aW1hdGUgc2lnbmVkIGdlb2Rlc2ljIGFyZWEgb2YgdGhlIHBvbHlnb24gaW4gc3F1YXJlXG4gKiAgICAgbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBwMSwgcDIsIHAzLCBsb3dlckluZGV4LCBtaWRkbGVJbmRleCwgdXBwZXJJbmRleCwgaSxcbiAgICBhcmVhID0gMCxcbiAgICBjb29yZHNMZW5ndGggPSBjb29yZHMubGVuZ3RoO1xuXG4gICAgaWYgKGNvb3Jkc0xlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMikgey8vIGkgPSBOLTJcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGNvb3Jkc0xlbmd0aCAtMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMSkgey8vIGkgPSBOLTFcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpID0gMCB0byBOLTNcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGkrMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gaSsyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDEgPSBjb29yZHNbbG93ZXJJbmRleF07XG4gICAgICAgICAgICBwMiA9IGNvb3Jkc1ttaWRkbGVJbmRleF07XG4gICAgICAgICAgICBwMyA9IGNvb3Jkc1t1cHBlckluZGV4XTtcbiAgICAgICAgICAgIGFyZWEgKz0gKCByYWQocDNbMF0pIC0gcmFkKHAxWzBdKSApICogTWF0aC5zaW4oIHJhZChwMlsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYSA9IGFyZWEgKiB3Z3M4NC5SQURJVVMgKiB3Z3M4NC5SQURJVVMgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiByYWQoXykge1xuICAgIHJldHVybiBfICogTWF0aC5QSSAvIDE4MDtcbn0iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdAbWFwYm94L2dlb2pzb24tYXJlYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJld2luZDtcblxuZnVuY3Rpb24gcmV3aW5kKGdqLCBvdXRlcikge1xuICAgIHN3aXRjaCAoKGdqICYmIGdqLnR5cGUpIHx8IG51bGwpIHtcbiAgICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZ2ouZmVhdHVyZXMgPSBnai5mZWF0dXJlcy5tYXAoY3VycnlPdXRlcihyZXdpbmQsIG91dGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgICAgZ2ouZ2VvbWV0cnkgPSByZXdpbmQoZ2ouZ2VvbWV0cnksIG91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdChnaiwgb3V0ZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VycnlPdXRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIGEoXywgYik7IH07XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3QoXywgb3V0ZXIpIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IGNvcnJlY3RSaW5ncyhfLmNvb3JkaW5hdGVzLCBvdXRlcik7XG4gICAgfSBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBfLmNvb3JkaW5hdGVzLm1hcChjdXJyeU91dGVyKGNvcnJlY3RSaW5ncywgb3V0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RSaW5ncyhfLCBvdXRlcikge1xuICAgIG91dGVyID0gISFvdXRlcjtcbiAgICBfWzBdID0gd2luZChfWzBdLCBvdXRlcik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9baV0gPSB3aW5kKF9baV0sICFvdXRlcik7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiB3aW5kKF8sIGRpcikge1xuICAgIHJldHVybiBjdyhfKSA9PT0gZGlyID8gXyA6IF8ucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBjdyhfKSB7XG4gICAgcmV0dXJuIGdlb2pzb25BcmVhLnJpbmcoXykgPj0gMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IE1hcENvbXBvbmVudCBmcm9tICcuLi9vYmplY3RzL21hcC9tYXAudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IE1hcERhdGEgZnJvbSAnLi9tYXAuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuaW1wb3J0IEdlb0pTT04gZnJvbSAnZ2VvanNvbic7XG5pbXBvcnQgcmV3aW5kIGZyb20gJ2dlb2pzb24tcmV3aW5kJztcbmltcG9ydCB7IG1hcENvbG9yQ29tYmluYXRpb25zIH0gZnJvbSAnLi4vLi4vY29uZmlnL2NvbG9ycydcblxuY2xhc3MgTWFwTXVsdGlMYXllciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudCgnbnljby1tYXAtbWwnLCBNYXBDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogJ1tkYXRhLWpzPVwibnljby1tYXAtbWxcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxheWVyczogTWFwRGF0YS5tdWx0aS5sYXllcnMsXG4gICAgICAgICAgY29uZmlnOiBNYXBEYXRhLm11bHRpLmNvbmZpZyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuZ2V0WmlwY29kZURhdGEoKTtcbiAgICAgICAgdGhpcy5nZXRCb3JvdWdoRGF0YSgpO1xuICAgICAgICB0aGlzLmdldE5laWdoYm9yaG9vZERhdGEoKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldFppcGNvZGVEYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gva2ltcGVuZ3Vpbi9nZW9KU09OQG1hc3Rlci90aWdlci16Y3RhLmdlb2pzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgTWFwRGF0YS5tdWx0aS5sYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3ppcGNvZGVzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlsdGVyQnk6ICdHRU9JRDEwJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRCb3JvdWdoRGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9kYXRhLmNpdHlvZm5ld3lvcmsudXMvcmVzb3VyY2UvN3QzYi15d3Z3Lmpzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgICAgICAgTWFwRGF0YS5tdWx0aS5sYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2Jvcm91Z2hzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmNvbnZlcnRUb0dlb0pTT04oZGF0YSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmlsdGVyQnk6ICdib3JvX25hbWUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE5laWdoYm9yaG9vZERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vZGF0YS5jaXR5b2ZuZXd5b3JrLnVzL3Jlc291cmNlL3EyejUtYWkzOC5qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICduZWlnaGJvcmhvb2RzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmNvbnZlcnRUb0dlb0pTT04oZGF0YSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmlsdGVyQnk6ICdudGFuYW1lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0VG9HZW9KU09OKGpzb25EYXRhKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGdlb2pzb24gc2F0aXNmaWVzIHJpZ2h0LWhhbmQgcnVsZVxuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXdpbmQoR2VvSlNPTi5wYXJzZShqc29uRGF0YSwge0dlb0pTT046ICd0aGVfZ2VvbSd9KSk7XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuY2xhc3MgTWFwU2luZ2xlTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tbWFwLXNsJywgTWFwQ29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cIm55Y28tbWFwLXNsXCJdJyxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXllcnM6IE1hcERhdGEuc2luZ2xlLmxheWVycyxcbiAgICAgICAgICBjb25maWc6IE1hcERhdGEuc2luZ2xlLmNvbmZpZyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2tpbXBlbmd1aW4vZ2VvSlNPTkBtYXN0ZXIvbnljby1ueWNfemlwY29kZXMuZ2VvanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBNYXBEYXRhLnNpbmdsZS5sYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ255Y28tbnljX3ppcGNvZGVzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKGRhdGEpLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnWkNUQTVDRTEwJyxcbiAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW46ICdCT1JPJyxcbiAgICAgICAgICAgICAgICBmaWxsOiBtYXBDb2xvckNvbWJpbmF0aW9uc1szXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBNYXBNdWx0aUxheWVyLFxuICBNYXBTaW5nbGVMYXllclxufSIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEljb25zIGZyb20gJy4uL2VsZW1lbnRzL2ljb25zL0ljb25zJztcbmltcG9ydCBGZWVkIGZyb20gJy4uL29iamVjdHMvZmVlZC9GZWVkJztcbmltcG9ydCBUb2dnbGUgZnJvbSAnLi4vdXRpbGl0aWVzL3RvZ2dsZS9Ub2dnbGUnO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4uL3V0aWxpdGllcy90cmFjay9UcmFjayc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJy4uL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QnO1xuaW1wb3J0IENoYXJ0QmFyIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXInO1xuaW1wb3J0IENoYXJ0SG9yaXpvbnRhbEJhciBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXInO1xuaW1wb3J0IENoYXJ0TGluZSBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZSc7XG5pbXBvcnQgQ2hhcnRQaWUgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZSc7XG5pbXBvcnQgeyBNYXBNdWx0aUxheWVyLCBNYXBTaW5nbGVMYXllciB9IGZyb20gJy4vTWFwJztcbi8qKiBpbXBvcnQgbW9kdWxlcyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciB0aGUgZ2xvYmFsIE55Y29QYXR0ZXJucyBpbnN0YW5jZVxuICovXG5jbGFzcyBueWNvIHtcbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIEljb25zIEVsZW1lbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgSWNvbnMgaW5zdGFuY2VcbiAgICovXG4gIGljb25zKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IEljb25zKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIEZlZWQgT2JqZWN0XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICBzZXR0aW5ncyAgU2V0dGluZyBmb3IgdGhlIGZlZWRcbiAgICogQHJldHVybiAge09iamVjdH0gICAgICAgICAgICBGZWVkIGluc3RhbmNlXG4gICAqL1xuICBmZWVkKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBGZWVkKHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUb2dnbGUgVXRpbGl0eVxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBUb2dnbGUgaW5zdGFuY2VcbiAgICovXG4gIHRvZ2dsZShzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVG9nZ2xlKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgVHJhY2sgTW9kdWxlXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRyYWNrIE1vZHVsZVxuICAgKi9cbiAgdHJhY2soc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrKCk7XG4gIH1cblxuICBzZWxlY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3QoKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgQ2hhcnQgT2JqZWN0c1xuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBDaGFydCBpbnN0YW5jZVxuICAgKi9cbiAgY2hhcnQodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnYmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRCYXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbEJhcicpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0SG9yaXpvbnRhbEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRMaW5lKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3BpZScpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0UGllKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgTWFwIE1vZHVsZVxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBNYXAgTW9kdWxlXG4gICAqL1xuICBtYXAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnbXVsdGknKVxuICAgICAgcmV0dXJuIG5ldyBNYXBNdWx0aUxheWVyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NpbmdsZScpXG4gICAgICByZXR1cm4gbmV3IE1hcFNpbmdsZUxheWVyKCk7XG4gIH1cblxuICAvKiogYWRkIEFQSXMgaGVyZSBhcyB0aGV5IGFyZSB3cml0dGVuICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IG55Y287XG4iXSwibmFtZXMiOlsiVXRpbGl0eSIsImRlYnVnIiwiZ2V0VXJsUGFyYW1ldGVyIiwiUEFSQU1TIiwiREVCVUciLCJuYW1lIiwicXVlcnlTdHJpbmciLCJxdWVyeSIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwiY29uc3QiLCJwYXJhbSIsInJlcGxhY2UiLCJyZWdleCIsIlJlZ0V4cCIsInJlc3VsdHMiLCJleGVjIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibG9jYWxpemUiLCJzbHVnIiwidGV4dCIsImxldCIsInN0cmluZ3MiLCJMT0NBTElaRURfU1RSSU5HUyIsIm1hdGNoIiwiZmlsdGVyIiwicyIsImhhc093blByb3BlcnR5IiwibGFiZWwiLCJTRUxFQ1RPUlMiLCJwYXJzZU1hcmtkb3duIiwiSWNvbnMiLCJwYXRoIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsImNvbnNvbGUiLCJkaXIiLCJjYXRjaCIsImVycm9yIiwiZGF0YSIsInNwcml0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJPYmplY3QiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJTeW1ib2wiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0UmF3VGFnIiwidmFsdWUiLCJpc093biIsImNhbGwiLCJ0YWciLCJ1bm1hc2tlZCIsImUiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJ0eXBlIiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJrZXlzIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwidGVzdCIsImdldFZhbHVlIiwib2JqZWN0Iiwia2V5IiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsIm90aGVyIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImNvcHlPYmplY3QiLCJzb3VyY2UiLCJwcm9wcyIsImN1c3RvbWl6ZXIiLCJpc05ldyIsImluZGV4IiwibGVuZ3RoIiwibmV3VmFsdWUiLCJpZGVudGl0eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3MiLCJuYXRpdmVNYXgiLCJNYXRoIiwibWF4Iiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsImFyZ3VtZW50cyIsImFycmF5IiwiQXJyYXkiLCJvdGhlckFyZ3MiLCJjb25zdGFudCIsImJhc2VTZXRUb1N0cmluZyIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsInNob3J0T3V0IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJzZXRUb1N0cmluZyIsImJhc2VSZXN0IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJyZUlzVWludCIsImlzSW5kZXgiLCJpc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJiYXNlVGltZXMiLCJuIiwiaXRlcmF0ZWUiLCJpc09iamVjdExpa2UiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJwdXNoIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIm5hdGl2ZUtleXNJbiIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwia2V5c0luIiwiYXNzaWduSW5XaXRoIiwic3JjSW5kZXgiLCJvdmVyQXJnIiwiYXJnIiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJvYmplY3RDdG9yU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImRvbUV4Y1RhZyIsImlzRXJyb3IiLCJtZXNzYWdlIiwiYXR0ZW1wdCIsIkVycm9yIiwiYXJyYXlNYXAiLCJiYXNlVmFsdWVzIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInNyY1ZhbHVlIiwic3RyaW5nRXNjYXBlcyIsImVzY2FwZVN0cmluZ0NoYXIiLCJjaHIiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJyZUludGVycG9sYXRlIiwiYmFzZVByb3BlcnR5T2YiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJlc2NhcGUiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJ0ZW1wbGF0ZVNldHRpbmdzIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJ0ZW1wbGF0ZSIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJfIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwib2Zmc2V0Iiwic2xpY2UiLCJ2YXJpYWJsZSIsImFycmF5RWFjaCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiYmFzZUZvciIsImJhc2VGb3JPd24iLCJjcmVhdGVCYXNlRWFjaCIsImVhY2hGdW5jIiwiY29sbGVjdGlvbiIsImJhc2VFYWNoIiwiY2FzdEZ1bmN0aW9uIiwiZm9yRWFjaCIsImxpc3RDYWNoZUNsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiYXNzb2NJbmRleE9mIiwiYXJyYXlQcm90byIsInNwbGljZSIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwiaGFzIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsIk1hcCIsIm5hdGl2ZUNyZWF0ZSIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJtYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcCIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJMQVJHRV9BUlJBWV9TSVpFIiwic3RhY2tTZXQiLCJwYWlycyIsIlN0YWNrIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImFsbG9jVW5zYWZlIiwiY2xvbmVCdWZmZXIiLCJidWZmZXIiLCJpc0RlZXAiLCJjb3B5IiwiVWludDhBcnJheSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZVR5cGVkQXJyYXkiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImNvcHlBcnJheSIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImJhc2VDcmVhdGUiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsInNhZmVHZXQiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU1lcmdlRGVlcCIsIm1lcmdlRnVuYyIsInN0YWNrIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNUeXBlZCIsImJhc2VNZXJnZSIsIm1lcmdlIiwidmFsdWVzIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiYWRkIiwiYXJyYXlTb21lIiwicHJlZGljYXRlIiwiY2FjaGVIYXMiLCJjYWNoZSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImVxdWFsQXJyYXlzIiwiYml0bWFzayIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInNlZW4iLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiY29udmVydCIsImFycmF5UHVzaCIsImJhc2VHZXRBbGxLZXlzIiwic3ltYm9sc0Z1bmMiLCJhcnJheUZpbHRlciIsInJlc0luZGV4Iiwic3R1YkFycmF5IiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJnZXRBbGxLZXlzIiwiZXF1YWxPYmplY3RzIiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJEYXRhVmlldyIsIlByb21pc2UiLCJTZXQiLCJXZWFrTWFwIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsImdldFRhZyIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJiYXNlSXNFcXVhbERlZXAiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc0VxdWFsIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJpc1N0cmljdENvbXBhcmFibGUiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VNYXRjaGVzIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwibWVtb2l6ZWQiLCJDYWNoZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiZGVmYXVsdFZhbHVlIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJoYXNJbiIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUiLCJiYXNlTWFwIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwic29ydCIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc051bGwiLCJ2YWxJc1JlZmxleGl2ZSIsInZhbElzU3ltYm9sIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsImNvbXBhcmVNdWx0aXBsZSIsIm9yZGVycyIsIm9iakNyaXRlcmlhIiwiY3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiYmFzZU9yZGVyQnkiLCJpdGVyYXRlZXMiLCJvcmRlckJ5Iiwibm9vcCIsImNyZWF0ZVNldCIsIkZlZWQiLCJjb25maWciLCJkZWZhdWx0IiwiX3NldHRpbmdzIiwiX21lcmdlIiwiaW5pdCIsImZlZWQiLCJyc3NUb0pzb24iLCJyc3NVcmwiLCJfZm9yRWFjaCIsInVybCIsInRoaXMiLCJfcmVxdWVzdCIsIl9wcm9jZXNzIiwiSlNPTiIsInBhcnNlIiwidGhpcyQxIiwiY29tcGlsZWQiLCJfcmVuZGVyIiwiZWwiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0b3IiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImV2ZW50IiwiX3hociIsInRhcmdldCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJvbnRpbWVvdXQiLCJvcGVuIiwic2VuZCIsImxvZyIsIl92YWx1ZXMiLCJ0ZW1wbGF0ZXMiLCJqb2luIiwiX3RlbXBsYXRlIiwibWVkaXVtIiwib3BlbmVyIiwiaGVhZGVyIiwicG9zdHMiLCJjbG9zZXIiLCJwb3N0RXhjZXJwdExlbmd0aCIsIml0ZW1zIiwicG9zdCIsImV4Y2VycHQiLCJkYXRlIiwiZGVzY3JpcHRpb24iLCJzdWJzdHIiLCJtaW4iLCJsYXN0SW5kZXhPZiIsInB1YkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJwb3N0RGF0ZUxvY2FsIiwicG9zdERhdGVGb3JtYXQiLCJtZXJnZWQiLCJjb25jYXQiLCJfb3JkZXJCeSIsInRpdGxlIiwidGl0bGVVcmwiLCJwcm9maWxlSW1nIiwiZm9udFNpemUiLCJyYXRpb1Byb2ZpbGUiLCJwb3N0Qm9yZGVyQ29sb3IiLCJwb3N0SW1nSGVpZ2h0IiwicG9zdEV4Y2VycHRUcmFpbCIsInBvc3RDdGFUZXh0IiwieWVhciIsIm1vbnRoIiwiZGF5IiwicG9zdERhdGVUaXRsZSIsImNsYXNzZXMiLCJ3cmFwcGVyIiwiZmVlZEl0ZW0iLCJsaW5rIiwidGh1bWJuYWlsIiwiaXRlbUZvb3RlciIsImN0YSIsInVuaXF1ZSIsIlRvZ2dsZSIsIm5hbWVzcGFjZSIsImluYWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJtYXRjaGVzIiwicHJldmVudERlZmF1bHQiLCJfdG9nZ2xlIiwiZ2V0QXR0cmlidXRlIiwiZWxlbWVudFRvZ2dsZSIsImRhdGFzZXQiLCJ1bmRvIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsYXNzTGlzdCIsInRvZ2dsZSIsImkiLCJlbEFyaWFSb2xlcyIsInRhcmdldEFyaWFSb2xlcyIsImNvbnRhaW5zIiwiaGFzaCIsIlRyYWNrIiwidHJhY2tLZXkiLCJ0cmFja0RhdGEiLCJjbGljayIsImQiLCJwYXRobmFtZSIsInd0Iiwid2VidHJlbmRzIiwiZ2EiLCJndGFnIiwidmlldyIsImFwcCIsImd0YWdWaWV3IiwiYXNzaWduIiwid3RkIiwiYXJnc2EiLCJmbGF0TWFwIiwiayIsIldlYnRyZW5kcyIsIm11bHRpVHJhY2siLCJ1cmkiLCJmaW5kIiwiZWxlbWVudCIsImFwcF9uYW1lIiwic2NyZWVuX25hbWUiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJvYmoiLCJfdG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwicGFyc2VGbG9hdCIsImZsb29yIiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJzdHJpbmdpZnkiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJsaXN0Iiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJhcnIiLCJpdGVtIiwiaW5kZXhPZiIsImhhc093biIsImNhY2hlZCIsImZuIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJ0b0FycmF5IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwiYiIsIm5vIiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJtIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZXZlcnkiLCJnZXRUaW1lIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJhc3luYyIsIl9saWZlY3ljbGVIb29rcyIsInVuaWNvZGVMZXR0ZXJzIiwiaXNSZXNlcnZlZCIsImRlZiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsImhhc1N5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJWTm9kZSIsImNoaWxkcmVuIiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInN0cmF0cyIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsImRlZiQkMSIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsImxlbiIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsIk51bWJlciIsImV4cGxpY2l0VHlwZXMiLCJzb21lIiwiZWxlbSIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsImhhbmRsZXIiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJwIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiX25vcm1hbGl6ZWQiLCIkc3RhYmxlIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJiaW5kRHluYW1pY0tleXMiLCJiYXNlT2JqIiwicHJlcGVuZE1vZGlmaWVyIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJfZCIsIl9wIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJsaXN0ZW5lcnMiLCJpbmplY3Rpb25zIiwic2NvcGVkU2xvdHMiLCJfc2NvcGVJZCIsIl9jIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiaW5zZXJ0IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGVzdHJveSIsIiRkZXN0cm95IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsIl9wYXJlbnRWbm9kZSIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiJHZub2RlIiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImNsYXNzIiwiaW5pdFJlbmRlciIsIl92bm9kZSIsInBhcmVudFZub2RlIiwiX3JlbmRlckNoaWxkcmVuIiwicGFyZW50RGF0YSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIlZ1ZSIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsIm93bmVyIiwib3duZXJzIiwic3luYyIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNyZWF0ZUdldHRlckludm9rZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJ1aWQkMyIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInNlbGVjdGVkIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWYiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJyYW5nZSIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiZHluYW1pYyIsInJhbmdlU2V0SXRlbSIsInBsYWluIiwiYWRkQXR0ciIsImR5bmFtaWNBdHRycyIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImlzRHluYW1pY0FyZyIsInByZXBlbmRNb2RpZmllck1hcmtlciIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwicmlnaHQiLCJtaWRkbGUiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0UmF3QmluZGluZ0F0dHIiLCJyYXdBdHRyc01hcCIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ0eXBlQmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsImVuZGVkIiwib25FbmQiLCJwcm9wQ291bnQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwiYXBwZWFyIiwic3RhcnRDbGFzcyIsImFwcGVhckNsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImJlZm9yZUFwcGVhciIsImJlZm9yZUVudGVyIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJhZnRlckFwcGVhciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZEhvb2siLCJhcHBlYXJDYW5jZWxsZWQiLCJlbnRlckNhbmNlbGxlZCIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJsZWF2ZUNhbmNlbGxlZCIsImFmdGVyTGVhdmUiLCJkZWxheUxlYXZlIiwicGVyZm9ybUxlYXZlIiwiYmVmb3JlTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJvdXRwdXRTb3VyY2VSYW5nZSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImR5bmFtaWNBcmdSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsInNsb3RSRSIsImxpbmVCcmVha1JFIiwid2hpdGVzcGFjZVJFJDEiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwid2hpdGVzcGFjZU9wdGlvbiIsIndoaXRlc3BhY2UiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJmb3IiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdFRhcmdldER5bmFtaWMiLCJzbG90QmluZGluZyIsImdldFNsb3ROYW1lIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwiZm5JbnZva2VSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwicHJlZml4Iiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiY29udGFpbnNTbG90Q2hpbGQiLCJnZW5TY29wZWRTbG90IiwiaXNMZWdhY3lTeW50YXgiLCJyZXZlcnNlUHJveHkiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJsaW5lTGVuZ3RoIiwicGFkIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiU2VsZWN0RGF0YSIsIlNlbGVjdCIsIlNlbGVjdENvbXBvbmVudCIsIl9jb25zdGFudHMiLCJkYXRhSGFuZGxlciIsIm5ld0RhdGEiLCJjaGFydCIsIl9jaGFydCIsIm5ld0RhdGFzZXRMYWJlbHMiLCJkYXRhc2V0cyIsIm9sZERhdGFzZXRMYWJlbHMiLCJvbGRMYWJlbHMiLCJuZXdMYWJlbHMiLCJvbGREYXRhc2V0S2V5cyIsIm5ld0RhdGFzZXRLZXlzIiwiZGVsZXRpb25LZXlzIiwiZGVsZXRpb25LZXkiLCJsYWJlbHMiLCJ4TGFiZWxzIiwieUxhYmVscyIsInJlbmRlckNoYXJ0IiwiY2hhcnREYXRhIiwicmVhY3RpdmVEYXRhIiwicmVhY3RpdmVQcm9wIiwiaG9va0NhbGxiYWNrIiwic2V0SG9va0NhbGxiYWNrIiwiaW5wdXQiLCJpc09iamVjdEVtcHR5IiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsImhhc093blByb3AiLCJjcmVhdGVVVEMiLCJmb3JtYXQiLCJsb2NhbGUiLCJzdHJpY3QiLCJjcmVhdGVMb2NhbE9yVVRDIiwidXRjIiwiZGVmYXVsdFBhcnNpbmdGbGFncyIsImVtcHR5IiwidW51c2VkVG9rZW5zIiwidW51c2VkSW5wdXQiLCJvdmVyZmxvdyIsImNoYXJzTGVmdE92ZXIiLCJudWxsSW5wdXQiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwiX3BmIiwiZnVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpbnZhbGlkV2Vla2RheSIsIl9zdHJpY3QiLCJiaWdIb3VyIiwiY3JlYXRlSW52YWxpZCIsIk5hTiIsIm1vbWVudFByb3BlcnRpZXMiLCJjb3B5Q29uZmlnIiwiX2lzQU1vbWVudE9iamVjdCIsIl90em0iLCJfaXNVVEMiLCJfb2Zmc2V0IiwiX2xvY2FsZSIsInVwZGF0ZUluUHJvZ3Jlc3MiLCJNb21lbnQiLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsImFic0Zsb29yIiwiY2VpbCIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJjb21wYXJlQXJyYXlzIiwiYXJyYXkxIiwiYXJyYXkyIiwiZG9udENvbnZlcnQiLCJsZW5ndGhEaWZmIiwiYWJzIiwiZGlmZnMiLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGUiLCJmaXJzdFRpbWUiLCJkZXByZWNhdGlvbkhhbmRsZXIiLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJfY29uZmlnIiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50IiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbFBhcnNlIiwibWVyZ2VDb25maWdzIiwicGFyZW50Q29uZmlnIiwiY2hpbGRDb25maWciLCJMb2NhbGUiLCJkZWZhdWx0Q2FsZW5kYXIiLCJzYW1lRGF5IiwibmV4dERheSIsIm5leHRXZWVrIiwibGFzdERheSIsImxhc3RXZWVrIiwic2FtZUVsc2UiLCJjYWxlbmRhciIsIm1vbSIsIm91dHB1dCIsIl9jYWxlbmRhciIsImRlZmF1bHRMb25nRGF0ZUZvcm1hdCIsIkxUUyIsIkxUIiwiTCIsIkxMIiwiTExMIiwiTExMTCIsImxvbmdEYXRlRm9ybWF0IiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJkZWZhdWx0SW52YWxpZERhdGUiLCJpbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJvcmRpbmFsIiwiX29yZGluYWwiLCJkZWZhdWx0UmVsYXRpdmVUaW1lIiwiZnV0dXJlIiwicGFzdCIsInNzIiwibW0iLCJoaCIsImRkIiwiTSIsIk1NIiwieSIsInl5IiwicmVsYXRpdmVUaW1lIiwid2l0aG91dFN1ZmZpeCIsImlzRnV0dXJlIiwiX3JlbGF0aXZlVGltZSIsInBhc3RGdXR1cmUiLCJkaWZmIiwiYWxpYXNlcyIsImFkZFVuaXRBbGlhcyIsInVuaXQiLCJzaG9ydGhhbmQiLCJsb3dlckNhc2UiLCJub3JtYWxpemVVbml0cyIsInVuaXRzIiwibm9ybWFsaXplT2JqZWN0VW5pdHMiLCJpbnB1dE9iamVjdCIsIm5vcm1hbGl6ZWRJbnB1dCIsIm5vcm1hbGl6ZWRQcm9wIiwicHJpb3JpdGllcyIsImFkZFVuaXRQcmlvcml0eSIsInByaW9yaXR5IiwiZ2V0UHJpb3JpdGl6ZWRVbml0cyIsInVuaXRzT2JqIiwidSIsInplcm9GaWxsIiwidGFyZ2V0TGVuZ3RoIiwiZm9yY2VTaWduIiwiYWJzTnVtYmVyIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsImxvY2FsZURhdGEiLCJyZW1vdmVGb3JtYXR0aW5nVG9rZW5zIiwibWFrZUZvcm1hdEZ1bmN0aW9uIiwiZm9ybWF0TW9tZW50IiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibWF0Y2gxIiwibWF0Y2gyIiwibWF0Y2gzIiwibWF0Y2g0IiwibWF0Y2g2IiwibWF0Y2gxdG8yIiwibWF0Y2gzdG80IiwibWF0Y2g1dG82IiwibWF0Y2gxdG8zIiwibWF0Y2gxdG80IiwibWF0Y2gxdG82IiwibWF0Y2hVbnNpZ25lZCIsIm1hdGNoU2lnbmVkIiwibWF0Y2hPZmZzZXQiLCJtYXRjaFNob3J0T2Zmc2V0IiwibWF0Y2hUaW1lc3RhbXAiLCJtYXRjaFdvcmQiLCJyZWdleGVzIiwiYWRkUmVnZXhUb2tlbiIsInN0cmljdFJlZ2V4IiwiaXNTdHJpY3QiLCJnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4iLCJ1bmVzY2FwZUZvcm1hdCIsInJlZ2V4RXNjYXBlIiwibWF0Y2hlZCIsInAxIiwicDIiLCJwMyIsInA0IiwiYWRkUGFyc2VUb2tlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwicGFyc2VUd29EaWdpdFllYXIiLCJkYXlzSW5ZZWFyIiwiaXNMZWFwWWVhciIsImdldFNldFllYXIiLCJtYWtlR2V0U2V0IiwiZ2V0SXNMZWFwWWVhciIsImtlZXBUaW1lIiwic2V0JDEiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwibW9kIiwieCIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TG9jYWxlTW9udGhzIiwibG9jYWxlTW9udGhzIiwiX21vbnRocyIsImlzRm9ybWF0IiwiZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0IiwibG9jYWxlTW9udGhzU2hvcnQiLCJfbW9udGhzU2hvcnQiLCJoYW5kbGVTdHJpY3RQYXJzZSIsIm1vbnRoTmFtZSIsImlpIiwibGxjIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJfbW9udGhzUGFyc2UiLCJfbG9uZ01vbnRoc1BhcnNlIiwiX3Nob3J0TW9udGhzUGFyc2UiLCJsb2NhbGVNb250aHNQYXJzZSIsIl9tb250aHNQYXJzZUV4YWN0Iiwic2V0TW9udGgiLCJkYXlPZk1vbnRoIiwiZ2V0U2V0TW9udGgiLCJnZXREYXlzSW5Nb250aCIsImRlZmF1bHRNb250aHNTaG9ydFJlZ2V4IiwiY29tcHV0ZU1vbnRoc1BhcnNlIiwiX21vbnRoc1Nob3J0U3RyaWN0UmVnZXgiLCJfbW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsIl9tb250aHNTdHJpY3RSZWdleCIsIl9tb250aHNSZWdleCIsImNtcExlblJldiIsInNob3J0UGllY2VzIiwibG9uZ1BpZWNlcyIsIm1peGVkUGllY2VzIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImxvY2FsZVdlZWtkYXlzIiwiX3dlZWtkYXlzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQiLCJsb2NhbGVXZWVrZGF5c1Nob3J0IiwiX3dlZWtkYXlzU2hvcnQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4iLCJsb2NhbGVXZWVrZGF5c01pbiIsIl93ZWVrZGF5c01pbiIsImhhbmRsZVN0cmljdFBhcnNlJDEiLCJ3ZWVrZGF5TmFtZSIsIl93ZWVrZGF5c1BhcnNlIiwiX3Nob3J0V2Vla2RheXNQYXJzZSIsIl9taW5XZWVrZGF5c1BhcnNlIiwibG9jYWxlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1BhcnNlRXhhY3QiLCJfZnVsbFdlZWtkYXlzUGFyc2UiLCJnZXRTZXREYXlPZldlZWsiLCJnZXREYXkiLCJnZXRTZXRMb2NhbGVEYXlPZldlZWsiLCJnZXRTZXRJU09EYXlPZldlZWsiLCJkZWZhdWx0V2Vla2RheXNSZWdleCIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsImRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRSZWdleCIsImRlZmF1bHRXZWVrZGF5c01pblJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwibG9jYWxlTWVyaWRpZW0iLCJpc0xvd2VyIiwiZ2V0U2V0SG91ciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwibG9hZExvY2FsZSIsIm9sZExvY2FsZSIsIl9hYmJyIiwiYWxpYXNlZFJlcXVpcmUiLCJnZXRTZXRHbG9iYWxMb2NhbGUiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwidXBkYXRlTG9jYWxlIiwidG1wTG9jYWxlIiwibGlzdExvY2FsZXMiLCJjaGVja092ZXJmbG93IiwiX292ZXJmbG93RGF5T2ZZZWFyIiwiX292ZXJmbG93V2Vla3MiLCJfb3ZlcmZsb3dXZWVrZGF5IiwiZGVmYXVsdHMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJfdXNlVVRDIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiY29uZmlnRnJvbUFycmF5IiwiY3VycmVudERhdGUiLCJleHBlY3RlZFdlZWtkYXkiLCJ5ZWFyVG9Vc2UiLCJkYXlPZlllYXJGcm9tV2Vla0luZm8iLCJfZGF5T2ZZZWFyIiwiX25leHREYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsInciLCJ3ZWVrWWVhciIsInRlbXAiLCJ3ZWVrZGF5T3ZlcmZsb3ciLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJjdXJXZWVrIiwiZ2ciLCJleHRlbmRlZElzb1JlZ2V4IiwiYmFzaWNJc29SZWdleCIsInR6UmVnZXgiLCJpc29EYXRlcyIsImlzb1RpbWVzIiwiYXNwTmV0SnNvblJlZ2V4IiwiY29uZmlnRnJvbUlTTyIsImFsbG93VGltZSIsImRhdGVGb3JtYXQiLCJ0aW1lRm9ybWF0IiwidHpGb3JtYXQiLCJjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IiwiZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyIsInllYXJTdHIiLCJtb250aFN0ciIsImRheVN0ciIsImhvdXJTdHIiLCJtaW51dGVTdHIiLCJzZWNvbmRTdHIiLCJ1bnRydW5jYXRlWWVhciIsInByZXByb2Nlc3NSRkMyODIyIiwiY2hlY2tXZWVrZGF5Iiwid2Vla2RheVN0ciIsInBhcnNlZElucHV0Iiwid2Vla2RheVByb3ZpZGVkIiwid2Vla2RheUFjdHVhbCIsIm9ic09mZnNldHMiLCJVVCIsIkdNVCIsIkVEVCIsIkVTVCIsIkNEVCIsIkNTVCIsIk1EVCIsIk1TVCIsIlBEVCIsIlBTVCIsImNhbGN1bGF0ZU9mZnNldCIsIm9ic09mZnNldCIsIm1pbGl0YXJ5T2Zmc2V0IiwibnVtT2Zmc2V0IiwiaG0iLCJjb25maWdGcm9tUkZDMjgyMiIsInBhcnNlZEFycmF5IiwiY29uZmlnRnJvbVN0cmluZyIsImNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrIiwiSVNPXzg2MDEiLCJSRkNfMjgyMiIsInNraXBwZWQiLCJzdHJpbmdMZW5ndGgiLCJ0b3RhbFBhcnNlZElucHV0TGVuZ3RoIiwibWVyaWRpZW1GaXhXcmFwIiwiaG91ciIsImlzUG0iLCJtZXJpZGllbUhvdXIiLCJjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkiLCJ0ZW1wQ29uZmlnIiwiYmVzdE1vbWVudCIsInNjb3JlVG9CZWF0IiwiY3VycmVudFNjb3JlIiwic2NvcmUiLCJjb25maWdGcm9tT2JqZWN0IiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJjcmVhdGVGcm9tQ29uZmlnIiwicHJlcGFyZUNvbmZpZyIsInByZXBhcnNlIiwiY29uZmlnRnJvbUlucHV0IiwiaXNVVEMiLCJwcm90b3R5cGVNaW4iLCJwcm90b3R5cGVNYXgiLCJwaWNrQnkiLCJtb21lbnRzIiwib3JkZXJpbmciLCJpc0R1cmF0aW9uVmFsaWQiLCJ1bml0SGFzRGVjaW1hbCIsImlzVmFsaWQkMSIsImNyZWF0ZUludmFsaWQkMSIsImNyZWF0ZUR1cmF0aW9uIiwiRHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfYnViYmxlIiwiaXNEdXJhdGlvbiIsImFic1JvdW5kIiwicm91bmQiLCJzZXBhcmF0b3IiLCJ1dGNPZmZzZXQiLCJvZmZzZXRGcm9tU3RyaW5nIiwiY2h1bmtPZmZzZXQiLCJtYXRjaGVyIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsInNldFRpbWUiLCJsb2NhbCIsImdldERhdGVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImdldFNldE9mZnNldCIsImtlZXBMb2NhbFRpbWUiLCJrZWVwTWludXRlcyIsImxvY2FsQWRqdXN0IiwiX2NoYW5nZUluUHJvZ3Jlc3MiLCJhZGRTdWJ0cmFjdCIsImdldFNldFpvbmUiLCJzZXRPZmZzZXRUb1VUQyIsInNldE9mZnNldFRvTG9jYWwiLCJzdWJ0cmFjdCIsInNldE9mZnNldFRvUGFyc2VkT2Zmc2V0IiwidFpvbmUiLCJoYXNBbGlnbmVkSG91ck9mZnNldCIsImlzRGF5bGlnaHRTYXZpbmdUaW1lIiwiaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkIiwiX2lzRFNUU2hpZnRlZCIsImlzTG9jYWwiLCJpc1V0Y09mZnNldCIsImlzVXRjIiwiYXNwTmV0UmVnZXgiLCJpc29SZWdleCIsImRpZmZSZXMiLCJwYXJzZUlzbyIsIm1vbWVudHNEaWZmZXJlbmNlIiwiaW52YWxpZCIsImlucCIsInBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsImlzQWRkaW5nIiwiZ2V0Q2FsZW5kYXJGb3JtYXQiLCJteU1vbWVudCIsImNhbGVuZGFyJDEiLCJ0aW1lIiwiZm9ybWF0cyIsInNvZCIsInN0YXJ0T2YiLCJjYWxlbmRhckZvcm1hdCIsImxvY2FsSW5wdXQiLCJlbmRPZiIsImlzQmV0d2VlbiIsImluY2x1c2l2aXR5IiwibG9jYWxGcm9tIiwibG9jYWxUbyIsImlzU2FtZSIsImlucHV0TXMiLCJpc1NhbWVPckFmdGVyIiwiaXNTYW1lT3JCZWZvcmUiLCJhc0Zsb2F0IiwidGhhdCIsInpvbmVEZWx0YSIsIm1vbnRoRGlmZiIsIndob2xlTW9udGhEaWZmIiwiYW5jaG9yIiwiYW5jaG9yMiIsImFkanVzdCIsImRlZmF1bHRGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0VXRjIiwidG9JU09TdHJpbmciLCJrZWVwT2Zmc2V0IiwidG9EYXRlIiwiaW5zcGVjdCIsInpvbmUiLCJkYXRldGltZSIsInN1ZmZpeCIsImlucHV0U3RyaW5nIiwicG9zdGZvcm1hdCIsImh1bWFuaXplIiwiZnJvbU5vdyIsInRvTm93IiwibmV3TG9jYWxlRGF0YSIsImxhbmciLCJNU19QRVJfU0VDT05EIiwiTVNfUEVSX01JTlVURSIsIk1TX1BFUl9IT1VSIiwiTVNfUEVSXzQwMF9ZRUFSUyIsIm1vZCQxIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibG9jYWxTdGFydE9mRGF0ZSIsInV0Y1N0YXJ0T2ZEYXRlIiwic3RhcnRPZkRhdGUiLCJpc29XZWVrZGF5IiwidW5peCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsImlzb1dlZWtZZWFyIiwiYWRkV2Vla1llYXJGb3JtYXRUb2tlbiIsImdldFNldFdlZWtZZWFyIiwiZ2V0U2V0V2Vla1llYXJIZWxwZXIiLCJnZXRTZXRJU09XZWVrWWVhciIsImdldElTT1dlZWtzSW5ZZWFyIiwiZ2V0V2Vla3NJblllYXIiLCJ3ZWVrSW5mbyIsIndlZWtzVGFyZ2V0Iiwic2V0V2Vla0FsbCIsImRheU9mWWVhckRhdGEiLCJnZXRTZXRRdWFydGVyIiwiZ2V0U2V0RGF5T2ZNb250aCIsImdldFNldERheU9mWWVhciIsImdldFNldE1pbnV0ZSIsImdldFNldFNlY29uZCIsInBhcnNlTXMiLCJnZXRTZXRNaWxsaXNlY29uZCIsImdldFpvbmVBYmJyIiwiZ2V0Wm9uZU5hbWUiLCJpc29XZWVrcyIsImlzb1dlZWtzSW5ZZWFyIiwicGFyc2Vab25lIiwiaXNEU1QiLCJ6b25lQWJiciIsInpvbmVOYW1lIiwiZGF0ZXMiLCJpc0RTVFNoaWZ0ZWQiLCJjcmVhdGVVbml4IiwiY3JlYXRlSW5ab25lIiwicHJlUGFyc2VQb3N0Rm9ybWF0IiwicHJvdG8kMSIsImZpcnN0RGF5T2ZZZWFyIiwiZmlyc3REYXlPZldlZWsiLCJnZXQkMSIsImZpZWxkIiwibGlzdE1vbnRoc0ltcGwiLCJvdXQiLCJsaXN0V2Vla2RheXNJbXBsIiwibG9jYWxlU29ydGVkIiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsInN1YnRyYWN0JDEiLCJhYnNDZWlsIiwiYnViYmxlIiwibW9udGhzRnJvbURheXMiLCJtb250aHNUb0RheXMiLCJkYXlzVG9Nb250aHMiLCJhcyIsInZhbHVlT2YkMSIsIm1ha2VBcyIsImFzTWlsbGlzZWNvbmRzIiwiYXNTZWNvbmRzIiwiYXNNaW51dGVzIiwiYXNIb3VycyIsImFzRGF5cyIsImFzV2Vla3MiLCJhc01vbnRocyIsImFzUXVhcnRlcnMiLCJhc1llYXJzIiwiY2xvbmUkMSIsImdldCQyIiwibWFrZUdldHRlciIsInRocmVzaG9sZHMiLCJzdWJzdGl0dXRlVGltZUFnbyIsInJlbGF0aXZlVGltZSQxIiwicG9zTmVnRHVyYXRpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJvdW5kaW5nRnVuY3Rpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndpdGhTdWZmaXgiLCJhYnMkMSIsInRvSVNPU3RyaW5nJDEiLCJZIiwiRCIsInRvRml4ZWQiLCJ0b3RhbCIsInRvdGFsU2lnbiIsInltU2lnbiIsImRheXNTaWduIiwiaG1zU2lnbiIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInJlbGF0aXZlVGltZVJvdW5kaW5nIiwicmVsYXRpdmVUaW1lVGhyZXNob2xkIiwiSFRNTDVfRk1UIiwiREFURVRJTUVfTE9DQUwiLCJEQVRFVElNRV9MT0NBTF9TRUNPTkRTIiwiREFURVRJTUVfTE9DQUxfTVMiLCJUSU1FIiwiVElNRV9TRUNPTkRTIiwiVElNRV9NUyIsInJlcXVpcmUkJDAiLCJtb21lbnQiLCJjb252ZXJzaW9ucyIsInJnYjJoc2wiLCJyZ2IyaHN2IiwicmdiMmh3YiIsInJnYjJjbXlrIiwicmdiMmtleXdvcmQiLCJyZ2IyeHl6IiwicmdiMmxhYiIsInJnYjJsY2giLCJoc2wycmdiIiwiaHNsMmhzdiIsImhzbDJod2IiLCJoc2wyY215ayIsImhzbDJrZXl3b3JkIiwiaHN2MnJnYiIsImhzdjJoc2wiLCJoc3YyaHdiIiwiaHN2MmNteWsiLCJoc3Yya2V5d29yZCIsImh3YjJyZ2IiLCJod2IyaHNsIiwiaHdiMmhzdiIsImh3YjJjbXlrIiwiaHdiMmtleXdvcmQiLCJjbXlrMnJnYiIsImNteWsyaHNsIiwiY215azJoc3YiLCJjbXlrMmh3YiIsImNteWsya2V5d29yZCIsImtleXdvcmQycmdiIiwia2V5d29yZDJoc2wiLCJrZXl3b3JkMmhzdiIsImtleXdvcmQyaHdiIiwia2V5d29yZDJjbXlrIiwia2V5d29yZDJsYWIiLCJrZXl3b3JkMnh5eiIsInh5ejJyZ2IiLCJ4eXoybGFiIiwieHl6MmxjaCIsImxhYjJ4eXoiLCJsYWIycmdiIiwibGFiMmxjaCIsImxjaDJsYWIiLCJsY2gyeHl6IiwibGNoMnJnYiIsInJnYiIsInIiLCJnIiwiZGVsdGEiLCJyZXZlcnNlS2V5d29yZHMiLCJ6IiwieHl6IiwiaHNsIiwidDEiLCJ0MiIsInQzIiwic3YiLCJoc3YiLCJoaSIsImYiLCJxIiwic2wiLCJod2IiLCJ3aCIsImJsIiwicmF0aW8iLCJjbXlrIiwibGFiIiwieTIiLCJociIsImF0YW4yIiwiUEkiLCJzcXJ0IiwibGNoIiwiY29zIiwic2luIiwia2V5d29yZCIsImNzc0tleXdvcmRzIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJDb252ZXJ0ZXIiLCJwYWlyIiwiY29udnMiLCJyb3V0ZVNwYWNlIiwiZ2V0VmFsdWVzIiwic2V0VmFsdWVzIiwidmFscyIsImZzcGFjZSIsImNvbG9yQ29udmVydCIsImNvbG9yTmFtZSIsImNvbG9yU3RyaW5nIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwiaGV4IiwicmdiYSIsInBlciIsImhleEFscGhhIiwic2NhbGUiLCJhbHBoYSIsImhzbGEiLCJoZXhEb3VibGUiLCJyZXZlcnNlTmFtZXMiLCJudW0iLCJDb2xvciIsImxpZ2h0bmVzcyIsIndoaXRlbmVzcyIsInNldFNwYWNlIiwicmdiQXJyYXkiLCJoc2xBcnJheSIsImhzdkFycmF5IiwiaHdiQXJyYXkiLCJjbXlrQXJyYXkiLCJyZ2JhQXJyYXkiLCJoc2xhQXJyYXkiLCJzZXRDaGFubmVsIiwiaHVlIiwic2F0dXJhdGlvbiIsInNhdHVyYXRpb252IiwiYmxhY2tuZXNzIiwicmdiTnVtYmVyIiwibHVtaW5vc2l0eSIsImx1bSIsImNoYW4iLCJjb250cmFzdCIsImNvbG9yMiIsImx1bTEiLCJsdW0yIiwibGV2ZWwiLCJjb250cmFzdFJhdGlvIiwiZGFyayIsInlpcSIsImxpZ2h0IiwibmVnYXRlIiwibGlnaHRlbiIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImJsYWNrZW4iLCJncmV5c2NhbGUiLCJjbGVhcmVyIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwidzEiLCJ3MiIsInNwYWNlcyIsIm1heGVzIiwiY2hhbnMiLCJjYXBwZWQiLCJzbmFtZSIsInN2YWx1ZXMiLCJjaGFydGpzQ29sb3IiLCJoZWxwZXJzIiwiaXNOdWxsT3JVbmRlZiIsInZhbHVlT3JEZWZhdWx0IiwidmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWFjaCIsImxvb3BhYmxlIiwicmV2ZXJzZSIsImFycmF5RXF1YWxzIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwia2xlbiIsIl9tZXJnZXIiLCJ0dmFsIiwic3ZhbCIsIl9tZXJnZXJJZiIsIm1lcmdlSWYiLCJtZXJnZXIiLCJzZXRGbiIsImluaGVyaXRzIiwiZXh0ZW5zaW9ucyIsIm1lIiwiQ2hhcnRFbGVtZW50IiwiU3Vycm9nYXRlIiwiX19zdXBlcl9fIiwiaGVscGVyc19jb3JlIiwiY2FsbENhbGxiYWNrIiwiZnJvbUluZGV4IiwiZ2V0VmFsdWVPckRlZmF1bHQiLCJnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJhc2luIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJoZWxwZXJzX2Vhc2luZyIsImVhc2luZ0VmZmVjdHMiLCJSQURfUEVSX0RFRyIsIkRPVUJMRV9QSSIsIkhBTEZfUEkiLCJRVUFSVEVSX1BJIiwiVFdPX1RISVJEU19QSSIsImV4cG9ydHMkMSIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmRlZFJlY3QiLCJyYWRpdXMiLCJib3R0b20iLCJtb3ZlVG8iLCJhcmMiLCJjbG9zZVBhdGgiLCJyZWN0IiwiZHJhd1BvaW50Iiwicm90YXRpb24iLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInJhZCIsImRyYXdJbWFnZSIsImJlZ2luUGF0aCIsImxpbmVUbyIsIlNRUlQxXzIiLCJmaWxsIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJwb2ludCIsImFyZWEiLCJlcHNpbG9uIiwiY2xpcEFyZWEiLCJzYXZlIiwiY2xpcCIsInVuY2xpcEFyZWEiLCJyZXN0b3JlIiwicHJldmlvdXMiLCJmbGlwIiwic3RlcHBlZCIsInN0ZXBwZWRMaW5lIiwibWlkcG9pbnQiLCJ0ZW5zaW9uIiwiYmV6aWVyQ3VydmVUbyIsImNvbnRyb2xQb2ludFByZXZpb3VzWCIsImNvbnRyb2xQb2ludE5leHRYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFkiLCJoZWxwZXJzX2NhbnZhcyIsImRyYXdSb3VuZGVkUmVjdGFuZ2xlIiwiX3NldCIsInNjb3BlIiwiZGVmYXVsdENvbG9yIiwiZGVmYXVsdEZvbnRDb2xvciIsImRlZmF1bHRGb250RmFtaWx5IiwiZGVmYXVsdEZvbnRTaXplIiwiZGVmYXVsdEZvbnRTdHlsZSIsImRlZmF1bHRMaW5lSGVpZ2h0Iiwic2hvd0xpbmVzIiwiY29yZV9kZWZhdWx0cyIsInRvRm9udFN0cmluZyIsImZvbnQiLCJmYW1pbHkiLCJoZWxwZXJzX29wdGlvbnMiLCJ0b0xpbmVIZWlnaHQiLCJ0b1BhZGRpbmciLCJfcGFyc2VGb250IiwiZ2xvYmFsRGVmYXVsdHMiLCJmb250RmFtaWx5IiwibGluZUhlaWdodCIsImZvbnRTdHlsZSIsImlucHV0cyIsImhlbHBlcnMkMSIsImVhc2luZyIsImNhbnZhcyIsImVhc2UiLCJvcmlnaW4iLCJjMCIsImMxIiwiRWxlbWVudCIsImNvbmZpZ3VyYXRpb24iLCJpbml0aWFsaXplIiwiaGlkZGVuIiwicGl2b3QiLCJfdmlldyIsIl9tb2RlbCIsIl9zdGFydCIsInRvb2x0aXBQb3NpdGlvbiIsImhhc1ZhbHVlIiwiY29yZV9lbGVtZW50IiwiZXhwb3J0cyQyIiwiY3VycmVudFN0ZXAiLCJudW1TdGVwcyIsIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCJvbkFuaW1hdGlvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb24iLCJhbmltYXRpb24iLCJvblByb2dyZXNzIiwib25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0IiwiYWRkQW5pbWF0aW9uIiwic3RhcnRUaW1lIiwiYW5pbWF0aW5nIiwiY2FuY2VsQW5pbWF0aW9uIiwiZmluZEluZGV4IiwicmVxdWVzdEFuaW1GcmFtZSIsInN0YXJ0RGlnZXN0IiwibmV4dFN0ZXAiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwiRGF0YXNldENvbnRyb2xsZXIiLCJkYXRhc2V0SW5kZXgiLCJkYXRhc2V0RWxlbWVudFR5cGUiLCJkYXRhRWxlbWVudFR5cGUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJ1cGRhdGVJbmRleCIsImdldE1ldGEiLCJnZXREYXRhc2V0IiwieEF4aXNJRCIsInNjYWxlcyIsInhBeGVzIiwieUF4aXNJRCIsInlBeGVzIiwiZ2V0RGF0YXNldE1ldGEiLCJnZXRTY2FsZUZvcklkIiwic2NhbGVJRCIsIl9nZXRWYWx1ZVNjYWxlSWQiLCJfZ2V0SW5kZXhTY2FsZUlkIiwiX2dldFZhbHVlU2NhbGUiLCJfZ2V0SW5kZXhTY2FsZSIsInJlc2V0IiwiY3JlYXRlTWV0YURhdGFzZXQiLCJfZGF0YXNldEluZGV4IiwiY3JlYXRlTWV0YURhdGEiLCJfaW5kZXgiLCJtZXRhRGF0YSIsImFkZEVsZW1lbnRBbmRSZXNldCIsInVwZGF0ZUVsZW1lbnQiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJyZXN5bmNFbGVtZW50cyIsImVhc2luZ1ZhbHVlIiwiZWxlbWVudHMiLCJkcmF3IiwicmVtb3ZlSG92ZXJTdHlsZSIsIiRwcmV2aW91c1N0eWxlIiwic2V0SG92ZXJTdHlsZSIsImN1c3RvbSIsImdldEhvdmVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJCb3JkZXJXaWR0aCIsIm51bU1ldGEiLCJudW1EYXRhIiwiaW5zZXJ0RWxlbWVudHMiLCJvbkRhdGFQdXNoIiwib25EYXRhUG9wIiwib25EYXRhU2hpZnQiLCJvbkRhdGFTcGxpY2UiLCJvbkRhdGFVbnNoaWZ0IiwiY29yZV9kYXRhc2V0Q29udHJvbGxlciIsImJvcmRlckFsaWduIiwiZWxlbWVudF9hcmMiLCJpbkxhYmVsUmFuZ2UiLCJtb3VzZVgiLCJob3ZlclJhZGl1cyIsImluUmFuZ2UiLCJjaGFydFgiLCJjaGFydFkiLCJwb2ludFJlbGF0aXZlUG9zaXRpb24iLCJnZXRBbmdsZUZyb21Qb2ludCIsImFuZ2xlIiwiZGlzdGFuY2UiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImdldENlbnRlclBvaW50IiwiaGFsZkFuZ2xlIiwiaGFsZlJhZGl1cyIsImdldEFyZWEiLCJjZW50cmVBbmdsZSIsInJhbmdlRnJvbUNlbnRyZSIsInNBIiwiZUEiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJzdHJva2VTdHlsZSIsInZhbHVlT3JEZWZhdWx0JDEiLCJsaW5lIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsImNhcEJlemllclBvaW50cyIsImVsZW1lbnRfbGluZSIsInNwYW5HYXBzIiwicG9pbnRzIiwiX2NoaWxkcmVuIiwiZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzIiwibGFzdERyYXduSW5kZXgiLCJjdXJyZW50Vk0iLCJfbG9vcCIsImxpbmVDYXAiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicHJldmlvdXNJdGVtIiwic2tpcCIsInZhbHVlT3JEZWZhdWx0JDIiLCJkZWZhdWx0Q29sb3IkMSIsInBvaW50U3R5bGUiLCJoaXRSYWRpdXMiLCJ4UmFuZ2UiLCJ5UmFuZ2UiLCJtb3VzZVkiLCJlbGVtZW50X3BvaW50IiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsInBhZGRpbmciLCJjaGFydEFyZWEiLCJkZWZhdWx0Q29sb3IkMiIsInJlY3RhbmdsZSIsImJvcmRlclNraXBwZWQiLCJpc1ZlcnRpY2FsIiwiZ2V0QmFyQm91bmRzIiwieDEiLCJ4MiIsInkxIiwiaGFsZiIsInN3YXAiLCJvcmlnIiwidjIiLCJwYXJzZUJvcmRlclNraXBwZWQiLCJlZGdlIiwiaG9yaXpvbnRhbCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJib3JkZXIiLCJvdXRlciIsImlubmVyIiwic2tpcFgiLCJza2lwWSIsImVsZW1lbnRfcmVjdGFuZ2xlIiwicmVjdHMiLCJmaWxsUmVjdCIsIkFyYyIsIkxpbmUiLCJQb2ludCIsIlJlY3RhbmdsZSIsInJlc29sdmUkMSIsImhvdmVyIiwiY2F0ZWdvcnlQZXJjZW50YWdlIiwiYmFyUGVyY2VudGFnZSIsImdyaWRMaW5lcyIsIm9mZnNldEdyaWRMaW5lcyIsImNvbXB1dGVNaW5TYW1wbGVTaXplIiwicGl4ZWxzIiwiaXNIb3Jpem9udGFsIiwidGlja3MiLCJnZXRUaWNrcyIsImN1cnIiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsInN0YWNrQ291bnQiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwicGVyY2VudCIsImNvbnRyb2xsZXJfYmFyIiwiYmFyIiwiX3J1bGVyIiwiZ2V0UnVsZXIiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiX3hTY2FsZSIsIl95U2NhbGUiLCJkYXRhc2V0TGFiZWwiLCJfdXBkYXRlRWxlbWVudEdlb21ldHJ5IiwidnNjYWxlIiwiZ2V0QmFzZVBpeGVsIiwidnBpeGVscyIsImNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsImNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiaGVhZCIsImNlbnRlciIsIl9nZXRTdGFja3MiLCJzdGFja3MiLCJpc0RhdGFzZXRWaXNpYmxlIiwiZ2V0U3RhY2tDb3VudCIsImdldFN0YWNrSW5kZXgiLCJnZXRQaXhlbEZvclZhbHVlIiwiZ2V0UmlnaHRWYWx1ZSIsIm1pbkJhckxlbmd0aCIsImltZXRhIiwiaXZhbHVlIiwiY29udHJvbGxlciIsInN0YWNrSW5kZXgiLCJtYXhCYXJUaGlja25lc3MiLCJJbmZpbml0eSIsImRhdGFJbmRleCIsInZhbHVlT3JEZWZhdWx0JDMiLCJyZXNvbHZlJDIiLCJwb3NpdGlvbiIsInRvb2x0aXBzIiwiZGF0YVBvaW50IiwieExhYmVsIiwieUxhYmVsIiwiY29udHJvbGxlcl9idWJibGUiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJkc0luZGV4IiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwiX29wdGlvbnMiLCJyZXNvbHZlJDMiLCJ2YWx1ZU9yRGVmYXVsdCQ0IiwiYW5pbWF0ZVJvdGF0ZSIsImFuaW1hdGVTY2FsZSIsImxlZ2VuZENhbGxiYWNrIiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJkcyIsImFyY09wdHMiLCJidyIsIm9uQ2xpY2siLCJsZWdlbmRJdGVtIiwiY3V0b3V0UGVyY2VudGFnZSIsImNpcmN1bWZlcmVuY2UiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImNvbnRyb2xsZXJfZG91Z2hudXQiLCJnZXRSaW5nSW5kZXgiLCJyaW5nSW5kZXgiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsIm1pblNpemUiLCJhcmNzIiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsImNvbnRhaW5zMCIsImNvbnRhaW5zOTAiLCJjb250YWluczE4MCIsImNvbnRhaW5zMjcwIiwiY3V0b3V0IiwiZ2V0TWF4Qm9yZGVyV2lkdGgiLCJyYWRpdXNMZW5ndGgiLCJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY2FsY3VsYXRlVG90YWwiLCJfZ2V0UmluZ1dlaWdodE9mZnNldCIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCJob3ZlcldpZHRoIiwicmluZ1dlaWdodE9mZnNldCIsImRhdGFTZXRJbmRleCIsImF4aXMiLCJjb250cm9sbGVyX2hvcml6b250YWxCYXIiLCJ2YWx1ZU9yRGVmYXVsdCQ1IiwicmVzb2x2ZSQ0IiwiaXNQb2ludEluQXJlYSIsImxpbmVFbmFibGVkIiwic2hvd0xpbmUiLCJjb250cm9sbGVyX2xpbmUiLCJsaW5lVGVuc2lvbiIsIl9zY2FsZSIsIl9yZXNvbHZlTGluZU9wdGlvbnMiLCJ1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwibGluZU1vZGVsIiwiX3Jlc29sdmVQb2ludE9wdGlvbnMiLCJjYWxjdWxhdGVQb2ludFkiLCJFTEVNRU5UX09QVElPTlMiLCJlbGVtZW50T3B0aW9ucyIsInN1bVBvcyIsInN1bU5lZyIsImRzTWV0YSIsInN0YWNrZWRSaWdodFZhbHVlIiwicmlnaHRWYWx1ZSIsImNvbnRyb2xQb2ludHMiLCJwdCIsImNhcENvbnRyb2xQb2ludCIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic3BsaW5lQ3VydmUiLCJuZXh0SXRlbSIsImhhbGZCb3JkZXJXaWR0aCIsInJlc29sdmUkNSIsImFuZ2xlTGluZXMiLCJwb2ludExhYmVscyIsImJlZ2luQXRaZXJvIiwiY29udHJvbGxlcl9wb2xhckFyZWEiLCJzdGFydHMiLCJfc3RhcnRzIiwiYW5nbGVzIiwiX2FuZ2xlcyIsIl91cGRhdGVSYWRpdXMiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwicmVzZXRSYWRpdXMiLCJkb3VnaG51dCIsImNvbnRyb2xsZXJfcGllIiwidmFsdWVPckRlZmF1bHQkNiIsInJlc29sdmUkNiIsImNvbnRyb2xsZXJfcmFkYXIiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwiY29udHJvbGxlcl9zY2F0dGVyIiwiY29udHJvbGxlcnMiLCJob3Jpem9udGFsQmFyIiwicG9sYXJBcmVhIiwicGllIiwicmFkYXIiLCJzY2F0dGVyIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsInBhcnNlVmlzaWJsZUl0ZW1zIiwiamxlbiIsImdldEludGVyc2VjdEl0ZW1zIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiaW50ZXJzZWN0IiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsIlBPU0lUSVZFX0lORklOSVRZIiwibmVhcmVzdEl0ZW1zIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJpbmRleE1vZGUiLCJjb3JlX2ludGVyYWN0aW9uIiwibW9kZXMiLCJzaW5nbGUiLCJuZWFyZXN0IiwiaW50ZXJzZWN0c0l0ZW0iLCJmaWx0ZXJCeVBvc2l0aW9uIiwid2hlcmUiLCJzb3J0QnlXZWlnaHQiLCJfdG1wSW5kZXhfIiwiZmluZE1heFBhZGRpbmciLCJib3hlcyIsImJveCIsImdldFBhZGRpbmciLCJib3hQYWRkaW5nIiwiYWRkU2l6ZUJ5UG9zaXRpb24iLCJsYXlvdXQiLCJjb3JlX2xheW91dHMiLCJhZGRCb3giLCJmdWxsV2lkdGgiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwibGF5b3V0T3B0aW9ucyIsImxlZnRQYWRkaW5nIiwicmlnaHRQYWRkaW5nIiwidG9wUGFkZGluZyIsImJvdHRvbVBhZGRpbmciLCJsZWZ0Qm94ZXMiLCJyaWdodEJveGVzIiwidG9wQm94ZXMiLCJib3R0b21Cb3hlcyIsImNoYXJ0QXJlYUJveGVzIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsIm91dGVyQm94ZXMiLCJjaGFydFdpZHRoIiwiY2hhcnRIZWlnaHQiLCJjaGFydEFyZWFXaWR0aCIsInZlcnRpY2FsQm94V2lkdGgiLCJtYXhDaGFydEFyZWFXaWR0aCIsIm1heENoYXJ0QXJlYUhlaWdodCIsIm91dGVyQm94U2l6ZXMiLCJtaW5Cb3hTaXplcyIsIm1heFBhZGRpbmciLCJnZXRNaW5pbXVtQm94U2l6ZSIsImZpdEJveCIsIm1pbkJveFNpemUiLCJmaW5kTmV4dFdoZXJlIiwibWluQm94Iiwic2NhbGVNYXJnaW4iLCJmaW5hbEZpdFZlcnRpY2FsQm94IiwibGVmdFBhZGRpbmdBZGRpdGlvbiIsInRvcFBhZGRpbmdBZGRpdGlvbiIsIm5ld01heENoYXJ0QXJlYUhlaWdodCIsIm5ld01heENoYXJ0QXJlYVdpZHRoIiwicGxhY2VCb3giLCJwbGF0Zm9ybV9iYXNpYyIsImFjcXVpcmVDb250ZXh0IiwiZ2V0Q29udGV4dCIsInBsYXRmb3JtX2RvbSIsInBsYXRmb3JtX2RvbSQxIiwiZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSIsInN0eWxlc2hlZXQiLCJFWFBBTkRPX0tFWSIsIkNTU19QUkVGSVgiLCJDU1NfU0laRV9NT05JVE9SIiwiQ1NTX1JFTkRFUl9NT05JVE9SIiwiQ1NTX1JFTkRFUl9BTklNQVRJT04iLCJBTklNQVRJT05fU1RBUlRfRVZFTlRTIiwiRVZFTlRfVFlQRVMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm91dCIsInJlYWRVc2VkU2l6ZSIsImluaXRDYW52YXMiLCJyZW5kZXJIZWlnaHQiLCJyZW5kZXJXaWR0aCIsImRpc3BsYXlXaWR0aCIsImFzcGVjdFJhdGlvIiwiZGlzcGxheUhlaWdodCIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJzdXBwb3J0cyIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50IiwiZnJvbU5hdGl2ZUV2ZW50IiwidGhyb3R0bGVkIiwidGlja2luZyIsImNyZWF0ZURpdiIsImNsYXNzTmFtZSIsImNyZWF0ZVJlc2l6ZXIiLCJtYXhTaXplIiwicmVzaXplciIsImV4cGFuZCIsInNocmluayIsIl9yZXNldCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJvblNjcm9sbCIsIndhdGNoRm9yUmVuZGVyIiwiZXhwYW5kbyIsInJlbmRlclByb3h5IiwiYW5pbWF0aW9uTmFtZSIsInJlZmxvdyIsIm9mZnNldFBhcmVudCIsInVud2F0Y2hGb3JSZW5kZXIiLCJhZGRSZXNpemVMaXN0ZW5lciIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJjbGllbnRXaWR0aCIsInJlbW92ZVJlc2l6ZUxpc3RlbmVyIiwiaW5qZWN0Q1NTIiwiX3N0eWxlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJwbGF0Zm9ybV9kb20kMiIsImRpc2FibGVDU1NJbmplY3Rpb24iLCJfZW5hYmxlZCIsIl9lbnN1cmVMb2FkZWQiLCJfbG9hZGVkIiwiZ2V0RWxlbWVudEJ5SWQiLCJyZWxlYXNlQ29udGV4dCIsInByb3hpZXMiLCJhZGRFdmVudCIsInJlbW92ZUV2ZW50IiwiaW1wbGVtZW50YXRpb24iLCJwbHVnaW5zIiwiY29yZV9wbHVnaW5zIiwiX3BsdWdpbnMiLCJfY2FjaGVJZCIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsImlkeCIsImdldEFsbCIsImRlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIiRwbHVnaW5zIiwiX2ludmFsaWRhdGUiLCJjb3JlX3NjYWxlU2VydmljZSIsImNvbnN0cnVjdG9ycyIsInJlZ2lzdGVyU2NhbGVUeXBlIiwic2NhbGVDb25zdHJ1Y3RvciIsInNjYWxlRGVmYXVsdHMiLCJnZXRTY2FsZUNvbnN0cnVjdG9yIiwiZ2V0U2NhbGVEZWZhdWx0cyIsInVwZGF0ZVNjYWxlRGVmYXVsdHMiLCJhZGRpdGlvbnMiLCJhZGRTY2FsZXNUb0xheW91dCIsInZhbHVlT3JEZWZhdWx0JDciLCJlbmFibGVkIiwidGl0bGVGb250U3R5bGUiLCJ0aXRsZVNwYWNpbmciLCJ0aXRsZU1hcmdpbkJvdHRvbSIsInRpdGxlRm9udENvbG9yIiwidGl0bGVBbGlnbiIsImJvZHlTcGFjaW5nIiwiYm9keUZvbnRDb2xvciIsImJvZHlBbGlnbiIsImZvb3RlckZvbnRTdHlsZSIsImZvb3RlclNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJGb250Q29sb3IiLCJmb290ZXJBbGlnbiIsInlQYWRkaW5nIiwieFBhZGRpbmciLCJjYXJldFBhZGRpbmciLCJjYXJldFNpemUiLCJtdWx0aUtleUJhY2tncm91bmQiLCJkaXNwbGF5Q29sb3JzIiwiYmVmb3JlVGl0bGUiLCJ0b29sdGlwSXRlbXMiLCJsYWJlbENvdW50IiwiYWZ0ZXJUaXRsZSIsImJlZm9yZUJvZHkiLCJiZWZvcmVMYWJlbCIsImxhYmVsQ29sb3IiLCJsYWJlbFRleHRDb2xvciIsImFmdGVyTGFiZWwiLCJhZnRlckJvZHkiLCJiZWZvcmVGb290ZXIiLCJmb290ZXIiLCJhZnRlckZvb3RlciIsInBvc2l0aW9uZXJzIiwiYXZlcmFnZSIsImV2ZW50UG9zaXRpb24iLCJuZWFyZXN0RWxlbWVudCIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInRwIiwicHVzaE9yQ29uY2F0IiwidG9QdXNoIiwic3BsaXROZXdsaW5lcyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRMYWJlbEZvckluZGV4IiwiZ2V0QmFzZU1vZGVsIiwidG9vbHRpcE9wdHMiLCJ4QWxpZ24iLCJ5QWxpZ24iLCJfYm9keUZvbnRGYW1pbHkiLCJib2R5Rm9udEZhbWlseSIsIl9ib2R5Rm9udFN0eWxlIiwiYm9keUZvbnRTdHlsZSIsIl9ib2R5QWxpZ24iLCJib2R5Rm9udFNpemUiLCJfdGl0bGVGb250RmFtaWx5IiwidGl0bGVGb250RmFtaWx5IiwiX3RpdGxlRm9udFN0eWxlIiwidGl0bGVGb250U2l6ZSIsIl90aXRsZUFsaWduIiwiX2Zvb3RlckZvbnRGYW1pbHkiLCJmb290ZXJGb250RmFtaWx5IiwiX2Zvb3RlckZvbnRTdHlsZSIsImZvb3RlckZvbnRTaXplIiwiX2Zvb3RlckFsaWduIiwib3BhY2l0eSIsImxlZ2VuZENvbG9yQmFja2dyb3VuZCIsImdldFRvb2x0aXBTaXplIiwidG9vbHRpcCIsImNvbWJpbmVkQm9keUxlbmd0aCIsImJvZHlJdGVtIiwiYWZ0ZXIiLCJ0aXRsZUxpbmVDb3VudCIsImZvb3RlckxpbmVDb3VudCIsIndpZHRoUGFkZGluZyIsIm1heExpbmVXaWR0aCIsIm1lYXN1cmVUZXh0IiwiZm9udFN0cmluZyIsImRldGVybWluZUFsaWdubWVudCIsImxmIiwicmYiLCJvbGYiLCJvcmYiLCJ5ZiIsIm1pZFgiLCJtaWRZIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwicGFkZGluZ0FuZFNpemUiLCJyYWRpdXNBbmRQYWRkaW5nIiwiZ2V0QWxpZ25lZFgiLCJhbGlnbiIsImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwiZXhwb3J0cyQzIiwiX2xhc3RBY3RpdmUiLCJnZXRUaXRsZSIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiY2hhbmdlZCIsImV4aXN0aW5nTW9kZWwiLCJfYWN0aXZlIiwiYmFja2dyb3VuZFBvaW50IiwidG9vbHRpcFNpemUiLCJjYXJldFgiLCJjYXJldFkiLCJsYWJlbENvbG9ycyIsImxhYmVsVGV4dENvbG9ycyIsIl9ldmVudFBvc2l0aW9uIiwiaXRlbVNvcnQiLCJkYXRhUG9pbnRzIiwiZHJhd0NhcmV0IiwidG9vbHRpcFBvaW50IiwiY2FyZXRQb3NpdGlvbiIsImdldENhcmV0UG9zaXRpb24iLCJ4MyIsInkzIiwicHRYIiwicHRZIiwiZHJhd1RpdGxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJkcmF3Qm9keSIsImRyYXdDb2xvckJveGVzIiwieExpbmVQYWRkaW5nIiwiY29sb3JYIiwidGV4dENvbG9yIiwiZmlsbExpbmVPZlRleHQiLCJzdHJva2VSZWN0IiwiZHJhd0Zvb3RlciIsImRyYXdCYWNrZ3JvdW5kIiwicXVhZHJhdGljQ3VydmVUbyIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJoYW5kbGVFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJwb3NpdGlvbmVyc18xIiwiY29yZV90b29sdGlwIiwidmFsdWVPckRlZmF1bHQkOCIsIm9uSG92ZXIiLCJhbmltYXRpb25EdXJhdGlvbiIsInJlc3BvbnNpdmUiLCJyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb24iLCJtZXJnZVNjYWxlQ29uZmlnIiwic2xlbiIsIm1lcmdlQ29uZmlnIiwiaW5pdENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsIm5ld09wdGlvbnMiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiQ2hhcnQiLCJjb25zdHJ1Y3QiLCJfYnVmZmVyZWRSZW5kZXIiLCJpbnN0YW5jZXMiLCJyZXRpbmFTY2FsZSIsImRldmljZVBpeGVsUmF0aW8iLCJiaW5kRXZlbnRzIiwicmVzaXplIiwiaW5pdFRvb2xUaXAiLCJuZXdXaWR0aCIsImdldE1heGltdW1XaWR0aCIsIm5ld0hlaWdodCIsImdldE1heGltdW1IZWlnaHQiLCJuZXdTaXplIiwib25SZXNpemUiLCJzY2FsZXNPcHRpb25zIiwic2NhbGVPcHRpb25zIiwieEF4aXNPcHRpb25zIiwieUF4aXNPcHRpb25zIiwiZHR5cGUiLCJkcG9zaXRpb24iLCJpc0RlZmF1bHQiLCJzY2FsZVR5cGUiLCJzY2FsZUNsYXNzIiwibWVyZ2VUaWNrc09wdGlvbnMiLCJoYXNVcGRhdGVkIiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJkZXN0cm95RGF0YXNldE1ldGEiLCJDb250cm9sbGVyQ2xhc3MiLCJyZXNldEVsZW1lbnRzIiwidXBkYXRlTGF5b3V0IiwidXBkYXRlRGF0YXNldHMiLCJsYXN0QWN0aXZlIiwiX2J1ZmZlcmVkUmVxdWVzdCIsInVwZGF0ZURhdGFzZXQiLCJhbmltYXRpb25PcHRpb25zIiwiYW5pbWF0aW9uT2JqZWN0IiwiZWFzaW5nRnVuY3Rpb24iLCJzdGVwRGVjaW1hbCIsImRyYXdEYXRhc2V0cyIsIl9kcmF3VG9vbHRpcCIsImRyYXdEYXRhc2V0IiwiZ2V0RWxlbWVudEF0RXZlbnQiLCJnZXRFbGVtZW50c0F0RXZlbnQiLCJnZXRFbGVtZW50c0F0WEF4aXMiLCJnZXREYXRhc2V0QXRFdmVudCIsIl9tZXRhIiwiZ2VuZXJhdGVMZWdlbmQiLCJ1bmJpbmRFdmVudHMiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiX2NoYXJ0SW5zdGFuY2UiLCJfbGlzdGVuZXJzIiwiZXZlbnRIYW5kbGVyIiwidXBkYXRlSG92ZXJTdHlsZSIsImJ1ZmZlcmVkUmVxdWVzdCIsImhvdmVyT3B0aW9ucyIsImNvcmVfY29udHJvbGxlciIsIkNvbnRyb2xsZXIiLCJjb25maWdNZXJnZSIsInNjYWxlTWVyZ2UiLCJjb3JlX2hlbHBlcnMiLCJmaWx0ZXJDYWxsYmFjayIsImZpbHRlcmVkIiwiYXJyYXlUb1NlYXJjaCIsInN0YXJ0SW5kZXgiLCJjdXJyZW50SXRlbSIsImZpbmRQcmV2aW91c1doZXJlIiwiYWxtb3N0RXF1YWxzIiwiYWxtb3N0V2hvbGUiLCJyb3VuZGVkIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJsb2cxMCIsImV4cG9uZW50IiwiTE9HMTBFIiwicG93ZXJPZjEwIiwiaXNQb3dlck9mMTAiLCJ0b1JhZGlhbnMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImQwMSIsImQxMiIsInMwMSIsInMxMiIsImZhIiwiZmIiLCJFUFNJTE9OIiwicG9pbnRzV2l0aFRhbmdlbnRzIiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJwb2ludEJlZm9yZSIsInBvaW50Q3VycmVudCIsInBvaW50QWZ0ZXIiLCJzbG9wZURlbHRhWCIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJsb29wIiwibmljZU51bSIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZXZ0Iiwib3JpZ2luYWxFdmVudCIsInNyY0VsZW1lbnQiLCJib3VuZGluZ1JlY3QiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFyc2VNYXhTdHlsZSIsInBhcmVudFByb3BlcnR5IiwidmFsdWVJblBpeGVscyIsImlzQ29uc3RyYWluZWRWYWx1ZSIsImdldENvbnN0cmFpbnREaW1lbnNpb24iLCJkb21Ob2RlIiwibWF4U3R5bGUiLCJwZXJjZW50YWdlUHJvcGVydHkiLCJkZWZhdWx0VmlldyIsIl9nZXRQYXJlbnROb2RlIiwiY29uc3RyYWluZWROb2RlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJfY2FsY3VsYXRlUGFkZGluZyIsInBhcmVudERpbWVuc2lvbiIsImhvc3QiLCJjdyIsImNsaWVudEhlaWdodCIsImN1cnJlbnRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsInBpeGVsU2l6ZSIsImxvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImdjIiwiZ2FyYmFnZUNvbGxlY3QiLCJsb25nZXN0IiwidGhpbmciLCJuZXN0ZWRUaGluZyIsImdjTGVuIiwidGV4dFdpZHRoIiwibnVtYmVyT2ZMYWJlbExpbmVzIiwibnVtYmVyT2ZMaW5lcyIsImNvbG9yIiwiQ2FudmFzR3JhZGllbnQiLCJjb2xvclZhbHVlIiwiQ2FudmFzUGF0dGVybiIsIkRhdGVBZGFwdGVyIiwiX2NyZWF0ZSIsIm92ZXJyaWRlIiwibWVtYmVycyIsIl9kYXRlIiwiY29yZV9hZGFwdGVycyIsImNvcmVfdGlja3MiLCJmb3JtYXR0ZXJzIiwidGlja1ZhbHVlIiwibG9nRGVsdGEiLCJ0aWNrU3RyaW5nIiwibWF4VGljayIsImxvZ1RpY2siLCJ0b0V4cG9uZW50aWFsIiwibnVtRGVjaW1hbCIsImxvZ2FyaXRobWljIiwicmVtYWluIiwidmFsdWVPckRlZmF1bHQkOSIsImRyYXdCb3JkZXIiLCJkcmF3T25DaGFydEFyZWEiLCJkcmF3VGlja3MiLCJ0aWNrTWFya0xlbmd0aCIsInplcm9MaW5lV2lkdGgiLCJ6ZXJvTGluZUNvbG9yIiwiemVyb0xpbmVCb3JkZXJEYXNoIiwiemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0Iiwic2NhbGVMYWJlbCIsImxhYmVsU3RyaW5nIiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJtaW5vciIsIm1ham9yIiwibGFiZWxzRnJvbVRpY2tzIiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsImxpbmVWYWx1ZSIsImNvbXB1dGVUZXh0U2l6ZSIsInRpY2siLCJjb3JlX3NjYWxlIiwiX3RpY2tzIiwiYmVmb3JlVXBkYXRlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJtYXJnaW5zIiwiX21heExhYmVsTGluZXMiLCJsb25nZXN0TGFiZWxXaWR0aCIsImxvbmdlc3RUZXh0Q2FjaGUiLCJiZWZvcmVTZXREaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsImFmdGVyU2V0RGltZW5zaW9ucyIsImJlZm9yZURhdGFMaW1pdHMiLCJkZXRlcm1pbmVEYXRhTGltaXRzIiwiYWZ0ZXJEYXRhTGltaXRzIiwiYmVmb3JlQnVpbGRUaWNrcyIsImJ1aWxkVGlja3MiLCJhZnRlckJ1aWxkVGlja3MiLCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJjb252ZXJ0VGlja3NUb0xhYmVscyIsImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiY2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24iLCJiZWZvcmVGaXQiLCJmaXQiLCJhZnRlckZpdCIsImFmdGVyVXBkYXRlIiwidGlja09wdHMiLCJ1c2VyQ2FsbGJhY2siLCJ0aWNrRm9udCIsImxhYmVsUm90YXRpb24iLCJvcmlnaW5hbExhYmVsV2lkdGgiLCJsYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tXaWR0aCIsImFuZ2xlUmFkaWFucyIsInNjYWxlTGFiZWxPcHRzIiwiZ3JpZExpbmVPcHRzIiwiX2lzVmlzaWJsZSIsInBhcnNlRm9udCIsImlzRnVsbFdpZHRoIiwic2NhbGVMYWJlbEZvbnQiLCJzY2FsZUxhYmVsUGFkZGluZyIsImRlbHRhSGVpZ2h0IiwibGFyZ2VzdFRleHRXaWR0aCIsInRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImxhYmVsSGVpZ2h0IiwiZmlyc3RMYWJlbFdpZHRoIiwibGFzdExhYmVsV2lkdGgiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UmlnaHQiLCJoYW5kbGVNYXJnaW5zIiwicmF3VmFsdWUiLCJnZXRWYWx1ZUZvclBpeGVsIiwiaW5uZXJXaWR0aCIsImZpbmFsVmFsIiwiaW5uZXJIZWlnaHQiLCJkZWNpbWFsIiwidmFsdWVPZmZzZXQiLCJnZXRCYXNlVmFsdWUiLCJfYXV0b1NraXAiLCJvcHRpb25UaWNrcyIsInRpY2tDb3VudCIsInNraXBSYXRpbyIsIm1heFRpY2tzIiwibWF4VGlja3NMaW1pdCIsInRpY2tzTGVuZ3RoIiwiX3RpY2tTaXplIiwiYXhpc0xlbmd0aCIsIlBhZGRpbmdCb3R0b20iLCJyb3QiLCJvcHRpb25NYWpvclRpY2tzIiwiaXNSb3RhdGVkIiwiaXNNaXJyb3JlZCIsInRpY2tGb250Q29sb3IiLCJmb250Q29sb3IiLCJtYWpvclRpY2tGb250Q29sb3IiLCJtYWpvclRpY2tGb250IiwidGwiLCJzY2FsZUxhYmVsRm9udENvbG9yIiwibGFiZWxSb3RhdGlvblJhZGlhbnMiLCJpdGVtc1RvRHJhdyIsImF4aXNXaWR0aCIsImFsaWduUGl4ZWwiLCJib3JkZXJWYWx1ZSIsInRpY2tTdGFydCIsInRpY2tFbmQiLCJsaW5lQ29sb3IiLCJ6ZXJvTGluZUluZGV4IiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwibGFiZWxYIiwibGFiZWxZIiwidGV4dE9mZnNldCIsImxhYmVsWU9mZnNldCIsImxhYmVsWE9mZnNldCIsImdsV2lkdGgiLCJnbENvbG9yIiwiZ2xCb3JkZXJEYXNoIiwiZ2xCb3JkZXJEYXNoT2Zmc2V0IiwiaXRlbVRvRHJhdyIsInRyYW5zbGF0ZSIsInNjYWxlTGFiZWxYIiwic2NhbGVMYWJlbFkiLCJoYWxmTGluZUhlaWdodCIsImlzTGVmdCIsImZpcnN0TGluZVdpZHRoIiwibGFzdExpbmVXaWR0aCIsImRlZmF1bHRDb25maWciLCJzY2FsZV9jYXRlZ29yeSIsImdldExhYmVscyIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJvZmZzZXRBbXQiLCJ2YWx1ZUNhdGVnb3J5IiwidmFsdWVXaWR0aCIsIndpZHRoT2Zmc2V0IiwidmFsdWVIZWlnaHQiLCJoZWlnaHRPZmZzZXQiLCJob3J6IiwidmFsdWVEaW1lbnNpb24iLCJfZGVmYXVsdHMiLCJnZW5lcmF0ZVRpY2tzIiwiZ2VuZXJhdGlvbk9wdGlvbnMiLCJkYXRhUmFuZ2UiLCJNSU5fU1BBQ0lORyIsInN0ZXBTaXplIiwibWF4TnVtU3BhY2VzIiwicHJlY2lzaW9uIiwicm1pbiIsInJtYXgiLCJzcGFjaW5nIiwiZmFjdG9yIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJzY2FsZV9saW5lYXJiYXNlIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsIm1pblNpZ24iLCJtYXhTaWduIiwic2V0TWluIiwic3VnZ2VzdGVkTWluIiwic2V0TWF4Iiwic3VnZ2VzdGVkTWF4IiwiZ2V0VGlja0xpbWl0IiwiX2NvbXB1dGVUaWNrTGltaXQiLCJoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMiLCJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsImZpeGVkU3RlcFNpemUiLCJ0aWNrc0FzTnVtYmVycyIsImRlZmF1bHRDb25maWckMSIsInNjYWxlX2xpbmVhciIsIkRFRkFVTFRfTUlOIiwiREVGQVVMVF9NQVgiLCJJRE1hdGNoZXMiLCJoYXNTdGFja3MiLCJ2YWx1ZXNQZXJTdGFjayIsInBvc2l0aXZlVmFsdWVzIiwibmVnYXRpdmVWYWx1ZXMiLCJyZWxhdGl2ZVBvaW50cyIsInZhbHVlc0ZvclR5cGUiLCJtaW5WYWwiLCJtYXhWYWwiLCJpbm5lckRpbWVuc2lvbiIsIl9kZWZhdWx0cyQxIiwidmFsdWVPckRlZmF1bHQkYSIsImdlbmVyYXRlVGlja3MkMSIsInRpY2tWYWwiLCJlbmRFeHAiLCJlbmRTaWduaWZpY2FuZCIsInNpZ25pZmljYW5kIiwibWluTm90WmVybyIsImxhc3RUaWNrIiwiZGVmYXVsdENvbmZpZyQyIiwibm9uTmVnYXRpdmVPckRlZmF1bHQiLCJzY2FsZV9sb2dhcml0aG1pYyIsInRpY2tWYWx1ZXMiLCJfZ2V0Rmlyc3RUaWNrVmFsdWUiLCJmaXJzdFRpY2tWYWx1ZSIsIl9kZWZhdWx0cyQyIiwidmFsdWVPckRlZmF1bHQkYiIsInZhbHVlQXRJbmRleE9yRGVmYXVsdCQxIiwicmVzb2x2ZSQ3IiwiZGVmYXVsdENvbmZpZyQzIiwiYW5pbWF0ZSIsInNob3dMYWJlbEJhY2tkcm9wIiwiYmFja2Ryb3BDb2xvciIsImJhY2tkcm9wUGFkZGluZ1kiLCJiYWNrZHJvcFBhZGRpbmdYIiwiZ2V0VmFsdWVDb3VudCIsImdldFRpY2tCYWNrZHJvcEhlaWdodCIsIm1lYXN1cmVMYWJlbFNpemUiLCJkZXRlcm1pbmVMaW1pdHMiLCJmaXRXaXRoUG9pbnRMYWJlbHMiLCJwbEZvbnQiLCJmdXJ0aGVzdExpbWl0cyIsImZ1cnRoZXN0QW5nbGVzIiwidGV4dFNpemUiLCJfcG9pbnRMYWJlbFNpemVzIiwidmFsdWVDb3VudCIsImdldFBvaW50UG9zaXRpb24iLCJkcmF3aW5nQXJlYSIsImdldEluZGV4QW5nbGUiLCJoTGltaXRzIiwidkxpbWl0cyIsInNldFJlZHVjdGlvbnMiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodCIsImRyYXdQb2ludExhYmVscyIsImFuZ2xlTGluZU9wdHMiLCJwb2ludExhYmVsT3B0cyIsInRpY2tCYWNrZHJvcEhlaWdodCIsIm91dGVyRGlzdGFuY2UiLCJvdXRlclBvc2l0aW9uIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJwb2ludExhYmVsRm9udENvbG9yIiwiZHJhd1JhZGl1c0xpbmUiLCJudW1iZXJPclplcm8iLCJzY2FsZV9yYWRpYWxMaW5lYXIiLCJzZXRDZW50ZXJQb2ludCIsImxhcmdlc3RQb3NzaWJsZVJhZGl1cyIsInJhZGl1c1JlZHVjdGlvbkxlZnQiLCJyYWRpdXNSZWR1Y3Rpb25SaWdodCIsInJhZGl1c1JlZHVjdGlvblRvcCIsInJhZGl1c1JlZHVjdGlvbkJvdHRvbSIsImxlZnRNb3ZlbWVudCIsInJpZ2h0TW92ZW1lbnQiLCJ0b3BNb3ZlbWVudCIsImJvdHRvbU1vdmVtZW50IiwibWF4UmlnaHQiLCJtYXhMZWZ0IiwibWF4VG9wIiwibWF4Qm90dG9tIiwiYW5nbGVNdWx0aXBsaWVyIiwic3RhcnRBbmdsZVJhZGlhbnMiLCJzY2FsaW5nRmFjdG9yIiwiZGlzdGFuY2VGcm9tQ2VudGVyIiwidGhpc0FuZ2xlIiwiZ2V0QmFzZVBvc2l0aW9uIiwieUNlbnRlck9mZnNldCIsIl9kZWZhdWx0cyQzIiwidmFsdWVPckRlZmF1bHQkYyIsIk1JTl9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiSU5URVJWQUxTIiwiY29tbW9uIiwic3RlcHMiLCJVTklUUyIsInNvcnRlciIsImFycmF5VW5pcXVlIiwiYnVpbGRMb29rdXBUYWJsZSIsInRpbWVzdGFtcHMiLCJkaXN0cmlidXRpb24iLCJ0YWJsZSIsImxvb2t1cCIsImxvIiwibWlkIiwiaTAiLCJpMSIsImludGVycG9sYXRlJDEiLCJza2V5IiwidGtleSIsInNwYW4iLCJ0b1RpbWVzdGFtcCIsImFkYXB0ZXIiLCJfYWRhcHRlciIsInBhcnNlciIsImRldGVybWluZVN0ZXBTaXplIiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCJkZXRlcm1pbmVNYWpvclVuaXQiLCJ0aW1lT3B0cyIsInVuaXRTdGVwU2l6ZSIsIm1ham9yVGlja3NFbmFibGVkIiwiZmlyc3QiLCJjb21wdXRlT2Zmc2V0cyIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJtYWpvclVuaXQiLCJkZWZhdWx0Q29uZmlnJDQiLCJhZGFwdGVycyIsImRpc3BsYXlGb3JtYXQiLCJkaXNwbGF5Rm9ybWF0cyIsInNjYWxlX3RpbWUiLCJ0aW1lc3RhbXAiLCJkYXRhTGFiZWxzIiwiX2hvcml6b250YWwiLCJfdGFibGUiLCJfdGltZXN0YW1wcyIsImdldExhYmVsQ2FwYWNpdHkiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfb2Zmc2V0cyIsInRvb2x0aXBGb3JtYXQiLCJ0aWNrRm9ybWF0RnVuY3Rpb24iLCJtaW5vckZvcm1hdCIsIm1ham9yRm9ybWF0IiwibWFqb3JUaW1lIiwibWFqb3JUaWNrT3B0cyIsImZvcm1hdHRlciIsImdldFBpeGVsRm9yT2Zmc2V0IiwiaXNSZXZlcnNlIiwiZ2V0TGFiZWxXaWR0aCIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwidGlja0ZvbnRTaXplIiwiZXhhbXBsZVRpbWUiLCJleGFtcGxlTGFiZWwiLCJfZGVmYXVsdHMkNCIsImNhdGVnb3J5IiwicmFkaWFsTGluZWFyIiwiRk9STUFUUyIsIl9pZCIsImFtb3VudCIsImZpbGxlciIsInByb3BhZ2F0ZSIsIm1hcHBlcnMiLCJ2aXNpYmxlIiwiYm91bmRhcnkiLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUJvdW5kYXJ5Iiwic2NhbGVCb3R0b20iLCJzY2FsZVRvcCIsInNjYWxlWmVybyIsInJlc29sdmVUYXJnZXQiLCJ2aXNpdGVkIiwiY3JlYXRlTWFwcGVyIiwiaXNEcmF3YWJsZSIsImRyYXdBcmVhIiwiY3VydmUwIiwiY3VydmUxIiwibGVuMCIsImxlbjEiLCJkb0ZpbGwiLCJtYXBwZXIiLCJwMCIsImQwIiwiZDEiLCJwbHVnaW5fZmlsbGVyIiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEYXRhc2V0RHJhdyIsIm5vb3AkMSIsInZhbHVlT3JEZWZhdWx0JGQiLCJjaSIsIm9uTGVhdmUiLCJib3hXaWR0aCIsImxpbmVEYXNoIiwiZ2V0Qm94V2lkdGgiLCJsYWJlbE9wdHMiLCJ1c2VQb2ludFN0eWxlIiwiTGVnZW5kIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJiZWZvcmVCdWlsZExhYmVscyIsImJ1aWxkTGFiZWxzIiwiYWZ0ZXJCdWlsZExhYmVscyIsImxlZ2VuZEl0ZW1zIiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiaXRlbUhlaWdodCIsIml0ZW1XaWR0aCIsImxpbmVEZWZhdWx0IiwibGVnZW5kV2lkdGgiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiU1FSVDIiLCJoYWxmRm9udFNpemUiLCJ4TGVmdCIsInlNaWRkbGUiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJob3ZlcmVkSXRlbSIsImNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaCIsImxlZ2VuZE9wdHMiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJiZWZvcmVJbml0IiwiYWZ0ZXJFdmVudCIsIm5vb3AkMiIsIlRpdGxlIiwibGluZUNvdW50IiwiZm9udE9wdHMiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoIiwidGl0bGVPcHRzIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIl9hZGFwdGVycyIsIkFuaW1hdGlvbiIsImFuaW1hdGlvblNlcnZpY2UiLCJJbnRlcmFjdGlvbiIsImxheW91dHMiLCJTY2FsZSIsInNjYWxlU2VydmljZSIsIlRpY2tzIiwiVG9vbHRpcCIsInBsdWdpblNlcnZpY2UiLCJQbHVnaW5CYXNlIiwiY2FudmFzSGVscGVycyIsImxheW91dFNlcnZpY2UiLCJMaW5lYXJTY2FsZUJhc2UiLCJjZmciLCJnZW5lcmF0ZUNoYXJ0IiwiY2hhcnRJZCIsImNoYXJ0VHlwZSIsImNzc0NsYXNzZXMiLCJfZGVmYXVsdCIsImFkZFBsdWdpbiIsImJlZm9yZURlc3Ryb3kiLCJCYXIiLCJIb3Jpem9udGFsQmFyIiwiUGllIiwiY2hhcnRMYWJlbHMiLCJjaGFydERhdGFMaXN0IiwiQ2hhcnREYXRhIiwiQ2hhcnRCYXIiLCJDaGFydENvbXBvbmVudCIsIkNoYXJ0SG9yaXpvbnRhbEJhciIsIkNoYXJ0TGluZSIsIkNoYXJ0UGllIiwibnljb0NvbG9ycyIsImNvbG9ycyIsImNvbG9yQ29tYmluYXRpb25zIiwibWFwQ29sb3JDb21iaW5hdGlvbnMiLCJNYXBEYXRhIiwibGF5ZXJzIiwiQVBJS2V5IiwiY29udGFpbmVySWQiLCJsZWdlbmRJZCIsInpvb20iLCJkaXNhYmxlU2Nyb2xsIiwibWFwVHlwZSIsIm11bHRpIiwiR2VvSlNPTiIsImRvVGhyb3dzIiwiaW52YWxpZEdlb21ldHJ5IiwiSW52YWxpZEdlb21ldHJ5RXJyb3IiLCJpc0dlb21ldHJ5VmFsaWQiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwib2JqZWN0cyIsImdlb2pzb24iLCJhcHBseURlZmF1bHRzIiwicHJvcEZ1bmMiLCJnZW9tQXR0cnMiLCJzZXRHZW9tIiwiZ2V0UHJvcEZ1bmN0aW9uIiwiZmVhdHVyZXMiLCJnZXRGZWF0dXJlIiwiYWRkT3B0aW9uYWxzIiwiZ2VvbXMiLCJzZXR0aW5nIiwiY3JzIiwiY2hlY2tDUlMiLCJpc1Bvc3RncmVzIiwiYmJveCIsImV4dHJhR2xvYmFsIiwicHJvcGVydGllcyIsImdlb20iLCJzZXRHZW9tQXR0ckxpc3QiLCJmZWF0dXJlIiwiYnVpbGRHZW9tIiwiaXNOZXN0ZWQiLCJndHlwZSIsIm5ld0l0ZW0iLCJwYXRocyIsIml0ZW1DbG9uZSIsImFkZEV4dHJhIiwicmluZ0FyZWEiLCJwb2x5Z29uQXJlYSIsImdlb21ldHJpZXMiLCJjb29yZHMiLCJsb3dlckluZGV4IiwibWlkZGxlSW5kZXgiLCJ1cHBlckluZGV4IiwiY29vcmRzTGVuZ3RoIiwid2dzODQiLCJSQURJVVMiLCJyZXdpbmQiLCJnaiIsImN1cnJ5T3V0ZXIiLCJjb3JyZWN0IiwiY29ycmVjdFJpbmdzIiwid2luZCIsImdlb2pzb25BcmVhIiwicmluZyIsIk1hcE11bHRpTGF5ZXIiLCJNYXBDb21wb25lbnQiLCJnZXRaaXBjb2RlRGF0YSIsImdldEJvcm91Z2hEYXRhIiwiZ2V0TmVpZ2hib3Job29kRGF0YSIsImZpbHRlckJ5IiwiY29udmVydFRvR2VvSlNPTiIsImpzb25EYXRhIiwiTWFwU2luZ2xlTGF5ZXIiLCJsZWdlbmRDb2x1bW4iLCJueWNvIiwiaWNvbnMiLCJ0cmFjayIsInNlbGVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU1BLElBQU1BLFNBQU8sR0FLWCxnQkFBQSxHQUFjO1NBQ0wsSUFBVDtDQU5GOzs7Ozs7O0FBY0FBLFNBQU8sQ0FBQ0MsS0FBUixlQUFtQjtTQUFJRCxTQUFPLENBQUNFLGVBQVIsQ0FBd0JGLFNBQU8sQ0FBQ0csTUFBUixDQUFlQyxLQUF2QyxNQUFrRDtDQUF6RTs7Ozs7Ozs7OztBQVNBSixTQUFPLENBQUNFLGVBQVIsYUFBMkJHLE1BQU1DLGFBQWE7TUFDdENDLEtBQUssR0FBR0QsV0FBVyxJQUFJRSxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE1BQTdDQztNQUNNQyxLQUFLLEdBQUdQLElBQUksQ0FBQ1EsT0FBTCxDQUFhLE1BQWIsRUFBcUIsS0FBckIsRUFBNEJBLE9BQTVCLENBQW9DLE1BQXBDLEVBQTRDLEtBQTVDLENBQWRGO01BQ01HLEtBQUssR0FBRyxJQUFJQyxNQUFKLENBQVcsV0FBV0gs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RUFBTyxHQUFQLENBckJVO01Bc0JoQkMsUUFBUSxFQUFFLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLENBdEJNO01BdUJoQkMsUUFBUSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkJNO01Bd0JoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeEJBO01BeUJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekJNO01BMEJoQkMsU0FBUyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBMUJJO01BMkJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0JNO01BNEJoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUJJO01BNkJoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBN0JFO01BOEJoQkMsY0FBYyxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBOUJBO01BK0JoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBL0JJO01BZ0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaENJO01BaUNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBakNNO01Ba0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbENJO01BbUNoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkNFO01Bb0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBcENBO01BcUNoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBckNBO01Bc0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBdENBO01BdUNoQkMsYUFBYSxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkNBO01Bd0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBeENJO01BeUNoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBekNNO01BMENoQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBMUNFO01BMkNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0NNO01BNENoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUNNO01BNkNoQkMsVUFBVSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBN0NJO01BOENoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBOUNJO01BK0NoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0NFO01BZ0RoQkMsV0FBVyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBaERFO01BaURoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBakRNO01Ba0RoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbERJO01BbURoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkRJO01Bb0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERVO01BcURoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBckRJO01Bc0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdERVO01BdURoQkMsS0FBSyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBdkRRO01Bd0RoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeERFO01BeURoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekRVO01BMERoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMURNO01BMkRoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0RNO01BNERoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNURJO01BNkRoQkMsTUFBTSxFQUFFLENBQUMsRUFBRCxFQUFJLENBQUosRUFBTSxHQUFOLENBN0RRO01BOERoQkMsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOURRO01BK0RoQkMsS0FBSyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0RRO01BZ0VoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEVNO01BaUVoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakVBO01Ba0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBbEVJO01BbUVoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkVFO01Bb0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEVJO01BcUVoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckVJO01Bc0VoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEVJO01BdUVoQkMsb0JBQW9CLEVBQUUsQ0FBQyxHQUFELEVBQUssR0FB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eEdRO01BeUdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBekdJO01BMEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBMUdRO01BMkdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxDQUFSLENBM0dJO01BNEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUdRO01BNkdoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0dBO01BOEdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOUdJO01BK0doQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0dBO01BZ0hoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEhBO01BaUhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakhJO01Ba0hoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEhJO01BbUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBbkhVO01Bb0hoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEhVO01BcUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckhVO01Bc0hoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEhJO01BdUhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBdkhRO01Bd0hoQkMsYUFBYSxFQUFFLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxHQUFWLENBeEhDO01BeUhoQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBekhVO01BMEhoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUhJO01BMkhoQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBM0hJO01BNEhoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNUhFO01BNkhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0hRO01BOEhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBOUhJO01BK0hoQkMsUUFBUSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBL0hNO01BZ0loQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaElNO01BaUloQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBaklRO01Ba0loQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbElRO01BbUloQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbklNO01Bb0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBcElJO01BcUloQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcklJO01Bc0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdElJO01BdUloQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdklVO01Bd0loQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBeElFO01BeUloQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBeklJO01BMEloQkMsR0FBRyxF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
